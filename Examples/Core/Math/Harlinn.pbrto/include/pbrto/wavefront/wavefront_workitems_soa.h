// SOA definitions automatically generated by soac
// DO NOT EDIT THIS FILE MANUALLY

template <typename T> struct SOA;

template <> struct SOA<PixelSampleState> {
    SOA() = default;
    SOA(int n, Allocator alloc) : nAlloc(n) {
        this->filterWeight = alloc.allocate_object<Float>(n);
        this->pPixel = SOA<Point2i>(n, alloc);
        this->lambda = SOA<SampledWavelengths>(n, alloc);
        this->L = SOA<SampledSpectrum>(n, alloc);
        this->cameraRayWeight = SOA<SampledSpectrum>(n, alloc);
        this->visibleSurface = SOA<VisibleSurface>(n, alloc);
        this->samples = SOA<RaySamples>(n, alloc);
    }
    SOA &operator=(const SOA& s) {
        nAlloc = s.nAlloc;
        this->filterWeight = s.filterWeight;
        this->pPixel = s.pPixel;
        this->lambda = s.lambda;
        this->L = s.L;
        this->cameraRayWeight = s.cameraRayWeight;
        this->visibleSurface = s.visibleSurface;
        this->samples = s.samples;
        return *this;
    }
    struct GetSetIndirector {
        PBRT_CPU_GPU
        operator PixelSampleState() const {
            PixelSampleState r;
            r.filterWeight = soa->filterWeight[i];
            r.pPixel = soa->pPixel[i];
            r.lambda = soa->lambda[i];
            r.L = soa->L[i];
            r.cameraRayWeight = soa->cameraRayWeight[i];
            r.visibleSurface = soa->visibleSurface[i];
            r.samples = soa->samples[i];
            return r;
        }
        PBRT_CPU_GPU
        void operator=(const PixelSampleState &a) {
            soa->filterWeight[i] = a.filterWeight;
            soa->pPixel[i] = a.pPixel;
            soa->lambda[i] = a.lambda;
            soa->L[i] = a.L;
            soa->cameraRayWeight[i] = a.cameraRayWeight;
            soa->visibleSurface[i] = a.visibleSurface;
            soa->samples[i] = a.samples;
        }

        SOA *soa;
        int i;
    };

    PBRT_CPU_GPU
    GetSetIndirector operator[](int i) {
        DCHECK_LT(i, nAlloc);
        return GetSetIndirector{this, i};
    }
    PBRT_CPU_GPU
    PixelSampleState operator[](int i) const {
        DCHECK_LT(i, nAlloc);
        PixelSampleState r;
        r.filterWeight = this->filterWeight[i];
        r.pPixel = this->pPixel[i];
        r.lambda = this->lambda[i];
        r.L = this->L[i];
        r.cameraRayWeight = this->cameraRayWeight[i];
        r.visibleSurface = this->visibleSurface[i];
        r.samples = this->samples[i];
        return r;
    }

    int nAlloc;
    Float * PBRT_RESTRICT filterWeight;
    SOA<Point2i> pPixel;
    SOA<SampledWavelengths> lambda;
    SOA<SampledSpectrum> L;
    SOA<SampledSpectrum> cameraRayWeight;
    SOA<VisibleSurface> visibleSurface;
    SOA<RaySamples> samples;
};

template <> struct SOA<RayWorkItem> {
    SOA() = default;
    SOA(int n, Allocator alloc) : nAlloc(n) {
        this->ray = SOA<Ray>(n, alloc);
        this->depth = alloc.allocate_object<int>(n);
        this->pixelIndex = alloc.allocate_object<int>(n);
        this->lambda = SOA<SampledWavelengths>(n, alloc);
        this->beta = SOA<SampledSpectrum>(n, alloc);
        this->r_u = SOA<SampledSpectrum>(n, alloc);
        this->r_l = SOA<SampledSpectrum>(n, alloc);
        this->prevIntrCtx = SOA<LightSampleContext>(n, alloc);
        this->etaScale = alloc.allocate_object<Float>(n);
        this->specularBounce = alloc.allocate_object<int>(n);
        this->anyNonSpecularBounces = alloc.allocate_object<int>(n);
    }
    SOA &operator=(const SOA& s) {
        nAlloc = s.nAlloc;
        this->ray = s.ray;
        this->depth = s.depth;
        this->pixelIndex = s.pixelIndex;
        this->lambda = s.lambda;
        this->beta = s.beta;
        this->r_u = s.r_u;
        this->r_l = s.r_l;
        this->prevIntrCtx = s.prevIntrCtx;
        this->etaScale = s.etaScale;
        this->specularBounce = s.specularBounce;
        this->anyNonSpecularBounces = s.anyNonSpecularBounces;
        return *this;
    }
    struct GetSetIndirector {
        PBRT_CPU_GPU
        operator RayWorkItem() const {
            RayWorkItem r;
            r.ray = soa->ray[i];
            r.depth = soa->depth[i];
            r.pixelIndex = soa->pixelIndex[i];
            r.lambda = soa->lambda[i];
            r.beta = soa->beta[i];
            r.r_u = soa->r_u[i];
            r.r_l = soa->r_l[i];
            r.prevIntrCtx = soa->prevIntrCtx[i];
            r.etaScale = soa->etaScale[i];
            r.specularBounce = soa->specularBounce[i];
            r.anyNonSpecularBounces = soa->anyNonSpecularBounces[i];
            return r;
        }
        PBRT_CPU_GPU
        void operator=(const RayWorkItem &a) {
            soa->ray[i] = a.ray;
            soa->depth[i] = a.depth;
            soa->pixelIndex[i] = a.pixelIndex;
            soa->lambda[i] = a.lambda;
            soa->beta[i] = a.beta;
            soa->r_u[i] = a.r_u;
            soa->r_l[i] = a.r_l;
            soa->prevIntrCtx[i] = a.prevIntrCtx;
            soa->etaScale[i] = a.etaScale;
            soa->specularBounce[i] = a.specularBounce;
            soa->anyNonSpecularBounces[i] = a.anyNonSpecularBounces;
        }

        SOA *soa;
        int i;
    };

    PBRT_CPU_GPU
    GetSetIndirector operator[](int i) {
        DCHECK_LT(i, nAlloc);
        return GetSetIndirector{this, i};
    }
    PBRT_CPU_GPU
    RayWorkItem operator[](int i) const {
        DCHECK_LT(i, nAlloc);
        RayWorkItem r;
        r.ray = this->ray[i];
        r.depth = this->depth[i];
        r.pixelIndex = this->pixelIndex[i];
        r.lambda = this->lambda[i];
        r.beta = this->beta[i];
        r.r_u = this->r_u[i];
        r.r_l = this->r_l[i];
        r.prevIntrCtx = this->prevIntrCtx[i];
        r.etaScale = this->etaScale[i];
        r.specularBounce = this->specularBounce[i];
        r.anyNonSpecularBounces = this->anyNonSpecularBounces[i];
        return r;
    }

    int nAlloc;
    SOA<Ray> ray;
    int * PBRT_RESTRICT depth;
    int * PBRT_RESTRICT pixelIndex;
    SOA<SampledWavelengths> lambda;
    SOA<SampledSpectrum> beta;
    SOA<SampledSpectrum> r_u;
    SOA<SampledSpectrum> r_l;
    SOA<LightSampleContext> prevIntrCtx;
    Float * PBRT_RESTRICT etaScale;
    int * PBRT_RESTRICT specularBounce;
    int * PBRT_RESTRICT anyNonSpecularBounces;
};

template <> struct SOA<EscapedRayWorkItem> {
    SOA() = default;
    SOA(int n, Allocator alloc) : nAlloc(n) {
        this->rayo = SOA<Point3f>(n, alloc);
        this->rayd = SOA<Vector3f>(n, alloc);
        this->depth = alloc.allocate_object<int>(n);
        this->beta = SOA<SampledSpectrum>(n, alloc);
        this->r_u = SOA<SampledSpectrum>(n, alloc);
        this->r_l = SOA<SampledSpectrum>(n, alloc);
        this->lambda = SOA<SampledWavelengths>(n, alloc);
        this->prevIntrCtx = SOA<LightSampleContext>(n, alloc);
        this->specularBounce = alloc.allocate_object<int>(n);
        this->pixelIndex = alloc.allocate_object<int>(n);
    }
    SOA &operator=(const SOA& s) {
        nAlloc = s.nAlloc;
        this->rayo = s.rayo;
        this->rayd = s.rayd;
        this->depth = s.depth;
        this->beta = s.beta;
        this->r_u = s.r_u;
        this->r_l = s.r_l;
        this->lambda = s.lambda;
        this->prevIntrCtx = s.prevIntrCtx;
        this->specularBounce = s.specularBounce;
        this->pixelIndex = s.pixelIndex;
        return *this;
    }
    struct GetSetIndirector {
        PBRT_CPU_GPU
        operator EscapedRayWorkItem() const {
            EscapedRayWorkItem r;
            r.rayo = soa->rayo[i];
            r.rayd = soa->rayd[i];
            r.depth = soa->depth[i];
            r.beta = soa->beta[i];
            r.r_u = soa->r_u[i];
            r.r_l = soa->r_l[i];
            r.lambda = soa->lambda[i];
            r.prevIntrCtx = soa->prevIntrCtx[i];
            r.specularBounce = soa->specularBounce[i];
            r.pixelIndex = soa->pixelIndex[i];
            return r;
        }
        PBRT_CPU_GPU
        void operator=(const EscapedRayWorkItem &a) {
            soa->rayo[i] = a.rayo;
            soa->rayd[i] = a.rayd;
            soa->depth[i] = a.depth;
            soa->beta[i] = a.beta;
            soa->r_u[i] = a.r_u;
            soa->r_l[i] = a.r_l;
            soa->lambda[i] = a.lambda;
            soa->prevIntrCtx[i] = a.prevIntrCtx;
            soa->specularBounce[i] = a.specularBounce;
            soa->pixelIndex[i] = a.pixelIndex;
        }

        SOA *soa;
        int i;
    };

    PBRT_CPU_GPU
    GetSetIndirector operator[](int i) {
        DCHECK_LT(i, nAlloc);
        return GetSetIndirector{this, i};
    }
    PBRT_CPU_GPU
    EscapedRayWorkItem operator[](int i) const {
        DCHECK_LT(i, nAlloc);
        EscapedRayWorkItem r;
        r.rayo = this->rayo[i];
        r.rayd = this->rayd[i];
        r.depth = this->depth[i];
        r.beta = this->beta[i];
        r.r_u = this->r_u[i];
        r.r_l = this->r_l[i];
        r.lambda = this->lambda[i];
        r.prevIntrCtx = this->prevIntrCtx[i];
        r.specularBounce = this->specularBounce[i];
        r.pixelIndex = this->pixelIndex[i];
        return r;
    }

    int nAlloc;
    SOA<Point3f> rayo;
    SOA<Vector3f> rayd;
    int * PBRT_RESTRICT depth;
    SOA<SampledSpectrum> beta;
    SOA<SampledSpectrum> r_u;
    SOA<SampledSpectrum> r_l;
    SOA<SampledWavelengths> lambda;
    SOA<LightSampleContext> prevIntrCtx;
    int * PBRT_RESTRICT specularBounce;
    int * PBRT_RESTRICT pixelIndex;
};

template <> struct SOA<HitAreaLightWorkItem> {
    SOA() = default;
    SOA(int n, Allocator alloc) : nAlloc(n) {
        this->areaLight = alloc.allocate_object<Light>(n);
        this->lambda = SOA<SampledWavelengths>(n, alloc);
        this->beta = SOA<SampledSpectrum>(n, alloc);
        this->r_u = SOA<SampledSpectrum>(n, alloc);
        this->r_l = SOA<SampledSpectrum>(n, alloc);
        this->p = SOA<Point3f>(n, alloc);
        this->n = SOA<Normal3f>(n, alloc);
        this->uv = SOA<Point2f>(n, alloc);
        this->wo = SOA<Vector3f>(n, alloc);
        this->depth = alloc.allocate_object<int>(n);
        this->prevIntrCtx = SOA<LightSampleContext>(n, alloc);
        this->specularBounce = alloc.allocate_object<int>(n);
        this->pixelIndex = alloc.allocate_object<int>(n);
    }
    SOA &operator=(const SOA& s) {
        nAlloc = s.nAlloc;
        this->areaLight = s.areaLight;
        this->lambda = s.lambda;
        this->beta = s.beta;
        this->r_u = s.r_u;
        this->r_l = s.r_l;
        this->p = s.p;
        this->n = s.n;
        this->uv = s.uv;
        this->wo = s.wo;
        this->depth = s.depth;
        this->prevIntrCtx = s.prevIntrCtx;
        this->specularBounce = s.specularBounce;
        this->pixelIndex = s.pixelIndex;
        return *this;
    }
    struct GetSetIndirector {
        PBRT_CPU_GPU
        operator HitAreaLightWorkItem() const {
            HitAreaLightWorkItem r;
            r.areaLight = soa->areaLight[i];
            r.lambda = soa->lambda[i];
            r.beta = soa->beta[i];
            r.r_u = soa->r_u[i];
            r.r_l = soa->r_l[i];
            r.p = soa->p[i];
            r.n = soa->n[i];
            r.uv = soa->uv[i];
            r.wo = soa->wo[i];
            r.depth = soa->depth[i];
            r.prevIntrCtx = soa->prevIntrCtx[i];
            r.specularBounce = soa->specularBounce[i];
            r.pixelIndex = soa->pixelIndex[i];
            return r;
        }
        PBRT_CPU_GPU
        void operator=(const HitAreaLightWorkItem &a) {
            soa->areaLight[i] = a.areaLight;
            soa->lambda[i] = a.lambda;
            soa->beta[i] = a.beta;
            soa->r_u[i] = a.r_u;
            soa->r_l[i] = a.r_l;
            soa->p[i] = a.p;
            soa->n[i] = a.n;
            soa->uv[i] = a.uv;
            soa->wo[i] = a.wo;
            soa->depth[i] = a.depth;
            soa->prevIntrCtx[i] = a.prevIntrCtx;
            soa->specularBounce[i] = a.specularBounce;
            soa->pixelIndex[i] = a.pixelIndex;
        }

        SOA *soa;
        int i;
    };

    PBRT_CPU_GPU
    GetSetIndirector operator[](int i) {
        DCHECK_LT(i, nAlloc);
        return GetSetIndirector{this, i};
    }
    PBRT_CPU_GPU
    HitAreaLightWorkItem operator[](int i) const {
        DCHECK_LT(i, nAlloc);
        HitAreaLightWorkItem r;
        r.areaLight = this->areaLight[i];
        r.lambda = this->lambda[i];
        r.beta = this->beta[i];
        r.r_u = this->r_u[i];
        r.r_l = this->r_l[i];
        r.p = this->p[i];
        r.n = this->n[i];
        r.uv = this->uv[i];
        r.wo = this->wo[i];
        r.depth = this->depth[i];
        r.prevIntrCtx = this->prevIntrCtx[i];
        r.specularBounce = this->specularBounce[i];
        r.pixelIndex = this->pixelIndex[i];
        return r;
    }

    int nAlloc;
    Light * PBRT_RESTRICT areaLight;
    SOA<SampledWavelengths> lambda;
    SOA<SampledSpectrum> beta;
    SOA<SampledSpectrum> r_u;
    SOA<SampledSpectrum> r_l;
    SOA<Point3f> p;
    SOA<Normal3f> n;
    SOA<Point2f> uv;
    SOA<Vector3f> wo;
    int * PBRT_RESTRICT depth;
    SOA<LightSampleContext> prevIntrCtx;
    int * PBRT_RESTRICT specularBounce;
    int * PBRT_RESTRICT pixelIndex;
};

template <> struct SOA<ShadowRayWorkItem> {
    SOA() = default;
    SOA(int n, Allocator alloc) : nAlloc(n) {
        this->ray = SOA<Ray>(n, alloc);
        this->tMax = alloc.allocate_object<Float>(n);
        this->lambda = SOA<SampledWavelengths>(n, alloc);
        this->Ld = SOA<SampledSpectrum>(n, alloc);
        this->r_u = SOA<SampledSpectrum>(n, alloc);
        this->r_l = SOA<SampledSpectrum>(n, alloc);
        this->pixelIndex = alloc.allocate_object<int>(n);
    }
    SOA &operator=(const SOA& s) {
        nAlloc = s.nAlloc;
        this->ray = s.ray;
        this->tMax = s.tMax;
        this->lambda = s.lambda;
        this->Ld = s.Ld;
        this->r_u = s.r_u;
        this->r_l = s.r_l;
        this->pixelIndex = s.pixelIndex;
        return *this;
    }
    struct GetSetIndirector {
        PBRT_CPU_GPU
        operator ShadowRayWorkItem() const {
            ShadowRayWorkItem r;
            r.ray = soa->ray[i];
            r.tMax = soa->tMax[i];
            r.lambda = soa->lambda[i];
            r.Ld = soa->Ld[i];
            r.r_u = soa->r_u[i];
            r.r_l = soa->r_l[i];
            r.pixelIndex = soa->pixelIndex[i];
            return r;
        }
        PBRT_CPU_GPU
        void operator=(const ShadowRayWorkItem &a) {
            soa->ray[i] = a.ray;
            soa->tMax[i] = a.tMax;
            soa->lambda[i] = a.lambda;
            soa->Ld[i] = a.Ld;
            soa->r_u[i] = a.r_u;
            soa->r_l[i] = a.r_l;
            soa->pixelIndex[i] = a.pixelIndex;
        }

        SOA *soa;
        int i;
    };

    PBRT_CPU_GPU
    GetSetIndirector operator[](int i) {
        DCHECK_LT(i, nAlloc);
        return GetSetIndirector{this, i};
    }
    PBRT_CPU_GPU
    ShadowRayWorkItem operator[](int i) const {
        DCHECK_LT(i, nAlloc);
        ShadowRayWorkItem r;
        r.ray = this->ray[i];
        r.tMax = this->tMax[i];
        r.lambda = this->lambda[i];
        r.Ld = this->Ld[i];
        r.r_u = this->r_u[i];
        r.r_l = this->r_l[i];
        r.pixelIndex = this->pixelIndex[i];
        return r;
    }

    int nAlloc;
    SOA<Ray> ray;
    Float * PBRT_RESTRICT tMax;
    SOA<SampledWavelengths> lambda;
    SOA<SampledSpectrum> Ld;
    SOA<SampledSpectrum> r_u;
    SOA<SampledSpectrum> r_l;
    int * PBRT_RESTRICT pixelIndex;
};

template <> struct SOA<GetBSSRDFAndProbeRayWorkItem> {
    SOA() = default;
    SOA(int n, Allocator alloc) : nAlloc(n) {
        this->material = alloc.allocate_object<Material>(n);
        this->lambda = SOA<SampledWavelengths>(n, alloc);
        this->beta = SOA<SampledSpectrum>(n, alloc);
        this->r_u = SOA<SampledSpectrum>(n, alloc);
        this->p = SOA<Point3f>(n, alloc);
        this->wo = SOA<Vector3f>(n, alloc);
        this->n = SOA<Normal3f>(n, alloc);
        this->ns = SOA<Normal3f>(n, alloc);
        this->dpdus = SOA<Vector3f>(n, alloc);
        this->uv = SOA<Point2f>(n, alloc);
        this->depth = alloc.allocate_object<int>(n);
        this->mediumInterface = SOA<MediumInterface>(n, alloc);
        this->etaScale = alloc.allocate_object<Float>(n);
        this->pixelIndex = alloc.allocate_object<int>(n);
    }
    SOA &operator=(const SOA& s) {
        nAlloc = s.nAlloc;
        this->material = s.material;
        this->lambda = s.lambda;
        this->beta = s.beta;
        this->r_u = s.r_u;
        this->p = s.p;
        this->wo = s.wo;
        this->n = s.n;
        this->ns = s.ns;
        this->dpdus = s.dpdus;
        this->uv = s.uv;
        this->depth = s.depth;
        this->mediumInterface = s.mediumInterface;
        this->etaScale = s.etaScale;
        this->pixelIndex = s.pixelIndex;
        return *this;
    }
    struct GetSetIndirector {
        PBRT_CPU_GPU
        operator GetBSSRDFAndProbeRayWorkItem() const {
            GetBSSRDFAndProbeRayWorkItem r;
            r.material = soa->material[i];
            r.lambda = soa->lambda[i];
            r.beta = soa->beta[i];
            r.r_u = soa->r_u[i];
            r.p = soa->p[i];
            r.wo = soa->wo[i];
            r.n = soa->n[i];
            r.ns = soa->ns[i];
            r.dpdus = soa->dpdus[i];
            r.uv = soa->uv[i];
            r.depth = soa->depth[i];
            r.mediumInterface = soa->mediumInterface[i];
            r.etaScale = soa->etaScale[i];
            r.pixelIndex = soa->pixelIndex[i];
            return r;
        }
        PBRT_CPU_GPU
        void operator=(const GetBSSRDFAndProbeRayWorkItem &a) {
            soa->material[i] = a.material;
            soa->lambda[i] = a.lambda;
            soa->beta[i] = a.beta;
            soa->r_u[i] = a.r_u;
            soa->p[i] = a.p;
            soa->wo[i] = a.wo;
            soa->n[i] = a.n;
            soa->ns[i] = a.ns;
            soa->dpdus[i] = a.dpdus;
            soa->uv[i] = a.uv;
            soa->depth[i] = a.depth;
            soa->mediumInterface[i] = a.mediumInterface;
            soa->etaScale[i] = a.etaScale;
            soa->pixelIndex[i] = a.pixelIndex;
        }

        SOA *soa;
        int i;
    };

    PBRT_CPU_GPU
    GetSetIndirector operator[](int i) {
        DCHECK_LT(i, nAlloc);
        return GetSetIndirector{this, i};
    }
    PBRT_CPU_GPU
    GetBSSRDFAndProbeRayWorkItem operator[](int i) const {
        DCHECK_LT(i, nAlloc);
        GetBSSRDFAndProbeRayWorkItem r;
        r.material = this->material[i];
        r.lambda = this->lambda[i];
        r.beta = this->beta[i];
        r.r_u = this->r_u[i];
        r.p = this->p[i];
        r.wo = this->wo[i];
        r.n = this->n[i];
        r.ns = this->ns[i];
        r.dpdus = this->dpdus[i];
        r.uv = this->uv[i];
        r.depth = this->depth[i];
        r.mediumInterface = this->mediumInterface[i];
        r.etaScale = this->etaScale[i];
        r.pixelIndex = this->pixelIndex[i];
        return r;
    }

    int nAlloc;
    Material * PBRT_RESTRICT material;
    SOA<SampledWavelengths> lambda;
    SOA<SampledSpectrum> beta;
    SOA<SampledSpectrum> r_u;
    SOA<Point3f> p;
    SOA<Vector3f> wo;
    SOA<Normal3f> n;
    SOA<Normal3f> ns;
    SOA<Vector3f> dpdus;
    SOA<Point2f> uv;
    int * PBRT_RESTRICT depth;
    SOA<MediumInterface> mediumInterface;
    Float * PBRT_RESTRICT etaScale;
    int * PBRT_RESTRICT pixelIndex;
};

template <> struct SOA<SubsurfaceScatterWorkItem> {
    SOA() = default;
    SOA(int n, Allocator alloc) : nAlloc(n) {
        this->p0 = SOA<Point3f>(n, alloc);
        this->p1 = SOA<Point3f>(n, alloc);
        this->depth = alloc.allocate_object<int>(n);
        this->material = alloc.allocate_object<Material>(n);
        this->bssrdf = SOA<TabulatedBSSRDF>(n, alloc);
        this->lambda = SOA<SampledWavelengths>(n, alloc);
        this->beta = SOA<SampledSpectrum>(n, alloc);
        this->r_u = SOA<SampledSpectrum>(n, alloc);
        this->mediumInterface = SOA<MediumInterface>(n, alloc);
        this->etaScale = alloc.allocate_object<Float>(n);
        this->pixelIndex = alloc.allocate_object<int>(n);
        this->reservoirPDF = alloc.allocate_object<Float>(n);
        this->uLight = alloc.allocate_object<Float>(n);
        this->ssi = SOA<SubsurfaceInteraction>(n, alloc);
    }
    SOA &operator=(const SOA& s) {
        nAlloc = s.nAlloc;
        this->p0 = s.p0;
        this->p1 = s.p1;
        this->depth = s.depth;
        this->material = s.material;
        this->bssrdf = s.bssrdf;
        this->lambda = s.lambda;
        this->beta = s.beta;
        this->r_u = s.r_u;
        this->mediumInterface = s.mediumInterface;
        this->etaScale = s.etaScale;
        this->pixelIndex = s.pixelIndex;
        this->reservoirPDF = s.reservoirPDF;
        this->uLight = s.uLight;
        this->ssi = s.ssi;
        return *this;
    }
    struct GetSetIndirector {
        PBRT_CPU_GPU
        operator SubsurfaceScatterWorkItem() const {
            SubsurfaceScatterWorkItem r;
            r.p0 = soa->p0[i];
            r.p1 = soa->p1[i];
            r.depth = soa->depth[i];
            r.material = soa->material[i];
            r.bssrdf = soa->bssrdf[i];
            r.lambda = soa->lambda[i];
            r.beta = soa->beta[i];
            r.r_u = soa->r_u[i];
            r.mediumInterface = soa->mediumInterface[i];
            r.etaScale = soa->etaScale[i];
            r.pixelIndex = soa->pixelIndex[i];
            r.reservoirPDF = soa->reservoirPDF[i];
            r.uLight = soa->uLight[i];
            r.ssi = soa->ssi[i];
            return r;
        }
        PBRT_CPU_GPU
        void operator=(const SubsurfaceScatterWorkItem &a) {
            soa->p0[i] = a.p0;
            soa->p1[i] = a.p1;
            soa->depth[i] = a.depth;
            soa->material[i] = a.material;
            soa->bssrdf[i] = a.bssrdf;
            soa->lambda[i] = a.lambda;
            soa->beta[i] = a.beta;
            soa->r_u[i] = a.r_u;
            soa->mediumInterface[i] = a.mediumInterface;
            soa->etaScale[i] = a.etaScale;
            soa->pixelIndex[i] = a.pixelIndex;
            soa->reservoirPDF[i] = a.reservoirPDF;
            soa->uLight[i] = a.uLight;
            soa->ssi[i] = a.ssi;
        }

        SOA *soa;
        int i;
    };

    PBRT_CPU_GPU
    GetSetIndirector operator[](int i) {
        DCHECK_LT(i, nAlloc);
        return GetSetIndirector{this, i};
    }
    PBRT_CPU_GPU
    SubsurfaceScatterWorkItem operator[](int i) const {
        DCHECK_LT(i, nAlloc);
        SubsurfaceScatterWorkItem r;
        r.p0 = this->p0[i];
        r.p1 = this->p1[i];
        r.depth = this->depth[i];
        r.material = this->material[i];
        r.bssrdf = this->bssrdf[i];
        r.lambda = this->lambda[i];
        r.beta = this->beta[i];
        r.r_u = this->r_u[i];
        r.mediumInterface = this->mediumInterface[i];
        r.etaScale = this->etaScale[i];
        r.pixelIndex = this->pixelIndex[i];
        r.reservoirPDF = this->reservoirPDF[i];
        r.uLight = this->uLight[i];
        r.ssi = this->ssi[i];
        return r;
    }

    int nAlloc;
    SOA<Point3f> p0;
    SOA<Point3f> p1;
    int * PBRT_RESTRICT depth;
    Material * PBRT_RESTRICT material;
    SOA<TabulatedBSSRDF> bssrdf;
    SOA<SampledWavelengths> lambda;
    SOA<SampledSpectrum> beta;
    SOA<SampledSpectrum> r_u;
    SOA<MediumInterface> mediumInterface;
    Float * PBRT_RESTRICT etaScale;
    int * PBRT_RESTRICT pixelIndex;
    Float * PBRT_RESTRICT reservoirPDF;
    Float * PBRT_RESTRICT uLight;
    SOA<SubsurfaceInteraction> ssi;
};

template <> struct SOA<MediumSampleWorkItem> {
    SOA() = default;
    SOA(int n, Allocator alloc) : nAlloc(n) {
        this->ray = SOA<Ray>(n, alloc);
        this->depth = alloc.allocate_object<int>(n);
        this->tMax = alloc.allocate_object<Float>(n);
        this->lambda = SOA<SampledWavelengths>(n, alloc);
        this->beta = SOA<SampledSpectrum>(n, alloc);
        this->r_u = SOA<SampledSpectrum>(n, alloc);
        this->r_l = SOA<SampledSpectrum>(n, alloc);
        this->pixelIndex = alloc.allocate_object<int>(n);
        this->areaLight = alloc.allocate_object<Light>(n);
        this->pi = SOA<Point3fi>(n, alloc);
        this->n = SOA<Normal3f>(n, alloc);
        this->dpdu = SOA<Vector3f>(n, alloc);
        this->dpdv = SOA<Vector3f>(n, alloc);
        this->wo = SOA<Vector3f>(n, alloc);
        this->uv = SOA<Point2f>(n, alloc);
        this->prevIntrCtx = SOA<LightSampleContext>(n, alloc);
        this->specularBounce = alloc.allocate_object<int>(n);
        this->material = alloc.allocate_object<Material>(n);
        this->ns = SOA<Normal3f>(n, alloc);
        this->dpdus = SOA<Vector3f>(n, alloc);
        this->dpdvs = SOA<Vector3f>(n, alloc);
        this->dndus = SOA<Normal3f>(n, alloc);
        this->dndvs = SOA<Normal3f>(n, alloc);
        this->faceIndex = alloc.allocate_object<int>(n);
        this->anyNonSpecularBounces = alloc.allocate_object<int>(n);
        this->etaScale = alloc.allocate_object<Float>(n);
        this->mediumInterface = SOA<MediumInterface>(n, alloc);
    }
    SOA &operator=(const SOA& s) {
        nAlloc = s.nAlloc;
        this->ray = s.ray;
        this->depth = s.depth;
        this->tMax = s.tMax;
        this->lambda = s.lambda;
        this->beta = s.beta;
        this->r_u = s.r_u;
        this->r_l = s.r_l;
        this->pixelIndex = s.pixelIndex;
        this->areaLight = s.areaLight;
        this->pi = s.pi;
        this->n = s.n;
        this->dpdu = s.dpdu;
        this->dpdv = s.dpdv;
        this->wo = s.wo;
        this->uv = s.uv;
        this->prevIntrCtx = s.prevIntrCtx;
        this->specularBounce = s.specularBounce;
        this->material = s.material;
        this->ns = s.ns;
        this->dpdus = s.dpdus;
        this->dpdvs = s.dpdvs;
        this->dndus = s.dndus;
        this->dndvs = s.dndvs;
        this->faceIndex = s.faceIndex;
        this->anyNonSpecularBounces = s.anyNonSpecularBounces;
        this->etaScale = s.etaScale;
        this->mediumInterface = s.mediumInterface;
        return *this;
    }
    struct GetSetIndirector {
        PBRT_CPU_GPU
        operator MediumSampleWorkItem() const {
            MediumSampleWorkItem r;
            r.ray = soa->ray[i];
            r.depth = soa->depth[i];
            r.tMax = soa->tMax[i];
            r.lambda = soa->lambda[i];
            r.beta = soa->beta[i];
            r.r_u = soa->r_u[i];
            r.r_l = soa->r_l[i];
            r.pixelIndex = soa->pixelIndex[i];
            r.areaLight = soa->areaLight[i];
            r.pi = soa->pi[i];
            r.n = soa->n[i];
            r.dpdu = soa->dpdu[i];
            r.dpdv = soa->dpdv[i];
            r.wo = soa->wo[i];
            r.uv = soa->uv[i];
            r.prevIntrCtx = soa->prevIntrCtx[i];
            r.specularBounce = soa->specularBounce[i];
            r.material = soa->material[i];
            r.ns = soa->ns[i];
            r.dpdus = soa->dpdus[i];
            r.dpdvs = soa->dpdvs[i];
            r.dndus = soa->dndus[i];
            r.dndvs = soa->dndvs[i];
            r.faceIndex = soa->faceIndex[i];
            r.anyNonSpecularBounces = soa->anyNonSpecularBounces[i];
            r.etaScale = soa->etaScale[i];
            r.mediumInterface = soa->mediumInterface[i];
            return r;
        }
        PBRT_CPU_GPU
        void operator=(const MediumSampleWorkItem &a) {
            soa->ray[i] = a.ray;
            soa->depth[i] = a.depth;
            soa->tMax[i] = a.tMax;
            soa->lambda[i] = a.lambda;
            soa->beta[i] = a.beta;
            soa->r_u[i] = a.r_u;
            soa->r_l[i] = a.r_l;
            soa->pixelIndex[i] = a.pixelIndex;
            soa->areaLight[i] = a.areaLight;
            soa->pi[i] = a.pi;
            soa->n[i] = a.n;
            soa->dpdu[i] = a.dpdu;
            soa->dpdv[i] = a.dpdv;
            soa->wo[i] = a.wo;
            soa->uv[i] = a.uv;
            soa->prevIntrCtx[i] = a.prevIntrCtx;
            soa->specularBounce[i] = a.specularBounce;
            soa->material[i] = a.material;
            soa->ns[i] = a.ns;
            soa->dpdus[i] = a.dpdus;
            soa->dpdvs[i] = a.dpdvs;
            soa->dndus[i] = a.dndus;
            soa->dndvs[i] = a.dndvs;
            soa->faceIndex[i] = a.faceIndex;
            soa->anyNonSpecularBounces[i] = a.anyNonSpecularBounces;
            soa->etaScale[i] = a.etaScale;
            soa->mediumInterface[i] = a.mediumInterface;
        }

        SOA *soa;
        int i;
    };

    PBRT_CPU_GPU
    GetSetIndirector operator[](int i) {
        DCHECK_LT(i, nAlloc);
        return GetSetIndirector{this, i};
    }
    PBRT_CPU_GPU
    MediumSampleWorkItem operator[](int i) const {
        DCHECK_LT(i, nAlloc);
        MediumSampleWorkItem r;
        r.ray = this->ray[i];
        r.depth = this->depth[i];
        r.tMax = this->tMax[i];
        r.lambda = this->lambda[i];
        r.beta = this->beta[i];
        r.r_u = this->r_u[i];
        r.r_l = this->r_l[i];
        r.pixelIndex = this->pixelIndex[i];
        r.areaLight = this->areaLight[i];
        r.pi = this->pi[i];
        r.n = this->n[i];
        r.dpdu = this->dpdu[i];
        r.dpdv = this->dpdv[i];
        r.wo = this->wo[i];
        r.uv = this->uv[i];
        r.prevIntrCtx = this->prevIntrCtx[i];
        r.specularBounce = this->specularBounce[i];
        r.material = this->material[i];
        r.ns = this->ns[i];
        r.dpdus = this->dpdus[i];
        r.dpdvs = this->dpdvs[i];
        r.dndus = this->dndus[i];
        r.dndvs = this->dndvs[i];
        r.faceIndex = this->faceIndex[i];
        r.anyNonSpecularBounces = this->anyNonSpecularBounces[i];
        r.etaScale = this->etaScale[i];
        r.mediumInterface = this->mediumInterface[i];
        return r;
    }

    int nAlloc;
    SOA<Ray> ray;
    int * PBRT_RESTRICT depth;
    Float * PBRT_RESTRICT tMax;
    SOA<SampledWavelengths> lambda;
    SOA<SampledSpectrum> beta;
    SOA<SampledSpectrum> r_u;
    SOA<SampledSpectrum> r_l;
    int * PBRT_RESTRICT pixelIndex;
    Light * PBRT_RESTRICT areaLight;
    SOA<Point3fi> pi;
    SOA<Normal3f> n;
    SOA<Vector3f> dpdu;
    SOA<Vector3f> dpdv;
    SOA<Vector3f> wo;
    SOA<Point2f> uv;
    SOA<LightSampleContext> prevIntrCtx;
    int * PBRT_RESTRICT specularBounce;
    Material * PBRT_RESTRICT material;
    SOA<Normal3f> ns;
    SOA<Vector3f> dpdus;
    SOA<Vector3f> dpdvs;
    SOA<Normal3f> dndus;
    SOA<Normal3f> dndvs;
    int * PBRT_RESTRICT faceIndex;
    int * PBRT_RESTRICT anyNonSpecularBounces;
    Float * PBRT_RESTRICT etaScale;
    SOA<MediumInterface> mediumInterface;
};

template <typename ConcretePhaseFunction> struct SOA<MediumScatterWorkItem<ConcretePhaseFunction>> {
    SOA() = default;
    SOA(int n, Allocator alloc) : nAlloc(n) {
        this->p = SOA<Point3f>(n, alloc);
        this->depth = alloc.allocate_object<int>(n);
        this->lambda = SOA<SampledWavelengths>(n, alloc);
        this->beta = SOA<SampledSpectrum>(n, alloc);
        this->r_u = SOA<SampledSpectrum>(n, alloc);
        this->phase = alloc.allocate_object<const ConcretePhaseFunction*>(n);
        this->wo = SOA<Vector3f>(n, alloc);
        this->time = alloc.allocate_object<Float>(n);
        this->etaScale = alloc.allocate_object<Float>(n);
        this->medium = alloc.allocate_object<Medium>(n);
        this->pixelIndex = alloc.allocate_object<int>(n);
    }
    SOA &operator=(const SOA& s) {
        nAlloc = s.nAlloc;
        this->p = s.p;
        this->depth = s.depth;
        this->lambda = s.lambda;
        this->beta = s.beta;
        this->r_u = s.r_u;
        this->phase = s.phase;
        this->wo = s.wo;
        this->time = s.time;
        this->etaScale = s.etaScale;
        this->medium = s.medium;
        this->pixelIndex = s.pixelIndex;
        return *this;
    }
    struct GetSetIndirector {
        PBRT_CPU_GPU
        operator MediumScatterWorkItem<ConcretePhaseFunction>() const {
            MediumScatterWorkItem<ConcretePhaseFunction> r;
            r.p = soa->p[i];
            r.depth = soa->depth[i];
            r.lambda = soa->lambda[i];
            r.beta = soa->beta[i];
            r.r_u = soa->r_u[i];
            r.phase = soa->phase[i];
            r.wo = soa->wo[i];
            r.time = soa->time[i];
            r.etaScale = soa->etaScale[i];
            r.medium = soa->medium[i];
            r.pixelIndex = soa->pixelIndex[i];
            return r;
        }
        PBRT_CPU_GPU
        void operator=(const MediumScatterWorkItem<ConcretePhaseFunction> &a) {
            soa->p[i] = a.p;
            soa->depth[i] = a.depth;
            soa->lambda[i] = a.lambda;
            soa->beta[i] = a.beta;
            soa->r_u[i] = a.r_u;
            soa->phase[i] = a.phase;
            soa->wo[i] = a.wo;
            soa->time[i] = a.time;
            soa->etaScale[i] = a.etaScale;
            soa->medium[i] = a.medium;
            soa->pixelIndex[i] = a.pixelIndex;
        }

        SOA *soa;
        int i;
    };

    PBRT_CPU_GPU
    GetSetIndirector operator[](int i) {
        DCHECK_LT(i, nAlloc);
        return GetSetIndirector{this, i};
    }
    PBRT_CPU_GPU
    MediumScatterWorkItem<ConcretePhaseFunction> operator[](int i) const {
        DCHECK_LT(i, nAlloc);
        MediumScatterWorkItem<ConcretePhaseFunction> r;
        r.p = this->p[i];
        r.depth = this->depth[i];
        r.lambda = this->lambda[i];
        r.beta = this->beta[i];
        r.r_u = this->r_u[i];
        r.phase = this->phase[i];
        r.wo = this->wo[i];
        r.time = this->time[i];
        r.etaScale = this->etaScale[i];
        r.medium = this->medium[i];
        r.pixelIndex = this->pixelIndex[i];
        return r;
    }

    int nAlloc;
    SOA<Point3f> p;
    int * PBRT_RESTRICT depth;
    SOA<SampledWavelengths> lambda;
    SOA<SampledSpectrum> beta;
    SOA<SampledSpectrum> r_u;
    const ConcretePhaseFunction* * PBRT_RESTRICT phase;
    SOA<Vector3f> wo;
    Float * PBRT_RESTRICT time;
    Float * PBRT_RESTRICT etaScale;
    Medium * PBRT_RESTRICT medium;
    int * PBRT_RESTRICT pixelIndex;
};

template <typename ConcreteMaterial> struct SOA<MaterialEvalWorkItem<ConcreteMaterial>> {
    SOA() = default;
    SOA(int n, Allocator alloc) : nAlloc(n) {
        this->material = alloc.allocate_object<const ConcreteMaterial*>(n);
        this->lambda = SOA<SampledWavelengths>(n, alloc);
        this->beta = SOA<SampledSpectrum>(n, alloc);
        this->r_u = SOA<SampledSpectrum>(n, alloc);
        this->pi = SOA<Point3fi>(n, alloc);
        this->n = SOA<Normal3f>(n, alloc);
        this->ns = SOA<Normal3f>(n, alloc);
        this->dpdu = SOA<Vector3f>(n, alloc);
        this->dpdv = SOA<Vector3f>(n, alloc);
        this->dpdus = SOA<Vector3f>(n, alloc);
        this->dpdvs = SOA<Vector3f>(n, alloc);
        this->dndus = SOA<Normal3f>(n, alloc);
        this->dndvs = SOA<Normal3f>(n, alloc);
        this->wo = SOA<Vector3f>(n, alloc);
        this->uv = SOA<Point2f>(n, alloc);
        this->depth = alloc.allocate_object<int>(n);
        this->faceIndex = alloc.allocate_object<int>(n);
        this->time = alloc.allocate_object<Float>(n);
        this->anyNonSpecularBounces = alloc.allocate_object<int>(n);
        this->etaScale = alloc.allocate_object<Float>(n);
        this->mediumInterface = SOA<MediumInterface>(n, alloc);
        this->pixelIndex = alloc.allocate_object<int>(n);
    }
    SOA &operator=(const SOA& s) {
        nAlloc = s.nAlloc;
        this->material = s.material;
        this->lambda = s.lambda;
        this->beta = s.beta;
        this->r_u = s.r_u;
        this->pi = s.pi;
        this->n = s.n;
        this->ns = s.ns;
        this->dpdu = s.dpdu;
        this->dpdv = s.dpdv;
        this->dpdus = s.dpdus;
        this->dpdvs = s.dpdvs;
        this->dndus = s.dndus;
        this->dndvs = s.dndvs;
        this->wo = s.wo;
        this->uv = s.uv;
        this->depth = s.depth;
        this->faceIndex = s.faceIndex;
        this->time = s.time;
        this->anyNonSpecularBounces = s.anyNonSpecularBounces;
        this->etaScale = s.etaScale;
        this->mediumInterface = s.mediumInterface;
        this->pixelIndex = s.pixelIndex;
        return *this;
    }
    struct GetSetIndirector {
        PBRT_CPU_GPU
        operator MaterialEvalWorkItem<ConcreteMaterial>() const {
            MaterialEvalWorkItem<ConcreteMaterial> r;
            r.material = soa->material[i];
            r.lambda = soa->lambda[i];
            r.beta = soa->beta[i];
            r.r_u = soa->r_u[i];
            r.pi = soa->pi[i];
            r.n = soa->n[i];
            r.ns = soa->ns[i];
            r.dpdu = soa->dpdu[i];
            r.dpdv = soa->dpdv[i];
            r.dpdus = soa->dpdus[i];
            r.dpdvs = soa->dpdvs[i];
            r.dndus = soa->dndus[i];
            r.dndvs = soa->dndvs[i];
            r.wo = soa->wo[i];
            r.uv = soa->uv[i];
            r.depth = soa->depth[i];
            r.faceIndex = soa->faceIndex[i];
            r.time = soa->time[i];
            r.anyNonSpecularBounces = soa->anyNonSpecularBounces[i];
            r.etaScale = soa->etaScale[i];
            r.mediumInterface = soa->mediumInterface[i];
            r.pixelIndex = soa->pixelIndex[i];
            return r;
        }
        PBRT_CPU_GPU
        void operator=(const MaterialEvalWorkItem<ConcreteMaterial> &a) {
            soa->material[i] = a.material;
            soa->lambda[i] = a.lambda;
            soa->beta[i] = a.beta;
            soa->r_u[i] = a.r_u;
            soa->pi[i] = a.pi;
            soa->n[i] = a.n;
            soa->ns[i] = a.ns;
            soa->dpdu[i] = a.dpdu;
            soa->dpdv[i] = a.dpdv;
            soa->dpdus[i] = a.dpdus;
            soa->dpdvs[i] = a.dpdvs;
            soa->dndus[i] = a.dndus;
            soa->dndvs[i] = a.dndvs;
            soa->wo[i] = a.wo;
            soa->uv[i] = a.uv;
            soa->depth[i] = a.depth;
            soa->faceIndex[i] = a.faceIndex;
            soa->time[i] = a.time;
            soa->anyNonSpecularBounces[i] = a.anyNonSpecularBounces;
            soa->etaScale[i] = a.etaScale;
            soa->mediumInterface[i] = a.mediumInterface;
            soa->pixelIndex[i] = a.pixelIndex;
        }

        SOA *soa;
        int i;
    };

    PBRT_CPU_GPU
    GetSetIndirector operator[](int i) {
        DCHECK_LT(i, nAlloc);
        return GetSetIndirector{this, i};
    }
    PBRT_CPU_GPU
    MaterialEvalWorkItem<ConcreteMaterial> operator[](int i) const {
        DCHECK_LT(i, nAlloc);
        MaterialEvalWorkItem<ConcreteMaterial> r;
        r.material = this->material[i];
        r.lambda = this->lambda[i];
        r.beta = this->beta[i];
        r.r_u = this->r_u[i];
        r.pi = this->pi[i];
        r.n = this->n[i];
        r.ns = this->ns[i];
        r.dpdu = this->dpdu[i];
        r.dpdv = this->dpdv[i];
        r.dpdus = this->dpdus[i];
        r.dpdvs = this->dpdvs[i];
        r.dndus = this->dndus[i];
        r.dndvs = this->dndvs[i];
        r.wo = this->wo[i];
        r.uv = this->uv[i];
        r.depth = this->depth[i];
        r.faceIndex = this->faceIndex[i];
        r.time = this->time[i];
        r.anyNonSpecularBounces = this->anyNonSpecularBounces[i];
        r.etaScale = this->etaScale[i];
        r.mediumInterface = this->mediumInterface[i];
        r.pixelIndex = this->pixelIndex[i];
        return r;
    }

    int nAlloc;
    const ConcreteMaterial* * PBRT_RESTRICT material;
    SOA<SampledWavelengths> lambda;
    SOA<SampledSpectrum> beta;
    SOA<SampledSpectrum> r_u;
    SOA<Point3fi> pi;
    SOA<Normal3f> n;
    SOA<Normal3f> ns;
    SOA<Vector3f> dpdu;
    SOA<Vector3f> dpdv;
    SOA<Vector3f> dpdus;
    SOA<Vector3f> dpdvs;
    SOA<Normal3f> dndus;
    SOA<Normal3f> dndvs;
    SOA<Vector3f> wo;
    SOA<Point2f> uv;
    int * PBRT_RESTRICT depth;
    int * PBRT_RESTRICT faceIndex;
    Float * PBRT_RESTRICT time;
    int * PBRT_RESTRICT anyNonSpecularBounces;
    Float * PBRT_RESTRICT etaScale;
    SOA<MediumInterface> mediumInterface;
    int * PBRT_RESTRICT pixelIndex;
};

