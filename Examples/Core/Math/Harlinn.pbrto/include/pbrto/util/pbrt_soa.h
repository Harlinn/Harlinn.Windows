// SOA definitions automatically generated by soac
// DO NOT EDIT THIS FILE MANUALLY

template <typename T> struct SOA;

template <> struct SOA<Interval> {
    SOA() = default;
    SOA(int n, Allocator alloc) : nAlloc(n) {
        this->low = alloc.allocate_object<Float>(n);
        this->high = alloc.allocate_object<Float>(n);
    }
    SOA &operator=(const SOA& s) {
        nAlloc = s.nAlloc;
        this->low = s.low;
        this->high = s.high;
        return *this;
    }
    struct GetSetIndirector {
        PBRT_CPU_GPU
        operator Interval() const {
            Interval r;
            r.low = soa->low[i];
            r.high = soa->high[i];
            return r;
        }
        PBRT_CPU_GPU
        void operator=(const Interval &a) {
            soa->low[i] = a.low;
            soa->high[i] = a.high;
        }

        SOA *soa;
        int i;
    };

    PBRT_CPU_GPU
    GetSetIndirector operator[](int i) {
        DCHECK_LT(i, nAlloc);
        return GetSetIndirector{this, i};
    }
    PBRT_CPU_GPU
    Interval operator[](int i) const {
        DCHECK_LT(i, nAlloc);
        Interval r;
        r.low = this->low[i];
        r.high = this->high[i];
        return r;
    }

    int nAlloc;
    Float * PBRT_RESTRICT low;
    Float * PBRT_RESTRICT high;
};

template <> struct SOA<Point2f> {
    SOA() = default;
    SOA(int n, Allocator alloc) : nAlloc(n) {
        this->x = alloc.allocate_object<Float>(n);
        this->y = alloc.allocate_object<Float>(n);
    }
    SOA &operator=(const SOA& s) {
        nAlloc = s.nAlloc;
        this->x = s.x;
        this->y = s.y;
        return *this;
    }
    struct GetSetIndirector {
        PBRT_CPU_GPU
        operator Point2f() const {
            Point2f r;
            r.x = soa->x[i];
            r.y = soa->y[i];
            return r;
        }
        PBRT_CPU_GPU
        void operator=(const Point2f &a) {
            soa->x[i] = a.x;
            soa->y[i] = a.y;
        }

        SOA *soa;
        int i;
    };

    PBRT_CPU_GPU
    GetSetIndirector operator[](int i) {
        DCHECK_LT(i, nAlloc);
        return GetSetIndirector{this, i};
    }
    PBRT_CPU_GPU
    Point2f operator[](int i) const {
        DCHECK_LT(i, nAlloc);
        Point2f r;
        r.x = this->x[i];
        r.y = this->y[i];
        return r;
    }

    int nAlloc;
    Float * PBRT_RESTRICT x;
    Float * PBRT_RESTRICT y;
};

template <> struct SOA<Point2i> {
    SOA() = default;
    SOA(int n, Allocator alloc) : nAlloc(n) {
        this->x = alloc.allocate_object<int>(n);
        this->y = alloc.allocate_object<int>(n);
    }
    SOA &operator=(const SOA& s) {
        nAlloc = s.nAlloc;
        this->x = s.x;
        this->y = s.y;
        return *this;
    }
    struct GetSetIndirector {
        PBRT_CPU_GPU
        operator Point2i() const {
            Point2i r;
            r.x = soa->x[i];
            r.y = soa->y[i];
            return r;
        }
        PBRT_CPU_GPU
        void operator=(const Point2i &a) {
            soa->x[i] = a.x;
            soa->y[i] = a.y;
        }

        SOA *soa;
        int i;
    };

    PBRT_CPU_GPU
    GetSetIndirector operator[](int i) {
        DCHECK_LT(i, nAlloc);
        return GetSetIndirector{this, i};
    }
    PBRT_CPU_GPU
    Point2i operator[](int i) const {
        DCHECK_LT(i, nAlloc);
        Point2i r;
        r.x = this->x[i];
        r.y = this->y[i];
        return r;
    }

    int nAlloc;
    int * PBRT_RESTRICT x;
    int * PBRT_RESTRICT y;
};

template <> struct SOA<Point3f> {
    SOA() = default;
    SOA(int n, Allocator alloc) : nAlloc(n) {
        this->x = alloc.allocate_object<Float>(n);
        this->y = alloc.allocate_object<Float>(n);
        this->z = alloc.allocate_object<Float>(n);
    }
    SOA &operator=(const SOA& s) {
        nAlloc = s.nAlloc;
        this->x = s.x;
        this->y = s.y;
        this->z = s.z;
        return *this;
    }
    struct GetSetIndirector {
        PBRT_CPU_GPU
        operator Point3f() const {
            Point3f r;
            r.x = soa->x[i];
            r.y = soa->y[i];
            r.z = soa->z[i];
            return r;
        }
        PBRT_CPU_GPU
        void operator=(const Point3f &a) {
            soa->x[i] = a.x;
            soa->y[i] = a.y;
            soa->z[i] = a.z;
        }

        SOA *soa;
        int i;
    };

    PBRT_CPU_GPU
    GetSetIndirector operator[](int i) {
        DCHECK_LT(i, nAlloc);
        return GetSetIndirector{this, i};
    }
    PBRT_CPU_GPU
    Point3f operator[](int i) const {
        DCHECK_LT(i, nAlloc);
        Point3f r;
        r.x = this->x[i];
        r.y = this->y[i];
        r.z = this->z[i];
        return r;
    }

    int nAlloc;
    Float * PBRT_RESTRICT x;
    Float * PBRT_RESTRICT y;
    Float * PBRT_RESTRICT z;
};

template <> struct SOA<Vector3f> {
    SOA() = default;
    SOA(int n, Allocator alloc) : nAlloc(n) {
        this->x = alloc.allocate_object<Float>(n);
        this->y = alloc.allocate_object<Float>(n);
        this->z = alloc.allocate_object<Float>(n);
    }
    SOA &operator=(const SOA& s) {
        nAlloc = s.nAlloc;
        this->x = s.x;
        this->y = s.y;
        this->z = s.z;
        return *this;
    }
    struct GetSetIndirector {
        PBRT_CPU_GPU
        operator Vector3f() const {
            Vector3f r;
            r.x = soa->x[i];
            r.y = soa->y[i];
            r.z = soa->z[i];
            return r;
        }
        PBRT_CPU_GPU
        void operator=(const Vector3f &a) {
            soa->x[i] = a.x;
            soa->y[i] = a.y;
            soa->z[i] = a.z;
        }

        SOA *soa;
        int i;
    };

    PBRT_CPU_GPU
    GetSetIndirector operator[](int i) {
        DCHECK_LT(i, nAlloc);
        return GetSetIndirector{this, i};
    }
    PBRT_CPU_GPU
    Vector3f operator[](int i) const {
        DCHECK_LT(i, nAlloc);
        Vector3f r;
        r.x = this->x[i];
        r.y = this->y[i];
        r.z = this->z[i];
        return r;
    }

    int nAlloc;
    Float * PBRT_RESTRICT x;
    Float * PBRT_RESTRICT y;
    Float * PBRT_RESTRICT z;
};

template <> struct SOA<Normal3f> {
    SOA() = default;
    SOA(int n, Allocator alloc) : nAlloc(n) {
        this->x = alloc.allocate_object<Float>(n);
        this->y = alloc.allocate_object<Float>(n);
        this->z = alloc.allocate_object<Float>(n);
    }
    SOA &operator=(const SOA& s) {
        nAlloc = s.nAlloc;
        this->x = s.x;
        this->y = s.y;
        this->z = s.z;
        return *this;
    }
    struct GetSetIndirector {
        PBRT_CPU_GPU
        operator Normal3f() const {
            Normal3f r;
            r.x = soa->x[i];
            r.y = soa->y[i];
            r.z = soa->z[i];
            return r;
        }
        PBRT_CPU_GPU
        void operator=(const Normal3f &a) {
            soa->x[i] = a.x;
            soa->y[i] = a.y;
            soa->z[i] = a.z;
        }

        SOA *soa;
        int i;
    };

    PBRT_CPU_GPU
    GetSetIndirector operator[](int i) {
        DCHECK_LT(i, nAlloc);
        return GetSetIndirector{this, i};
    }
    PBRT_CPU_GPU
    Normal3f operator[](int i) const {
        DCHECK_LT(i, nAlloc);
        Normal3f r;
        r.x = this->x[i];
        r.y = this->y[i];
        r.z = this->z[i];
        return r;
    }

    int nAlloc;
    Float * PBRT_RESTRICT x;
    Float * PBRT_RESTRICT y;
    Float * PBRT_RESTRICT z;
};

template <> struct SOA<Point3fi> {
    SOA() = default;
    SOA(int n, Allocator alloc) : nAlloc(n) {
        this->x = SOA<Interval>(n, alloc);
        this->y = SOA<Interval>(n, alloc);
        this->z = SOA<Interval>(n, alloc);
    }
    SOA &operator=(const SOA& s) {
        nAlloc = s.nAlloc;
        this->x = s.x;
        this->y = s.y;
        this->z = s.z;
        return *this;
    }
    struct GetSetIndirector {
        PBRT_CPU_GPU
        operator Point3fi() const {
            Point3fi r;
            r.x = soa->x[i];
            r.y = soa->y[i];
            r.z = soa->z[i];
            return r;
        }
        PBRT_CPU_GPU
        void operator=(const Point3fi &a) {
            soa->x[i] = a.x;
            soa->y[i] = a.y;
            soa->z[i] = a.z;
        }

        SOA *soa;
        int i;
    };

    PBRT_CPU_GPU
    GetSetIndirector operator[](int i) {
        DCHECK_LT(i, nAlloc);
        return GetSetIndirector{this, i};
    }
    PBRT_CPU_GPU
    Point3fi operator[](int i) const {
        DCHECK_LT(i, nAlloc);
        Point3fi r;
        r.x = this->x[i];
        r.y = this->y[i];
        r.z = this->z[i];
        return r;
    }

    int nAlloc;
    SOA<Interval> x;
    SOA<Interval> y;
    SOA<Interval> z;
};

template <> struct SOA<Ray> {
    SOA() = default;
    SOA(int n, Allocator alloc) : nAlloc(n) {
        this->o = SOA<Point3f>(n, alloc);
        this->d = SOA<Vector3f>(n, alloc);
        this->time = alloc.allocate_object<Float>(n);
        this->medium = alloc.allocate_object<Medium>(n);
    }
    SOA &operator=(const SOA& s) {
        nAlloc = s.nAlloc;
        this->o = s.o;
        this->d = s.d;
        this->time = s.time;
        this->medium = s.medium;
        return *this;
    }
    struct GetSetIndirector {
        PBRT_CPU_GPU
        operator Ray() const {
            Ray r;
            r.o = soa->o[i];
            r.d = soa->d[i];
            r.time = soa->time[i];
            r.medium = soa->medium[i];
            return r;
        }
        PBRT_CPU_GPU
        void operator=(const Ray &a) {
            soa->o[i] = a.o;
            soa->d[i] = a.d;
            soa->time[i] = a.time;
            soa->medium[i] = a.medium;
        }

        SOA *soa;
        int i;
    };

    PBRT_CPU_GPU
    GetSetIndirector operator[](int i) {
        DCHECK_LT(i, nAlloc);
        return GetSetIndirector{this, i};
    }
    PBRT_CPU_GPU
    Ray operator[](int i) const {
        DCHECK_LT(i, nAlloc);
        Ray r;
        r.o = this->o[i];
        r.d = this->d[i];
        r.time = this->time[i];
        r.medium = this->medium[i];
        return r;
    }

    int nAlloc;
    SOA<Point3f> o;
    SOA<Vector3f> d;
    Float * PBRT_RESTRICT time;
    Medium * PBRT_RESTRICT medium;
};

template <> struct SOA<SubsurfaceInteraction> {
    SOA() = default;
    SOA(int n, Allocator alloc) : nAlloc(n) {
        this->pi = SOA<Point3fi>(n, alloc);
        this->n = SOA<Normal3f>(n, alloc);
        this->dpdu = SOA<Vector3f>(n, alloc);
        this->dpdv = SOA<Vector3f>(n, alloc);
        this->ns = SOA<Normal3f>(n, alloc);
        this->dpdus = SOA<Vector3f>(n, alloc);
        this->dpdvs = SOA<Vector3f>(n, alloc);
    }
    SOA &operator=(const SOA& s) {
        nAlloc = s.nAlloc;
        this->pi = s.pi;
        this->n = s.n;
        this->dpdu = s.dpdu;
        this->dpdv = s.dpdv;
        this->ns = s.ns;
        this->dpdus = s.dpdus;
        this->dpdvs = s.dpdvs;
        return *this;
    }
    struct GetSetIndirector {
        PBRT_CPU_GPU
        operator SubsurfaceInteraction() const {
            SubsurfaceInteraction r;
            r.pi = soa->pi[i];
            r.n = soa->n[i];
            r.dpdu = soa->dpdu[i];
            r.dpdv = soa->dpdv[i];
            r.ns = soa->ns[i];
            r.dpdus = soa->dpdus[i];
            r.dpdvs = soa->dpdvs[i];
            return r;
        }
        PBRT_CPU_GPU
        void operator=(const SubsurfaceInteraction &a) {
            soa->pi[i] = a.pi;
            soa->n[i] = a.n;
            soa->dpdu[i] = a.dpdu;
            soa->dpdv[i] = a.dpdv;
            soa->ns[i] = a.ns;
            soa->dpdus[i] = a.dpdus;
            soa->dpdvs[i] = a.dpdvs;
        }

        SOA *soa;
        int i;
    };

    PBRT_CPU_GPU
    GetSetIndirector operator[](int i) {
        DCHECK_LT(i, nAlloc);
        return GetSetIndirector{this, i};
    }
    PBRT_CPU_GPU
    SubsurfaceInteraction operator[](int i) const {
        DCHECK_LT(i, nAlloc);
        SubsurfaceInteraction r;
        r.pi = this->pi[i];
        r.n = this->n[i];
        r.dpdu = this->dpdu[i];
        r.dpdv = this->dpdv[i];
        r.ns = this->ns[i];
        r.dpdus = this->dpdus[i];
        r.dpdvs = this->dpdvs[i];
        return r;
    }

    int nAlloc;
    SOA<Point3fi> pi;
    SOA<Normal3f> n;
    SOA<Vector3f> dpdu;
    SOA<Vector3f> dpdv;
    SOA<Normal3f> ns;
    SOA<Vector3f> dpdus;
    SOA<Vector3f> dpdvs;
};

template <> struct SOA<Frame> {
    SOA() = default;
    SOA(int n, Allocator alloc) : nAlloc(n) {
        this->x = SOA<Vector3f>(n, alloc);
        this->y = SOA<Vector3f>(n, alloc);
        this->z = SOA<Vector3f>(n, alloc);
    }
    SOA &operator=(const SOA& s) {
        nAlloc = s.nAlloc;
        this->x = s.x;
        this->y = s.y;
        this->z = s.z;
        return *this;
    }
    struct GetSetIndirector {
        PBRT_CPU_GPU
        operator Frame() const {
            Frame r;
            r.x = soa->x[i];
            r.y = soa->y[i];
            r.z = soa->z[i];
            return r;
        }
        PBRT_CPU_GPU
        void operator=(const Frame &a) {
            soa->x[i] = a.x;
            soa->y[i] = a.y;
            soa->z[i] = a.z;
        }

        SOA *soa;
        int i;
    };

    PBRT_CPU_GPU
    GetSetIndirector operator[](int i) {
        DCHECK_LT(i, nAlloc);
        return GetSetIndirector{this, i};
    }
    PBRT_CPU_GPU
    Frame operator[](int i) const {
        DCHECK_LT(i, nAlloc);
        Frame r;
        r.x = this->x[i];
        r.y = this->y[i];
        r.z = this->z[i];
        return r;
    }

    int nAlloc;
    SOA<Vector3f> x;
    SOA<Vector3f> y;
    SOA<Vector3f> z;
};

template <> struct SOA<VisibleSurface> {
    SOA() = default;
    SOA(int n, Allocator alloc) : nAlloc(n) {
        this->set = alloc.allocate_object<bool>(n);
        this->p = SOA<Point3f>(n, alloc);
        this->n = SOA<Normal3f>(n, alloc);
        this->ns = SOA<Normal3f>(n, alloc);
        this->uv = SOA<Point2f>(n, alloc);
        this->time = alloc.allocate_object<Float>(n);
        this->dpdx = SOA<Vector3f>(n, alloc);
        this->dpdy = SOA<Vector3f>(n, alloc);
        this->albedo = SOA<SampledSpectrum>(n, alloc);
    }
    SOA &operator=(const SOA& s) {
        nAlloc = s.nAlloc;
        this->set = s.set;
        this->p = s.p;
        this->n = s.n;
        this->ns = s.ns;
        this->uv = s.uv;
        this->time = s.time;
        this->dpdx = s.dpdx;
        this->dpdy = s.dpdy;
        this->albedo = s.albedo;
        return *this;
    }
    struct GetSetIndirector {
        PBRT_CPU_GPU
        operator VisibleSurface() const {
            VisibleSurface r;
            r.set = soa->set[i];
            r.p = soa->p[i];
            r.n = soa->n[i];
            r.ns = soa->ns[i];
            r.uv = soa->uv[i];
            r.time = soa->time[i];
            r.dpdx = soa->dpdx[i];
            r.dpdy = soa->dpdy[i];
            r.albedo = soa->albedo[i];
            return r;
        }
        PBRT_CPU_GPU
        void operator=(const VisibleSurface &a) {
            soa->set[i] = a.set;
            soa->p[i] = a.p;
            soa->n[i] = a.n;
            soa->ns[i] = a.ns;
            soa->uv[i] = a.uv;
            soa->time[i] = a.time;
            soa->dpdx[i] = a.dpdx;
            soa->dpdy[i] = a.dpdy;
            soa->albedo[i] = a.albedo;
        }

        SOA *soa;
        int i;
    };

    PBRT_CPU_GPU
    GetSetIndirector operator[](int i) {
        DCHECK_LT(i, nAlloc);
        return GetSetIndirector{this, i};
    }
    PBRT_CPU_GPU
    VisibleSurface operator[](int i) const {
        DCHECK_LT(i, nAlloc);
        VisibleSurface r;
        r.set = this->set[i];
        r.p = this->p[i];
        r.n = this->n[i];
        r.ns = this->ns[i];
        r.uv = this->uv[i];
        r.time = this->time[i];
        r.dpdx = this->dpdx[i];
        r.dpdy = this->dpdy[i];
        r.albedo = this->albedo[i];
        return r;
    }

    int nAlloc;
    bool * PBRT_RESTRICT set;
    SOA<Point3f> p;
    SOA<Normal3f> n;
    SOA<Normal3f> ns;
    SOA<Point2f> uv;
    Float * PBRT_RESTRICT time;
    SOA<Vector3f> dpdx;
    SOA<Vector3f> dpdy;
    SOA<SampledSpectrum> albedo;
};

template <> struct SOA<MediumInterface> {
    SOA() = default;
    SOA(int n, Allocator alloc) : nAlloc(n) {
        this->inside = alloc.allocate_object<Medium>(n);
        this->outside = alloc.allocate_object<Medium>(n);
    }
    SOA &operator=(const SOA& s) {
        nAlloc = s.nAlloc;
        this->inside = s.inside;
        this->outside = s.outside;
        return *this;
    }
    struct GetSetIndirector {
        PBRT_CPU_GPU
        operator MediumInterface() const {
            MediumInterface r;
            r.inside = soa->inside[i];
            r.outside = soa->outside[i];
            return r;
        }
        PBRT_CPU_GPU
        void operator=(const MediumInterface &a) {
            soa->inside[i] = a.inside;
            soa->outside[i] = a.outside;
        }

        SOA *soa;
        int i;
    };

    PBRT_CPU_GPU
    GetSetIndirector operator[](int i) {
        DCHECK_LT(i, nAlloc);
        return GetSetIndirector{this, i};
    }
    PBRT_CPU_GPU
    MediumInterface operator[](int i) const {
        DCHECK_LT(i, nAlloc);
        MediumInterface r;
        r.inside = this->inside[i];
        r.outside = this->outside[i];
        return r;
    }

    int nAlloc;
    Medium * PBRT_RESTRICT inside;
    Medium * PBRT_RESTRICT outside;
};

template <> struct SOA<TabulatedBSSRDF> {
    SOA() = default;
    SOA(int n, Allocator alloc) : nAlloc(n) {
        this->po = SOA<Point3f>(n, alloc);
        this->wo = SOA<Vector3f>(n, alloc);
        this->ns = SOA<Normal3f>(n, alloc);
        this->eta = alloc.allocate_object<Float>(n);
        this->table = alloc.allocate_object<const BSSRDFTable*>(n);
        this->sigma_t = SOA<SampledSpectrum>(n, alloc);
        this->rho = SOA<SampledSpectrum>(n, alloc);
    }
    SOA &operator=(const SOA& s) {
        nAlloc = s.nAlloc;
        this->po = s.po;
        this->wo = s.wo;
        this->ns = s.ns;
        this->eta = s.eta;
        this->table = s.table;
        this->sigma_t = s.sigma_t;
        this->rho = s.rho;
        return *this;
    }
    struct GetSetIndirector {
        PBRT_CPU_GPU
        operator TabulatedBSSRDF() const {
            TabulatedBSSRDF r;
            r.po = soa->po[i];
            r.wo = soa->wo[i];
            r.ns = soa->ns[i];
            r.eta = soa->eta[i];
            r.table = soa->table[i];
            r.sigma_t = soa->sigma_t[i];
            r.rho = soa->rho[i];
            return r;
        }
        PBRT_CPU_GPU
        void operator=(const TabulatedBSSRDF &a) {
            soa->po[i] = a.po;
            soa->wo[i] = a.wo;
            soa->ns[i] = a.ns;
            soa->eta[i] = a.eta;
            soa->table[i] = a.table;
            soa->sigma_t[i] = a.sigma_t;
            soa->rho[i] = a.rho;
        }

        SOA *soa;
        int i;
    };

    PBRT_CPU_GPU
    GetSetIndirector operator[](int i) {
        DCHECK_LT(i, nAlloc);
        return GetSetIndirector{this, i};
    }
    PBRT_CPU_GPU
    TabulatedBSSRDF operator[](int i) const {
        DCHECK_LT(i, nAlloc);
        TabulatedBSSRDF r;
        r.po = this->po[i];
        r.wo = this->wo[i];
        r.ns = this->ns[i];
        r.eta = this->eta[i];
        r.table = this->table[i];
        r.sigma_t = this->sigma_t[i];
        r.rho = this->rho[i];
        return r;
    }

    int nAlloc;
    SOA<Point3f> po;
    SOA<Vector3f> wo;
    SOA<Normal3f> ns;
    Float * PBRT_RESTRICT eta;
    const BSSRDFTable* * PBRT_RESTRICT table;
    SOA<SampledSpectrum> sigma_t;
    SOA<SampledSpectrum> rho;
};

template <> struct SOA<LightSampleContext> {
    SOA() = default;
    SOA(int n, Allocator alloc) : nAlloc(n) {
        this->pi = SOA<Point3fi>(n, alloc);
        this->n = SOA<Normal3f>(n, alloc);
        this->ns = SOA<Normal3f>(n, alloc);
    }
    SOA &operator=(const SOA& s) {
        nAlloc = s.nAlloc;
        this->pi = s.pi;
        this->n = s.n;
        this->ns = s.ns;
        return *this;
    }
    struct GetSetIndirector {
        PBRT_CPU_GPU
        operator LightSampleContext() const {
            LightSampleContext r;
            r.pi = soa->pi[i];
            r.n = soa->n[i];
            r.ns = soa->ns[i];
            return r;
        }
        PBRT_CPU_GPU
        void operator=(const LightSampleContext &a) {
            soa->pi[i] = a.pi;
            soa->n[i] = a.n;
            soa->ns[i] = a.ns;
        }

        SOA *soa;
        int i;
    };

    PBRT_CPU_GPU
    GetSetIndirector operator[](int i) {
        DCHECK_LT(i, nAlloc);
        return GetSetIndirector{this, i};
    }
    PBRT_CPU_GPU
    LightSampleContext operator[](int i) const {
        DCHECK_LT(i, nAlloc);
        LightSampleContext r;
        r.pi = this->pi[i];
        r.n = this->n[i];
        r.ns = this->ns[i];
        return r;
    }

    int nAlloc;
    SOA<Point3fi> pi;
    SOA<Normal3f> n;
    SOA<Normal3f> ns;
};

