#pragma once
#ifndef DATA_DATATYPES_H_
#define DATA_DATATYPES_H_

#include "Data/Enums.h"
#include <HODBC.h>
#include <HCCData.h>


namespace Barrelman::Data
{
    using namespace Harlinn;
    using namespace Harlinn::ODBC;
    using namespace Harlinn::Common::Core;

    template<typename ObjectT, typename KeyT>
        requires std::is_enum_v<ObjectT>
    using BaseData = Harlinn::Common::Core::Data::BaseData<ObjectT, KeyT>;

    BARRELMAN_EXPORT std::shared_ptr<BaseData<Kind, Guid>> DataFactory( Kind kind );

    class AircraftTypeData : public BaseData<Kind, Guid>
    {
    public:
        using Base = BaseData<Kind, Guid>;
        static constexpr Kind KIND = Kind::AircraftType;
    private:
        Int64 rowVersion_ = 0;
        FixedDBWideString<127> name_;
    public:
        AircraftTypeData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(rowVersion_);
            name_.WriteTo( destination );
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(rowVersion_);
            name_.ReadFrom( source );
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<AircraftTypeData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<AircraftTypeData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const AircraftTypeData& >( other );
                if ( dataObject.rowVersion_ != rowVersion_ )
                {
                    return false;
                }
                if ( dataObject.name_ != name_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        Int64 RowVersion( ) const
        {
            return rowVersion_;
        }
        void SetRowVersion( const Int64& rowVersion )
        {
            rowVersion_ = rowVersion;
        }
        const FixedDBWideString<127>& Name( ) const
        {
            return name_;
        }
        void SetName( const WideString& name )
        {
            name_ = name;
        }
    };
    class AisMessageData : public BaseData<Kind, Guid>
    {
    public:
        using Base = BaseData<Kind, Guid>;
        static constexpr Kind KIND = Kind::AisMessage;
    private:
        Int64 rowVersion_ = 0;
        Guid aisTransceiver_;
        DateTime receivedTimestamp_;
        Int64 messageSequenceNumber_ = 0;
        Int32 repeat_ = 0;
        Guid mmsi_;
    public:
        AisMessageData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(rowVersion_);
            destination.Write(aisTransceiver_);
            destination.Write(receivedTimestamp_);
            destination.Write(messageSequenceNumber_);
            destination.Write(repeat_);
            destination.Write(mmsi_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(rowVersion_);
            source.Read(aisTransceiver_);
            source.Read(receivedTimestamp_);
            source.Read(messageSequenceNumber_);
            source.Read(repeat_);
            source.Read(mmsi_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<AisMessageData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<AisMessageData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const AisMessageData& >( other );
                if ( dataObject.rowVersion_ != rowVersion_ )
                {
                    return false;
                }
                if ( dataObject.aisTransceiver_ != aisTransceiver_ )
                {
                    return false;
                }
                if ( dataObject.receivedTimestamp_ != receivedTimestamp_ )
                {
                    return false;
                }
                if ( dataObject.messageSequenceNumber_ != messageSequenceNumber_ )
                {
                    return false;
                }
                if ( dataObject.repeat_ != repeat_ )
                {
                    return false;
                }
                if ( dataObject.mmsi_ != mmsi_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        Int64 RowVersion( ) const
        {
            return rowVersion_;
        }
        void SetRowVersion( const Int64& rowVersion )
        {
            rowVersion_ = rowVersion;
        }
        const Guid& AisTransceiver( ) const
        {
            return aisTransceiver_;
        }
        void SetAisTransceiver( const Guid& aisTransceiver )
        {
            aisTransceiver_ = aisTransceiver;
        }
        const DateTime& ReceivedTimestamp( ) const
        {
            return receivedTimestamp_;
        }
        void SetReceivedTimestamp( const DateTime& receivedTimestamp )
        {
            receivedTimestamp_ = receivedTimestamp;
        }
        Int64 MessageSequenceNumber( ) const
        {
            return messageSequenceNumber_;
        }
        void SetMessageSequenceNumber( Int64 messageSequenceNumber )
        {
            messageSequenceNumber_ = messageSequenceNumber;
        }
        Int32 Repeat( ) const
        {
            return repeat_;
        }
        void SetRepeat( Int32 repeat )
        {
            repeat_ = repeat;
        }
        const Guid& Mmsi( ) const
        {
            return mmsi_;
        }
        void SetMmsi( const Guid& mmsi )
        {
            mmsi_ = mmsi;
        }
    };
    class AidToNavigationReportMessageData : public AisMessageData
    {
    public:
        using Base = AisMessageData;
        static constexpr Kind KIND = Kind::AidToNavigationReportMessage;
    private:
        Data::NavigationalAidType navigationalAidType_ = Data::NavigationalAidType::NotSpecified;
        FixedDBWideString<100> name_;
        Data::PositionAccuracy positionAccuracy_ = Data::PositionAccuracy::Low;
        double longitude_ = 0.0;
        double latitude_ = 0.0;
        Int32 dimensionToBow_ = 0;
        Int32 dimensionToStern_ = 0;
        Int32 dimensionToPort_ = 0;
        Int32 dimensionToStarboard_ = 0;
        Data::PositionFixType positionFixType_ = Data::PositionFixType::Undefined1;
        Int32 timestamp_ = 0;
        bool offPosition_ = false;
        Int32 regionalReserved_ = 0;
        Data::Raim raim_ = Data::Raim::NotInUse;
        bool virtualAid_ = false;
        bool assigned_ = false;
        Int32 spare_ = 0;
        FixedDBWideString<100> nameExtension_;
    public:
        AidToNavigationReportMessageData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(navigationalAidType_);
            name_.WriteTo( destination );
            destination.Write(positionAccuracy_);
            destination.Write(longitude_);
            destination.Write(latitude_);
            destination.Write(dimensionToBow_);
            destination.Write(dimensionToStern_);
            destination.Write(dimensionToPort_);
            destination.Write(dimensionToStarboard_);
            destination.Write(positionFixType_);
            destination.Write(timestamp_);
            destination.Write(offPosition_);
            destination.Write(regionalReserved_);
            destination.Write(raim_);
            destination.Write(virtualAid_);
            destination.Write(assigned_);
            destination.Write(spare_);
            nameExtension_.WriteTo( destination );
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(navigationalAidType_);
            name_.ReadFrom( source );
            source.Read(positionAccuracy_);
            source.Read(longitude_);
            source.Read(latitude_);
            source.Read(dimensionToBow_);
            source.Read(dimensionToStern_);
            source.Read(dimensionToPort_);
            source.Read(dimensionToStarboard_);
            source.Read(positionFixType_);
            source.Read(timestamp_);
            source.Read(offPosition_);
            source.Read(regionalReserved_);
            source.Read(raim_);
            source.Read(virtualAid_);
            source.Read(assigned_);
            source.Read(spare_);
            nameExtension_.ReadFrom( source );
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<AidToNavigationReportMessageData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<AidToNavigationReportMessageData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const AidToNavigationReportMessageData& >( other );
                if ( dataObject.navigationalAidType_ != navigationalAidType_ )
                {
                    return false;
                }
                if ( dataObject.name_ != name_ )
                {
                    return false;
                }
                if ( dataObject.positionAccuracy_ != positionAccuracy_ )
                {
                    return false;
                }
                if ( dataObject.longitude_ != longitude_ )
                {
                    return false;
                }
                if ( dataObject.latitude_ != latitude_ )
                {
                    return false;
                }
                if ( dataObject.dimensionToBow_ != dimensionToBow_ )
                {
                    return false;
                }
                if ( dataObject.dimensionToStern_ != dimensionToStern_ )
                {
                    return false;
                }
                if ( dataObject.dimensionToPort_ != dimensionToPort_ )
                {
                    return false;
                }
                if ( dataObject.dimensionToStarboard_ != dimensionToStarboard_ )
                {
                    return false;
                }
                if ( dataObject.positionFixType_ != positionFixType_ )
                {
                    return false;
                }
                if ( dataObject.timestamp_ != timestamp_ )
                {
                    return false;
                }
                if ( dataObject.offPosition_ != offPosition_ )
                {
                    return false;
                }
                if ( dataObject.regionalReserved_ != regionalReserved_ )
                {
                    return false;
                }
                if ( dataObject.raim_ != raim_ )
                {
                    return false;
                }
                if ( dataObject.virtualAid_ != virtualAid_ )
                {
                    return false;
                }
                if ( dataObject.assigned_ != assigned_ )
                {
                    return false;
                }
                if ( dataObject.spare_ != spare_ )
                {
                    return false;
                }
                if ( dataObject.nameExtension_ != nameExtension_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        Data::NavigationalAidType NavigationalAidType( ) const
        {
            return navigationalAidType_;
        }
        void SetNavigationalAidType( Data::NavigationalAidType navigationalAidType )
        {
            navigationalAidType_ = navigationalAidType;
        }
        const FixedDBWideString<100>& Name( ) const
        {
            return name_;
        }
        void SetName( const WideString& name )
        {
            name_ = name;
        }
        Data::PositionAccuracy PositionAccuracy( ) const
        {
            return positionAccuracy_;
        }
        void SetPositionAccuracy( Data::PositionAccuracy positionAccuracy )
        {
            positionAccuracy_ = positionAccuracy;
        }
        double Longitude( ) const
        {
            return longitude_;
        }
        void SetLongitude( double longitude )
        {
            longitude_ = longitude;
        }
        double Latitude( ) const
        {
            return latitude_;
        }
        void SetLatitude( double latitude )
        {
            latitude_ = latitude;
        }
        Int32 DimensionToBow( ) const
        {
            return dimensionToBow_;
        }
        void SetDimensionToBow( Int32 dimensionToBow )
        {
            dimensionToBow_ = dimensionToBow;
        }
        Int32 DimensionToStern( ) const
        {
            return dimensionToStern_;
        }
        void SetDimensionToStern( Int32 dimensionToStern )
        {
            dimensionToStern_ = dimensionToStern;
        }
        Int32 DimensionToPort( ) const
        {
            return dimensionToPort_;
        }
        void SetDimensionToPort( Int32 dimensionToPort )
        {
            dimensionToPort_ = dimensionToPort;
        }
        Int32 DimensionToStarboard( ) const
        {
            return dimensionToStarboard_;
        }
        void SetDimensionToStarboard( Int32 dimensionToStarboard )
        {
            dimensionToStarboard_ = dimensionToStarboard;
        }
        Data::PositionFixType PositionFixType( ) const
        {
            return positionFixType_;
        }
        void SetPositionFixType( Data::PositionFixType positionFixType )
        {
            positionFixType_ = positionFixType;
        }
        Int32 Timestamp( ) const
        {
            return timestamp_;
        }
        void SetTimestamp( Int32 timestamp )
        {
            timestamp_ = timestamp;
        }
        bool OffPosition( ) const
        {
            return offPosition_;
        }
        void SetOffPosition( bool offPosition )
        {
            offPosition_ = offPosition;
        }
        Int32 RegionalReserved( ) const
        {
            return regionalReserved_;
        }
        void SetRegionalReserved( Int32 regionalReserved )
        {
            regionalReserved_ = regionalReserved;
        }
        Data::Raim Raim( ) const
        {
            return raim_;
        }
        void SetRaim( Data::Raim raim )
        {
            raim_ = raim;
        }
        bool VirtualAid( ) const
        {
            return virtualAid_;
        }
        void SetVirtualAid( bool virtualAid )
        {
            virtualAid_ = virtualAid;
        }
        bool Assigned( ) const
        {
            return assigned_;
        }
        void SetAssigned( bool assigned )
        {
            assigned_ = assigned;
        }
        Int32 Spare( ) const
        {
            return spare_;
        }
        void SetSpare( Int32 spare )
        {
            spare_ = spare;
        }
        const FixedDBWideString<100>& NameExtension( ) const
        {
            return nameExtension_;
        }
        void SetNameExtension( const WideString& nameExtension )
        {
            nameExtension_ = nameExtension;
        }
    };
    class AisAddressedSafetyRelatedMessageData : public AisMessageData
    {
    public:
        using Base = AisMessageData;
        static constexpr Kind KIND = Kind::AisAddressedSafetyRelatedMessage;
    private:
        Int32 sequenceNumber_ = 0;
        Guid destinationMmsi_;
        bool retransmitFlag_ = false;
        Int32 spare_ = 0;
        FixedDBWideString<100> text_;
    public:
        AisAddressedSafetyRelatedMessageData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(sequenceNumber_);
            destination.Write(destinationMmsi_);
            destination.Write(retransmitFlag_);
            destination.Write(spare_);
            text_.WriteTo( destination );
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(sequenceNumber_);
            source.Read(destinationMmsi_);
            source.Read(retransmitFlag_);
            source.Read(spare_);
            text_.ReadFrom( source );
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<AisAddressedSafetyRelatedMessageData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<AisAddressedSafetyRelatedMessageData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const AisAddressedSafetyRelatedMessageData& >( other );
                if ( dataObject.sequenceNumber_ != sequenceNumber_ )
                {
                    return false;
                }
                if ( dataObject.destinationMmsi_ != destinationMmsi_ )
                {
                    return false;
                }
                if ( dataObject.retransmitFlag_ != retransmitFlag_ )
                {
                    return false;
                }
                if ( dataObject.spare_ != spare_ )
                {
                    return false;
                }
                if ( dataObject.text_ != text_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        Int32 SequenceNumber( ) const
        {
            return sequenceNumber_;
        }
        void SetSequenceNumber( Int32 sequenceNumber )
        {
            sequenceNumber_ = sequenceNumber;
        }
        const Guid& DestinationMmsi( ) const
        {
            return destinationMmsi_;
        }
        void SetDestinationMmsi( const Guid& destinationMmsi )
        {
            destinationMmsi_ = destinationMmsi;
        }
        bool RetransmitFlag( ) const
        {
            return retransmitFlag_;
        }
        void SetRetransmitFlag( bool retransmitFlag )
        {
            retransmitFlag_ = retransmitFlag;
        }
        Int32 Spare( ) const
        {
            return spare_;
        }
        void SetSpare( Int32 spare )
        {
            spare_ = spare;
        }
        const FixedDBWideString<100>& Text( ) const
        {
            return text_;
        }
        void SetText( const WideString& text )
        {
            text_ = text;
        }
    };
    class AisBaseStationReportMessageData : public AisMessageData
    {
    public:
        using Base = AisMessageData;
        static constexpr Kind KIND = Kind::AisBaseStationReportMessage;
    private:
        DateTime timestamp_;
        Data::PositionAccuracy positionAccuracy_ = Data::PositionAccuracy::Low;
        double longitude_ = 0.0;
        double latitude_ = 0.0;
        Data::PositionFixType positionFixType_ = Data::PositionFixType::Undefined1;
        Int32 spare_ = 0;
        Data::Raim raim_ = Data::Raim::NotInUse;
        Int32 radioStatus_ = 0;
    public:
        AisBaseStationReportMessageData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(timestamp_);
            destination.Write(positionAccuracy_);
            destination.Write(longitude_);
            destination.Write(latitude_);
            destination.Write(positionFixType_);
            destination.Write(spare_);
            destination.Write(raim_);
            destination.Write(radioStatus_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(timestamp_);
            source.Read(positionAccuracy_);
            source.Read(longitude_);
            source.Read(latitude_);
            source.Read(positionFixType_);
            source.Read(spare_);
            source.Read(raim_);
            source.Read(radioStatus_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<AisBaseStationReportMessageData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<AisBaseStationReportMessageData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const AisBaseStationReportMessageData& >( other );
                if ( dataObject.timestamp_ != timestamp_ )
                {
                    return false;
                }
                if ( dataObject.positionAccuracy_ != positionAccuracy_ )
                {
                    return false;
                }
                if ( dataObject.longitude_ != longitude_ )
                {
                    return false;
                }
                if ( dataObject.latitude_ != latitude_ )
                {
                    return false;
                }
                if ( dataObject.positionFixType_ != positionFixType_ )
                {
                    return false;
                }
                if ( dataObject.spare_ != spare_ )
                {
                    return false;
                }
                if ( dataObject.raim_ != raim_ )
                {
                    return false;
                }
                if ( dataObject.radioStatus_ != radioStatus_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        const DateTime& Timestamp( ) const
        {
            return timestamp_;
        }
        void SetTimestamp( const DateTime& timestamp )
        {
            timestamp_ = timestamp;
        }
        Data::PositionAccuracy PositionAccuracy( ) const
        {
            return positionAccuracy_;
        }
        void SetPositionAccuracy( Data::PositionAccuracy positionAccuracy )
        {
            positionAccuracy_ = positionAccuracy;
        }
        double Longitude( ) const
        {
            return longitude_;
        }
        void SetLongitude( double longitude )
        {
            longitude_ = longitude;
        }
        double Latitude( ) const
        {
            return latitude_;
        }
        void SetLatitude( double latitude )
        {
            latitude_ = latitude;
        }
        Data::PositionFixType PositionFixType( ) const
        {
            return positionFixType_;
        }
        void SetPositionFixType( Data::PositionFixType positionFixType )
        {
            positionFixType_ = positionFixType;
        }
        Int32 Spare( ) const
        {
            return spare_;
        }
        void SetSpare( Int32 spare )
        {
            spare_ = spare;
        }
        Data::Raim Raim( ) const
        {
            return raim_;
        }
        void SetRaim( Data::Raim raim )
        {
            raim_ = raim;
        }
        Int32 RadioStatus( ) const
        {
            return radioStatus_;
        }
        void SetRadioStatus( Int32 radioStatus )
        {
            radioStatus_ = radioStatus;
        }
    };
    class AisBinaryAcknowledgeMessageData : public AisMessageData
    {
    public:
        using Base = AisMessageData;
        static constexpr Kind KIND = Kind::AisBinaryAcknowledgeMessage;
    private:
        Int32 spare_ = 0;
        Int32 sequenceNumber1_ = 0;
        Guid mmsi1_;
        Int32 sequenceNumber2_ = 0;
        Guid mmsi2_;
        Int32 sequenceNumber3_ = 0;
        Guid mmsi3_;
        Int32 sequenceNumber4_ = 0;
        Guid mmsi4_;
    public:
        AisBinaryAcknowledgeMessageData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(spare_);
            destination.Write(sequenceNumber1_);
            destination.Write(mmsi1_);
            destination.Write(sequenceNumber2_);
            destination.Write(mmsi2_);
            destination.Write(sequenceNumber3_);
            destination.Write(mmsi3_);
            destination.Write(sequenceNumber4_);
            destination.Write(mmsi4_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(spare_);
            source.Read(sequenceNumber1_);
            source.Read(mmsi1_);
            source.Read(sequenceNumber2_);
            source.Read(mmsi2_);
            source.Read(sequenceNumber3_);
            source.Read(mmsi3_);
            source.Read(sequenceNumber4_);
            source.Read(mmsi4_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<AisBinaryAcknowledgeMessageData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<AisBinaryAcknowledgeMessageData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const AisBinaryAcknowledgeMessageData& >( other );
                if ( dataObject.spare_ != spare_ )
                {
                    return false;
                }
                if ( dataObject.sequenceNumber1_ != sequenceNumber1_ )
                {
                    return false;
                }
                if ( dataObject.mmsi1_ != mmsi1_ )
                {
                    return false;
                }
                if ( dataObject.sequenceNumber2_ != sequenceNumber2_ )
                {
                    return false;
                }
                if ( dataObject.mmsi2_ != mmsi2_ )
                {
                    return false;
                }
                if ( dataObject.sequenceNumber3_ != sequenceNumber3_ )
                {
                    return false;
                }
                if ( dataObject.mmsi3_ != mmsi3_ )
                {
                    return false;
                }
                if ( dataObject.sequenceNumber4_ != sequenceNumber4_ )
                {
                    return false;
                }
                if ( dataObject.mmsi4_ != mmsi4_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        Int32 Spare( ) const
        {
            return spare_;
        }
        void SetSpare( Int32 spare )
        {
            spare_ = spare;
        }
        Int32 SequenceNumber1( ) const
        {
            return sequenceNumber1_;
        }
        void SetSequenceNumber1( Int32 sequenceNumber1 )
        {
            sequenceNumber1_ = sequenceNumber1;
        }
        const Guid& Mmsi1( ) const
        {
            return mmsi1_;
        }
        void SetMmsi1( const Guid& mmsi1 )
        {
            mmsi1_ = mmsi1;
        }
        Int32 SequenceNumber2( ) const
        {
            return sequenceNumber2_;
        }
        void SetSequenceNumber2( Int32 sequenceNumber2 )
        {
            sequenceNumber2_ = sequenceNumber2;
        }
        const Guid& Mmsi2( ) const
        {
            return mmsi2_;
        }
        void SetMmsi2( const Guid& mmsi2 )
        {
            mmsi2_ = mmsi2;
        }
        Int32 SequenceNumber3( ) const
        {
            return sequenceNumber3_;
        }
        void SetSequenceNumber3( Int32 sequenceNumber3 )
        {
            sequenceNumber3_ = sequenceNumber3;
        }
        const Guid& Mmsi3( ) const
        {
            return mmsi3_;
        }
        void SetMmsi3( const Guid& mmsi3 )
        {
            mmsi3_ = mmsi3;
        }
        Int32 SequenceNumber4( ) const
        {
            return sequenceNumber4_;
        }
        void SetSequenceNumber4( Int32 sequenceNumber4 )
        {
            sequenceNumber4_ = sequenceNumber4;
        }
        const Guid& Mmsi4( ) const
        {
            return mmsi4_;
        }
        void SetMmsi4( const Guid& mmsi4 )
        {
            mmsi4_ = mmsi4;
        }
    };
    class AisBinaryAddressedMessageData : public AisMessageData
    {
    public:
        using Base = AisMessageData;
        static constexpr Kind KIND = Kind::AisBinaryAddressedMessage;
    private:
        Int32 sequenceNumber_ = 0;
        Guid destinationMmsi_;
        bool retransmitFlag_ = false;
        Int32 spare_ = 0;
        Int32 designatedAreaCode_ = 0;
        Int32 functionalId_ = 0;
        WideString data_;
        SQLLEN dataLength_ = SQL_NULL_DATA;
    public:
        AisBinaryAddressedMessageData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(sequenceNumber_);
            destination.Write(destinationMmsi_);
            destination.Write(retransmitFlag_);
            destination.Write(spare_);
            destination.Write(designatedAreaCode_);
            destination.Write(functionalId_);
            destination.Write(data_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(sequenceNumber_);
            source.Read(destinationMmsi_);
            source.Read(retransmitFlag_);
            source.Read(spare_);
            source.Read(designatedAreaCode_);
            source.Read(functionalId_);
            source.Read(data_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<AisBinaryAddressedMessageData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<AisBinaryAddressedMessageData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const AisBinaryAddressedMessageData& >( other );
                if ( dataObject.sequenceNumber_ != sequenceNumber_ )
                {
                    return false;
                }
                if ( dataObject.destinationMmsi_ != destinationMmsi_ )
                {
                    return false;
                }
                if ( dataObject.retransmitFlag_ != retransmitFlag_ )
                {
                    return false;
                }
                if ( dataObject.spare_ != spare_ )
                {
                    return false;
                }
                if ( dataObject.designatedAreaCode_ != designatedAreaCode_ )
                {
                    return false;
                }
                if ( dataObject.functionalId_ != functionalId_ )
                {
                    return false;
                }
                if ( dataObject.data_ != data_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        Int32 SequenceNumber( ) const
        {
            return sequenceNumber_;
        }
        void SetSequenceNumber( Int32 sequenceNumber )
        {
            sequenceNumber_ = sequenceNumber;
        }
        const Guid& DestinationMmsi( ) const
        {
            return destinationMmsi_;
        }
        void SetDestinationMmsi( const Guid& destinationMmsi )
        {
            destinationMmsi_ = destinationMmsi;
        }
        bool RetransmitFlag( ) const
        {
            return retransmitFlag_;
        }
        void SetRetransmitFlag( bool retransmitFlag )
        {
            retransmitFlag_ = retransmitFlag;
        }
        Int32 Spare( ) const
        {
            return spare_;
        }
        void SetSpare( Int32 spare )
        {
            spare_ = spare;
        }
        Int32 DesignatedAreaCode( ) const
        {
            return designatedAreaCode_;
        }
        void SetDesignatedAreaCode( Int32 designatedAreaCode )
        {
            designatedAreaCode_ = designatedAreaCode;
        }
        Int32 FunctionalId( ) const
        {
            return functionalId_;
        }
        void SetFunctionalId( Int32 functionalId )
        {
            functionalId_ = functionalId;
        }
        const WideString& Data( ) const
        {
            return data_;
        }
        void SetData( const WideString& data )
        {
            data_ = data;
        }
    };
    class AisBinaryBroadcastMessageData : public AisMessageData
    {
    public:
        using Base = AisMessageData;
        static constexpr Kind KIND = Kind::AisBinaryBroadcastMessage;
    private:
        Int32 spare_ = 0;
        Int32 designatedAreaCode_ = 0;
        Int32 functionalId_ = 0;
        WideString data_;
        SQLLEN dataLength_ = SQL_NULL_DATA;
    public:
        AisBinaryBroadcastMessageData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(spare_);
            destination.Write(designatedAreaCode_);
            destination.Write(functionalId_);
            destination.Write(data_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(spare_);
            source.Read(designatedAreaCode_);
            source.Read(functionalId_);
            source.Read(data_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<AisBinaryBroadcastMessageData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<AisBinaryBroadcastMessageData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const AisBinaryBroadcastMessageData& >( other );
                if ( dataObject.spare_ != spare_ )
                {
                    return false;
                }
                if ( dataObject.designatedAreaCode_ != designatedAreaCode_ )
                {
                    return false;
                }
                if ( dataObject.functionalId_ != functionalId_ )
                {
                    return false;
                }
                if ( dataObject.data_ != data_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        Int32 Spare( ) const
        {
            return spare_;
        }
        void SetSpare( Int32 spare )
        {
            spare_ = spare;
        }
        Int32 DesignatedAreaCode( ) const
        {
            return designatedAreaCode_;
        }
        void SetDesignatedAreaCode( Int32 designatedAreaCode )
        {
            designatedAreaCode_ = designatedAreaCode;
        }
        Int32 FunctionalId( ) const
        {
            return functionalId_;
        }
        void SetFunctionalId( Int32 functionalId )
        {
            functionalId_ = functionalId;
        }
        const WideString& Data( ) const
        {
            return data_;
        }
        void SetData( const WideString& data )
        {
            data_ = data;
        }
    };
    class AisDataLinkManagementMessageData : public AisMessageData
    {
    public:
        using Base = AisMessageData;
        static constexpr Kind KIND = Kind::AisDataLinkManagementMessage;
    private:
        Int32 spare_ = 0;
        Int32 offset1_ = 0;
        Int32 reservedSlots1_ = 0;
        Int32 timeout1_ = 0;
        Int32 increment1_ = 0;
        Int32 offset2_ = 0;
        Int32 reservedSlots2_ = 0;
        Int32 timeout2_ = 0;
        Int32 increment2_ = 0;
        Int32 offset3_ = 0;
        Int32 reservedSlots3_ = 0;
        Int32 timeout3_ = 0;
        Int32 increment3_ = 0;
        Int32 offset4_ = 0;
        Int32 reservedSlots4_ = 0;
        Int32 timeout4_ = 0;
        Int32 increment4_ = 0;
    public:
        AisDataLinkManagementMessageData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(spare_);
            destination.Write(offset1_);
            destination.Write(reservedSlots1_);
            destination.Write(timeout1_);
            destination.Write(increment1_);
            destination.Write(offset2_);
            destination.Write(reservedSlots2_);
            destination.Write(timeout2_);
            destination.Write(increment2_);
            destination.Write(offset3_);
            destination.Write(reservedSlots3_);
            destination.Write(timeout3_);
            destination.Write(increment3_);
            destination.Write(offset4_);
            destination.Write(reservedSlots4_);
            destination.Write(timeout4_);
            destination.Write(increment4_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(spare_);
            source.Read(offset1_);
            source.Read(reservedSlots1_);
            source.Read(timeout1_);
            source.Read(increment1_);
            source.Read(offset2_);
            source.Read(reservedSlots2_);
            source.Read(timeout2_);
            source.Read(increment2_);
            source.Read(offset3_);
            source.Read(reservedSlots3_);
            source.Read(timeout3_);
            source.Read(increment3_);
            source.Read(offset4_);
            source.Read(reservedSlots4_);
            source.Read(timeout4_);
            source.Read(increment4_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<AisDataLinkManagementMessageData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<AisDataLinkManagementMessageData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const AisDataLinkManagementMessageData& >( other );
                if ( dataObject.spare_ != spare_ )
                {
                    return false;
                }
                if ( dataObject.offset1_ != offset1_ )
                {
                    return false;
                }
                if ( dataObject.reservedSlots1_ != reservedSlots1_ )
                {
                    return false;
                }
                if ( dataObject.timeout1_ != timeout1_ )
                {
                    return false;
                }
                if ( dataObject.increment1_ != increment1_ )
                {
                    return false;
                }
                if ( dataObject.offset2_ != offset2_ )
                {
                    return false;
                }
                if ( dataObject.reservedSlots2_ != reservedSlots2_ )
                {
                    return false;
                }
                if ( dataObject.timeout2_ != timeout2_ )
                {
                    return false;
                }
                if ( dataObject.increment2_ != increment2_ )
                {
                    return false;
                }
                if ( dataObject.offset3_ != offset3_ )
                {
                    return false;
                }
                if ( dataObject.reservedSlots3_ != reservedSlots3_ )
                {
                    return false;
                }
                if ( dataObject.timeout3_ != timeout3_ )
                {
                    return false;
                }
                if ( dataObject.increment3_ != increment3_ )
                {
                    return false;
                }
                if ( dataObject.offset4_ != offset4_ )
                {
                    return false;
                }
                if ( dataObject.reservedSlots4_ != reservedSlots4_ )
                {
                    return false;
                }
                if ( dataObject.timeout4_ != timeout4_ )
                {
                    return false;
                }
                if ( dataObject.increment4_ != increment4_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        Int32 Spare( ) const
        {
            return spare_;
        }
        void SetSpare( Int32 spare )
        {
            spare_ = spare;
        }
        Int32 Offset1( ) const
        {
            return offset1_;
        }
        void SetOffset1( Int32 offset1 )
        {
            offset1_ = offset1;
        }
        Int32 ReservedSlots1( ) const
        {
            return reservedSlots1_;
        }
        void SetReservedSlots1( Int32 reservedSlots1 )
        {
            reservedSlots1_ = reservedSlots1;
        }
        Int32 Timeout1( ) const
        {
            return timeout1_;
        }
        void SetTimeout1( Int32 timeout1 )
        {
            timeout1_ = timeout1;
        }
        Int32 Increment1( ) const
        {
            return increment1_;
        }
        void SetIncrement1( Int32 increment1 )
        {
            increment1_ = increment1;
        }
        Int32 Offset2( ) const
        {
            return offset2_;
        }
        void SetOffset2( Int32 offset2 )
        {
            offset2_ = offset2;
        }
        Int32 ReservedSlots2( ) const
        {
            return reservedSlots2_;
        }
        void SetReservedSlots2( Int32 reservedSlots2 )
        {
            reservedSlots2_ = reservedSlots2;
        }
        Int32 Timeout2( ) const
        {
            return timeout2_;
        }
        void SetTimeout2( Int32 timeout2 )
        {
            timeout2_ = timeout2;
        }
        Int32 Increment2( ) const
        {
            return increment2_;
        }
        void SetIncrement2( Int32 increment2 )
        {
            increment2_ = increment2;
        }
        Int32 Offset3( ) const
        {
            return offset3_;
        }
        void SetOffset3( Int32 offset3 )
        {
            offset3_ = offset3;
        }
        Int32 ReservedSlots3( ) const
        {
            return reservedSlots3_;
        }
        void SetReservedSlots3( Int32 reservedSlots3 )
        {
            reservedSlots3_ = reservedSlots3;
        }
        Int32 Timeout3( ) const
        {
            return timeout3_;
        }
        void SetTimeout3( Int32 timeout3 )
        {
            timeout3_ = timeout3;
        }
        Int32 Increment3( ) const
        {
            return increment3_;
        }
        void SetIncrement3( Int32 increment3 )
        {
            increment3_ = increment3;
        }
        Int32 Offset4( ) const
        {
            return offset4_;
        }
        void SetOffset4( Int32 offset4 )
        {
            offset4_ = offset4;
        }
        Int32 ReservedSlots4( ) const
        {
            return reservedSlots4_;
        }
        void SetReservedSlots4( Int32 reservedSlots4 )
        {
            reservedSlots4_ = reservedSlots4;
        }
        Int32 Timeout4( ) const
        {
            return timeout4_;
        }
        void SetTimeout4( Int32 timeout4 )
        {
            timeout4_ = timeout4;
        }
        Int32 Increment4( ) const
        {
            return increment4_;
        }
        void SetIncrement4( Int32 increment4 )
        {
            increment4_ = increment4;
        }
    };
    class AisExtendedClassBCsPositionReportMessageData : public AisMessageData
    {
    public:
        using Base = AisMessageData;
        static constexpr Kind KIND = Kind::AisExtendedClassBCsPositionReportMessage;
    private:
        Int32 reserved_ = 0;
        double speedOverGround_ = 0.0;
        Data::PositionAccuracy positionAccuracy_ = Data::PositionAccuracy::Low;
        double longitude_ = 0.0;
        double latitude_ = 0.0;
        double courseOverGround_ = 0.0;
        DBInt32 trueHeading_;
        Int32 timestamp_ = 0;
        Int32 regionalReserved_ = 0;
        Guid name_;
        Data::ShipType shipType_ = Data::ShipType::NotAvailable;
        Int32 dimensionToBow_ = 0;
        Int32 dimensionToStern_ = 0;
        Int32 dimensionToPort_ = 0;
        Int32 dimensionToStarboard_ = 0;
        Data::PositionFixType positionFixType_ = Data::PositionFixType::Undefined1;
        Data::Raim raim_ = Data::Raim::NotInUse;
        bool dataTerminalReady_ = false;
        bool assigned_ = false;
        Int32 spare_ = 0;
    public:
        AisExtendedClassBCsPositionReportMessageData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(reserved_);
            destination.Write(speedOverGround_);
            destination.Write(positionAccuracy_);
            destination.Write(longitude_);
            destination.Write(latitude_);
            destination.Write(courseOverGround_);
            trueHeading_.WriteTo( destination );
            destination.Write(timestamp_);
            destination.Write(regionalReserved_);
            destination.Write(name_);
            destination.Write(shipType_);
            destination.Write(dimensionToBow_);
            destination.Write(dimensionToStern_);
            destination.Write(dimensionToPort_);
            destination.Write(dimensionToStarboard_);
            destination.Write(positionFixType_);
            destination.Write(raim_);
            destination.Write(dataTerminalReady_);
            destination.Write(assigned_);
            destination.Write(spare_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(reserved_);
            source.Read(speedOverGround_);
            source.Read(positionAccuracy_);
            source.Read(longitude_);
            source.Read(latitude_);
            source.Read(courseOverGround_);
            trueHeading_.ReadFrom( source );
            source.Read(timestamp_);
            source.Read(regionalReserved_);
            source.Read(name_);
            source.Read(shipType_);
            source.Read(dimensionToBow_);
            source.Read(dimensionToStern_);
            source.Read(dimensionToPort_);
            source.Read(dimensionToStarboard_);
            source.Read(positionFixType_);
            source.Read(raim_);
            source.Read(dataTerminalReady_);
            source.Read(assigned_);
            source.Read(spare_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<AisExtendedClassBCsPositionReportMessageData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<AisExtendedClassBCsPositionReportMessageData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const AisExtendedClassBCsPositionReportMessageData& >( other );
                if ( dataObject.reserved_ != reserved_ )
                {
                    return false;
                }
                if ( dataObject.speedOverGround_ != speedOverGround_ )
                {
                    return false;
                }
                if ( dataObject.positionAccuracy_ != positionAccuracy_ )
                {
                    return false;
                }
                if ( dataObject.longitude_ != longitude_ )
                {
                    return false;
                }
                if ( dataObject.latitude_ != latitude_ )
                {
                    return false;
                }
                if ( dataObject.courseOverGround_ != courseOverGround_ )
                {
                    return false;
                }
                if ( dataObject.trueHeading_ != trueHeading_ )
                {
                    return false;
                }
                if ( dataObject.timestamp_ != timestamp_ )
                {
                    return false;
                }
                if ( dataObject.regionalReserved_ != regionalReserved_ )
                {
                    return false;
                }
                if ( dataObject.name_ != name_ )
                {
                    return false;
                }
                if ( dataObject.shipType_ != shipType_ )
                {
                    return false;
                }
                if ( dataObject.dimensionToBow_ != dimensionToBow_ )
                {
                    return false;
                }
                if ( dataObject.dimensionToStern_ != dimensionToStern_ )
                {
                    return false;
                }
                if ( dataObject.dimensionToPort_ != dimensionToPort_ )
                {
                    return false;
                }
                if ( dataObject.dimensionToStarboard_ != dimensionToStarboard_ )
                {
                    return false;
                }
                if ( dataObject.positionFixType_ != positionFixType_ )
                {
                    return false;
                }
                if ( dataObject.raim_ != raim_ )
                {
                    return false;
                }
                if ( dataObject.dataTerminalReady_ != dataTerminalReady_ )
                {
                    return false;
                }
                if ( dataObject.assigned_ != assigned_ )
                {
                    return false;
                }
                if ( dataObject.spare_ != spare_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        Int32 Reserved( ) const
        {
            return reserved_;
        }
        void SetReserved( Int32 reserved )
        {
            reserved_ = reserved;
        }
        double SpeedOverGround( ) const
        {
            return speedOverGround_;
        }
        void SetSpeedOverGround( double speedOverGround )
        {
            speedOverGround_ = speedOverGround;
        }
        Data::PositionAccuracy PositionAccuracy( ) const
        {
            return positionAccuracy_;
        }
        void SetPositionAccuracy( Data::PositionAccuracy positionAccuracy )
        {
            positionAccuracy_ = positionAccuracy;
        }
        double Longitude( ) const
        {
            return longitude_;
        }
        void SetLongitude( double longitude )
        {
            longitude_ = longitude;
        }
        double Latitude( ) const
        {
            return latitude_;
        }
        void SetLatitude( double latitude )
        {
            latitude_ = latitude;
        }
        double CourseOverGround( ) const
        {
            return courseOverGround_;
        }
        void SetCourseOverGround( double courseOverGround )
        {
            courseOverGround_ = courseOverGround;
        }
        const DBInt32& TrueHeading( ) const
        {
            return trueHeading_;
        }
        void SetTrueHeading( const DBInt32& trueHeading )
        {
            trueHeading_ = trueHeading;
        }
        Int32 Timestamp( ) const
        {
            return timestamp_;
        }
        void SetTimestamp( Int32 timestamp )
        {
            timestamp_ = timestamp;
        }
        Int32 RegionalReserved( ) const
        {
            return regionalReserved_;
        }
        void SetRegionalReserved( Int32 regionalReserved )
        {
            regionalReserved_ = regionalReserved;
        }
        const Guid& Name( ) const
        {
            return name_;
        }
        void SetName( const Guid& name )
        {
            name_ = name;
        }
        Data::ShipType ShipType( ) const
        {
            return shipType_;
        }
        void SetShipType( Data::ShipType shipType )
        {
            shipType_ = shipType;
        }
        Int32 DimensionToBow( ) const
        {
            return dimensionToBow_;
        }
        void SetDimensionToBow( Int32 dimensionToBow )
        {
            dimensionToBow_ = dimensionToBow;
        }
        Int32 DimensionToStern( ) const
        {
            return dimensionToStern_;
        }
        void SetDimensionToStern( Int32 dimensionToStern )
        {
            dimensionToStern_ = dimensionToStern;
        }
        Int32 DimensionToPort( ) const
        {
            return dimensionToPort_;
        }
        void SetDimensionToPort( Int32 dimensionToPort )
        {
            dimensionToPort_ = dimensionToPort;
        }
        Int32 DimensionToStarboard( ) const
        {
            return dimensionToStarboard_;
        }
        void SetDimensionToStarboard( Int32 dimensionToStarboard )
        {
            dimensionToStarboard_ = dimensionToStarboard;
        }
        Data::PositionFixType PositionFixType( ) const
        {
            return positionFixType_;
        }
        void SetPositionFixType( Data::PositionFixType positionFixType )
        {
            positionFixType_ = positionFixType;
        }
        Data::Raim Raim( ) const
        {
            return raim_;
        }
        void SetRaim( Data::Raim raim )
        {
            raim_ = raim;
        }
        bool DataTerminalReady( ) const
        {
            return dataTerminalReady_;
        }
        void SetDataTerminalReady( bool dataTerminalReady )
        {
            dataTerminalReady_ = dataTerminalReady;
        }
        bool Assigned( ) const
        {
            return assigned_;
        }
        void SetAssigned( bool assigned )
        {
            assigned_ = assigned;
        }
        Int32 Spare( ) const
        {
            return spare_;
        }
        void SetSpare( Int32 spare )
        {
            spare_ = spare;
        }
    };
    class AisInterrogationMessageData : public AisMessageData
    {
    public:
        using Base = AisMessageData;
        static constexpr Kind KIND = Kind::AisInterrogationMessage;
    private:
        Guid interrogatedMmsi_;
        Data::AisMessageType firstMessageType_ = Data::AisMessageType::PositionReportClassA;
        Int32 firstSlotOffset_ = 0;
        DBEnum<Data::AisMessageType> secondMessageType_;
        DBInt32 secondSlotOffset_;
        Guid secondStationInterrogationMmsi_;
        DBEnum<Data::AisMessageType> secondStationFirstMessageType_;
        DBInt32 secondStationFirstSlotOffset_;
    public:
        AisInterrogationMessageData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(interrogatedMmsi_);
            destination.Write(firstMessageType_);
            destination.Write(firstSlotOffset_);
            secondMessageType_.WriteTo( destination );
            secondSlotOffset_.WriteTo( destination );
            destination.Write(secondStationInterrogationMmsi_);
            secondStationFirstMessageType_.WriteTo( destination );
            secondStationFirstSlotOffset_.WriteTo( destination );
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(interrogatedMmsi_);
            source.Read(firstMessageType_);
            source.Read(firstSlotOffset_);
            secondMessageType_.ReadFrom( source );
            secondSlotOffset_.ReadFrom( source );
            source.Read(secondStationInterrogationMmsi_);
            secondStationFirstMessageType_.ReadFrom( source );
            secondStationFirstSlotOffset_.ReadFrom( source );
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<AisInterrogationMessageData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<AisInterrogationMessageData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const AisInterrogationMessageData& >( other );
                if ( dataObject.interrogatedMmsi_ != interrogatedMmsi_ )
                {
                    return false;
                }
                if ( dataObject.firstMessageType_ != firstMessageType_ )
                {
                    return false;
                }
                if ( dataObject.firstSlotOffset_ != firstSlotOffset_ )
                {
                    return false;
                }
                if ( dataObject.secondMessageType_ != secondMessageType_ )
                {
                    return false;
                }
                if ( dataObject.secondSlotOffset_ != secondSlotOffset_ )
                {
                    return false;
                }
                if ( dataObject.secondStationInterrogationMmsi_ != secondStationInterrogationMmsi_ )
                {
                    return false;
                }
                if ( dataObject.secondStationFirstMessageType_ != secondStationFirstMessageType_ )
                {
                    return false;
                }
                if ( dataObject.secondStationFirstSlotOffset_ != secondStationFirstSlotOffset_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        const Guid& InterrogatedMmsi( ) const
        {
            return interrogatedMmsi_;
        }
        void SetInterrogatedMmsi( const Guid& interrogatedMmsi )
        {
            interrogatedMmsi_ = interrogatedMmsi;
        }
        Data::AisMessageType FirstMessageType( ) const
        {
            return firstMessageType_;
        }
        void SetFirstMessageType( Data::AisMessageType firstMessageType )
        {
            firstMessageType_ = firstMessageType;
        }
        Int32 FirstSlotOffset( ) const
        {
            return firstSlotOffset_;
        }
        void SetFirstSlotOffset( Int32 firstSlotOffset )
        {
            firstSlotOffset_ = firstSlotOffset;
        }
        const DBEnum<Data::AisMessageType>& SecondMessageType( ) const
        {
            return secondMessageType_;
        }
        void SetSecondMessageType( const DBEnum<Data::AisMessageType>& secondMessageType )
        {
            secondMessageType_ = secondMessageType;
        }
        const DBInt32& SecondSlotOffset( ) const
        {
            return secondSlotOffset_;
        }
        void SetSecondSlotOffset( const DBInt32& secondSlotOffset )
        {
            secondSlotOffset_ = secondSlotOffset;
        }
        const Guid& SecondStationInterrogationMmsi( ) const
        {
            return secondStationInterrogationMmsi_;
        }
        void SetSecondStationInterrogationMmsi( const Guid& secondStationInterrogationMmsi )
        {
            secondStationInterrogationMmsi_ = secondStationInterrogationMmsi;
        }
        const DBEnum<Data::AisMessageType>& SecondStationFirstMessageType( ) const
        {
            return secondStationFirstMessageType_;
        }
        void SetSecondStationFirstMessageType( const DBEnum<Data::AisMessageType>& secondStationFirstMessageType )
        {
            secondStationFirstMessageType_ = secondStationFirstMessageType;
        }
        const DBInt32& SecondStationFirstSlotOffset( ) const
        {
            return secondStationFirstSlotOffset_;
        }
        void SetSecondStationFirstSlotOffset( const DBInt32& secondStationFirstSlotOffset )
        {
            secondStationFirstSlotOffset_ = secondStationFirstSlotOffset;
        }
    };
    class AisPositionReportClassAMessageBaseData : public AisMessageData
    {
    public:
        using Base = AisMessageData;
        static constexpr Kind KIND = Kind::AisPositionReportClassAMessageBase;
    private:
        Data::NavigationStatus navigationStatus_ = Data::NavigationStatus::UnderWayUsingEngine;
        DBInt32 rateOfTurn_;
        double speedOverGround_ = 0.0;
        Data::PositionAccuracy positionAccuracy_ = Data::PositionAccuracy::Low;
        double longitude_ = 0.0;
        double latitude_ = 0.0;
        double courseOverGround_ = 0.0;
        DBInt32 trueHeading_;
        Int32 timestamp_ = 0;
        Data::ManeuverIndicator maneuverIndicator_ = Data::ManeuverIndicator::NotAvailable;
        Int32 spare_ = 0;
        Data::Raim raim_ = Data::Raim::NotInUse;
        Int32 radioStatus_ = 0;
    public:
        AisPositionReportClassAMessageBaseData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(navigationStatus_);
            rateOfTurn_.WriteTo( destination );
            destination.Write(speedOverGround_);
            destination.Write(positionAccuracy_);
            destination.Write(longitude_);
            destination.Write(latitude_);
            destination.Write(courseOverGround_);
            trueHeading_.WriteTo( destination );
            destination.Write(timestamp_);
            destination.Write(maneuverIndicator_);
            destination.Write(spare_);
            destination.Write(raim_);
            destination.Write(radioStatus_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(navigationStatus_);
            rateOfTurn_.ReadFrom( source );
            source.Read(speedOverGround_);
            source.Read(positionAccuracy_);
            source.Read(longitude_);
            source.Read(latitude_);
            source.Read(courseOverGround_);
            trueHeading_.ReadFrom( source );
            source.Read(timestamp_);
            source.Read(maneuverIndicator_);
            source.Read(spare_);
            source.Read(raim_);
            source.Read(radioStatus_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<AisPositionReportClassAMessageBaseData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<AisPositionReportClassAMessageBaseData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const AisPositionReportClassAMessageBaseData& >( other );
                if ( dataObject.navigationStatus_ != navigationStatus_ )
                {
                    return false;
                }
                if ( dataObject.rateOfTurn_ != rateOfTurn_ )
                {
                    return false;
                }
                if ( dataObject.speedOverGround_ != speedOverGround_ )
                {
                    return false;
                }
                if ( dataObject.positionAccuracy_ != positionAccuracy_ )
                {
                    return false;
                }
                if ( dataObject.longitude_ != longitude_ )
                {
                    return false;
                }
                if ( dataObject.latitude_ != latitude_ )
                {
                    return false;
                }
                if ( dataObject.courseOverGround_ != courseOverGround_ )
                {
                    return false;
                }
                if ( dataObject.trueHeading_ != trueHeading_ )
                {
                    return false;
                }
                if ( dataObject.timestamp_ != timestamp_ )
                {
                    return false;
                }
                if ( dataObject.maneuverIndicator_ != maneuverIndicator_ )
                {
                    return false;
                }
                if ( dataObject.spare_ != spare_ )
                {
                    return false;
                }
                if ( dataObject.raim_ != raim_ )
                {
                    return false;
                }
                if ( dataObject.radioStatus_ != radioStatus_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        Data::NavigationStatus NavigationStatus( ) const
        {
            return navigationStatus_;
        }
        void SetNavigationStatus( Data::NavigationStatus navigationStatus )
        {
            navigationStatus_ = navigationStatus;
        }
        const DBInt32& RateOfTurn( ) const
        {
            return rateOfTurn_;
        }
        void SetRateOfTurn( const DBInt32& rateOfTurn )
        {
            rateOfTurn_ = rateOfTurn;
        }
        double SpeedOverGround( ) const
        {
            return speedOverGround_;
        }
        void SetSpeedOverGround( double speedOverGround )
        {
            speedOverGround_ = speedOverGround;
        }
        Data::PositionAccuracy PositionAccuracy( ) const
        {
            return positionAccuracy_;
        }
        void SetPositionAccuracy( Data::PositionAccuracy positionAccuracy )
        {
            positionAccuracy_ = positionAccuracy;
        }
        double Longitude( ) const
        {
            return longitude_;
        }
        void SetLongitude( double longitude )
        {
            longitude_ = longitude;
        }
        double Latitude( ) const
        {
            return latitude_;
        }
        void SetLatitude( double latitude )
        {
            latitude_ = latitude;
        }
        double CourseOverGround( ) const
        {
            return courseOverGround_;
        }
        void SetCourseOverGround( double courseOverGround )
        {
            courseOverGround_ = courseOverGround;
        }
        const DBInt32& TrueHeading( ) const
        {
            return trueHeading_;
        }
        void SetTrueHeading( const DBInt32& trueHeading )
        {
            trueHeading_ = trueHeading;
        }
        Int32 Timestamp( ) const
        {
            return timestamp_;
        }
        void SetTimestamp( Int32 timestamp )
        {
            timestamp_ = timestamp;
        }
        Data::ManeuverIndicator ManeuverIndicator( ) const
        {
            return maneuverIndicator_;
        }
        void SetManeuverIndicator( Data::ManeuverIndicator maneuverIndicator )
        {
            maneuverIndicator_ = maneuverIndicator;
        }
        Int32 Spare( ) const
        {
            return spare_;
        }
        void SetSpare( Int32 spare )
        {
            spare_ = spare;
        }
        Data::Raim Raim( ) const
        {
            return raim_;
        }
        void SetRaim( Data::Raim raim )
        {
            raim_ = raim;
        }
        Int32 RadioStatus( ) const
        {
            return radioStatus_;
        }
        void SetRadioStatus( Int32 radioStatus )
        {
            radioStatus_ = radioStatus;
        }
    };
    class AisPositionReportClassAAssignedScheduleMessageData : public AisPositionReportClassAMessageBaseData
    {
    public:
        using Base = AisPositionReportClassAMessageBaseData;
        static constexpr Kind KIND = Kind::AisPositionReportClassAAssignedScheduleMessage;
    private:
    public:
        AisPositionReportClassAAssignedScheduleMessageData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<AisPositionReportClassAAssignedScheduleMessageData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<AisPositionReportClassAAssignedScheduleMessageData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const AisPositionReportClassAAssignedScheduleMessageData& >( other );
                return true;
            }
            return false;
        }
    };
    class AisPositionReportClassAMessageData : public AisPositionReportClassAMessageBaseData
    {
    public:
        using Base = AisPositionReportClassAMessageBaseData;
        static constexpr Kind KIND = Kind::AisPositionReportClassAMessage;
    private:
    public:
        AisPositionReportClassAMessageData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<AisPositionReportClassAMessageData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<AisPositionReportClassAMessageData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const AisPositionReportClassAMessageData& >( other );
                return true;
            }
            return false;
        }
    };
    class AisPositionReportClassAResponseToInterrogationMessageData : public AisPositionReportClassAMessageBaseData
    {
    public:
        using Base = AisPositionReportClassAMessageBaseData;
        static constexpr Kind KIND = Kind::AisPositionReportClassAResponseToInterrogationMessage;
    private:
    public:
        AisPositionReportClassAResponseToInterrogationMessageData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<AisPositionReportClassAResponseToInterrogationMessageData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<AisPositionReportClassAResponseToInterrogationMessageData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const AisPositionReportClassAResponseToInterrogationMessageData& >( other );
                return true;
            }
            return false;
        }
    };
    class AisPositionReportForLongRangeApplicationsMessageData : public AisMessageData
    {
    public:
        using Base = AisMessageData;
        static constexpr Kind KIND = Kind::AisPositionReportForLongRangeApplicationsMessage;
    private:
        Data::PositionAccuracy positionAccuracy_ = Data::PositionAccuracy::Low;
        Data::Raim raim_ = Data::Raim::NotInUse;
        Data::NavigationStatus navigationStatus_ = Data::NavigationStatus::UnderWayUsingEngine;
        double longitude_ = 0.0;
        double latitude_ = 0.0;
        double speedOverGround_ = 0.0;
        double courseOverGround_ = 0.0;
        Data::GnssPositionStatus gnssPositionStatus_ = Data::GnssPositionStatus::CurrentGnssPosition;
        Int32 spare_ = 0;
    public:
        AisPositionReportForLongRangeApplicationsMessageData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(positionAccuracy_);
            destination.Write(raim_);
            destination.Write(navigationStatus_);
            destination.Write(longitude_);
            destination.Write(latitude_);
            destination.Write(speedOverGround_);
            destination.Write(courseOverGround_);
            destination.Write(gnssPositionStatus_);
            destination.Write(spare_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(positionAccuracy_);
            source.Read(raim_);
            source.Read(navigationStatus_);
            source.Read(longitude_);
            source.Read(latitude_);
            source.Read(speedOverGround_);
            source.Read(courseOverGround_);
            source.Read(gnssPositionStatus_);
            source.Read(spare_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<AisPositionReportForLongRangeApplicationsMessageData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<AisPositionReportForLongRangeApplicationsMessageData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const AisPositionReportForLongRangeApplicationsMessageData& >( other );
                if ( dataObject.positionAccuracy_ != positionAccuracy_ )
                {
                    return false;
                }
                if ( dataObject.raim_ != raim_ )
                {
                    return false;
                }
                if ( dataObject.navigationStatus_ != navigationStatus_ )
                {
                    return false;
                }
                if ( dataObject.longitude_ != longitude_ )
                {
                    return false;
                }
                if ( dataObject.latitude_ != latitude_ )
                {
                    return false;
                }
                if ( dataObject.speedOverGround_ != speedOverGround_ )
                {
                    return false;
                }
                if ( dataObject.courseOverGround_ != courseOverGround_ )
                {
                    return false;
                }
                if ( dataObject.gnssPositionStatus_ != gnssPositionStatus_ )
                {
                    return false;
                }
                if ( dataObject.spare_ != spare_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        Data::PositionAccuracy PositionAccuracy( ) const
        {
            return positionAccuracy_;
        }
        void SetPositionAccuracy( Data::PositionAccuracy positionAccuracy )
        {
            positionAccuracy_ = positionAccuracy;
        }
        Data::Raim Raim( ) const
        {
            return raim_;
        }
        void SetRaim( Data::Raim raim )
        {
            raim_ = raim;
        }
        Data::NavigationStatus NavigationStatus( ) const
        {
            return navigationStatus_;
        }
        void SetNavigationStatus( Data::NavigationStatus navigationStatus )
        {
            navigationStatus_ = navigationStatus;
        }
        double Longitude( ) const
        {
            return longitude_;
        }
        void SetLongitude( double longitude )
        {
            longitude_ = longitude;
        }
        double Latitude( ) const
        {
            return latitude_;
        }
        void SetLatitude( double latitude )
        {
            latitude_ = latitude;
        }
        double SpeedOverGround( ) const
        {
            return speedOverGround_;
        }
        void SetSpeedOverGround( double speedOverGround )
        {
            speedOverGround_ = speedOverGround;
        }
        double CourseOverGround( ) const
        {
            return courseOverGround_;
        }
        void SetCourseOverGround( double courseOverGround )
        {
            courseOverGround_ = courseOverGround;
        }
        Data::GnssPositionStatus GnssPositionStatus( ) const
        {
            return gnssPositionStatus_;
        }
        void SetGnssPositionStatus( Data::GnssPositionStatus gnssPositionStatus )
        {
            gnssPositionStatus_ = gnssPositionStatus;
        }
        Int32 Spare( ) const
        {
            return spare_;
        }
        void SetSpare( Int32 spare )
        {
            spare_ = spare;
        }
    };
    class AisSafetyRelatedAcknowledgmentMessageData : public AisMessageData
    {
    public:
        using Base = AisMessageData;
        static constexpr Kind KIND = Kind::AisSafetyRelatedAcknowledgmentMessage;
    private:
        Int32 spare_ = 0;
        Int32 sequenceNumber1_ = 0;
        Guid mmsi1_;
        Int32 sequenceNumber2_ = 0;
        Guid mmsi2_;
        Int32 sequenceNumber3_ = 0;
        Guid mmsi3_;
        Int32 sequenceNumber4_ = 0;
        Guid mmsi4_;
    public:
        AisSafetyRelatedAcknowledgmentMessageData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(spare_);
            destination.Write(sequenceNumber1_);
            destination.Write(mmsi1_);
            destination.Write(sequenceNumber2_);
            destination.Write(mmsi2_);
            destination.Write(sequenceNumber3_);
            destination.Write(mmsi3_);
            destination.Write(sequenceNumber4_);
            destination.Write(mmsi4_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(spare_);
            source.Read(sequenceNumber1_);
            source.Read(mmsi1_);
            source.Read(sequenceNumber2_);
            source.Read(mmsi2_);
            source.Read(sequenceNumber3_);
            source.Read(mmsi3_);
            source.Read(sequenceNumber4_);
            source.Read(mmsi4_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<AisSafetyRelatedAcknowledgmentMessageData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<AisSafetyRelatedAcknowledgmentMessageData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const AisSafetyRelatedAcknowledgmentMessageData& >( other );
                if ( dataObject.spare_ != spare_ )
                {
                    return false;
                }
                if ( dataObject.sequenceNumber1_ != sequenceNumber1_ )
                {
                    return false;
                }
                if ( dataObject.mmsi1_ != mmsi1_ )
                {
                    return false;
                }
                if ( dataObject.sequenceNumber2_ != sequenceNumber2_ )
                {
                    return false;
                }
                if ( dataObject.mmsi2_ != mmsi2_ )
                {
                    return false;
                }
                if ( dataObject.sequenceNumber3_ != sequenceNumber3_ )
                {
                    return false;
                }
                if ( dataObject.mmsi3_ != mmsi3_ )
                {
                    return false;
                }
                if ( dataObject.sequenceNumber4_ != sequenceNumber4_ )
                {
                    return false;
                }
                if ( dataObject.mmsi4_ != mmsi4_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        Int32 Spare( ) const
        {
            return spare_;
        }
        void SetSpare( Int32 spare )
        {
            spare_ = spare;
        }
        Int32 SequenceNumber1( ) const
        {
            return sequenceNumber1_;
        }
        void SetSequenceNumber1( Int32 sequenceNumber1 )
        {
            sequenceNumber1_ = sequenceNumber1;
        }
        const Guid& Mmsi1( ) const
        {
            return mmsi1_;
        }
        void SetMmsi1( const Guid& mmsi1 )
        {
            mmsi1_ = mmsi1;
        }
        Int32 SequenceNumber2( ) const
        {
            return sequenceNumber2_;
        }
        void SetSequenceNumber2( Int32 sequenceNumber2 )
        {
            sequenceNumber2_ = sequenceNumber2;
        }
        const Guid& Mmsi2( ) const
        {
            return mmsi2_;
        }
        void SetMmsi2( const Guid& mmsi2 )
        {
            mmsi2_ = mmsi2;
        }
        Int32 SequenceNumber3( ) const
        {
            return sequenceNumber3_;
        }
        void SetSequenceNumber3( Int32 sequenceNumber3 )
        {
            sequenceNumber3_ = sequenceNumber3;
        }
        const Guid& Mmsi3( ) const
        {
            return mmsi3_;
        }
        void SetMmsi3( const Guid& mmsi3 )
        {
            mmsi3_ = mmsi3;
        }
        Int32 SequenceNumber4( ) const
        {
            return sequenceNumber4_;
        }
        void SetSequenceNumber4( Int32 sequenceNumber4 )
        {
            sequenceNumber4_ = sequenceNumber4;
        }
        const Guid& Mmsi4( ) const
        {
            return mmsi4_;
        }
        void SetMmsi4( const Guid& mmsi4 )
        {
            mmsi4_ = mmsi4;
        }
    };
    class AisStandardClassBCsPositionReportMessageData : public AisMessageData
    {
    public:
        using Base = AisMessageData;
        static constexpr Kind KIND = Kind::AisStandardClassBCsPositionReportMessage;
    private:
        Int32 reserved_ = 0;
        double speedOverGround_ = 0.0;
        Data::PositionAccuracy positionAccuracy_ = Data::PositionAccuracy::Low;
        double longitude_ = 0.0;
        double latitude_ = 0.0;
        double courseOverGround_ = 0.0;
        DBInt32 trueHeading_;
        Int32 timestamp_ = 0;
        Int32 regionalReserved_ = 0;
        bool isCsUnit_ = false;
        bool hasDisplay_ = false;
        bool hasDscCapability_ = false;
        bool band_ = false;
        bool canAcceptMessage22_ = false;
        bool assigned_ = false;
        Data::Raim raim_ = Data::Raim::NotInUse;
        Int32 radioStatus_ = 0;
    public:
        AisStandardClassBCsPositionReportMessageData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(reserved_);
            destination.Write(speedOverGround_);
            destination.Write(positionAccuracy_);
            destination.Write(longitude_);
            destination.Write(latitude_);
            destination.Write(courseOverGround_);
            trueHeading_.WriteTo( destination );
            destination.Write(timestamp_);
            destination.Write(regionalReserved_);
            destination.Write(isCsUnit_);
            destination.Write(hasDisplay_);
            destination.Write(hasDscCapability_);
            destination.Write(band_);
            destination.Write(canAcceptMessage22_);
            destination.Write(assigned_);
            destination.Write(raim_);
            destination.Write(radioStatus_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(reserved_);
            source.Read(speedOverGround_);
            source.Read(positionAccuracy_);
            source.Read(longitude_);
            source.Read(latitude_);
            source.Read(courseOverGround_);
            trueHeading_.ReadFrom( source );
            source.Read(timestamp_);
            source.Read(regionalReserved_);
            source.Read(isCsUnit_);
            source.Read(hasDisplay_);
            source.Read(hasDscCapability_);
            source.Read(band_);
            source.Read(canAcceptMessage22_);
            source.Read(assigned_);
            source.Read(raim_);
            source.Read(radioStatus_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<AisStandardClassBCsPositionReportMessageData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<AisStandardClassBCsPositionReportMessageData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const AisStandardClassBCsPositionReportMessageData& >( other );
                if ( dataObject.reserved_ != reserved_ )
                {
                    return false;
                }
                if ( dataObject.speedOverGround_ != speedOverGround_ )
                {
                    return false;
                }
                if ( dataObject.positionAccuracy_ != positionAccuracy_ )
                {
                    return false;
                }
                if ( dataObject.longitude_ != longitude_ )
                {
                    return false;
                }
                if ( dataObject.latitude_ != latitude_ )
                {
                    return false;
                }
                if ( dataObject.courseOverGround_ != courseOverGround_ )
                {
                    return false;
                }
                if ( dataObject.trueHeading_ != trueHeading_ )
                {
                    return false;
                }
                if ( dataObject.timestamp_ != timestamp_ )
                {
                    return false;
                }
                if ( dataObject.regionalReserved_ != regionalReserved_ )
                {
                    return false;
                }
                if ( dataObject.isCsUnit_ != isCsUnit_ )
                {
                    return false;
                }
                if ( dataObject.hasDisplay_ != hasDisplay_ )
                {
                    return false;
                }
                if ( dataObject.hasDscCapability_ != hasDscCapability_ )
                {
                    return false;
                }
                if ( dataObject.band_ != band_ )
                {
                    return false;
                }
                if ( dataObject.canAcceptMessage22_ != canAcceptMessage22_ )
                {
                    return false;
                }
                if ( dataObject.assigned_ != assigned_ )
                {
                    return false;
                }
                if ( dataObject.raim_ != raim_ )
                {
                    return false;
                }
                if ( dataObject.radioStatus_ != radioStatus_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        Int32 Reserved( ) const
        {
            return reserved_;
        }
        void SetReserved( Int32 reserved )
        {
            reserved_ = reserved;
        }
        double SpeedOverGround( ) const
        {
            return speedOverGround_;
        }
        void SetSpeedOverGround( double speedOverGround )
        {
            speedOverGround_ = speedOverGround;
        }
        Data::PositionAccuracy PositionAccuracy( ) const
        {
            return positionAccuracy_;
        }
        void SetPositionAccuracy( Data::PositionAccuracy positionAccuracy )
        {
            positionAccuracy_ = positionAccuracy;
        }
        double Longitude( ) const
        {
            return longitude_;
        }
        void SetLongitude( double longitude )
        {
            longitude_ = longitude;
        }
        double Latitude( ) const
        {
            return latitude_;
        }
        void SetLatitude( double latitude )
        {
            latitude_ = latitude;
        }
        double CourseOverGround( ) const
        {
            return courseOverGround_;
        }
        void SetCourseOverGround( double courseOverGround )
        {
            courseOverGround_ = courseOverGround;
        }
        const DBInt32& TrueHeading( ) const
        {
            return trueHeading_;
        }
        void SetTrueHeading( const DBInt32& trueHeading )
        {
            trueHeading_ = trueHeading;
        }
        Int32 Timestamp( ) const
        {
            return timestamp_;
        }
        void SetTimestamp( Int32 timestamp )
        {
            timestamp_ = timestamp;
        }
        Int32 RegionalReserved( ) const
        {
            return regionalReserved_;
        }
        void SetRegionalReserved( Int32 regionalReserved )
        {
            regionalReserved_ = regionalReserved;
        }
        bool IsCsUnit( ) const
        {
            return isCsUnit_;
        }
        void SetIsCsUnit( bool isCsUnit )
        {
            isCsUnit_ = isCsUnit;
        }
        bool HasDisplay( ) const
        {
            return hasDisplay_;
        }
        void SetHasDisplay( bool hasDisplay )
        {
            hasDisplay_ = hasDisplay;
        }
        bool HasDscCapability( ) const
        {
            return hasDscCapability_;
        }
        void SetHasDscCapability( bool hasDscCapability )
        {
            hasDscCapability_ = hasDscCapability;
        }
        bool Band( ) const
        {
            return band_;
        }
        void SetBand( bool band )
        {
            band_ = band;
        }
        bool CanAcceptMessage22( ) const
        {
            return canAcceptMessage22_;
        }
        void SetCanAcceptMessage22( bool canAcceptMessage22 )
        {
            canAcceptMessage22_ = canAcceptMessage22;
        }
        bool Assigned( ) const
        {
            return assigned_;
        }
        void SetAssigned( bool assigned )
        {
            assigned_ = assigned;
        }
        Data::Raim Raim( ) const
        {
            return raim_;
        }
        void SetRaim( Data::Raim raim )
        {
            raim_ = raim;
        }
        Int32 RadioStatus( ) const
        {
            return radioStatus_;
        }
        void SetRadioStatus( Int32 radioStatus )
        {
            radioStatus_ = radioStatus;
        }
    };
    class AisStandardSarAircraftPositionReportMessageData : public AisMessageData
    {
    public:
        using Base = AisMessageData;
        static constexpr Kind KIND = Kind::AisStandardSarAircraftPositionReportMessage;
    private:
        Int32 altitude_ = 0;
        Int32 speedOverGround_ = 0;
        Data::PositionAccuracy positionAccuracy_ = Data::PositionAccuracy::Low;
        double longitude_ = 0.0;
        double latitude_ = 0.0;
        double courseOverGround_ = 0.0;
        Int32 timestamp_ = 0;
        Int32 reserved_ = 0;
        bool dataTerminalReady_ = false;
        Int32 spare_ = 0;
        bool assigned_ = false;
        Data::Raim raim_ = Data::Raim::NotInUse;
        Int32 radioStatus_ = 0;
    public:
        AisStandardSarAircraftPositionReportMessageData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(altitude_);
            destination.Write(speedOverGround_);
            destination.Write(positionAccuracy_);
            destination.Write(longitude_);
            destination.Write(latitude_);
            destination.Write(courseOverGround_);
            destination.Write(timestamp_);
            destination.Write(reserved_);
            destination.Write(dataTerminalReady_);
            destination.Write(spare_);
            destination.Write(assigned_);
            destination.Write(raim_);
            destination.Write(radioStatus_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(altitude_);
            source.Read(speedOverGround_);
            source.Read(positionAccuracy_);
            source.Read(longitude_);
            source.Read(latitude_);
            source.Read(courseOverGround_);
            source.Read(timestamp_);
            source.Read(reserved_);
            source.Read(dataTerminalReady_);
            source.Read(spare_);
            source.Read(assigned_);
            source.Read(raim_);
            source.Read(radioStatus_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<AisStandardSarAircraftPositionReportMessageData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<AisStandardSarAircraftPositionReportMessageData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const AisStandardSarAircraftPositionReportMessageData& >( other );
                if ( dataObject.altitude_ != altitude_ )
                {
                    return false;
                }
                if ( dataObject.speedOverGround_ != speedOverGround_ )
                {
                    return false;
                }
                if ( dataObject.positionAccuracy_ != positionAccuracy_ )
                {
                    return false;
                }
                if ( dataObject.longitude_ != longitude_ )
                {
                    return false;
                }
                if ( dataObject.latitude_ != latitude_ )
                {
                    return false;
                }
                if ( dataObject.courseOverGround_ != courseOverGround_ )
                {
                    return false;
                }
                if ( dataObject.timestamp_ != timestamp_ )
                {
                    return false;
                }
                if ( dataObject.reserved_ != reserved_ )
                {
                    return false;
                }
                if ( dataObject.dataTerminalReady_ != dataTerminalReady_ )
                {
                    return false;
                }
                if ( dataObject.spare_ != spare_ )
                {
                    return false;
                }
                if ( dataObject.assigned_ != assigned_ )
                {
                    return false;
                }
                if ( dataObject.raim_ != raim_ )
                {
                    return false;
                }
                if ( dataObject.radioStatus_ != radioStatus_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        Int32 Altitude( ) const
        {
            return altitude_;
        }
        void SetAltitude( Int32 altitude )
        {
            altitude_ = altitude;
        }
        Int32 SpeedOverGround( ) const
        {
            return speedOverGround_;
        }
        void SetSpeedOverGround( Int32 speedOverGround )
        {
            speedOverGround_ = speedOverGround;
        }
        Data::PositionAccuracy PositionAccuracy( ) const
        {
            return positionAccuracy_;
        }
        void SetPositionAccuracy( Data::PositionAccuracy positionAccuracy )
        {
            positionAccuracy_ = positionAccuracy;
        }
        double Longitude( ) const
        {
            return longitude_;
        }
        void SetLongitude( double longitude )
        {
            longitude_ = longitude;
        }
        double Latitude( ) const
        {
            return latitude_;
        }
        void SetLatitude( double latitude )
        {
            latitude_ = latitude;
        }
        double CourseOverGround( ) const
        {
            return courseOverGround_;
        }
        void SetCourseOverGround( double courseOverGround )
        {
            courseOverGround_ = courseOverGround;
        }
        Int32 Timestamp( ) const
        {
            return timestamp_;
        }
        void SetTimestamp( Int32 timestamp )
        {
            timestamp_ = timestamp;
        }
        Int32 Reserved( ) const
        {
            return reserved_;
        }
        void SetReserved( Int32 reserved )
        {
            reserved_ = reserved;
        }
        bool DataTerminalReady( ) const
        {
            return dataTerminalReady_;
        }
        void SetDataTerminalReady( bool dataTerminalReady )
        {
            dataTerminalReady_ = dataTerminalReady;
        }
        Int32 Spare( ) const
        {
            return spare_;
        }
        void SetSpare( Int32 spare )
        {
            spare_ = spare;
        }
        bool Assigned( ) const
        {
            return assigned_;
        }
        void SetAssigned( bool assigned )
        {
            assigned_ = assigned;
        }
        Data::Raim Raim( ) const
        {
            return raim_;
        }
        void SetRaim( Data::Raim raim )
        {
            raim_ = raim;
        }
        Int32 RadioStatus( ) const
        {
            return radioStatus_;
        }
        void SetRadioStatus( Int32 radioStatus )
        {
            radioStatus_ = radioStatus;
        }
    };
    class AisStaticAndVoyageRelatedDataMessageData : public AisMessageData
    {
    public:
        using Base = AisMessageData;
        static constexpr Kind KIND = Kind::AisStaticAndVoyageRelatedDataMessage;
    private:
        Int32 aisVersion_ = 0;
        Guid imoNumber_;
        Guid callsign_;
        Guid shipName_;
        Data::ShipType shipType_ = Data::ShipType::NotAvailable;
        Int32 dimensionToBow_ = 0;
        Int32 dimensionToStern_ = 0;
        Int32 dimensionToPort_ = 0;
        Int32 dimensionToStarboard_ = 0;
        Data::PositionFixType positionFixType_ = Data::PositionFixType::Undefined1;
        DBDateTime estimatedTimeOfArrival_;
        double draught_ = 0.0;
        FixedDBWideString<100> destination_;
        bool dataTerminalReady_ = false;
        Int32 spare_ = 0;
    public:
        AisStaticAndVoyageRelatedDataMessageData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(aisVersion_);
            destination.Write(imoNumber_);
            destination.Write(callsign_);
            destination.Write(shipName_);
            destination.Write(shipType_);
            destination.Write(dimensionToBow_);
            destination.Write(dimensionToStern_);
            destination.Write(dimensionToPort_);
            destination.Write(dimensionToStarboard_);
            destination.Write(positionFixType_);
            estimatedTimeOfArrival_.WriteTo( destination );
            destination.Write(draught_);
            destination_.WriteTo( destination );
            destination.Write(dataTerminalReady_);
            destination.Write(spare_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(aisVersion_);
            source.Read(imoNumber_);
            source.Read(callsign_);
            source.Read(shipName_);
            source.Read(shipType_);
            source.Read(dimensionToBow_);
            source.Read(dimensionToStern_);
            source.Read(dimensionToPort_);
            source.Read(dimensionToStarboard_);
            source.Read(positionFixType_);
            estimatedTimeOfArrival_.ReadFrom( source );
            source.Read(draught_);
            destination_.ReadFrom( source );
            source.Read(dataTerminalReady_);
            source.Read(spare_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<AisStaticAndVoyageRelatedDataMessageData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<AisStaticAndVoyageRelatedDataMessageData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const AisStaticAndVoyageRelatedDataMessageData& >( other );
                if ( dataObject.aisVersion_ != aisVersion_ )
                {
                    return false;
                }
                if ( dataObject.imoNumber_ != imoNumber_ )
                {
                    return false;
                }
                if ( dataObject.callsign_ != callsign_ )
                {
                    return false;
                }
                if ( dataObject.shipName_ != shipName_ )
                {
                    return false;
                }
                if ( dataObject.shipType_ != shipType_ )
                {
                    return false;
                }
                if ( dataObject.dimensionToBow_ != dimensionToBow_ )
                {
                    return false;
                }
                if ( dataObject.dimensionToStern_ != dimensionToStern_ )
                {
                    return false;
                }
                if ( dataObject.dimensionToPort_ != dimensionToPort_ )
                {
                    return false;
                }
                if ( dataObject.dimensionToStarboard_ != dimensionToStarboard_ )
                {
                    return false;
                }
                if ( dataObject.positionFixType_ != positionFixType_ )
                {
                    return false;
                }
                if ( dataObject.estimatedTimeOfArrival_ != estimatedTimeOfArrival_ )
                {
                    return false;
                }
                if ( dataObject.draught_ != draught_ )
                {
                    return false;
                }
                if ( dataObject.destination_ != destination_ )
                {
                    return false;
                }
                if ( dataObject.dataTerminalReady_ != dataTerminalReady_ )
                {
                    return false;
                }
                if ( dataObject.spare_ != spare_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        Int32 AisVersion( ) const
        {
            return aisVersion_;
        }
        void SetAisVersion( Int32 aisVersion )
        {
            aisVersion_ = aisVersion;
        }
        const Guid& ImoNumber( ) const
        {
            return imoNumber_;
        }
        void SetImoNumber( const Guid& imoNumber )
        {
            imoNumber_ = imoNumber;
        }
        const Guid& Callsign( ) const
        {
            return callsign_;
        }
        void SetCallsign( const Guid& callsign )
        {
            callsign_ = callsign;
        }
        const Guid& ShipName( ) const
        {
            return shipName_;
        }
        void SetShipName( const Guid& shipName )
        {
            shipName_ = shipName;
        }
        Data::ShipType ShipType( ) const
        {
            return shipType_;
        }
        void SetShipType( Data::ShipType shipType )
        {
            shipType_ = shipType;
        }
        Int32 DimensionToBow( ) const
        {
            return dimensionToBow_;
        }
        void SetDimensionToBow( Int32 dimensionToBow )
        {
            dimensionToBow_ = dimensionToBow;
        }
        Int32 DimensionToStern( ) const
        {
            return dimensionToStern_;
        }
        void SetDimensionToStern( Int32 dimensionToStern )
        {
            dimensionToStern_ = dimensionToStern;
        }
        Int32 DimensionToPort( ) const
        {
            return dimensionToPort_;
        }
        void SetDimensionToPort( Int32 dimensionToPort )
        {
            dimensionToPort_ = dimensionToPort;
        }
        Int32 DimensionToStarboard( ) const
        {
            return dimensionToStarboard_;
        }
        void SetDimensionToStarboard( Int32 dimensionToStarboard )
        {
            dimensionToStarboard_ = dimensionToStarboard;
        }
        Data::PositionFixType PositionFixType( ) const
        {
            return positionFixType_;
        }
        void SetPositionFixType( Data::PositionFixType positionFixType )
        {
            positionFixType_ = positionFixType;
        }
        const DBDateTime& EstimatedTimeOfArrival( ) const
        {
            return estimatedTimeOfArrival_;
        }
        void SetEstimatedTimeOfArrival( const DBDateTime& estimatedTimeOfArrival )
        {
            estimatedTimeOfArrival_ = estimatedTimeOfArrival;
        }
        double Draught( ) const
        {
            return draught_;
        }
        void SetDraught( double draught )
        {
            draught_ = draught;
        }
        const FixedDBWideString<100>& Destination( ) const
        {
            return destination_;
        }
        void SetDestination( const WideString& destination )
        {
            destination_ = destination;
        }
        bool DataTerminalReady( ) const
        {
            return dataTerminalReady_;
        }
        void SetDataTerminalReady( bool dataTerminalReady )
        {
            dataTerminalReady_ = dataTerminalReady;
        }
        Int32 Spare( ) const
        {
            return spare_;
        }
        void SetSpare( Int32 spare )
        {
            spare_ = spare;
        }
    };
    class AisStaticDataReportMessageData : public AisMessageData
    {
    public:
        using Base = AisMessageData;
        static constexpr Kind KIND = Kind::AisStaticDataReportMessage;
    private:
        Int32 partNumber_ = 0;
    public:
        AisStaticDataReportMessageData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(partNumber_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(partNumber_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<AisStaticDataReportMessageData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<AisStaticDataReportMessageData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const AisStaticDataReportMessageData& >( other );
                if ( dataObject.partNumber_ != partNumber_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        Int32 PartNumber( ) const
        {
            return partNumber_;
        }
        void SetPartNumber( Int32 partNumber )
        {
            partNumber_ = partNumber;
        }
    };
    class AisStaticDataReportPartAMessageData : public AisStaticDataReportMessageData
    {
    public:
        using Base = AisStaticDataReportMessageData;
        static constexpr Kind KIND = Kind::AisStaticDataReportPartAMessage;
    private:
        Guid shipName_;
        Int32 spare_ = 0;
    public:
        AisStaticDataReportPartAMessageData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(shipName_);
            destination.Write(spare_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(shipName_);
            source.Read(spare_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<AisStaticDataReportPartAMessageData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<AisStaticDataReportPartAMessageData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const AisStaticDataReportPartAMessageData& >( other );
                if ( dataObject.shipName_ != shipName_ )
                {
                    return false;
                }
                if ( dataObject.spare_ != spare_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        const Guid& ShipName( ) const
        {
            return shipName_;
        }
        void SetShipName( const Guid& shipName )
        {
            shipName_ = shipName;
        }
        Int32 Spare( ) const
        {
            return spare_;
        }
        void SetSpare( Int32 spare )
        {
            spare_ = spare;
        }
    };
    class AisStaticDataReportPartBMessageData : public AisStaticDataReportMessageData
    {
    public:
        using Base = AisStaticDataReportMessageData;
        static constexpr Kind KIND = Kind::AisStaticDataReportPartBMessage;
    private:
        Data::ShipType shipType_ = Data::ShipType::NotAvailable;
        FixedDBWideString<100> vendorId_;
        Int32 unitModelCode_ = 0;
        Int32 serialNumber_ = 0;
        Guid callsign_;
        Int32 dimensionToBow_ = 0;
        Int32 dimensionToStern_ = 0;
        Int32 dimensionToPort_ = 0;
        Int32 dimensionToStarboard_ = 0;
        Guid mothershipMmsi_;
        Data::PositionFixType positionFixType_ = Data::PositionFixType::Undefined1;
        Int32 spare_ = 0;
    public:
        AisStaticDataReportPartBMessageData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(shipType_);
            vendorId_.WriteTo( destination );
            destination.Write(unitModelCode_);
            destination.Write(serialNumber_);
            destination.Write(callsign_);
            destination.Write(dimensionToBow_);
            destination.Write(dimensionToStern_);
            destination.Write(dimensionToPort_);
            destination.Write(dimensionToStarboard_);
            destination.Write(mothershipMmsi_);
            destination.Write(positionFixType_);
            destination.Write(spare_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(shipType_);
            vendorId_.ReadFrom( source );
            source.Read(unitModelCode_);
            source.Read(serialNumber_);
            source.Read(callsign_);
            source.Read(dimensionToBow_);
            source.Read(dimensionToStern_);
            source.Read(dimensionToPort_);
            source.Read(dimensionToStarboard_);
            source.Read(mothershipMmsi_);
            source.Read(positionFixType_);
            source.Read(spare_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<AisStaticDataReportPartBMessageData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<AisStaticDataReportPartBMessageData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const AisStaticDataReportPartBMessageData& >( other );
                if ( dataObject.shipType_ != shipType_ )
                {
                    return false;
                }
                if ( dataObject.vendorId_ != vendorId_ )
                {
                    return false;
                }
                if ( dataObject.unitModelCode_ != unitModelCode_ )
                {
                    return false;
                }
                if ( dataObject.serialNumber_ != serialNumber_ )
                {
                    return false;
                }
                if ( dataObject.callsign_ != callsign_ )
                {
                    return false;
                }
                if ( dataObject.dimensionToBow_ != dimensionToBow_ )
                {
                    return false;
                }
                if ( dataObject.dimensionToStern_ != dimensionToStern_ )
                {
                    return false;
                }
                if ( dataObject.dimensionToPort_ != dimensionToPort_ )
                {
                    return false;
                }
                if ( dataObject.dimensionToStarboard_ != dimensionToStarboard_ )
                {
                    return false;
                }
                if ( dataObject.mothershipMmsi_ != mothershipMmsi_ )
                {
                    return false;
                }
                if ( dataObject.positionFixType_ != positionFixType_ )
                {
                    return false;
                }
                if ( dataObject.spare_ != spare_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        Data::ShipType ShipType( ) const
        {
            return shipType_;
        }
        void SetShipType( Data::ShipType shipType )
        {
            shipType_ = shipType;
        }
        const FixedDBWideString<100>& VendorId( ) const
        {
            return vendorId_;
        }
        void SetVendorId( const WideString& vendorId )
        {
            vendorId_ = vendorId;
        }
        Int32 UnitModelCode( ) const
        {
            return unitModelCode_;
        }
        void SetUnitModelCode( Int32 unitModelCode )
        {
            unitModelCode_ = unitModelCode;
        }
        Int32 SerialNumber( ) const
        {
            return serialNumber_;
        }
        void SetSerialNumber( Int32 serialNumber )
        {
            serialNumber_ = serialNumber;
        }
        const Guid& Callsign( ) const
        {
            return callsign_;
        }
        void SetCallsign( const Guid& callsign )
        {
            callsign_ = callsign;
        }
        Int32 DimensionToBow( ) const
        {
            return dimensionToBow_;
        }
        void SetDimensionToBow( Int32 dimensionToBow )
        {
            dimensionToBow_ = dimensionToBow;
        }
        Int32 DimensionToStern( ) const
        {
            return dimensionToStern_;
        }
        void SetDimensionToStern( Int32 dimensionToStern )
        {
            dimensionToStern_ = dimensionToStern;
        }
        Int32 DimensionToPort( ) const
        {
            return dimensionToPort_;
        }
        void SetDimensionToPort( Int32 dimensionToPort )
        {
            dimensionToPort_ = dimensionToPort;
        }
        Int32 DimensionToStarboard( ) const
        {
            return dimensionToStarboard_;
        }
        void SetDimensionToStarboard( Int32 dimensionToStarboard )
        {
            dimensionToStarboard_ = dimensionToStarboard;
        }
        const Guid& MothershipMmsi( ) const
        {
            return mothershipMmsi_;
        }
        void SetMothershipMmsi( const Guid& mothershipMmsi )
        {
            mothershipMmsi_ = mothershipMmsi;
        }
        Data::PositionFixType PositionFixType( ) const
        {
            return positionFixType_;
        }
        void SetPositionFixType( Data::PositionFixType positionFixType )
        {
            positionFixType_ = positionFixType;
        }
        Int32 Spare( ) const
        {
            return spare_;
        }
        void SetSpare( Int32 spare )
        {
            spare_ = spare;
        }
    };
    class AisUtcAndDateInquiryMessageData : public AisMessageData
    {
    public:
        using Base = AisMessageData;
        static constexpr Kind KIND = Kind::AisUtcAndDateInquiryMessage;
    private:
        Int32 spare1_ = 0;
        Int32 destinationMmsi_ = 0;
        Int32 spare2_ = 0;
    public:
        AisUtcAndDateInquiryMessageData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(spare1_);
            destination.Write(destinationMmsi_);
            destination.Write(spare2_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(spare1_);
            source.Read(destinationMmsi_);
            source.Read(spare2_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<AisUtcAndDateInquiryMessageData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<AisUtcAndDateInquiryMessageData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const AisUtcAndDateInquiryMessageData& >( other );
                if ( dataObject.spare1_ != spare1_ )
                {
                    return false;
                }
                if ( dataObject.destinationMmsi_ != destinationMmsi_ )
                {
                    return false;
                }
                if ( dataObject.spare2_ != spare2_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        Int32 Spare1( ) const
        {
            return spare1_;
        }
        void SetSpare1( Int32 spare1 )
        {
            spare1_ = spare1;
        }
        Int32 DestinationMmsi( ) const
        {
            return destinationMmsi_;
        }
        void SetDestinationMmsi( Int32 destinationMmsi )
        {
            destinationMmsi_ = destinationMmsi;
        }
        Int32 Spare2( ) const
        {
            return spare2_;
        }
        void SetSpare2( Int32 spare2 )
        {
            spare2_ = spare2;
        }
    };
    class AisUtcAndDateResponseMessageData : public AisMessageData
    {
    public:
        using Base = AisMessageData;
        static constexpr Kind KIND = Kind::AisUtcAndDateResponseMessage;
    private:
        DateTime datetime_;
        Data::PositionAccuracy positionAccuracy_ = Data::PositionAccuracy::Low;
        double longitude_ = 0.0;
        double latitude_ = 0.0;
        Data::PositionFixType positionFixType_ = Data::PositionFixType::Undefined1;
        Int32 spare_ = 0;
        Data::Raim raim_ = Data::Raim::NotInUse;
        Int32 radioStatus_ = 0;
    public:
        AisUtcAndDateResponseMessageData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(datetime_);
            destination.Write(positionAccuracy_);
            destination.Write(longitude_);
            destination.Write(latitude_);
            destination.Write(positionFixType_);
            destination.Write(spare_);
            destination.Write(raim_);
            destination.Write(radioStatus_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(datetime_);
            source.Read(positionAccuracy_);
            source.Read(longitude_);
            source.Read(latitude_);
            source.Read(positionFixType_);
            source.Read(spare_);
            source.Read(raim_);
            source.Read(radioStatus_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<AisUtcAndDateResponseMessageData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<AisUtcAndDateResponseMessageData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const AisUtcAndDateResponseMessageData& >( other );
                if ( dataObject.datetime_ != datetime_ )
                {
                    return false;
                }
                if ( dataObject.positionAccuracy_ != positionAccuracy_ )
                {
                    return false;
                }
                if ( dataObject.longitude_ != longitude_ )
                {
                    return false;
                }
                if ( dataObject.latitude_ != latitude_ )
                {
                    return false;
                }
                if ( dataObject.positionFixType_ != positionFixType_ )
                {
                    return false;
                }
                if ( dataObject.spare_ != spare_ )
                {
                    return false;
                }
                if ( dataObject.raim_ != raim_ )
                {
                    return false;
                }
                if ( dataObject.radioStatus_ != radioStatus_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        const DateTime& Datetime( ) const
        {
            return datetime_;
        }
        void SetDatetime( const DateTime& datetime )
        {
            datetime_ = datetime;
        }
        Data::PositionAccuracy PositionAccuracy( ) const
        {
            return positionAccuracy_;
        }
        void SetPositionAccuracy( Data::PositionAccuracy positionAccuracy )
        {
            positionAccuracy_ = positionAccuracy;
        }
        double Longitude( ) const
        {
            return longitude_;
        }
        void SetLongitude( double longitude )
        {
            longitude_ = longitude;
        }
        double Latitude( ) const
        {
            return latitude_;
        }
        void SetLatitude( double latitude )
        {
            latitude_ = latitude;
        }
        Data::PositionFixType PositionFixType( ) const
        {
            return positionFixType_;
        }
        void SetPositionFixType( Data::PositionFixType positionFixType )
        {
            positionFixType_ = positionFixType;
        }
        Int32 Spare( ) const
        {
            return spare_;
        }
        void SetSpare( Int32 spare )
        {
            spare_ = spare;
        }
        Data::Raim Raim( ) const
        {
            return raim_;
        }
        void SetRaim( Data::Raim raim )
        {
            raim_ = raim;
        }
        Int32 RadioStatus( ) const
        {
            return radioStatus_;
        }
        void SetRadioStatus( Int32 radioStatus )
        {
            radioStatus_ = radioStatus;
        }
    };
    class AisTransceiverCommandData : public BaseData<Kind, Guid>
    {
    public:
        using Base = BaseData<Kind, Guid>;
        static constexpr Kind KIND = Kind::AisTransceiverCommand;
    private:
        Int64 rowVersion_ = 0;
        Guid aisTransceiver_;
        DateTime timestamp_;
        Data::DeviceCommandSourceType deviceCommandSourceType_ = Data::DeviceCommandSourceType::Unknown;
        Guid deviceCommandSourceId_;
        Guid reply_;
    public:
        AisTransceiverCommandData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(rowVersion_);
            destination.Write(aisTransceiver_);
            destination.Write(timestamp_);
            destination.Write(deviceCommandSourceType_);
            destination.Write(deviceCommandSourceId_);
            destination.Write(reply_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(rowVersion_);
            source.Read(aisTransceiver_);
            source.Read(timestamp_);
            source.Read(deviceCommandSourceType_);
            source.Read(deviceCommandSourceId_);
            source.Read(reply_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<AisTransceiverCommandData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<AisTransceiverCommandData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const AisTransceiverCommandData& >( other );
                if ( dataObject.rowVersion_ != rowVersion_ )
                {
                    return false;
                }
                if ( dataObject.aisTransceiver_ != aisTransceiver_ )
                {
                    return false;
                }
                if ( dataObject.timestamp_ != timestamp_ )
                {
                    return false;
                }
                if ( dataObject.deviceCommandSourceType_ != deviceCommandSourceType_ )
                {
                    return false;
                }
                if ( dataObject.deviceCommandSourceId_ != deviceCommandSourceId_ )
                {
                    return false;
                }
                if ( dataObject.reply_ != reply_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        Int64 RowVersion( ) const
        {
            return rowVersion_;
        }
        void SetRowVersion( const Int64& rowVersion )
        {
            rowVersion_ = rowVersion;
        }
        const Guid& AisTransceiver( ) const
        {
            return aisTransceiver_;
        }
        void SetAisTransceiver( const Guid& aisTransceiver )
        {
            aisTransceiver_ = aisTransceiver;
        }
        const DateTime& Timestamp( ) const
        {
            return timestamp_;
        }
        void SetTimestamp( const DateTime& timestamp )
        {
            timestamp_ = timestamp;
        }
        Data::DeviceCommandSourceType DeviceCommandSourceType( ) const
        {
            return deviceCommandSourceType_;
        }
        void SetDeviceCommandSourceType( Data::DeviceCommandSourceType deviceCommandSourceType )
        {
            deviceCommandSourceType_ = deviceCommandSourceType;
        }
        const Guid& DeviceCommandSourceId( ) const
        {
            return deviceCommandSourceId_;
        }
        void SetDeviceCommandSourceId( const Guid& deviceCommandSourceId )
        {
            deviceCommandSourceId_ = deviceCommandSourceId;
        }
        const Guid& Reply( ) const
        {
            return reply_;
        }
        void SetReply( const Guid& reply )
        {
            reply_ = reply;
        }
    };
    class AisTransceiverCommandReplyData : public BaseData<Kind, Guid>
    {
    public:
        using Base = BaseData<Kind, Guid>;
        static constexpr Kind KIND = Kind::AisTransceiverCommandReply;
    private:
        Int64 rowVersion_ = 0;
        Guid aisTransceiver_;
        DateTime timestamp_;
        Guid command_;
        Data::DeviceCommandReplyStatus status_ = Data::DeviceCommandReplyStatus::Unknown;
        WideString message_;
        SQLLEN messageLength_ = SQL_NULL_DATA;
    public:
        AisTransceiverCommandReplyData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(rowVersion_);
            destination.Write(aisTransceiver_);
            destination.Write(timestamp_);
            destination.Write(command_);
            destination.Write(status_);
            destination.Write(message_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(rowVersion_);
            source.Read(aisTransceiver_);
            source.Read(timestamp_);
            source.Read(command_);
            source.Read(status_);
            source.Read(message_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<AisTransceiverCommandReplyData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<AisTransceiverCommandReplyData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const AisTransceiverCommandReplyData& >( other );
                if ( dataObject.rowVersion_ != rowVersion_ )
                {
                    return false;
                }
                if ( dataObject.aisTransceiver_ != aisTransceiver_ )
                {
                    return false;
                }
                if ( dataObject.timestamp_ != timestamp_ )
                {
                    return false;
                }
                if ( dataObject.command_ != command_ )
                {
                    return false;
                }
                if ( dataObject.status_ != status_ )
                {
                    return false;
                }
                if ( dataObject.message_ != message_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        Int64 RowVersion( ) const
        {
            return rowVersion_;
        }
        void SetRowVersion( const Int64& rowVersion )
        {
            rowVersion_ = rowVersion;
        }
        const Guid& AisTransceiver( ) const
        {
            return aisTransceiver_;
        }
        void SetAisTransceiver( const Guid& aisTransceiver )
        {
            aisTransceiver_ = aisTransceiver;
        }
        const DateTime& Timestamp( ) const
        {
            return timestamp_;
        }
        void SetTimestamp( const DateTime& timestamp )
        {
            timestamp_ = timestamp;
        }
        const Guid& Command( ) const
        {
            return command_;
        }
        void SetCommand( const Guid& command )
        {
            command_ = command;
        }
        Data::DeviceCommandReplyStatus Status( ) const
        {
            return status_;
        }
        void SetStatus( Data::DeviceCommandReplyStatus status )
        {
            status_ = status;
        }
        const WideString& Message( ) const
        {
            return message_;
        }
        void SetMessage( const WideString& message )
        {
            message_ = message;
        }
    };
    class AisTransceiverConfigurationData : public BaseData<Kind, Guid>
    {
    public:
        using Base = BaseData<Kind, Guid>;
        static constexpr Kind KIND = Kind::AisTransceiverConfiguration;
    private:
        Int64 rowVersion_ = 0;
        Guid aisTransceiver_;
        DateTime timestamp_;
        FixedDBWideString<127> userName_;
        FixedDBWideString<127> password_;
        double latitude_ = 0.0;
        double longitude_ = 0.0;
        FixedDBWideString<127> aisProviderLoginURL_;
        FixedDBWideString<32> comPort_;
        Int32 baudRate_ = 0;
        bool filterByArea_ = false;
        double upperLeftCornerLatitude_ = 0.0;
        double upperLeftCornerLongitude_ = 0.0;
        double bottomRightCornerLatitude_ = 0.0;
        double bottomRightCornerLongitude_ = 0.0;
        FixedDBWideString<127> aisProviderIPAddress_;
        Int32 aisProviderPort_ = 0;
        bool useLogin_ = false;
        Int32 aisProviderLoginPort_ = 0;
        bool canSendAISMessage_ = false;
        WideString textMessageHeader_;
        SQLLEN textMessageHeaderLength_ = SQL_NULL_DATA;
        WideString urls_;
        SQLLEN urlsLength_ = SQL_NULL_DATA;
        Int32 udpPort_ = 0;
        Data::AisTransceiverConnectionType connectionType_ = Data::AisTransceiverConnectionType::Unknown;
        bool enableRefreshAidToNavigationIn30sec_ = false;
        bool enableAidToNavigationFromFile_ = false;
        WideString aidToNavigationHeader_;
        SQLLEN aidToNavigationHeaderLength_ = SQL_NULL_DATA;
        bool sendingMMSI_ = false;
        Int32 sourceUpdateRate_ = 0;
        bool enableRefreshStayingStillTargetIn30sec_ = false;
        WideString excludeSendAisBaseStation_;
        SQLLEN excludeSendAisBaseStationLength_ = SQL_NULL_DATA;
        WideString excludeSendAisA_;
        SQLLEN excludeSendAisALength_ = SQL_NULL_DATA;
        bool enableSendBaseStationAlarms_ = false;
        FixedDBWideString<127> aisWebConfig_;
        bool storeReceivedSentences_ = false;
        bool storeSentMessages_ = false;
        bool storeUnsentMessages_ = false;
    public:
        AisTransceiverConfigurationData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(rowVersion_);
            destination.Write(aisTransceiver_);
            destination.Write(timestamp_);
            userName_.WriteTo( destination );
            password_.WriteTo( destination );
            destination.Write(latitude_);
            destination.Write(longitude_);
            aisProviderLoginURL_.WriteTo( destination );
            comPort_.WriteTo( destination );
            destination.Write(baudRate_);
            destination.Write(filterByArea_);
            destination.Write(upperLeftCornerLatitude_);
            destination.Write(upperLeftCornerLongitude_);
            destination.Write(bottomRightCornerLatitude_);
            destination.Write(bottomRightCornerLongitude_);
            aisProviderIPAddress_.WriteTo( destination );
            destination.Write(aisProviderPort_);
            destination.Write(useLogin_);
            destination.Write(aisProviderLoginPort_);
            destination.Write(canSendAISMessage_);
            destination.Write(textMessageHeader_);
            destination.Write(urls_);
            destination.Write(udpPort_);
            destination.Write(connectionType_);
            destination.Write(enableRefreshAidToNavigationIn30sec_);
            destination.Write(enableAidToNavigationFromFile_);
            destination.Write(aidToNavigationHeader_);
            destination.Write(sendingMMSI_);
            destination.Write(sourceUpdateRate_);
            destination.Write(enableRefreshStayingStillTargetIn30sec_);
            destination.Write(excludeSendAisBaseStation_);
            destination.Write(excludeSendAisA_);
            destination.Write(enableSendBaseStationAlarms_);
            aisWebConfig_.WriteTo( destination );
            destination.Write(storeReceivedSentences_);
            destination.Write(storeSentMessages_);
            destination.Write(storeUnsentMessages_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(rowVersion_);
            source.Read(aisTransceiver_);
            source.Read(timestamp_);
            userName_.ReadFrom( source );
            password_.ReadFrom( source );
            source.Read(latitude_);
            source.Read(longitude_);
            aisProviderLoginURL_.ReadFrom( source );
            comPort_.ReadFrom( source );
            source.Read(baudRate_);
            source.Read(filterByArea_);
            source.Read(upperLeftCornerLatitude_);
            source.Read(upperLeftCornerLongitude_);
            source.Read(bottomRightCornerLatitude_);
            source.Read(bottomRightCornerLongitude_);
            aisProviderIPAddress_.ReadFrom( source );
            source.Read(aisProviderPort_);
            source.Read(useLogin_);
            source.Read(aisProviderLoginPort_);
            source.Read(canSendAISMessage_);
            source.Read(textMessageHeader_);
            source.Read(urls_);
            source.Read(udpPort_);
            source.Read(connectionType_);
            source.Read(enableRefreshAidToNavigationIn30sec_);
            source.Read(enableAidToNavigationFromFile_);
            source.Read(aidToNavigationHeader_);
            source.Read(sendingMMSI_);
            source.Read(sourceUpdateRate_);
            source.Read(enableRefreshStayingStillTargetIn30sec_);
            source.Read(excludeSendAisBaseStation_);
            source.Read(excludeSendAisA_);
            source.Read(enableSendBaseStationAlarms_);
            aisWebConfig_.ReadFrom( source );
            source.Read(storeReceivedSentences_);
            source.Read(storeSentMessages_);
            source.Read(storeUnsentMessages_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<AisTransceiverConfigurationData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<AisTransceiverConfigurationData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const AisTransceiverConfigurationData& >( other );
                if ( dataObject.rowVersion_ != rowVersion_ )
                {
                    return false;
                }
                if ( dataObject.aisTransceiver_ != aisTransceiver_ )
                {
                    return false;
                }
                if ( dataObject.timestamp_ != timestamp_ )
                {
                    return false;
                }
                if ( dataObject.userName_ != userName_ )
                {
                    return false;
                }
                if ( dataObject.password_ != password_ )
                {
                    return false;
                }
                if ( dataObject.latitude_ != latitude_ )
                {
                    return false;
                }
                if ( dataObject.longitude_ != longitude_ )
                {
                    return false;
                }
                if ( dataObject.aisProviderLoginURL_ != aisProviderLoginURL_ )
                {
                    return false;
                }
                if ( dataObject.comPort_ != comPort_ )
                {
                    return false;
                }
                if ( dataObject.baudRate_ != baudRate_ )
                {
                    return false;
                }
                if ( dataObject.filterByArea_ != filterByArea_ )
                {
                    return false;
                }
                if ( dataObject.upperLeftCornerLatitude_ != upperLeftCornerLatitude_ )
                {
                    return false;
                }
                if ( dataObject.upperLeftCornerLongitude_ != upperLeftCornerLongitude_ )
                {
                    return false;
                }
                if ( dataObject.bottomRightCornerLatitude_ != bottomRightCornerLatitude_ )
                {
                    return false;
                }
                if ( dataObject.bottomRightCornerLongitude_ != bottomRightCornerLongitude_ )
                {
                    return false;
                }
                if ( dataObject.aisProviderIPAddress_ != aisProviderIPAddress_ )
                {
                    return false;
                }
                if ( dataObject.aisProviderPort_ != aisProviderPort_ )
                {
                    return false;
                }
                if ( dataObject.useLogin_ != useLogin_ )
                {
                    return false;
                }
                if ( dataObject.aisProviderLoginPort_ != aisProviderLoginPort_ )
                {
                    return false;
                }
                if ( dataObject.canSendAISMessage_ != canSendAISMessage_ )
                {
                    return false;
                }
                if ( dataObject.textMessageHeader_ != textMessageHeader_ )
                {
                    return false;
                }
                if ( dataObject.urls_ != urls_ )
                {
                    return false;
                }
                if ( dataObject.udpPort_ != udpPort_ )
                {
                    return false;
                }
                if ( dataObject.connectionType_ != connectionType_ )
                {
                    return false;
                }
                if ( dataObject.enableRefreshAidToNavigationIn30sec_ != enableRefreshAidToNavigationIn30sec_ )
                {
                    return false;
                }
                if ( dataObject.enableAidToNavigationFromFile_ != enableAidToNavigationFromFile_ )
                {
                    return false;
                }
                if ( dataObject.aidToNavigationHeader_ != aidToNavigationHeader_ )
                {
                    return false;
                }
                if ( dataObject.sendingMMSI_ != sendingMMSI_ )
                {
                    return false;
                }
                if ( dataObject.sourceUpdateRate_ != sourceUpdateRate_ )
                {
                    return false;
                }
                if ( dataObject.enableRefreshStayingStillTargetIn30sec_ != enableRefreshStayingStillTargetIn30sec_ )
                {
                    return false;
                }
                if ( dataObject.excludeSendAisBaseStation_ != excludeSendAisBaseStation_ )
                {
                    return false;
                }
                if ( dataObject.excludeSendAisA_ != excludeSendAisA_ )
                {
                    return false;
                }
                if ( dataObject.enableSendBaseStationAlarms_ != enableSendBaseStationAlarms_ )
                {
                    return false;
                }
                if ( dataObject.aisWebConfig_ != aisWebConfig_ )
                {
                    return false;
                }
                if ( dataObject.storeReceivedSentences_ != storeReceivedSentences_ )
                {
                    return false;
                }
                if ( dataObject.storeSentMessages_ != storeSentMessages_ )
                {
                    return false;
                }
                if ( dataObject.storeUnsentMessages_ != storeUnsentMessages_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        Int64 RowVersion( ) const
        {
            return rowVersion_;
        }
        void SetRowVersion( const Int64& rowVersion )
        {
            rowVersion_ = rowVersion;
        }
        const Guid& AisTransceiver( ) const
        {
            return aisTransceiver_;
        }
        void SetAisTransceiver( const Guid& aisTransceiver )
        {
            aisTransceiver_ = aisTransceiver;
        }
        const DateTime& Timestamp( ) const
        {
            return timestamp_;
        }
        void SetTimestamp( const DateTime& timestamp )
        {
            timestamp_ = timestamp;
        }
        const FixedDBWideString<127>& UserName( ) const
        {
            return userName_;
        }
        void SetUserName( const WideString& userName )
        {
            userName_ = userName;
        }
        const FixedDBWideString<127>& Password( ) const
        {
            return password_;
        }
        void SetPassword( const WideString& password )
        {
            password_ = password;
        }
        double Latitude( ) const
        {
            return latitude_;
        }
        void SetLatitude( double latitude )
        {
            latitude_ = latitude;
        }
        double Longitude( ) const
        {
            return longitude_;
        }
        void SetLongitude( double longitude )
        {
            longitude_ = longitude;
        }
        const FixedDBWideString<127>& AisProviderLoginURL( ) const
        {
            return aisProviderLoginURL_;
        }
        void SetAisProviderLoginURL( const WideString& aisProviderLoginURL )
        {
            aisProviderLoginURL_ = aisProviderLoginURL;
        }
        const FixedDBWideString<32>& ComPort( ) const
        {
            return comPort_;
        }
        void SetComPort( const WideString& comPort )
        {
            comPort_ = comPort;
        }
        Int32 BaudRate( ) const
        {
            return baudRate_;
        }
        void SetBaudRate( Int32 baudRate )
        {
            baudRate_ = baudRate;
        }
        bool FilterByArea( ) const
        {
            return filterByArea_;
        }
        void SetFilterByArea( bool filterByArea )
        {
            filterByArea_ = filterByArea;
        }
        double UpperLeftCornerLatitude( ) const
        {
            return upperLeftCornerLatitude_;
        }
        void SetUpperLeftCornerLatitude( double upperLeftCornerLatitude )
        {
            upperLeftCornerLatitude_ = upperLeftCornerLatitude;
        }
        double UpperLeftCornerLongitude( ) const
        {
            return upperLeftCornerLongitude_;
        }
        void SetUpperLeftCornerLongitude( double upperLeftCornerLongitude )
        {
            upperLeftCornerLongitude_ = upperLeftCornerLongitude;
        }
        double BottomRightCornerLatitude( ) const
        {
            return bottomRightCornerLatitude_;
        }
        void SetBottomRightCornerLatitude( double bottomRightCornerLatitude )
        {
            bottomRightCornerLatitude_ = bottomRightCornerLatitude;
        }
        double BottomRightCornerLongitude( ) const
        {
            return bottomRightCornerLongitude_;
        }
        void SetBottomRightCornerLongitude( double bottomRightCornerLongitude )
        {
            bottomRightCornerLongitude_ = bottomRightCornerLongitude;
        }
        const FixedDBWideString<127>& AisProviderIPAddress( ) const
        {
            return aisProviderIPAddress_;
        }
        void SetAisProviderIPAddress( const WideString& aisProviderIPAddress )
        {
            aisProviderIPAddress_ = aisProviderIPAddress;
        }
        Int32 AisProviderPort( ) const
        {
            return aisProviderPort_;
        }
        void SetAisProviderPort( Int32 aisProviderPort )
        {
            aisProviderPort_ = aisProviderPort;
        }
        bool UseLogin( ) const
        {
            return useLogin_;
        }
        void SetUseLogin( bool useLogin )
        {
            useLogin_ = useLogin;
        }
        Int32 AisProviderLoginPort( ) const
        {
            return aisProviderLoginPort_;
        }
        void SetAisProviderLoginPort( Int32 aisProviderLoginPort )
        {
            aisProviderLoginPort_ = aisProviderLoginPort;
        }
        bool CanSendAISMessage( ) const
        {
            return canSendAISMessage_;
        }
        void SetCanSendAISMessage( bool canSendAISMessage )
        {
            canSendAISMessage_ = canSendAISMessage;
        }
        const WideString& TextMessageHeader( ) const
        {
            return textMessageHeader_;
        }
        void SetTextMessageHeader( const WideString& textMessageHeader )
        {
            textMessageHeader_ = textMessageHeader;
        }
        const WideString& Urls( ) const
        {
            return urls_;
        }
        void SetUrls( const WideString& urls )
        {
            urls_ = urls;
        }
        Int32 UdpPort( ) const
        {
            return udpPort_;
        }
        void SetUdpPort( Int32 udpPort )
        {
            udpPort_ = udpPort;
        }
        Data::AisTransceiverConnectionType ConnectionType( ) const
        {
            return connectionType_;
        }
        void SetConnectionType( Data::AisTransceiverConnectionType connectionType )
        {
            connectionType_ = connectionType;
        }
        bool EnableRefreshAidToNavigationIn30sec( ) const
        {
            return enableRefreshAidToNavigationIn30sec_;
        }
        void SetEnableRefreshAidToNavigationIn30sec( bool enableRefreshAidToNavigationIn30sec )
        {
            enableRefreshAidToNavigationIn30sec_ = enableRefreshAidToNavigationIn30sec;
        }
        bool EnableAidToNavigationFromFile( ) const
        {
            return enableAidToNavigationFromFile_;
        }
        void SetEnableAidToNavigationFromFile( bool enableAidToNavigationFromFile )
        {
            enableAidToNavigationFromFile_ = enableAidToNavigationFromFile;
        }
        const WideString& AidToNavigationHeader( ) const
        {
            return aidToNavigationHeader_;
        }
        void SetAidToNavigationHeader( const WideString& aidToNavigationHeader )
        {
            aidToNavigationHeader_ = aidToNavigationHeader;
        }
        bool SendingMMSI( ) const
        {
            return sendingMMSI_;
        }
        void SetSendingMMSI( bool sendingMMSI )
        {
            sendingMMSI_ = sendingMMSI;
        }
        Int32 SourceUpdateRate( ) const
        {
            return sourceUpdateRate_;
        }
        void SetSourceUpdateRate( Int32 sourceUpdateRate )
        {
            sourceUpdateRate_ = sourceUpdateRate;
        }
        bool EnableRefreshStayingStillTargetIn30sec( ) const
        {
            return enableRefreshStayingStillTargetIn30sec_;
        }
        void SetEnableRefreshStayingStillTargetIn30sec( bool enableRefreshStayingStillTargetIn30sec )
        {
            enableRefreshStayingStillTargetIn30sec_ = enableRefreshStayingStillTargetIn30sec;
        }
        const WideString& ExcludeSendAisBaseStation( ) const
        {
            return excludeSendAisBaseStation_;
        }
        void SetExcludeSendAisBaseStation( const WideString& excludeSendAisBaseStation )
        {
            excludeSendAisBaseStation_ = excludeSendAisBaseStation;
        }
        const WideString& ExcludeSendAisA( ) const
        {
            return excludeSendAisA_;
        }
        void SetExcludeSendAisA( const WideString& excludeSendAisA )
        {
            excludeSendAisA_ = excludeSendAisA;
        }
        bool EnableSendBaseStationAlarms( ) const
        {
            return enableSendBaseStationAlarms_;
        }
        void SetEnableSendBaseStationAlarms( bool enableSendBaseStationAlarms )
        {
            enableSendBaseStationAlarms_ = enableSendBaseStationAlarms;
        }
        const FixedDBWideString<127>& AisWebConfig( ) const
        {
            return aisWebConfig_;
        }
        void SetAisWebConfig( const WideString& aisWebConfig )
        {
            aisWebConfig_ = aisWebConfig;
        }
        bool StoreReceivedSentences( ) const
        {
            return storeReceivedSentences_;
        }
        void SetStoreReceivedSentences( bool storeReceivedSentences )
        {
            storeReceivedSentences_ = storeReceivedSentences;
        }
        bool StoreSentMessages( ) const
        {
            return storeSentMessages_;
        }
        void SetStoreSentMessages( bool storeSentMessages )
        {
            storeSentMessages_ = storeSentMessages;
        }
        bool StoreUnsentMessages( ) const
        {
            return storeUnsentMessages_;
        }
        void SetStoreUnsentMessages( bool storeUnsentMessages )
        {
            storeUnsentMessages_ = storeUnsentMessages;
        }
    };
    class AisTransceiverRawMessageData : public BaseData<Kind, Guid>
    {
    public:
        using Base = BaseData<Kind, Guid>;
        static constexpr Kind KIND = Kind::AisTransceiverRawMessage;
    private:
        Int64 rowVersion_ = 0;
        Guid aisTransceiver_;
        DateTime timestamp_;
        bool isSent_ = false;
        FixedDBWideString<100> message_;
    public:
        AisTransceiverRawMessageData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(rowVersion_);
            destination.Write(aisTransceiver_);
            destination.Write(timestamp_);
            destination.Write(isSent_);
            message_.WriteTo( destination );
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(rowVersion_);
            source.Read(aisTransceiver_);
            source.Read(timestamp_);
            source.Read(isSent_);
            message_.ReadFrom( source );
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<AisTransceiverRawMessageData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<AisTransceiverRawMessageData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const AisTransceiverRawMessageData& >( other );
                if ( dataObject.rowVersion_ != rowVersion_ )
                {
                    return false;
                }
                if ( dataObject.aisTransceiver_ != aisTransceiver_ )
                {
                    return false;
                }
                if ( dataObject.timestamp_ != timestamp_ )
                {
                    return false;
                }
                if ( dataObject.isSent_ != isSent_ )
                {
                    return false;
                }
                if ( dataObject.message_ != message_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        Int64 RowVersion( ) const
        {
            return rowVersion_;
        }
        void SetRowVersion( const Int64& rowVersion )
        {
            rowVersion_ = rowVersion;
        }
        const Guid& AisTransceiver( ) const
        {
            return aisTransceiver_;
        }
        void SetAisTransceiver( const Guid& aisTransceiver )
        {
            aisTransceiver_ = aisTransceiver;
        }
        const DateTime& Timestamp( ) const
        {
            return timestamp_;
        }
        void SetTimestamp( const DateTime& timestamp )
        {
            timestamp_ = timestamp;
        }
        bool IsSent( ) const
        {
            return isSent_;
        }
        void SetIsSent( bool isSent )
        {
            isSent_ = isSent;
        }
        const FixedDBWideString<100>& Message( ) const
        {
            return message_;
        }
        void SetMessage( const WideString& message )
        {
            message_ = message;
        }
    };
    class AisTransceiverRawSentenceData : public BaseData<Kind, Guid>
    {
    public:
        using Base = BaseData<Kind, Guid>;
        static constexpr Kind KIND = Kind::AisTransceiverRawSentence;
    private:
        Int64 rowVersion_ = 0;
        Guid aisTransceiver_;
        DateTime timestamp_;
        WideString sentence_;
        SQLLEN sentenceLength_ = SQL_NULL_DATA;
    public:
        AisTransceiverRawSentenceData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(rowVersion_);
            destination.Write(aisTransceiver_);
            destination.Write(timestamp_);
            destination.Write(sentence_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(rowVersion_);
            source.Read(aisTransceiver_);
            source.Read(timestamp_);
            source.Read(sentence_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<AisTransceiverRawSentenceData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<AisTransceiverRawSentenceData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const AisTransceiverRawSentenceData& >( other );
                if ( dataObject.rowVersion_ != rowVersion_ )
                {
                    return false;
                }
                if ( dataObject.aisTransceiver_ != aisTransceiver_ )
                {
                    return false;
                }
                if ( dataObject.timestamp_ != timestamp_ )
                {
                    return false;
                }
                if ( dataObject.sentence_ != sentence_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        Int64 RowVersion( ) const
        {
            return rowVersion_;
        }
        void SetRowVersion( const Int64& rowVersion )
        {
            rowVersion_ = rowVersion;
        }
        const Guid& AisTransceiver( ) const
        {
            return aisTransceiver_;
        }
        void SetAisTransceiver( const Guid& aisTransceiver )
        {
            aisTransceiver_ = aisTransceiver;
        }
        const DateTime& Timestamp( ) const
        {
            return timestamp_;
        }
        void SetTimestamp( const DateTime& timestamp )
        {
            timestamp_ = timestamp;
        }
        const WideString& Sentence( ) const
        {
            return sentence_;
        }
        void SetSentence( const WideString& sentence )
        {
            sentence_ = sentence;
        }
    };
    class AlarmStateChangeData : public BaseData<Kind, Guid>
    {
    public:
        using Base = BaseData<Kind, Guid>;
        static constexpr Kind KIND = Kind::AlarmStateChange;
    private:
        Int64 rowVersion_ = 0;
        Guid alarm_;
        DateTime timestamp_;
        Data::AlarmState state_ = Data::AlarmState::Unknown;
    public:
        AlarmStateChangeData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(rowVersion_);
            destination.Write(alarm_);
            destination.Write(timestamp_);
            destination.Write(state_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(rowVersion_);
            source.Read(alarm_);
            source.Read(timestamp_);
            source.Read(state_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<AlarmStateChangeData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<AlarmStateChangeData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const AlarmStateChangeData& >( other );
                if ( dataObject.rowVersion_ != rowVersion_ )
                {
                    return false;
                }
                if ( dataObject.alarm_ != alarm_ )
                {
                    return false;
                }
                if ( dataObject.timestamp_ != timestamp_ )
                {
                    return false;
                }
                if ( dataObject.state_ != state_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        Int64 RowVersion( ) const
        {
            return rowVersion_;
        }
        void SetRowVersion( const Int64& rowVersion )
        {
            rowVersion_ = rowVersion;
        }
        const Guid& Alarm( ) const
        {
            return alarm_;
        }
        void SetAlarm( const Guid& alarm )
        {
            alarm_ = alarm;
        }
        const DateTime& Timestamp( ) const
        {
            return timestamp_;
        }
        void SetTimestamp( const DateTime& timestamp )
        {
            timestamp_ = timestamp;
        }
        Data::AlarmState State( ) const
        {
            return state_;
        }
        void SetState( Data::AlarmState state )
        {
            state_ = state;
        }
    };
    class BaseStationTypeData : public BaseData<Kind, Guid>
    {
    public:
        using Base = BaseData<Kind, Guid>;
        static constexpr Kind KIND = Kind::BaseStationType;
    private:
        Int64 rowVersion_ = 0;
        FixedDBWideString<127> name_;
    public:
        BaseStationTypeData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(rowVersion_);
            name_.WriteTo( destination );
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(rowVersion_);
            name_.ReadFrom( source );
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<BaseStationTypeData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<BaseStationTypeData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const BaseStationTypeData& >( other );
                if ( dataObject.rowVersion_ != rowVersion_ )
                {
                    return false;
                }
                if ( dataObject.name_ != name_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        Int64 RowVersion( ) const
        {
            return rowVersion_;
        }
        void SetRowVersion( const Int64& rowVersion )
        {
            rowVersion_ = rowVersion;
        }
        const FixedDBWideString<127>& Name( ) const
        {
            return name_;
        }
        void SetName( const WideString& name )
        {
            name_ = name;
        }
    };
    class BinaryTimeseriesValueData : public BaseData<Kind, Guid>
    {
    public:
        using Base = BaseData<Kind, Guid>;
        static constexpr Kind KIND = Kind::BinaryTimeseriesValue;
    private:
        Int64 rowVersion_ = 0;
        Guid timeseries_;
        DateTime timestamp_;
        Binary value_;
        SQLLEN valueLength_ = SQL_NULL_DATA;
    public:
        BinaryTimeseriesValueData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(rowVersion_);
            destination.Write(timeseries_);
            destination.Write(timestamp_);
            destination.Write(value_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(rowVersion_);
            source.Read(timeseries_);
            source.Read(timestamp_);
            source.Read(value_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<BinaryTimeseriesValueData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<BinaryTimeseriesValueData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const BinaryTimeseriesValueData& >( other );
                if ( dataObject.rowVersion_ != rowVersion_ )
                {
                    return false;
                }
                if ( dataObject.timeseries_ != timeseries_ )
                {
                    return false;
                }
                if ( dataObject.timestamp_ != timestamp_ )
                {
                    return false;
                }
                if ( dataObject.value_ != value_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        Int64 RowVersion( ) const
        {
            return rowVersion_;
        }
        void SetRowVersion( const Int64& rowVersion )
        {
            rowVersion_ = rowVersion;
        }
        const Guid& Timeseries( ) const
        {
            return timeseries_;
        }
        void SetTimeseries( const Guid& timeseries )
        {
            timeseries_ = timeseries;
        }
        const DateTime& Timestamp( ) const
        {
            return timestamp_;
        }
        void SetTimestamp( const DateTime& timestamp )
        {
            timestamp_ = timestamp;
        }
        const Binary& Value( ) const
        {
            return value_;
        }
        void SetValue( const Binary& value )
        {
            value_ = value;
        }
    };
    class BookmarkData : public BaseData<Kind, Guid>
    {
    public:
        using Base = BaseData<Kind, Guid>;
        static constexpr Kind KIND = Kind::Bookmark;
    private:
        Int64 rowVersion_ = 0;
        Guid view_;
        FixedDBWideString<100> name_;
        DBDateTime timestamp_;
        double latitude_ = 0.0;
        double longitude_ = 0.0;
        double zoomLevel_ = 0.0;
    public:
        BookmarkData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(rowVersion_);
            destination.Write(view_);
            name_.WriteTo( destination );
            timestamp_.WriteTo( destination );
            destination.Write(latitude_);
            destination.Write(longitude_);
            destination.Write(zoomLevel_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(rowVersion_);
            source.Read(view_);
            name_.ReadFrom( source );
            timestamp_.ReadFrom( source );
            source.Read(latitude_);
            source.Read(longitude_);
            source.Read(zoomLevel_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<BookmarkData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<BookmarkData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const BookmarkData& >( other );
                if ( dataObject.rowVersion_ != rowVersion_ )
                {
                    return false;
                }
                if ( dataObject.view_ != view_ )
                {
                    return false;
                }
                if ( dataObject.name_ != name_ )
                {
                    return false;
                }
                if ( dataObject.timestamp_ != timestamp_ )
                {
                    return false;
                }
                if ( dataObject.latitude_ != latitude_ )
                {
                    return false;
                }
                if ( dataObject.longitude_ != longitude_ )
                {
                    return false;
                }
                if ( dataObject.zoomLevel_ != zoomLevel_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        Int64 RowVersion( ) const
        {
            return rowVersion_;
        }
        void SetRowVersion( const Int64& rowVersion )
        {
            rowVersion_ = rowVersion;
        }
        const Guid& View( ) const
        {
            return view_;
        }
        void SetView( const Guid& view )
        {
            view_ = view;
        }
        const FixedDBWideString<100>& Name( ) const
        {
            return name_;
        }
        void SetName( const WideString& name )
        {
            name_ = name;
        }
        const DBDateTime& Timestamp( ) const
        {
            return timestamp_;
        }
        void SetTimestamp( const DBDateTime& timestamp )
        {
            timestamp_ = timestamp;
        }
        double Latitude( ) const
        {
            return latitude_;
        }
        void SetLatitude( double latitude )
        {
            latitude_ = latitude;
        }
        double Longitude( ) const
        {
            return longitude_;
        }
        void SetLongitude( double longitude )
        {
            longitude_ = longitude;
        }
        double ZoomLevel( ) const
        {
            return zoomLevel_;
        }
        void SetZoomLevel( double zoomLevel )
        {
            zoomLevel_ = zoomLevel;
        }
    };
    class BooleanTimeseriesValueData : public BaseData<Kind, Guid>
    {
    public:
        using Base = BaseData<Kind, Guid>;
        static constexpr Kind KIND = Kind::BooleanTimeseriesValue;
    private:
        Int64 rowVersion_ = 0;
        Guid timeseries_;
        DateTime timestamp_;
        DBBoolean  value_;
    public:
        BooleanTimeseriesValueData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(rowVersion_);
            destination.Write(timeseries_);
            destination.Write(timestamp_);
            value_.WriteTo( destination );
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(rowVersion_);
            source.Read(timeseries_);
            source.Read(timestamp_);
            value_.ReadFrom( source );
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<BooleanTimeseriesValueData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<BooleanTimeseriesValueData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const BooleanTimeseriesValueData& >( other );
                if ( dataObject.rowVersion_ != rowVersion_ )
                {
                    return false;
                }
                if ( dataObject.timeseries_ != timeseries_ )
                {
                    return false;
                }
                if ( dataObject.timestamp_ != timestamp_ )
                {
                    return false;
                }
                if ( dataObject.value_ != value_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        Int64 RowVersion( ) const
        {
            return rowVersion_;
        }
        void SetRowVersion( const Int64& rowVersion )
        {
            rowVersion_ = rowVersion;
        }
        const Guid& Timeseries( ) const
        {
            return timeseries_;
        }
        void SetTimeseries( const Guid& timeseries )
        {
            timeseries_ = timeseries;
        }
        const DateTime& Timestamp( ) const
        {
            return timestamp_;
        }
        void SetTimestamp( const DateTime& timestamp )
        {
            timestamp_ = timestamp;
        }
        const DBBoolean & Value( ) const
        {
            return value_;
        }
        void SetValue( const DBBoolean & value )
        {
            value_ = value;
        }
    };
    class ByteTimeseriesValueData : public BaseData<Kind, Guid>
    {
    public:
        using Base = BaseData<Kind, Guid>;
        static constexpr Kind KIND = Kind::ByteTimeseriesValue;
    private:
        Int64 rowVersion_ = 0;
        Guid timeseries_;
        DateTime timestamp_;
        DBByte value_;
    public:
        ByteTimeseriesValueData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(rowVersion_);
            destination.Write(timeseries_);
            destination.Write(timestamp_);
            value_.WriteTo( destination );
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(rowVersion_);
            source.Read(timeseries_);
            source.Read(timestamp_);
            value_.ReadFrom( source );
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<ByteTimeseriesValueData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<ByteTimeseriesValueData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const ByteTimeseriesValueData& >( other );
                if ( dataObject.rowVersion_ != rowVersion_ )
                {
                    return false;
                }
                if ( dataObject.timeseries_ != timeseries_ )
                {
                    return false;
                }
                if ( dataObject.timestamp_ != timestamp_ )
                {
                    return false;
                }
                if ( dataObject.value_ != value_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        Int64 RowVersion( ) const
        {
            return rowVersion_;
        }
        void SetRowVersion( const Int64& rowVersion )
        {
            rowVersion_ = rowVersion;
        }
        const Guid& Timeseries( ) const
        {
            return timeseries_;
        }
        void SetTimeseries( const Guid& timeseries )
        {
            timeseries_ = timeseries;
        }
        const DateTime& Timestamp( ) const
        {
            return timestamp_;
        }
        void SetTimestamp( const DateTime& timestamp )
        {
            timestamp_ = timestamp;
        }
        const DBByte& Value( ) const
        {
            return value_;
        }
        void SetValue( const DBByte& value )
        {
            value_ = value;
        }
    };
    class CameraCommandData : public BaseData<Kind, Guid>
    {
    public:
        using Base = BaseData<Kind, Guid>;
        static constexpr Kind KIND = Kind::CameraCommand;
    private:
        Int64 rowVersion_ = 0;
        Guid camera_;
        DateTime timestamp_;
        Data::DeviceCommandSourceType deviceCommandSourceType_ = Data::DeviceCommandSourceType::Unknown;
        Guid deviceCommandSourceId_;
        Guid reply_;
    public:
        CameraCommandData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(rowVersion_);
            destination.Write(camera_);
            destination.Write(timestamp_);
            destination.Write(deviceCommandSourceType_);
            destination.Write(deviceCommandSourceId_);
            destination.Write(reply_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(rowVersion_);
            source.Read(camera_);
            source.Read(timestamp_);
            source.Read(deviceCommandSourceType_);
            source.Read(deviceCommandSourceId_);
            source.Read(reply_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<CameraCommandData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<CameraCommandData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const CameraCommandData& >( other );
                if ( dataObject.rowVersion_ != rowVersion_ )
                {
                    return false;
                }
                if ( dataObject.camera_ != camera_ )
                {
                    return false;
                }
                if ( dataObject.timestamp_ != timestamp_ )
                {
                    return false;
                }
                if ( dataObject.deviceCommandSourceType_ != deviceCommandSourceType_ )
                {
                    return false;
                }
                if ( dataObject.deviceCommandSourceId_ != deviceCommandSourceId_ )
                {
                    return false;
                }
                if ( dataObject.reply_ != reply_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        Int64 RowVersion( ) const
        {
            return rowVersion_;
        }
        void SetRowVersion( const Int64& rowVersion )
        {
            rowVersion_ = rowVersion;
        }
        const Guid& Camera( ) const
        {
            return camera_;
        }
        void SetCamera( const Guid& camera )
        {
            camera_ = camera;
        }
        const DateTime& Timestamp( ) const
        {
            return timestamp_;
        }
        void SetTimestamp( const DateTime& timestamp )
        {
            timestamp_ = timestamp;
        }
        Data::DeviceCommandSourceType DeviceCommandSourceType( ) const
        {
            return deviceCommandSourceType_;
        }
        void SetDeviceCommandSourceType( Data::DeviceCommandSourceType deviceCommandSourceType )
        {
            deviceCommandSourceType_ = deviceCommandSourceType;
        }
        const Guid& DeviceCommandSourceId( ) const
        {
            return deviceCommandSourceId_;
        }
        void SetDeviceCommandSourceId( const Guid& deviceCommandSourceId )
        {
            deviceCommandSourceId_ = deviceCommandSourceId;
        }
        const Guid& Reply( ) const
        {
            return reply_;
        }
        void SetReply( const Guid& reply )
        {
            reply_ = reply;
        }
    };
    class CameraCommandAbsoluteMoveData : public CameraCommandData
    {
    public:
        using Base = CameraCommandData;
        static constexpr Kind KIND = Kind::CameraCommandAbsoluteMove;
    private:
        Data::CameraPanTiltMode positionPanTiltMode_ = Data::CameraPanTiltMode::Unknown;
        DBDouble panAngle_;
        DBDouble tiltAngle_;
        Data::CameraFocalLengthMode positionFocalLengthMode_ = Data::CameraFocalLengthMode::Unknown;
        DBDouble focalLength_;
        Data::CameraPanTiltMode speedPanTiltMode_ = Data::CameraPanTiltMode::Unknown;
        DBDouble panSpeed_;
        DBDouble tiltSpeed_;
        Data::CameraFocalLengthMode speedFocalLengthMode_ = Data::CameraFocalLengthMode::Unknown;
        DBDouble zoomSpeed_;
    public:
        CameraCommandAbsoluteMoveData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(positionPanTiltMode_);
            panAngle_.WriteTo( destination );
            tiltAngle_.WriteTo( destination );
            destination.Write(positionFocalLengthMode_);
            focalLength_.WriteTo( destination );
            destination.Write(speedPanTiltMode_);
            panSpeed_.WriteTo( destination );
            tiltSpeed_.WriteTo( destination );
            destination.Write(speedFocalLengthMode_);
            zoomSpeed_.WriteTo( destination );
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(positionPanTiltMode_);
            panAngle_.ReadFrom( source );
            tiltAngle_.ReadFrom( source );
            source.Read(positionFocalLengthMode_);
            focalLength_.ReadFrom( source );
            source.Read(speedPanTiltMode_);
            panSpeed_.ReadFrom( source );
            tiltSpeed_.ReadFrom( source );
            source.Read(speedFocalLengthMode_);
            zoomSpeed_.ReadFrom( source );
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<CameraCommandAbsoluteMoveData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<CameraCommandAbsoluteMoveData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const CameraCommandAbsoluteMoveData& >( other );
                if ( dataObject.positionPanTiltMode_ != positionPanTiltMode_ )
                {
                    return false;
                }
                if ( dataObject.panAngle_ != panAngle_ )
                {
                    return false;
                }
                if ( dataObject.tiltAngle_ != tiltAngle_ )
                {
                    return false;
                }
                if ( dataObject.positionFocalLengthMode_ != positionFocalLengthMode_ )
                {
                    return false;
                }
                if ( dataObject.focalLength_ != focalLength_ )
                {
                    return false;
                }
                if ( dataObject.speedPanTiltMode_ != speedPanTiltMode_ )
                {
                    return false;
                }
                if ( dataObject.panSpeed_ != panSpeed_ )
                {
                    return false;
                }
                if ( dataObject.tiltSpeed_ != tiltSpeed_ )
                {
                    return false;
                }
                if ( dataObject.speedFocalLengthMode_ != speedFocalLengthMode_ )
                {
                    return false;
                }
                if ( dataObject.zoomSpeed_ != zoomSpeed_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        Data::CameraPanTiltMode PositionPanTiltMode( ) const
        {
            return positionPanTiltMode_;
        }
        void SetPositionPanTiltMode( Data::CameraPanTiltMode positionPanTiltMode )
        {
            positionPanTiltMode_ = positionPanTiltMode;
        }
        const DBDouble& PanAngle( ) const
        {
            return panAngle_;
        }
        void SetPanAngle( const DBDouble& panAngle )
        {
            panAngle_ = panAngle;
        }
        const DBDouble& TiltAngle( ) const
        {
            return tiltAngle_;
        }
        void SetTiltAngle( const DBDouble& tiltAngle )
        {
            tiltAngle_ = tiltAngle;
        }
        Data::CameraFocalLengthMode PositionFocalLengthMode( ) const
        {
            return positionFocalLengthMode_;
        }
        void SetPositionFocalLengthMode( Data::CameraFocalLengthMode positionFocalLengthMode )
        {
            positionFocalLengthMode_ = positionFocalLengthMode;
        }
        const DBDouble& FocalLength( ) const
        {
            return focalLength_;
        }
        void SetFocalLength( const DBDouble& focalLength )
        {
            focalLength_ = focalLength;
        }
        Data::CameraPanTiltMode SpeedPanTiltMode( ) const
        {
            return speedPanTiltMode_;
        }
        void SetSpeedPanTiltMode( Data::CameraPanTiltMode speedPanTiltMode )
        {
            speedPanTiltMode_ = speedPanTiltMode;
        }
        const DBDouble& PanSpeed( ) const
        {
            return panSpeed_;
        }
        void SetPanSpeed( const DBDouble& panSpeed )
        {
            panSpeed_ = panSpeed;
        }
        const DBDouble& TiltSpeed( ) const
        {
            return tiltSpeed_;
        }
        void SetTiltSpeed( const DBDouble& tiltSpeed )
        {
            tiltSpeed_ = tiltSpeed;
        }
        Data::CameraFocalLengthMode SpeedFocalLengthMode( ) const
        {
            return speedFocalLengthMode_;
        }
        void SetSpeedFocalLengthMode( Data::CameraFocalLengthMode speedFocalLengthMode )
        {
            speedFocalLengthMode_ = speedFocalLengthMode;
        }
        const DBDouble& ZoomSpeed( ) const
        {
            return zoomSpeed_;
        }
        void SetZoomSpeed( const DBDouble& zoomSpeed )
        {
            zoomSpeed_ = zoomSpeed;
        }
    };
    class CameraCommandAdjustPanTiltZoomData : public CameraCommandData
    {
    public:
        using Base = CameraCommandData;
        static constexpr Kind KIND = Kind::CameraCommandAdjustPanTiltZoom;
    private:
        DBDouble x_;
        DBDouble y_;
        DBDouble z_;
    public:
        CameraCommandAdjustPanTiltZoomData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            x_.WriteTo( destination );
            y_.WriteTo( destination );
            z_.WriteTo( destination );
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            x_.ReadFrom( source );
            y_.ReadFrom( source );
            z_.ReadFrom( source );
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<CameraCommandAdjustPanTiltZoomData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<CameraCommandAdjustPanTiltZoomData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const CameraCommandAdjustPanTiltZoomData& >( other );
                if ( dataObject.x_ != x_ )
                {
                    return false;
                }
                if ( dataObject.y_ != y_ )
                {
                    return false;
                }
                if ( dataObject.z_ != z_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        const DBDouble& X( ) const
        {
            return x_;
        }
        void SetX( const DBDouble& x )
        {
            x_ = x;
        }
        const DBDouble& Y( ) const
        {
            return y_;
        }
        void SetY( const DBDouble& y )
        {
            y_ = y;
        }
        const DBDouble& Z( ) const
        {
            return z_;
        }
        void SetZ( const DBDouble& z )
        {
            z_ = z;
        }
    };
    class CameraCommandContinuousMoveData : public CameraCommandData
    {
    public:
        using Base = CameraCommandData;
        static constexpr Kind KIND = Kind::CameraCommandContinuousMove;
    private:
        bool normalized_ = false;
        DBDouble panVelocity_;
        DBDouble tiltVelocity_;
        DBDouble zoomVelocity_;
        DBTimeSpan duration_;
    public:
        CameraCommandContinuousMoveData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(normalized_);
            panVelocity_.WriteTo( destination );
            tiltVelocity_.WriteTo( destination );
            zoomVelocity_.WriteTo( destination );
            duration_.WriteTo( destination );
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(normalized_);
            panVelocity_.ReadFrom( source );
            tiltVelocity_.ReadFrom( source );
            zoomVelocity_.ReadFrom( source );
            duration_.ReadFrom( source );
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<CameraCommandContinuousMoveData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<CameraCommandContinuousMoveData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const CameraCommandContinuousMoveData& >( other );
                if ( dataObject.normalized_ != normalized_ )
                {
                    return false;
                }
                if ( dataObject.panVelocity_ != panVelocity_ )
                {
                    return false;
                }
                if ( dataObject.tiltVelocity_ != tiltVelocity_ )
                {
                    return false;
                }
                if ( dataObject.zoomVelocity_ != zoomVelocity_ )
                {
                    return false;
                }
                if ( dataObject.duration_ != duration_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        bool Normalized( ) const
        {
            return normalized_;
        }
        void SetNormalized( bool normalized )
        {
            normalized_ = normalized;
        }
        const DBDouble& PanVelocity( ) const
        {
            return panVelocity_;
        }
        void SetPanVelocity( const DBDouble& panVelocity )
        {
            panVelocity_ = panVelocity;
        }
        const DBDouble& TiltVelocity( ) const
        {
            return tiltVelocity_;
        }
        void SetTiltVelocity( const DBDouble& tiltVelocity )
        {
            tiltVelocity_ = tiltVelocity;
        }
        const DBDouble& ZoomVelocity( ) const
        {
            return zoomVelocity_;
        }
        void SetZoomVelocity( const DBDouble& zoomVelocity )
        {
            zoomVelocity_ = zoomVelocity;
        }
        const DBTimeSpan& Duration( ) const
        {
            return duration_;
        }
        void SetDuration( const DBTimeSpan& duration )
        {
            duration_ = duration;
        }
    };
    class CameraCommandGeoMoveData : public CameraCommandData
    {
    public:
        using Base = CameraCommandData;
        static constexpr Kind KIND = Kind::CameraCommandGeoMove;
    private:
        double latitude_ = 0.0;
        double longitude_ = 0.0;
        DBDouble altitude_;
        DBDouble viewportWidth_;
        DBDouble viewportHeight_;
    public:
        CameraCommandGeoMoveData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(latitude_);
            destination.Write(longitude_);
            altitude_.WriteTo( destination );
            viewportWidth_.WriteTo( destination );
            viewportHeight_.WriteTo( destination );
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(latitude_);
            source.Read(longitude_);
            altitude_.ReadFrom( source );
            viewportWidth_.ReadFrom( source );
            viewportHeight_.ReadFrom( source );
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<CameraCommandGeoMoveData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<CameraCommandGeoMoveData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const CameraCommandGeoMoveData& >( other );
                if ( dataObject.latitude_ != latitude_ )
                {
                    return false;
                }
                if ( dataObject.longitude_ != longitude_ )
                {
                    return false;
                }
                if ( dataObject.altitude_ != altitude_ )
                {
                    return false;
                }
                if ( dataObject.viewportWidth_ != viewportWidth_ )
                {
                    return false;
                }
                if ( dataObject.viewportHeight_ != viewportHeight_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        double Latitude( ) const
        {
            return latitude_;
        }
        void SetLatitude( double latitude )
        {
            latitude_ = latitude;
        }
        double Longitude( ) const
        {
            return longitude_;
        }
        void SetLongitude( double longitude )
        {
            longitude_ = longitude;
        }
        const DBDouble& Altitude( ) const
        {
            return altitude_;
        }
        void SetAltitude( const DBDouble& altitude )
        {
            altitude_ = altitude;
        }
        const DBDouble& ViewportWidth( ) const
        {
            return viewportWidth_;
        }
        void SetViewportWidth( const DBDouble& viewportWidth )
        {
            viewportWidth_ = viewportWidth;
        }
        const DBDouble& ViewportHeight( ) const
        {
            return viewportHeight_;
        }
        void SetViewportHeight( const DBDouble& viewportHeight )
        {
            viewportHeight_ = viewportHeight;
        }
    };
    class CameraCommandRelativeMoveData : public CameraCommandData
    {
    public:
        using Base = CameraCommandData;
        static constexpr Kind KIND = Kind::CameraCommandRelativeMove;
    private:
        bool normalized_ = false;
        DBDouble panAngle_;
        DBDouble tiltAngle_;
        DBDouble focalLength_;
        DBDouble panSpeed_;
        DBDouble tiltSpeed_;
        DBDouble zoomSpeed_;
    public:
        CameraCommandRelativeMoveData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(normalized_);
            panAngle_.WriteTo( destination );
            tiltAngle_.WriteTo( destination );
            focalLength_.WriteTo( destination );
            panSpeed_.WriteTo( destination );
            tiltSpeed_.WriteTo( destination );
            zoomSpeed_.WriteTo( destination );
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(normalized_);
            panAngle_.ReadFrom( source );
            tiltAngle_.ReadFrom( source );
            focalLength_.ReadFrom( source );
            panSpeed_.ReadFrom( source );
            tiltSpeed_.ReadFrom( source );
            zoomSpeed_.ReadFrom( source );
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<CameraCommandRelativeMoveData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<CameraCommandRelativeMoveData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const CameraCommandRelativeMoveData& >( other );
                if ( dataObject.normalized_ != normalized_ )
                {
                    return false;
                }
                if ( dataObject.panAngle_ != panAngle_ )
                {
                    return false;
                }
                if ( dataObject.tiltAngle_ != tiltAngle_ )
                {
                    return false;
                }
                if ( dataObject.focalLength_ != focalLength_ )
                {
                    return false;
                }
                if ( dataObject.panSpeed_ != panSpeed_ )
                {
                    return false;
                }
                if ( dataObject.tiltSpeed_ != tiltSpeed_ )
                {
                    return false;
                }
                if ( dataObject.zoomSpeed_ != zoomSpeed_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        bool Normalized( ) const
        {
            return normalized_;
        }
        void SetNormalized( bool normalized )
        {
            normalized_ = normalized;
        }
        const DBDouble& PanAngle( ) const
        {
            return panAngle_;
        }
        void SetPanAngle( const DBDouble& panAngle )
        {
            panAngle_ = panAngle;
        }
        const DBDouble& TiltAngle( ) const
        {
            return tiltAngle_;
        }
        void SetTiltAngle( const DBDouble& tiltAngle )
        {
            tiltAngle_ = tiltAngle;
        }
        const DBDouble& FocalLength( ) const
        {
            return focalLength_;
        }
        void SetFocalLength( const DBDouble& focalLength )
        {
            focalLength_ = focalLength;
        }
        const DBDouble& PanSpeed( ) const
        {
            return panSpeed_;
        }
        void SetPanSpeed( const DBDouble& panSpeed )
        {
            panSpeed_ = panSpeed;
        }
        const DBDouble& TiltSpeed( ) const
        {
            return tiltSpeed_;
        }
        void SetTiltSpeed( const DBDouble& tiltSpeed )
        {
            tiltSpeed_ = tiltSpeed;
        }
        const DBDouble& ZoomSpeed( ) const
        {
            return zoomSpeed_;
        }
        void SetZoomSpeed( const DBDouble& zoomSpeed )
        {
            zoomSpeed_ = zoomSpeed;
        }
    };
    class CameraCommandReleasePTZOwnershipData : public CameraCommandData
    {
    public:
        using Base = CameraCommandData;
        static constexpr Kind KIND = Kind::CameraCommandReleasePTZOwnership;
    private:
    public:
        CameraCommandReleasePTZOwnershipData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<CameraCommandReleasePTZOwnershipData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<CameraCommandReleasePTZOwnershipData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const CameraCommandReleasePTZOwnershipData& >( other );
                return true;
            }
            return false;
        }
    };
    class CameraCommandRequestPTZOwnershipData : public CameraCommandData
    {
    public:
        using Base = CameraCommandData;
        static constexpr Kind KIND = Kind::CameraCommandRequestPTZOwnership;
    private:
    public:
        CameraCommandRequestPTZOwnershipData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<CameraCommandRequestPTZOwnershipData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<CameraCommandRequestPTZOwnershipData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const CameraCommandRequestPTZOwnershipData& >( other );
                return true;
            }
            return false;
        }
    };
    class CameraCommandSetAutoFocusData : public CameraCommandData
    {
    public:
        using Base = CameraCommandData;
        static constexpr Kind KIND = Kind::CameraCommandSetAutoFocus;
    private:
        bool enabled_ = false;
    public:
        CameraCommandSetAutoFocusData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(enabled_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(enabled_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<CameraCommandSetAutoFocusData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<CameraCommandSetAutoFocusData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const CameraCommandSetAutoFocusData& >( other );
                if ( dataObject.enabled_ != enabled_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        bool Enabled( ) const
        {
            return enabled_;
        }
        void SetEnabled( bool enabled )
        {
            enabled_ = enabled;
        }
    };
    class CameraCommandSetBlackAndWhiteData : public CameraCommandData
    {
    public:
        using Base = CameraCommandData;
        static constexpr Kind KIND = Kind::CameraCommandSetBlackAndWhite;
    private:
        bool enabled_ = false;
    public:
        CameraCommandSetBlackAndWhiteData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(enabled_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(enabled_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<CameraCommandSetBlackAndWhiteData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<CameraCommandSetBlackAndWhiteData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const CameraCommandSetBlackAndWhiteData& >( other );
                if ( dataObject.enabled_ != enabled_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        bool Enabled( ) const
        {
            return enabled_;
        }
        void SetEnabled( bool enabled )
        {
            enabled_ = enabled;
        }
    };
    class CameraCommandSetFollowedData : public CameraCommandData
    {
    public:
        using Base = CameraCommandData;
        static constexpr Kind KIND = Kind::CameraCommandSetFollowed;
    private:
        Guid trackId_;
        Data::CameraFollowReason reason_ = Data::CameraFollowReason::Alarm;
    public:
        CameraCommandSetFollowedData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(trackId_);
            destination.Write(reason_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(trackId_);
            source.Read(reason_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<CameraCommandSetFollowedData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<CameraCommandSetFollowedData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const CameraCommandSetFollowedData& >( other );
                if ( dataObject.trackId_ != trackId_ )
                {
                    return false;
                }
                if ( dataObject.reason_ != reason_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        const Guid& TrackId( ) const
        {
            return trackId_;
        }
        void SetTrackId( const Guid& trackId )
        {
            trackId_ = trackId;
        }
        Data::CameraFollowReason Reason( ) const
        {
            return reason_;
        }
        void SetReason( Data::CameraFollowReason reason )
        {
            reason_ = reason;
        }
    };
    class CameraCommandSetInfraRedLampData : public CameraCommandData
    {
    public:
        using Base = CameraCommandData;
        static constexpr Kind KIND = Kind::CameraCommandSetInfraRedLamp;
    private:
        bool enabled_ = false;
    public:
        CameraCommandSetInfraRedLampData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(enabled_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(enabled_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<CameraCommandSetInfraRedLampData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<CameraCommandSetInfraRedLampData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const CameraCommandSetInfraRedLampData& >( other );
                if ( dataObject.enabled_ != enabled_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        bool Enabled( ) const
        {
            return enabled_;
        }
        void SetEnabled( bool enabled )
        {
            enabled_ = enabled;
        }
    };
    class CameraCommandSetWasherData : public CameraCommandData
    {
    public:
        using Base = CameraCommandData;
        static constexpr Kind KIND = Kind::CameraCommandSetWasher;
    private:
        bool enabled_ = false;
    public:
        CameraCommandSetWasherData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(enabled_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(enabled_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<CameraCommandSetWasherData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<CameraCommandSetWasherData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const CameraCommandSetWasherData& >( other );
                if ( dataObject.enabled_ != enabled_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        bool Enabled( ) const
        {
            return enabled_;
        }
        void SetEnabled( bool enabled )
        {
            enabled_ = enabled;
        }
    };
    class CameraCommandSetWiperData : public CameraCommandData
    {
    public:
        using Base = CameraCommandData;
        static constexpr Kind KIND = Kind::CameraCommandSetWiper;
    private:
        bool enabled_ = false;
    public:
        CameraCommandSetWiperData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(enabled_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(enabled_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<CameraCommandSetWiperData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<CameraCommandSetWiperData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const CameraCommandSetWiperData& >( other );
                if ( dataObject.enabled_ != enabled_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        bool Enabled( ) const
        {
            return enabled_;
        }
        void SetEnabled( bool enabled )
        {
            enabled_ = enabled;
        }
    };
    class CameraCommandStopData : public CameraCommandData
    {
    public:
        using Base = CameraCommandData;
        static constexpr Kind KIND = Kind::CameraCommandStop;
    private:
        bool panTilt_ = false;
        bool zoom_ = false;
    public:
        CameraCommandStopData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(panTilt_);
            destination.Write(zoom_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(panTilt_);
            source.Read(zoom_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<CameraCommandStopData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<CameraCommandStopData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const CameraCommandStopData& >( other );
                if ( dataObject.panTilt_ != panTilt_ )
                {
                    return false;
                }
                if ( dataObject.zoom_ != zoom_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        bool PanTilt( ) const
        {
            return panTilt_;
        }
        void SetPanTilt( bool panTilt )
        {
            panTilt_ = panTilt;
        }
        bool Zoom( ) const
        {
            return zoom_;
        }
        void SetZoom( bool zoom )
        {
            zoom_ = zoom;
        }
    };
    class CameraCommandReplyData : public BaseData<Kind, Guid>
    {
    public:
        using Base = BaseData<Kind, Guid>;
        static constexpr Kind KIND = Kind::CameraCommandReply;
    private:
        Int64 rowVersion_ = 0;
        Guid camera_;
        DateTime timestamp_;
        Guid command_;
        Data::DeviceCommandReplyStatus status_ = Data::DeviceCommandReplyStatus::Unknown;
        WideString message_;
        SQLLEN messageLength_ = SQL_NULL_DATA;
        double panAngle_ = 0.0;
        double tiltAngle_ = 0.0;
        double focalLength_ = 0.0;
    public:
        CameraCommandReplyData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(rowVersion_);
            destination.Write(camera_);
            destination.Write(timestamp_);
            destination.Write(command_);
            destination.Write(status_);
            destination.Write(message_);
            destination.Write(panAngle_);
            destination.Write(tiltAngle_);
            destination.Write(focalLength_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(rowVersion_);
            source.Read(camera_);
            source.Read(timestamp_);
            source.Read(command_);
            source.Read(status_);
            source.Read(message_);
            source.Read(panAngle_);
            source.Read(tiltAngle_);
            source.Read(focalLength_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<CameraCommandReplyData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<CameraCommandReplyData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const CameraCommandReplyData& >( other );
                if ( dataObject.rowVersion_ != rowVersion_ )
                {
                    return false;
                }
                if ( dataObject.camera_ != camera_ )
                {
                    return false;
                }
                if ( dataObject.timestamp_ != timestamp_ )
                {
                    return false;
                }
                if ( dataObject.command_ != command_ )
                {
                    return false;
                }
                if ( dataObject.status_ != status_ )
                {
                    return false;
                }
                if ( dataObject.message_ != message_ )
                {
                    return false;
                }
                if ( dataObject.panAngle_ != panAngle_ )
                {
                    return false;
                }
                if ( dataObject.tiltAngle_ != tiltAngle_ )
                {
                    return false;
                }
                if ( dataObject.focalLength_ != focalLength_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        Int64 RowVersion( ) const
        {
            return rowVersion_;
        }
        void SetRowVersion( const Int64& rowVersion )
        {
            rowVersion_ = rowVersion;
        }
        const Guid& Camera( ) const
        {
            return camera_;
        }
        void SetCamera( const Guid& camera )
        {
            camera_ = camera;
        }
        const DateTime& Timestamp( ) const
        {
            return timestamp_;
        }
        void SetTimestamp( const DateTime& timestamp )
        {
            timestamp_ = timestamp;
        }
        const Guid& Command( ) const
        {
            return command_;
        }
        void SetCommand( const Guid& command )
        {
            command_ = command;
        }
        Data::DeviceCommandReplyStatus Status( ) const
        {
            return status_;
        }
        void SetStatus( Data::DeviceCommandReplyStatus status )
        {
            status_ = status;
        }
        const WideString& Message( ) const
        {
            return message_;
        }
        void SetMessage( const WideString& message )
        {
            message_ = message;
        }
        double PanAngle( ) const
        {
            return panAngle_;
        }
        void SetPanAngle( double panAngle )
        {
            panAngle_ = panAngle;
        }
        double TiltAngle( ) const
        {
            return tiltAngle_;
        }
        void SetTiltAngle( double tiltAngle )
        {
            tiltAngle_ = tiltAngle;
        }
        double FocalLength( ) const
        {
            return focalLength_;
        }
        void SetFocalLength( double focalLength )
        {
            focalLength_ = focalLength;
        }
    };
    class CameraConfigurationData : public BaseData<Kind, Guid>
    {
    public:
        using Base = BaseData<Kind, Guid>;
        static constexpr Kind KIND = Kind::CameraConfiguration;
    private:
        Int64 rowVersion_ = 0;
        Guid camera_;
        DateTime timestamp_;
        Data::CameraControlProtocol cameraControlProtocol_ = Data::CameraControlProtocol::Unknown;
        FixedDBWideString<127> cameraAddress_;
        Int32 cameraPort_ = 0;
        FixedDBWideString<127> cameraControlAddress_;
        Int32 cameraControlPort_ = 0;
        FixedDBWideString<127> cameraUserName_;
        FixedDBWideString<127> cameraPassword_;
        bool useRtspUriOverride_ = false;
        FixedDBWideString<127> rtspUriOverride_;
        double latitude_ = 0.0;
        double longitude_ = 0.0;
        double altitude_ = 0.0;
        bool useRelativePosition_ = false;
        double azimuthFromGPS_ = 0.0;
        double distanceFromGPS_ = 0.0;
        Data::CameraPanTiltMode panTiltMode_ = Data::CameraPanTiltMode::Unknown;
        double minTiltAngle_ = 0.0;
        double maxTiltAngle_ = 0.0;
        double minTiltScaleAngle_ = 0.0;
        double maxTiltScaleAngle_ = 0.0;
        bool useReverseTiltAngle_ = false;
        bool useReverseNormalizedTiltAngle_ = false;
        double minTiltVelocity_ = 0.0;
        double maxTiltVelocity_ = 0.0;
        double minTiltSpeed_ = 0.0;
        double maxTiltSpeed_ = 0.0;
        double minPanAngle_ = 0.0;
        double maxPanAngle_ = 0.0;
        double minPanScaleAngle_ = 0.0;
        double maxPanScaleAngle_ = 0.0;
        bool useReversePanAngle_ = false;
        bool useReverseNormalizedPanAngle_ = false;
        double minPanVelocity_ = 0.0;
        double maxPanVelocity_ = 0.0;
        double minPanSpeed_ = 0.0;
        double maxPanSpeed_ = 0.0;
        Data::CameraFocalLengthMode focalLengthMode_ = Data::CameraFocalLengthMode::Unknown;
        double minFocalLength_ = 0.0;
        double maxFocalLength_ = 0.0;
        double minFocalLengthScale_ = 0.0;
        double maxFocalLengthScale_ = 0.0;
        double minZoomVelocity_ = 0.0;
        double maxZoomVelocity_ = 0.0;
        double minZoomSpeed_ = 0.0;
        double maxZoomSpeed_ = 0.0;
        double imageSensorWidth_ = 0.0;
        double imageSensorHeight_ = 0.0;
        double homePanAngle_ = 0.0;
        double homeTiltAngle_ = 0.0;
        double homeFocalLength_ = 0.0;
        double panOffset_ = 0.0;
        double tiltOffset_ = 0.0;
        double aimAltitude_ = 0.0;
        double minimumTargetWidth_ = 0.0;
        TimeSpan targetLockTimeout_;
        TimeSpan updateStatusInterval_;
        TimeSpan readTimeout_;
        TimeSpan moveCommandStatusDelay_;
        FixedDBWideString<127> ptzProfileName_;
        FixedDBWideString<127> ptzConfigurationToken_;
        FixedDBWideString<127> videoSourceToken_;
    public:
        CameraConfigurationData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(rowVersion_);
            destination.Write(camera_);
            destination.Write(timestamp_);
            destination.Write(cameraControlProtocol_);
            cameraAddress_.WriteTo( destination );
            destination.Write(cameraPort_);
            cameraControlAddress_.WriteTo( destination );
            destination.Write(cameraControlPort_);
            cameraUserName_.WriteTo( destination );
            cameraPassword_.WriteTo( destination );
            destination.Write(useRtspUriOverride_);
            rtspUriOverride_.WriteTo( destination );
            destination.Write(latitude_);
            destination.Write(longitude_);
            destination.Write(altitude_);
            destination.Write(useRelativePosition_);
            destination.Write(azimuthFromGPS_);
            destination.Write(distanceFromGPS_);
            destination.Write(panTiltMode_);
            destination.Write(minTiltAngle_);
            destination.Write(maxTiltAngle_);
            destination.Write(minTiltScaleAngle_);
            destination.Write(maxTiltScaleAngle_);
            destination.Write(useReverseTiltAngle_);
            destination.Write(useReverseNormalizedTiltAngle_);
            destination.Write(minTiltVelocity_);
            destination.Write(maxTiltVelocity_);
            destination.Write(minTiltSpeed_);
            destination.Write(maxTiltSpeed_);
            destination.Write(minPanAngle_);
            destination.Write(maxPanAngle_);
            destination.Write(minPanScaleAngle_);
            destination.Write(maxPanScaleAngle_);
            destination.Write(useReversePanAngle_);
            destination.Write(useReverseNormalizedPanAngle_);
            destination.Write(minPanVelocity_);
            destination.Write(maxPanVelocity_);
            destination.Write(minPanSpeed_);
            destination.Write(maxPanSpeed_);
            destination.Write(focalLengthMode_);
            destination.Write(minFocalLength_);
            destination.Write(maxFocalLength_);
            destination.Write(minFocalLengthScale_);
            destination.Write(maxFocalLengthScale_);
            destination.Write(minZoomVelocity_);
            destination.Write(maxZoomVelocity_);
            destination.Write(minZoomSpeed_);
            destination.Write(maxZoomSpeed_);
            destination.Write(imageSensorWidth_);
            destination.Write(imageSensorHeight_);
            destination.Write(homePanAngle_);
            destination.Write(homeTiltAngle_);
            destination.Write(homeFocalLength_);
            destination.Write(panOffset_);
            destination.Write(tiltOffset_);
            destination.Write(aimAltitude_);
            destination.Write(minimumTargetWidth_);
            destination.Write(targetLockTimeout_);
            destination.Write(updateStatusInterval_);
            destination.Write(readTimeout_);
            destination.Write(moveCommandStatusDelay_);
            ptzProfileName_.WriteTo( destination );
            ptzConfigurationToken_.WriteTo( destination );
            videoSourceToken_.WriteTo( destination );
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(rowVersion_);
            source.Read(camera_);
            source.Read(timestamp_);
            source.Read(cameraControlProtocol_);
            cameraAddress_.ReadFrom( source );
            source.Read(cameraPort_);
            cameraControlAddress_.ReadFrom( source );
            source.Read(cameraControlPort_);
            cameraUserName_.ReadFrom( source );
            cameraPassword_.ReadFrom( source );
            source.Read(useRtspUriOverride_);
            rtspUriOverride_.ReadFrom( source );
            source.Read(latitude_);
            source.Read(longitude_);
            source.Read(altitude_);
            source.Read(useRelativePosition_);
            source.Read(azimuthFromGPS_);
            source.Read(distanceFromGPS_);
            source.Read(panTiltMode_);
            source.Read(minTiltAngle_);
            source.Read(maxTiltAngle_);
            source.Read(minTiltScaleAngle_);
            source.Read(maxTiltScaleAngle_);
            source.Read(useReverseTiltAngle_);
            source.Read(useReverseNormalizedTiltAngle_);
            source.Read(minTiltVelocity_);
            source.Read(maxTiltVelocity_);
            source.Read(minTiltSpeed_);
            source.Read(maxTiltSpeed_);
            source.Read(minPanAngle_);
            source.Read(maxPanAngle_);
            source.Read(minPanScaleAngle_);
            source.Read(maxPanScaleAngle_);
            source.Read(useReversePanAngle_);
            source.Read(useReverseNormalizedPanAngle_);
            source.Read(minPanVelocity_);
            source.Read(maxPanVelocity_);
            source.Read(minPanSpeed_);
            source.Read(maxPanSpeed_);
            source.Read(focalLengthMode_);
            source.Read(minFocalLength_);
            source.Read(maxFocalLength_);
            source.Read(minFocalLengthScale_);
            source.Read(maxFocalLengthScale_);
            source.Read(minZoomVelocity_);
            source.Read(maxZoomVelocity_);
            source.Read(minZoomSpeed_);
            source.Read(maxZoomSpeed_);
            source.Read(imageSensorWidth_);
            source.Read(imageSensorHeight_);
            source.Read(homePanAngle_);
            source.Read(homeTiltAngle_);
            source.Read(homeFocalLength_);
            source.Read(panOffset_);
            source.Read(tiltOffset_);
            source.Read(aimAltitude_);
            source.Read(minimumTargetWidth_);
            source.Read(targetLockTimeout_);
            source.Read(updateStatusInterval_);
            source.Read(readTimeout_);
            source.Read(moveCommandStatusDelay_);
            ptzProfileName_.ReadFrom( source );
            ptzConfigurationToken_.ReadFrom( source );
            videoSourceToken_.ReadFrom( source );
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<CameraConfigurationData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<CameraConfigurationData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const CameraConfigurationData& >( other );
                if ( dataObject.rowVersion_ != rowVersion_ )
                {
                    return false;
                }
                if ( dataObject.camera_ != camera_ )
                {
                    return false;
                }
                if ( dataObject.timestamp_ != timestamp_ )
                {
                    return false;
                }
                if ( dataObject.cameraControlProtocol_ != cameraControlProtocol_ )
                {
                    return false;
                }
                if ( dataObject.cameraAddress_ != cameraAddress_ )
                {
                    return false;
                }
                if ( dataObject.cameraPort_ != cameraPort_ )
                {
                    return false;
                }
                if ( dataObject.cameraControlAddress_ != cameraControlAddress_ )
                {
                    return false;
                }
                if ( dataObject.cameraControlPort_ != cameraControlPort_ )
                {
                    return false;
                }
                if ( dataObject.cameraUserName_ != cameraUserName_ )
                {
                    return false;
                }
                if ( dataObject.cameraPassword_ != cameraPassword_ )
                {
                    return false;
                }
                if ( dataObject.useRtspUriOverride_ != useRtspUriOverride_ )
                {
                    return false;
                }
                if ( dataObject.rtspUriOverride_ != rtspUriOverride_ )
                {
                    return false;
                }
                if ( dataObject.latitude_ != latitude_ )
                {
                    return false;
                }
                if ( dataObject.longitude_ != longitude_ )
                {
                    return false;
                }
                if ( dataObject.altitude_ != altitude_ )
                {
                    return false;
                }
                if ( dataObject.useRelativePosition_ != useRelativePosition_ )
                {
                    return false;
                }
                if ( dataObject.azimuthFromGPS_ != azimuthFromGPS_ )
                {
                    return false;
                }
                if ( dataObject.distanceFromGPS_ != distanceFromGPS_ )
                {
                    return false;
                }
                if ( dataObject.panTiltMode_ != panTiltMode_ )
                {
                    return false;
                }
                if ( dataObject.minTiltAngle_ != minTiltAngle_ )
                {
                    return false;
                }
                if ( dataObject.maxTiltAngle_ != maxTiltAngle_ )
                {
                    return false;
                }
                if ( dataObject.minTiltScaleAngle_ != minTiltScaleAngle_ )
                {
                    return false;
                }
                if ( dataObject.maxTiltScaleAngle_ != maxTiltScaleAngle_ )
                {
                    return false;
                }
                if ( dataObject.useReverseTiltAngle_ != useReverseTiltAngle_ )
                {
                    return false;
                }
                if ( dataObject.useReverseNormalizedTiltAngle_ != useReverseNormalizedTiltAngle_ )
                {
                    return false;
                }
                if ( dataObject.minTiltVelocity_ != minTiltVelocity_ )
                {
                    return false;
                }
                if ( dataObject.maxTiltVelocity_ != maxTiltVelocity_ )
                {
                    return false;
                }
                if ( dataObject.minTiltSpeed_ != minTiltSpeed_ )
                {
                    return false;
                }
                if ( dataObject.maxTiltSpeed_ != maxTiltSpeed_ )
                {
                    return false;
                }
                if ( dataObject.minPanAngle_ != minPanAngle_ )
                {
                    return false;
                }
                if ( dataObject.maxPanAngle_ != maxPanAngle_ )
                {
                    return false;
                }
                if ( dataObject.minPanScaleAngle_ != minPanScaleAngle_ )
                {
                    return false;
                }
                if ( dataObject.maxPanScaleAngle_ != maxPanScaleAngle_ )
                {
                    return false;
                }
                if ( dataObject.useReversePanAngle_ != useReversePanAngle_ )
                {
                    return false;
                }
                if ( dataObject.useReverseNormalizedPanAngle_ != useReverseNormalizedPanAngle_ )
                {
                    return false;
                }
                if ( dataObject.minPanVelocity_ != minPanVelocity_ )
                {
                    return false;
                }
                if ( dataObject.maxPanVelocity_ != maxPanVelocity_ )
                {
                    return false;
                }
                if ( dataObject.minPanSpeed_ != minPanSpeed_ )
                {
                    return false;
                }
                if ( dataObject.maxPanSpeed_ != maxPanSpeed_ )
                {
                    return false;
                }
                if ( dataObject.focalLengthMode_ != focalLengthMode_ )
                {
                    return false;
                }
                if ( dataObject.minFocalLength_ != minFocalLength_ )
                {
                    return false;
                }
                if ( dataObject.maxFocalLength_ != maxFocalLength_ )
                {
                    return false;
                }
                if ( dataObject.minFocalLengthScale_ != minFocalLengthScale_ )
                {
                    return false;
                }
                if ( dataObject.maxFocalLengthScale_ != maxFocalLengthScale_ )
                {
                    return false;
                }
                if ( dataObject.minZoomVelocity_ != minZoomVelocity_ )
                {
                    return false;
                }
                if ( dataObject.maxZoomVelocity_ != maxZoomVelocity_ )
                {
                    return false;
                }
                if ( dataObject.minZoomSpeed_ != minZoomSpeed_ )
                {
                    return false;
                }
                if ( dataObject.maxZoomSpeed_ != maxZoomSpeed_ )
                {
                    return false;
                }
                if ( dataObject.imageSensorWidth_ != imageSensorWidth_ )
                {
                    return false;
                }
                if ( dataObject.imageSensorHeight_ != imageSensorHeight_ )
                {
                    return false;
                }
                if ( dataObject.homePanAngle_ != homePanAngle_ )
                {
                    return false;
                }
                if ( dataObject.homeTiltAngle_ != homeTiltAngle_ )
                {
                    return false;
                }
                if ( dataObject.homeFocalLength_ != homeFocalLength_ )
                {
                    return false;
                }
                if ( dataObject.panOffset_ != panOffset_ )
                {
                    return false;
                }
                if ( dataObject.tiltOffset_ != tiltOffset_ )
                {
                    return false;
                }
                if ( dataObject.aimAltitude_ != aimAltitude_ )
                {
                    return false;
                }
                if ( dataObject.minimumTargetWidth_ != minimumTargetWidth_ )
                {
                    return false;
                }
                if ( dataObject.targetLockTimeout_ != targetLockTimeout_ )
                {
                    return false;
                }
                if ( dataObject.updateStatusInterval_ != updateStatusInterval_ )
                {
                    return false;
                }
                if ( dataObject.readTimeout_ != readTimeout_ )
                {
                    return false;
                }
                if ( dataObject.moveCommandStatusDelay_ != moveCommandStatusDelay_ )
                {
                    return false;
                }
                if ( dataObject.ptzProfileName_ != ptzProfileName_ )
                {
                    return false;
                }
                if ( dataObject.ptzConfigurationToken_ != ptzConfigurationToken_ )
                {
                    return false;
                }
                if ( dataObject.videoSourceToken_ != videoSourceToken_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        Int64 RowVersion( ) const
        {
            return rowVersion_;
        }
        void SetRowVersion( const Int64& rowVersion )
        {
            rowVersion_ = rowVersion;
        }
        const Guid& Camera( ) const
        {
            return camera_;
        }
        void SetCamera( const Guid& camera )
        {
            camera_ = camera;
        }
        const DateTime& Timestamp( ) const
        {
            return timestamp_;
        }
        void SetTimestamp( const DateTime& timestamp )
        {
            timestamp_ = timestamp;
        }
        Data::CameraControlProtocol CameraControlProtocol( ) const
        {
            return cameraControlProtocol_;
        }
        void SetCameraControlProtocol( Data::CameraControlProtocol cameraControlProtocol )
        {
            cameraControlProtocol_ = cameraControlProtocol;
        }
        const FixedDBWideString<127>& CameraAddress( ) const
        {
            return cameraAddress_;
        }
        void SetCameraAddress( const WideString& cameraAddress )
        {
            cameraAddress_ = cameraAddress;
        }
        Int32 CameraPort( ) const
        {
            return cameraPort_;
        }
        void SetCameraPort( Int32 cameraPort )
        {
            cameraPort_ = cameraPort;
        }
        const FixedDBWideString<127>& CameraControlAddress( ) const
        {
            return cameraControlAddress_;
        }
        void SetCameraControlAddress( const WideString& cameraControlAddress )
        {
            cameraControlAddress_ = cameraControlAddress;
        }
        Int32 CameraControlPort( ) const
        {
            return cameraControlPort_;
        }
        void SetCameraControlPort( Int32 cameraControlPort )
        {
            cameraControlPort_ = cameraControlPort;
        }
        const FixedDBWideString<127>& CameraUserName( ) const
        {
            return cameraUserName_;
        }
        void SetCameraUserName( const WideString& cameraUserName )
        {
            cameraUserName_ = cameraUserName;
        }
        const FixedDBWideString<127>& CameraPassword( ) const
        {
            return cameraPassword_;
        }
        void SetCameraPassword( const WideString& cameraPassword )
        {
            cameraPassword_ = cameraPassword;
        }
        bool UseRtspUriOverride( ) const
        {
            return useRtspUriOverride_;
        }
        void SetUseRtspUriOverride( bool useRtspUriOverride )
        {
            useRtspUriOverride_ = useRtspUriOverride;
        }
        const FixedDBWideString<127>& RtspUriOverride( ) const
        {
            return rtspUriOverride_;
        }
        void SetRtspUriOverride( const WideString& rtspUriOverride )
        {
            rtspUriOverride_ = rtspUriOverride;
        }
        double Latitude( ) const
        {
            return latitude_;
        }
        void SetLatitude( double latitude )
        {
            latitude_ = latitude;
        }
        double Longitude( ) const
        {
            return longitude_;
        }
        void SetLongitude( double longitude )
        {
            longitude_ = longitude;
        }
        double Altitude( ) const
        {
            return altitude_;
        }
        void SetAltitude( double altitude )
        {
            altitude_ = altitude;
        }
        bool UseRelativePosition( ) const
        {
            return useRelativePosition_;
        }
        void SetUseRelativePosition( bool useRelativePosition )
        {
            useRelativePosition_ = useRelativePosition;
        }
        double AzimuthFromGPS( ) const
        {
            return azimuthFromGPS_;
        }
        void SetAzimuthFromGPS( double azimuthFromGPS )
        {
            azimuthFromGPS_ = azimuthFromGPS;
        }
        double DistanceFromGPS( ) const
        {
            return distanceFromGPS_;
        }
        void SetDistanceFromGPS( double distanceFromGPS )
        {
            distanceFromGPS_ = distanceFromGPS;
        }
        Data::CameraPanTiltMode PanTiltMode( ) const
        {
            return panTiltMode_;
        }
        void SetPanTiltMode( Data::CameraPanTiltMode panTiltMode )
        {
            panTiltMode_ = panTiltMode;
        }
        double MinTiltAngle( ) const
        {
            return minTiltAngle_;
        }
        void SetMinTiltAngle( double minTiltAngle )
        {
            minTiltAngle_ = minTiltAngle;
        }
        double MaxTiltAngle( ) const
        {
            return maxTiltAngle_;
        }
        void SetMaxTiltAngle( double maxTiltAngle )
        {
            maxTiltAngle_ = maxTiltAngle;
        }
        double MinTiltScaleAngle( ) const
        {
            return minTiltScaleAngle_;
        }
        void SetMinTiltScaleAngle( double minTiltScaleAngle )
        {
            minTiltScaleAngle_ = minTiltScaleAngle;
        }
        double MaxTiltScaleAngle( ) const
        {
            return maxTiltScaleAngle_;
        }
        void SetMaxTiltScaleAngle( double maxTiltScaleAngle )
        {
            maxTiltScaleAngle_ = maxTiltScaleAngle;
        }
        bool UseReverseTiltAngle( ) const
        {
            return useReverseTiltAngle_;
        }
        void SetUseReverseTiltAngle( bool useReverseTiltAngle )
        {
            useReverseTiltAngle_ = useReverseTiltAngle;
        }
        bool UseReverseNormalizedTiltAngle( ) const
        {
            return useReverseNormalizedTiltAngle_;
        }
        void SetUseReverseNormalizedTiltAngle( bool useReverseNormalizedTiltAngle )
        {
            useReverseNormalizedTiltAngle_ = useReverseNormalizedTiltAngle;
        }
        double MinTiltVelocity( ) const
        {
            return minTiltVelocity_;
        }
        void SetMinTiltVelocity( double minTiltVelocity )
        {
            minTiltVelocity_ = minTiltVelocity;
        }
        double MaxTiltVelocity( ) const
        {
            return maxTiltVelocity_;
        }
        void SetMaxTiltVelocity( double maxTiltVelocity )
        {
            maxTiltVelocity_ = maxTiltVelocity;
        }
        double MinTiltSpeed( ) const
        {
            return minTiltSpeed_;
        }
        void SetMinTiltSpeed( double minTiltSpeed )
        {
            minTiltSpeed_ = minTiltSpeed;
        }
        double MaxTiltSpeed( ) const
        {
            return maxTiltSpeed_;
        }
        void SetMaxTiltSpeed( double maxTiltSpeed )
        {
            maxTiltSpeed_ = maxTiltSpeed;
        }
        double MinPanAngle( ) const
        {
            return minPanAngle_;
        }
        void SetMinPanAngle( double minPanAngle )
        {
            minPanAngle_ = minPanAngle;
        }
        double MaxPanAngle( ) const
        {
            return maxPanAngle_;
        }
        void SetMaxPanAngle( double maxPanAngle )
        {
            maxPanAngle_ = maxPanAngle;
        }
        double MinPanScaleAngle( ) const
        {
            return minPanScaleAngle_;
        }
        void SetMinPanScaleAngle( double minPanScaleAngle )
        {
            minPanScaleAngle_ = minPanScaleAngle;
        }
        double MaxPanScaleAngle( ) const
        {
            return maxPanScaleAngle_;
        }
        void SetMaxPanScaleAngle( double maxPanScaleAngle )
        {
            maxPanScaleAngle_ = maxPanScaleAngle;
        }
        bool UseReversePanAngle( ) const
        {
            return useReversePanAngle_;
        }
        void SetUseReversePanAngle( bool useReversePanAngle )
        {
            useReversePanAngle_ = useReversePanAngle;
        }
        bool UseReverseNormalizedPanAngle( ) const
        {
            return useReverseNormalizedPanAngle_;
        }
        void SetUseReverseNormalizedPanAngle( bool useReverseNormalizedPanAngle )
        {
            useReverseNormalizedPanAngle_ = useReverseNormalizedPanAngle;
        }
        double MinPanVelocity( ) const
        {
            return minPanVelocity_;
        }
        void SetMinPanVelocity( double minPanVelocity )
        {
            minPanVelocity_ = minPanVelocity;
        }
        double MaxPanVelocity( ) const
        {
            return maxPanVelocity_;
        }
        void SetMaxPanVelocity( double maxPanVelocity )
        {
            maxPanVelocity_ = maxPanVelocity;
        }
        double MinPanSpeed( ) const
        {
            return minPanSpeed_;
        }
        void SetMinPanSpeed( double minPanSpeed )
        {
            minPanSpeed_ = minPanSpeed;
        }
        double MaxPanSpeed( ) const
        {
            return maxPanSpeed_;
        }
        void SetMaxPanSpeed( double maxPanSpeed )
        {
            maxPanSpeed_ = maxPanSpeed;
        }
        Data::CameraFocalLengthMode FocalLengthMode( ) const
        {
            return focalLengthMode_;
        }
        void SetFocalLengthMode( Data::CameraFocalLengthMode focalLengthMode )
        {
            focalLengthMode_ = focalLengthMode;
        }
        double MinFocalLength( ) const
        {
            return minFocalLength_;
        }
        void SetMinFocalLength( double minFocalLength )
        {
            minFocalLength_ = minFocalLength;
        }
        double MaxFocalLength( ) const
        {
            return maxFocalLength_;
        }
        void SetMaxFocalLength( double maxFocalLength )
        {
            maxFocalLength_ = maxFocalLength;
        }
        double MinFocalLengthScale( ) const
        {
            return minFocalLengthScale_;
        }
        void SetMinFocalLengthScale( double minFocalLengthScale )
        {
            minFocalLengthScale_ = minFocalLengthScale;
        }
        double MaxFocalLengthScale( ) const
        {
            return maxFocalLengthScale_;
        }
        void SetMaxFocalLengthScale( double maxFocalLengthScale )
        {
            maxFocalLengthScale_ = maxFocalLengthScale;
        }
        double MinZoomVelocity( ) const
        {
            return minZoomVelocity_;
        }
        void SetMinZoomVelocity( double minZoomVelocity )
        {
            minZoomVelocity_ = minZoomVelocity;
        }
        double MaxZoomVelocity( ) const
        {
            return maxZoomVelocity_;
        }
        void SetMaxZoomVelocity( double maxZoomVelocity )
        {
            maxZoomVelocity_ = maxZoomVelocity;
        }
        double MinZoomSpeed( ) const
        {
            return minZoomSpeed_;
        }
        void SetMinZoomSpeed( double minZoomSpeed )
        {
            minZoomSpeed_ = minZoomSpeed;
        }
        double MaxZoomSpeed( ) const
        {
            return maxZoomSpeed_;
        }
        void SetMaxZoomSpeed( double maxZoomSpeed )
        {
            maxZoomSpeed_ = maxZoomSpeed;
        }
        double ImageSensorWidth( ) const
        {
            return imageSensorWidth_;
        }
        void SetImageSensorWidth( double imageSensorWidth )
        {
            imageSensorWidth_ = imageSensorWidth;
        }
        double ImageSensorHeight( ) const
        {
            return imageSensorHeight_;
        }
        void SetImageSensorHeight( double imageSensorHeight )
        {
            imageSensorHeight_ = imageSensorHeight;
        }
        double HomePanAngle( ) const
        {
            return homePanAngle_;
        }
        void SetHomePanAngle( double homePanAngle )
        {
            homePanAngle_ = homePanAngle;
        }
        double HomeTiltAngle( ) const
        {
            return homeTiltAngle_;
        }
        void SetHomeTiltAngle( double homeTiltAngle )
        {
            homeTiltAngle_ = homeTiltAngle;
        }
        double HomeFocalLength( ) const
        {
            return homeFocalLength_;
        }
        void SetHomeFocalLength( double homeFocalLength )
        {
            homeFocalLength_ = homeFocalLength;
        }
        double PanOffset( ) const
        {
            return panOffset_;
        }
        void SetPanOffset( double panOffset )
        {
            panOffset_ = panOffset;
        }
        double TiltOffset( ) const
        {
            return tiltOffset_;
        }
        void SetTiltOffset( double tiltOffset )
        {
            tiltOffset_ = tiltOffset;
        }
        double AimAltitude( ) const
        {
            return aimAltitude_;
        }
        void SetAimAltitude( double aimAltitude )
        {
            aimAltitude_ = aimAltitude;
        }
        double MinimumTargetWidth( ) const
        {
            return minimumTargetWidth_;
        }
        void SetMinimumTargetWidth( double minimumTargetWidth )
        {
            minimumTargetWidth_ = minimumTargetWidth;
        }
        const TimeSpan& TargetLockTimeout( ) const
        {
            return targetLockTimeout_;
        }
        void SetTargetLockTimeout( const TimeSpan& targetLockTimeout )
        {
            targetLockTimeout_ = targetLockTimeout;
        }
        const TimeSpan& UpdateStatusInterval( ) const
        {
            return updateStatusInterval_;
        }
        void SetUpdateStatusInterval( const TimeSpan& updateStatusInterval )
        {
            updateStatusInterval_ = updateStatusInterval;
        }
        const TimeSpan& ReadTimeout( ) const
        {
            return readTimeout_;
        }
        void SetReadTimeout( const TimeSpan& readTimeout )
        {
            readTimeout_ = readTimeout;
        }
        const TimeSpan& MoveCommandStatusDelay( ) const
        {
            return moveCommandStatusDelay_;
        }
        void SetMoveCommandStatusDelay( const TimeSpan& moveCommandStatusDelay )
        {
            moveCommandStatusDelay_ = moveCommandStatusDelay;
        }
        const FixedDBWideString<127>& PtzProfileName( ) const
        {
            return ptzProfileName_;
        }
        void SetPtzProfileName( const WideString& ptzProfileName )
        {
            ptzProfileName_ = ptzProfileName;
        }
        const FixedDBWideString<127>& PtzConfigurationToken( ) const
        {
            return ptzConfigurationToken_;
        }
        void SetPtzConfigurationToken( const WideString& ptzConfigurationToken )
        {
            ptzConfigurationToken_ = ptzConfigurationToken;
        }
        const FixedDBWideString<127>& VideoSourceToken( ) const
        {
            return videoSourceToken_;
        }
        void SetVideoSourceToken( const WideString& videoSourceToken )
        {
            videoSourceToken_ = videoSourceToken;
        }
    };
    class CameraPanCalibrationData : public BaseData<Kind, Guid>
    {
    public:
        using Base = BaseData<Kind, Guid>;
        static constexpr Kind KIND = Kind::CameraPanCalibration;
    private:
        Int64 rowVersion_ = 0;
        Guid camera_;
        DateTime timestamp_;
    public:
        CameraPanCalibrationData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(rowVersion_);
            destination.Write(camera_);
            destination.Write(timestamp_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(rowVersion_);
            source.Read(camera_);
            source.Read(timestamp_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<CameraPanCalibrationData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<CameraPanCalibrationData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const CameraPanCalibrationData& >( other );
                if ( dataObject.rowVersion_ != rowVersion_ )
                {
                    return false;
                }
                if ( dataObject.camera_ != camera_ )
                {
                    return false;
                }
                if ( dataObject.timestamp_ != timestamp_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        Int64 RowVersion( ) const
        {
            return rowVersion_;
        }
        void SetRowVersion( const Int64& rowVersion )
        {
            rowVersion_ = rowVersion;
        }
        const Guid& Camera( ) const
        {
            return camera_;
        }
        void SetCamera( const Guid& camera )
        {
            camera_ = camera;
        }
        const DateTime& Timestamp( ) const
        {
            return timestamp_;
        }
        void SetTimestamp( const DateTime& timestamp )
        {
            timestamp_ = timestamp;
        }
    };
    class CameraPanCalibrationValueData : public BaseData<Kind, Guid>
    {
    public:
        using Base = BaseData<Kind, Guid>;
        static constexpr Kind KIND = Kind::CameraPanCalibrationValue;
    private:
        Int64 rowVersion_ = 0;
        Guid panCalibration_;
        double panAngle_ = 0.0;
        double panOffset_ = 0.0;
    public:
        CameraPanCalibrationValueData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(rowVersion_);
            destination.Write(panCalibration_);
            destination.Write(panAngle_);
            destination.Write(panOffset_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(rowVersion_);
            source.Read(panCalibration_);
            source.Read(panAngle_);
            source.Read(panOffset_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<CameraPanCalibrationValueData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<CameraPanCalibrationValueData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const CameraPanCalibrationValueData& >( other );
                if ( dataObject.rowVersion_ != rowVersion_ )
                {
                    return false;
                }
                if ( dataObject.panCalibration_ != panCalibration_ )
                {
                    return false;
                }
                if ( dataObject.panAngle_ != panAngle_ )
                {
                    return false;
                }
                if ( dataObject.panOffset_ != panOffset_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        Int64 RowVersion( ) const
        {
            return rowVersion_;
        }
        void SetRowVersion( const Int64& rowVersion )
        {
            rowVersion_ = rowVersion;
        }
        const Guid& PanCalibration( ) const
        {
            return panCalibration_;
        }
        void SetPanCalibration( const Guid& panCalibration )
        {
            panCalibration_ = panCalibration;
        }
        double PanAngle( ) const
        {
            return panAngle_;
        }
        void SetPanAngle( double panAngle )
        {
            panAngle_ = panAngle;
        }
        double PanOffset( ) const
        {
            return panOffset_;
        }
        void SetPanOffset( double panOffset )
        {
            panOffset_ = panOffset;
        }
    };
    class CameraStatusData : public BaseData<Kind, Guid>
    {
    public:
        using Base = BaseData<Kind, Guid>;
        static constexpr Kind KIND = Kind::CameraStatus;
    private:
        Int64 rowVersion_ = 0;
        Guid camera_;
        Guid track_;
        DateTime timestamp_;
        Data::CameraPanTiltMode positionPanTiltMode_ = Data::CameraPanTiltMode::Unknown;
        double panAngle_ = 0.0;
        double tiltAngle_ = 0.0;
        Data::CameraFocalLengthMode positionFocalLengthMode_ = Data::CameraFocalLengthMode::Unknown;
        double focalLength_ = 0.0;
        Data::CameraMoveStatus panTiltMoveStatus_ = Data::CameraMoveStatus::Unknown;
        Data::CameraMoveStatus zoomMoveStatus_ = Data::CameraMoveStatus::Unknown;
        Data::CameraPanTiltMode velocityPanTiltMode_ = Data::CameraPanTiltMode::Unknown;
        DBDouble panVelocity_;
        DBDouble tiltVelocity_;
        Data::CameraFocalLengthMode velocityFocalLengthMode_ = Data::CameraFocalLengthMode::Unknown;
        DBDouble zoomVelocity_;
        Data::CameraFeatures activeFeatures_ = Data::CameraFeatures::None;
        WideString error_;
        SQLLEN errorLength_ = SQL_NULL_DATA;
    public:
        CameraStatusData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(rowVersion_);
            destination.Write(camera_);
            destination.Write(track_);
            destination.Write(timestamp_);
            destination.Write(positionPanTiltMode_);
            destination.Write(panAngle_);
            destination.Write(tiltAngle_);
            destination.Write(positionFocalLengthMode_);
            destination.Write(focalLength_);
            destination.Write(panTiltMoveStatus_);
            destination.Write(zoomMoveStatus_);
            destination.Write(velocityPanTiltMode_);
            panVelocity_.WriteTo( destination );
            tiltVelocity_.WriteTo( destination );
            destination.Write(velocityFocalLengthMode_);
            zoomVelocity_.WriteTo( destination );
            destination.Write(activeFeatures_);
            destination.Write(error_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(rowVersion_);
            source.Read(camera_);
            source.Read(track_);
            source.Read(timestamp_);
            source.Read(positionPanTiltMode_);
            source.Read(panAngle_);
            source.Read(tiltAngle_);
            source.Read(positionFocalLengthMode_);
            source.Read(focalLength_);
            source.Read(panTiltMoveStatus_);
            source.Read(zoomMoveStatus_);
            source.Read(velocityPanTiltMode_);
            panVelocity_.ReadFrom( source );
            tiltVelocity_.ReadFrom( source );
            source.Read(velocityFocalLengthMode_);
            zoomVelocity_.ReadFrom( source );
            source.Read(activeFeatures_);
            source.Read(error_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<CameraStatusData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<CameraStatusData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const CameraStatusData& >( other );
                if ( dataObject.rowVersion_ != rowVersion_ )
                {
                    return false;
                }
                if ( dataObject.camera_ != camera_ )
                {
                    return false;
                }
                if ( dataObject.track_ != track_ )
                {
                    return false;
                }
                if ( dataObject.timestamp_ != timestamp_ )
                {
                    return false;
                }
                if ( dataObject.positionPanTiltMode_ != positionPanTiltMode_ )
                {
                    return false;
                }
                if ( dataObject.panAngle_ != panAngle_ )
                {
                    return false;
                }
                if ( dataObject.tiltAngle_ != tiltAngle_ )
                {
                    return false;
                }
                if ( dataObject.positionFocalLengthMode_ != positionFocalLengthMode_ )
                {
                    return false;
                }
                if ( dataObject.focalLength_ != focalLength_ )
                {
                    return false;
                }
                if ( dataObject.panTiltMoveStatus_ != panTiltMoveStatus_ )
                {
                    return false;
                }
                if ( dataObject.zoomMoveStatus_ != zoomMoveStatus_ )
                {
                    return false;
                }
                if ( dataObject.velocityPanTiltMode_ != velocityPanTiltMode_ )
                {
                    return false;
                }
                if ( dataObject.panVelocity_ != panVelocity_ )
                {
                    return false;
                }
                if ( dataObject.tiltVelocity_ != tiltVelocity_ )
                {
                    return false;
                }
                if ( dataObject.velocityFocalLengthMode_ != velocityFocalLengthMode_ )
                {
                    return false;
                }
                if ( dataObject.zoomVelocity_ != zoomVelocity_ )
                {
                    return false;
                }
                if ( dataObject.activeFeatures_ != activeFeatures_ )
                {
                    return false;
                }
                if ( dataObject.error_ != error_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        Int64 RowVersion( ) const
        {
            return rowVersion_;
        }
        void SetRowVersion( const Int64& rowVersion )
        {
            rowVersion_ = rowVersion;
        }
        const Guid& Camera( ) const
        {
            return camera_;
        }
        void SetCamera( const Guid& camera )
        {
            camera_ = camera;
        }
        const Guid& Track( ) const
        {
            return track_;
        }
        void SetTrack( const Guid& track )
        {
            track_ = track;
        }
        const DateTime& Timestamp( ) const
        {
            return timestamp_;
        }
        void SetTimestamp( const DateTime& timestamp )
        {
            timestamp_ = timestamp;
        }
        Data::CameraPanTiltMode PositionPanTiltMode( ) const
        {
            return positionPanTiltMode_;
        }
        void SetPositionPanTiltMode( Data::CameraPanTiltMode positionPanTiltMode )
        {
            positionPanTiltMode_ = positionPanTiltMode;
        }
        double PanAngle( ) const
        {
            return panAngle_;
        }
        void SetPanAngle( double panAngle )
        {
            panAngle_ = panAngle;
        }
        double TiltAngle( ) const
        {
            return tiltAngle_;
        }
        void SetTiltAngle( double tiltAngle )
        {
            tiltAngle_ = tiltAngle;
        }
        Data::CameraFocalLengthMode PositionFocalLengthMode( ) const
        {
            return positionFocalLengthMode_;
        }
        void SetPositionFocalLengthMode( Data::CameraFocalLengthMode positionFocalLengthMode )
        {
            positionFocalLengthMode_ = positionFocalLengthMode;
        }
        double FocalLength( ) const
        {
            return focalLength_;
        }
        void SetFocalLength( double focalLength )
        {
            focalLength_ = focalLength;
        }
        Data::CameraMoveStatus PanTiltMoveStatus( ) const
        {
            return panTiltMoveStatus_;
        }
        void SetPanTiltMoveStatus( Data::CameraMoveStatus panTiltMoveStatus )
        {
            panTiltMoveStatus_ = panTiltMoveStatus;
        }
        Data::CameraMoveStatus ZoomMoveStatus( ) const
        {
            return zoomMoveStatus_;
        }
        void SetZoomMoveStatus( Data::CameraMoveStatus zoomMoveStatus )
        {
            zoomMoveStatus_ = zoomMoveStatus;
        }
        Data::CameraPanTiltMode VelocityPanTiltMode( ) const
        {
            return velocityPanTiltMode_;
        }
        void SetVelocityPanTiltMode( Data::CameraPanTiltMode velocityPanTiltMode )
        {
            velocityPanTiltMode_ = velocityPanTiltMode;
        }
        const DBDouble& PanVelocity( ) const
        {
            return panVelocity_;
        }
        void SetPanVelocity( const DBDouble& panVelocity )
        {
            panVelocity_ = panVelocity;
        }
        const DBDouble& TiltVelocity( ) const
        {
            return tiltVelocity_;
        }
        void SetTiltVelocity( const DBDouble& tiltVelocity )
        {
            tiltVelocity_ = tiltVelocity;
        }
        Data::CameraFocalLengthMode VelocityFocalLengthMode( ) const
        {
            return velocityFocalLengthMode_;
        }
        void SetVelocityFocalLengthMode( Data::CameraFocalLengthMode velocityFocalLengthMode )
        {
            velocityFocalLengthMode_ = velocityFocalLengthMode;
        }
        const DBDouble& ZoomVelocity( ) const
        {
            return zoomVelocity_;
        }
        void SetZoomVelocity( const DBDouble& zoomVelocity )
        {
            zoomVelocity_ = zoomVelocity;
        }
        Data::CameraFeatures ActiveFeatures( ) const
        {
            return activeFeatures_;
        }
        void SetActiveFeatures( Data::CameraFeatures activeFeatures )
        {
            activeFeatures_ = activeFeatures;
        }
        const WideString& Error( ) const
        {
            return error_;
        }
        void SetError( const WideString& error )
        {
            error_ = error;
        }
    };
    class CameraTiltCalibrationData : public BaseData<Kind, Guid>
    {
    public:
        using Base = BaseData<Kind, Guid>;
        static constexpr Kind KIND = Kind::CameraTiltCalibration;
    private:
        Int64 rowVersion_ = 0;
        Guid camera_;
        DateTime timestamp_;
    public:
        CameraTiltCalibrationData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(rowVersion_);
            destination.Write(camera_);
            destination.Write(timestamp_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(rowVersion_);
            source.Read(camera_);
            source.Read(timestamp_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<CameraTiltCalibrationData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<CameraTiltCalibrationData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const CameraTiltCalibrationData& >( other );
                if ( dataObject.rowVersion_ != rowVersion_ )
                {
                    return false;
                }
                if ( dataObject.camera_ != camera_ )
                {
                    return false;
                }
                if ( dataObject.timestamp_ != timestamp_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        Int64 RowVersion( ) const
        {
            return rowVersion_;
        }
        void SetRowVersion( const Int64& rowVersion )
        {
            rowVersion_ = rowVersion;
        }
        const Guid& Camera( ) const
        {
            return camera_;
        }
        void SetCamera( const Guid& camera )
        {
            camera_ = camera;
        }
        const DateTime& Timestamp( ) const
        {
            return timestamp_;
        }
        void SetTimestamp( const DateTime& timestamp )
        {
            timestamp_ = timestamp;
        }
    };
    class CameraTiltCalibrationValueData : public BaseData<Kind, Guid>
    {
    public:
        using Base = BaseData<Kind, Guid>;
        static constexpr Kind KIND = Kind::CameraTiltCalibrationValue;
    private:
        Int64 rowVersion_ = 0;
        Guid tiltCalibration_;
        double panAngle_ = 0.0;
        double tiltOffset_ = 0.0;
    public:
        CameraTiltCalibrationValueData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(rowVersion_);
            destination.Write(tiltCalibration_);
            destination.Write(panAngle_);
            destination.Write(tiltOffset_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(rowVersion_);
            source.Read(tiltCalibration_);
            source.Read(panAngle_);
            source.Read(tiltOffset_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<CameraTiltCalibrationValueData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<CameraTiltCalibrationValueData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const CameraTiltCalibrationValueData& >( other );
                if ( dataObject.rowVersion_ != rowVersion_ )
                {
                    return false;
                }
                if ( dataObject.tiltCalibration_ != tiltCalibration_ )
                {
                    return false;
                }
                if ( dataObject.panAngle_ != panAngle_ )
                {
                    return false;
                }
                if ( dataObject.tiltOffset_ != tiltOffset_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        Int64 RowVersion( ) const
        {
            return rowVersion_;
        }
        void SetRowVersion( const Int64& rowVersion )
        {
            rowVersion_ = rowVersion;
        }
        const Guid& TiltCalibration( ) const
        {
            return tiltCalibration_;
        }
        void SetTiltCalibration( const Guid& tiltCalibration )
        {
            tiltCalibration_ = tiltCalibration;
        }
        double PanAngle( ) const
        {
            return panAngle_;
        }
        void SetPanAngle( double panAngle )
        {
            panAngle_ = panAngle;
        }
        double TiltOffset( ) const
        {
            return tiltOffset_;
        }
        void SetTiltOffset( double tiltOffset )
        {
            tiltOffset_ = tiltOffset;
        }
    };
    class CameraZoomCalibrationData : public BaseData<Kind, Guid>
    {
    public:
        using Base = BaseData<Kind, Guid>;
        static constexpr Kind KIND = Kind::CameraZoomCalibration;
    private:
        Int64 rowVersion_ = 0;
        Guid camera_;
        DateTime timestamp_;
    public:
        CameraZoomCalibrationData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(rowVersion_);
            destination.Write(camera_);
            destination.Write(timestamp_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(rowVersion_);
            source.Read(camera_);
            source.Read(timestamp_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<CameraZoomCalibrationData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<CameraZoomCalibrationData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const CameraZoomCalibrationData& >( other );
                if ( dataObject.rowVersion_ != rowVersion_ )
                {
                    return false;
                }
                if ( dataObject.camera_ != camera_ )
                {
                    return false;
                }
                if ( dataObject.timestamp_ != timestamp_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        Int64 RowVersion( ) const
        {
            return rowVersion_;
        }
        void SetRowVersion( const Int64& rowVersion )
        {
            rowVersion_ = rowVersion;
        }
        const Guid& Camera( ) const
        {
            return camera_;
        }
        void SetCamera( const Guid& camera )
        {
            camera_ = camera;
        }
        const DateTime& Timestamp( ) const
        {
            return timestamp_;
        }
        void SetTimestamp( const DateTime& timestamp )
        {
            timestamp_ = timestamp;
        }
    };
    class CameraZoomCalibrationValueData : public BaseData<Kind, Guid>
    {
    public:
        using Base = BaseData<Kind, Guid>;
        static constexpr Kind KIND = Kind::CameraZoomCalibrationValue;
    private:
        Int64 rowVersion_ = 0;
        Guid zoomCalibration_;
        double focalLength_ = 0.0;
        double focalLengthOffset_ = 0.0;
    public:
        CameraZoomCalibrationValueData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(rowVersion_);
            destination.Write(zoomCalibration_);
            destination.Write(focalLength_);
            destination.Write(focalLengthOffset_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(rowVersion_);
            source.Read(zoomCalibration_);
            source.Read(focalLength_);
            source.Read(focalLengthOffset_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<CameraZoomCalibrationValueData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<CameraZoomCalibrationValueData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const CameraZoomCalibrationValueData& >( other );
                if ( dataObject.rowVersion_ != rowVersion_ )
                {
                    return false;
                }
                if ( dataObject.zoomCalibration_ != zoomCalibration_ )
                {
                    return false;
                }
                if ( dataObject.focalLength_ != focalLength_ )
                {
                    return false;
                }
                if ( dataObject.focalLengthOffset_ != focalLengthOffset_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        Int64 RowVersion( ) const
        {
            return rowVersion_;
        }
        void SetRowVersion( const Int64& rowVersion )
        {
            rowVersion_ = rowVersion;
        }
        const Guid& ZoomCalibration( ) const
        {
            return zoomCalibration_;
        }
        void SetZoomCalibration( const Guid& zoomCalibration )
        {
            zoomCalibration_ = zoomCalibration;
        }
        double FocalLength( ) const
        {
            return focalLength_;
        }
        void SetFocalLength( double focalLength )
        {
            focalLength_ = focalLength;
        }
        double FocalLengthOffset( ) const
        {
            return focalLengthOffset_;
        }
        void SetFocalLengthOffset( double focalLengthOffset )
        {
            focalLengthOffset_ = focalLengthOffset;
        }
    };
    class CatalogElementData : public BaseData<Kind, Guid>
    {
    public:
        using Base = BaseData<Kind, Guid>;
        static constexpr Kind KIND = Kind::CatalogElement;
    private:
        Int64 rowVersion_ = 0;
        Guid catalog_;
        FixedDBWideString<127> name_;
    public:
        CatalogElementData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(rowVersion_);
            destination.Write(catalog_);
            name_.WriteTo( destination );
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(rowVersion_);
            source.Read(catalog_);
            name_.ReadFrom( source );
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<CatalogElementData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<CatalogElementData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const CatalogElementData& >( other );
                if ( dataObject.rowVersion_ != rowVersion_ )
                {
                    return false;
                }
                if ( dataObject.catalog_ != catalog_ )
                {
                    return false;
                }
                if ( dataObject.name_ != name_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        Int64 RowVersion( ) const
        {
            return rowVersion_;
        }
        void SetRowVersion( const Int64& rowVersion )
        {
            rowVersion_ = rowVersion;
        }
        const Guid& Catalog( ) const
        {
            return catalog_;
        }
        void SetCatalog( const Guid& catalog )
        {
            catalog_ = catalog;
        }
        const FixedDBWideString<127>& Name( ) const
        {
            return name_;
        }
        void SetName( const WideString& name )
        {
            name_ = name;
        }
    };
    class CatalogData : public CatalogElementData
    {
    public:
        using Base = CatalogElementData;
        static constexpr Kind KIND = Kind::Catalog;
    private:
    public:
        CatalogData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<CatalogData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<CatalogData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const CatalogData& >( other );
                return true;
            }
            return false;
        }
    };
    class ElementData : public CatalogElementData
    {
    public:
        using Base = CatalogElementData;
        static constexpr Kind KIND = Kind::Element;
    private:
        Guid elementType_;
    public:
        ElementData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(elementType_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(elementType_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<ElementData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<ElementData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const ElementData& >( other );
                if ( dataObject.elementType_ != elementType_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        const Guid& ElementType( ) const
        {
            return elementType_;
        }
        void SetElementType( const Guid& elementType )
        {
            elementType_ = elementType;
        }
    };
    class CollectionInfoData : public BaseData<Kind, Guid>
    {
    public:
        using Base = BaseData<Kind, Guid>;
        static constexpr Kind KIND = Kind::CollectionInfo;
    private:
        Int64 rowVersion_ = 0;
        Int64 count_ = 0;
    public:
        CollectionInfoData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(rowVersion_);
            destination.Write(count_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(rowVersion_);
            source.Read(count_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<CollectionInfoData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<CollectionInfoData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const CollectionInfoData& >( other );
                if ( dataObject.rowVersion_ != rowVersion_ )
                {
                    return false;
                }
                if ( dataObject.count_ != count_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        Int64 RowVersion( ) const
        {
            return rowVersion_;
        }
        void SetRowVersion( const Int64& rowVersion )
        {
            rowVersion_ = rowVersion;
        }
        Int64 Count( ) const
        {
            return count_;
        }
        void SetCount( Int64 count )
        {
            count_ = count;
        }
    };
    class CountryData : public BaseData<Kind, Guid>
    {
    public:
        using Base = BaseData<Kind, Guid>;
        static constexpr Kind KIND = Kind::Country;
    private:
        Int64 rowVersion_ = 0;
        FixedDBWideString<127> name_;
        Int32 code_ = 0;
        FixedDBWideString<2> alpha2_;
        FixedDBWideString<3> alpha3_;
    public:
        CountryData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(rowVersion_);
            name_.WriteTo( destination );
            destination.Write(code_);
            alpha2_.WriteTo( destination );
            alpha3_.WriteTo( destination );
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(rowVersion_);
            name_.ReadFrom( source );
            source.Read(code_);
            alpha2_.ReadFrom( source );
            alpha3_.ReadFrom( source );
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<CountryData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<CountryData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const CountryData& >( other );
                if ( dataObject.rowVersion_ != rowVersion_ )
                {
                    return false;
                }
                if ( dataObject.name_ != name_ )
                {
                    return false;
                }
                if ( dataObject.code_ != code_ )
                {
                    return false;
                }
                if ( dataObject.alpha2_ != alpha2_ )
                {
                    return false;
                }
                if ( dataObject.alpha3_ != alpha3_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        Int64 RowVersion( ) const
        {
            return rowVersion_;
        }
        void SetRowVersion( const Int64& rowVersion )
        {
            rowVersion_ = rowVersion;
        }
        const FixedDBWideString<127>& Name( ) const
        {
            return name_;
        }
        void SetName( const WideString& name )
        {
            name_ = name;
        }
        Int32 Code( ) const
        {
            return code_;
        }
        void SetCode( Int32 code )
        {
            code_ = code;
        }
        const FixedDBWideString<2>& Alpha2( ) const
        {
            return alpha2_;
        }
        void SetAlpha2( const WideString& alpha2 )
        {
            alpha2_ = alpha2;
        }
        const FixedDBWideString<3>& Alpha3( ) const
        {
            return alpha3_;
        }
        void SetAlpha3( const WideString& alpha3 )
        {
            alpha3_ = alpha3;
        }
    };
    class CursorInfoData : public BaseData<Kind, Guid>
    {
    public:
        using Base = BaseData<Kind, Guid>;
        static constexpr Kind KIND = Kind::CursorInfo;
    private:
        Int64 rowVersion_ = 0;
        Int32 typeCode_ = 0;
    public:
        CursorInfoData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(rowVersion_);
            destination.Write(typeCode_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(rowVersion_);
            source.Read(typeCode_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<CursorInfoData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<CursorInfoData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const CursorInfoData& >( other );
                if ( dataObject.rowVersion_ != rowVersion_ )
                {
                    return false;
                }
                if ( dataObject.typeCode_ != typeCode_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        Int64 RowVersion( ) const
        {
            return rowVersion_;
        }
        void SetRowVersion( const Int64& rowVersion )
        {
            rowVersion_ = rowVersion;
        }
        Int32 TypeCode( ) const
        {
            return typeCode_;
        }
        void SetTypeCode( Int32 typeCode )
        {
            typeCode_ = typeCode;
        }
    };
    class DateTimeTimeseriesValueData : public BaseData<Kind, Guid>
    {
    public:
        using Base = BaseData<Kind, Guid>;
        static constexpr Kind KIND = Kind::DateTimeTimeseriesValue;
    private:
        Int64 rowVersion_ = 0;
        Guid timeseries_;
        DateTime timestamp_;
        DBDateTime value_;
    public:
        DateTimeTimeseriesValueData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(rowVersion_);
            destination.Write(timeseries_);
            destination.Write(timestamp_);
            value_.WriteTo( destination );
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(rowVersion_);
            source.Read(timeseries_);
            source.Read(timestamp_);
            value_.ReadFrom( source );
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<DateTimeTimeseriesValueData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<DateTimeTimeseriesValueData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const DateTimeTimeseriesValueData& >( other );
                if ( dataObject.rowVersion_ != rowVersion_ )
                {
                    return false;
                }
                if ( dataObject.timeseries_ != timeseries_ )
                {
                    return false;
                }
                if ( dataObject.timestamp_ != timestamp_ )
                {
                    return false;
                }
                if ( dataObject.value_ != value_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        Int64 RowVersion( ) const
        {
            return rowVersion_;
        }
        void SetRowVersion( const Int64& rowVersion )
        {
            rowVersion_ = rowVersion;
        }
        const Guid& Timeseries( ) const
        {
            return timeseries_;
        }
        void SetTimeseries( const Guid& timeseries )
        {
            timeseries_ = timeseries;
        }
        const DateTime& Timestamp( ) const
        {
            return timestamp_;
        }
        void SetTimestamp( const DateTime& timestamp )
        {
            timestamp_ = timestamp;
        }
        const DBDateTime& Value( ) const
        {
            return value_;
        }
        void SetValue( const DBDateTime& value )
        {
            value_ = value;
        }
    };
    class DeviceHostData : public BaseData<Kind, Guid>
    {
    public:
        using Base = BaseData<Kind, Guid>;
        static constexpr Kind KIND = Kind::DeviceHost;
    private:
        Int64 rowVersion_ = 0;
        FixedDBWideString<127> name_;
    public:
        DeviceHostData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(rowVersion_);
            name_.WriteTo( destination );
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(rowVersion_);
            name_.ReadFrom( source );
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<DeviceHostData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<DeviceHostData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const DeviceHostData& >( other );
                if ( dataObject.rowVersion_ != rowVersion_ )
                {
                    return false;
                }
                if ( dataObject.name_ != name_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        Int64 RowVersion( ) const
        {
            return rowVersion_;
        }
        void SetRowVersion( const Int64& rowVersion )
        {
            rowVersion_ = rowVersion;
        }
        const FixedDBWideString<127>& Name( ) const
        {
            return name_;
        }
        void SetName( const WideString& name )
        {
            name_ = name;
        }
    };
    class DeviceHostConfigurationData : public BaseData<Kind, Guid>
    {
    public:
        using Base = BaseData<Kind, Guid>;
        static constexpr Kind KIND = Kind::DeviceHostConfiguration;
    private:
        Int64 rowVersion_ = 0;
        Guid host_;
        DateTime timestamp_;
        FixedDBWideString<127> hostname_;
        Int32 port_ = 0;
        FixedDBWideString<100> queueName_;
    public:
        DeviceHostConfigurationData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(rowVersion_);
            destination.Write(host_);
            destination.Write(timestamp_);
            hostname_.WriteTo( destination );
            destination.Write(port_);
            queueName_.WriteTo( destination );
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(rowVersion_);
            source.Read(host_);
            source.Read(timestamp_);
            hostname_.ReadFrom( source );
            source.Read(port_);
            queueName_.ReadFrom( source );
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<DeviceHostConfigurationData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<DeviceHostConfigurationData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const DeviceHostConfigurationData& >( other );
                if ( dataObject.rowVersion_ != rowVersion_ )
                {
                    return false;
                }
                if ( dataObject.host_ != host_ )
                {
                    return false;
                }
                if ( dataObject.timestamp_ != timestamp_ )
                {
                    return false;
                }
                if ( dataObject.hostname_ != hostname_ )
                {
                    return false;
                }
                if ( dataObject.port_ != port_ )
                {
                    return false;
                }
                if ( dataObject.queueName_ != queueName_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        Int64 RowVersion( ) const
        {
            return rowVersion_;
        }
        void SetRowVersion( const Int64& rowVersion )
        {
            rowVersion_ = rowVersion;
        }
        const Guid& Host( ) const
        {
            return host_;
        }
        void SetHost( const Guid& host )
        {
            host_ = host;
        }
        const DateTime& Timestamp( ) const
        {
            return timestamp_;
        }
        void SetTimestamp( const DateTime& timestamp )
        {
            timestamp_ = timestamp;
        }
        const FixedDBWideString<127>& Hostname( ) const
        {
            return hostname_;
        }
        void SetHostname( const WideString& hostname )
        {
            hostname_ = hostname;
        }
        Int32 Port( ) const
        {
            return port_;
        }
        void SetPort( Int32 port )
        {
            port_ = port;
        }
        const FixedDBWideString<100>& QueueName( ) const
        {
            return queueName_;
        }
        void SetQueueName( const WideString& queueName )
        {
            queueName_ = queueName;
        }
    };
    class DoubleTimeseriesValueData : public BaseData<Kind, Guid>
    {
    public:
        using Base = BaseData<Kind, Guid>;
        static constexpr Kind KIND = Kind::DoubleTimeseriesValue;
    private:
        Int64 rowVersion_ = 0;
        Guid timeseries_;
        DateTime timestamp_;
        DBDouble value_;
    public:
        DoubleTimeseriesValueData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(rowVersion_);
            destination.Write(timeseries_);
            destination.Write(timestamp_);
            value_.WriteTo( destination );
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(rowVersion_);
            source.Read(timeseries_);
            source.Read(timestamp_);
            value_.ReadFrom( source );
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<DoubleTimeseriesValueData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<DoubleTimeseriesValueData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const DoubleTimeseriesValueData& >( other );
                if ( dataObject.rowVersion_ != rowVersion_ )
                {
                    return false;
                }
                if ( dataObject.timeseries_ != timeseries_ )
                {
                    return false;
                }
                if ( dataObject.timestamp_ != timestamp_ )
                {
                    return false;
                }
                if ( dataObject.value_ != value_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        Int64 RowVersion( ) const
        {
            return rowVersion_;
        }
        void SetRowVersion( const Int64& rowVersion )
        {
            rowVersion_ = rowVersion;
        }
        const Guid& Timeseries( ) const
        {
            return timeseries_;
        }
        void SetTimeseries( const Guid& timeseries )
        {
            timeseries_ = timeseries;
        }
        const DateTime& Timestamp( ) const
        {
            return timestamp_;
        }
        void SetTimestamp( const DateTime& timestamp )
        {
            timestamp_ = timestamp;
        }
        const DBDouble& Value( ) const
        {
            return value_;
        }
        void SetValue( const DBDouble& value )
        {
            value_ = value;
        }
    };
    class FacilityTypeData : public BaseData<Kind, Guid>
    {
    public:
        using Base = BaseData<Kind, Guid>;
        static constexpr Kind KIND = Kind::FacilityType;
    private:
        Int64 rowVersion_ = 0;
        FixedDBWideString<127> name_;
    public:
        FacilityTypeData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(rowVersion_);
            name_.WriteTo( destination );
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(rowVersion_);
            name_.ReadFrom( source );
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<FacilityTypeData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<FacilityTypeData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const FacilityTypeData& >( other );
                if ( dataObject.rowVersion_ != rowVersion_ )
                {
                    return false;
                }
                if ( dataObject.name_ != name_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        Int64 RowVersion( ) const
        {
            return rowVersion_;
        }
        void SetRowVersion( const Int64& rowVersion )
        {
            rowVersion_ = rowVersion;
        }
        const FixedDBWideString<127>& Name( ) const
        {
            return name_;
        }
        void SetName( const WideString& name )
        {
            name_ = name;
        }
    };
    class GeoPosition2DTimeseriesValueData : public BaseData<Kind, Guid>
    {
    public:
        using Base = BaseData<Kind, Guid>;
        static constexpr Kind KIND = Kind::GeoPosition2DTimeseriesValue;
    private:
        Int64 rowVersion_ = 0;
        Guid timeseries_;
        DateTime timestamp_;
        DBDouble latitude_;
        DBDouble longitude_;
    public:
        GeoPosition2DTimeseriesValueData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(rowVersion_);
            destination.Write(timeseries_);
            destination.Write(timestamp_);
            latitude_.WriteTo( destination );
            longitude_.WriteTo( destination );
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(rowVersion_);
            source.Read(timeseries_);
            source.Read(timestamp_);
            latitude_.ReadFrom( source );
            longitude_.ReadFrom( source );
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<GeoPosition2DTimeseriesValueData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<GeoPosition2DTimeseriesValueData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const GeoPosition2DTimeseriesValueData& >( other );
                if ( dataObject.rowVersion_ != rowVersion_ )
                {
                    return false;
                }
                if ( dataObject.timeseries_ != timeseries_ )
                {
                    return false;
                }
                if ( dataObject.timestamp_ != timestamp_ )
                {
                    return false;
                }
                if ( dataObject.latitude_ != latitude_ )
                {
                    return false;
                }
                if ( dataObject.longitude_ != longitude_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        Int64 RowVersion( ) const
        {
            return rowVersion_;
        }
        void SetRowVersion( const Int64& rowVersion )
        {
            rowVersion_ = rowVersion;
        }
        const Guid& Timeseries( ) const
        {
            return timeseries_;
        }
        void SetTimeseries( const Guid& timeseries )
        {
            timeseries_ = timeseries;
        }
        const DateTime& Timestamp( ) const
        {
            return timestamp_;
        }
        void SetTimestamp( const DateTime& timestamp )
        {
            timestamp_ = timestamp;
        }
        const DBDouble& Latitude( ) const
        {
            return latitude_;
        }
        void SetLatitude( const DBDouble& latitude )
        {
            latitude_ = latitude;
        }
        const DBDouble& Longitude( ) const
        {
            return longitude_;
        }
        void SetLongitude( const DBDouble& longitude )
        {
            longitude_ = longitude;
        }
    };
    class GeoPosition3DTimeseriesValueData : public BaseData<Kind, Guid>
    {
    public:
        using Base = BaseData<Kind, Guid>;
        static constexpr Kind KIND = Kind::GeoPosition3DTimeseriesValue;
    private:
        Int64 rowVersion_ = 0;
        Guid timeseries_;
        DateTime timestamp_;
        DBDouble latitude_;
        DBDouble longitude_;
        DBDouble altitude_;
    public:
        GeoPosition3DTimeseriesValueData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(rowVersion_);
            destination.Write(timeseries_);
            destination.Write(timestamp_);
            latitude_.WriteTo( destination );
            longitude_.WriteTo( destination );
            altitude_.WriteTo( destination );
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(rowVersion_);
            source.Read(timeseries_);
            source.Read(timestamp_);
            latitude_.ReadFrom( source );
            longitude_.ReadFrom( source );
            altitude_.ReadFrom( source );
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<GeoPosition3DTimeseriesValueData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<GeoPosition3DTimeseriesValueData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const GeoPosition3DTimeseriesValueData& >( other );
                if ( dataObject.rowVersion_ != rowVersion_ )
                {
                    return false;
                }
                if ( dataObject.timeseries_ != timeseries_ )
                {
                    return false;
                }
                if ( dataObject.timestamp_ != timestamp_ )
                {
                    return false;
                }
                if ( dataObject.latitude_ != latitude_ )
                {
                    return false;
                }
                if ( dataObject.longitude_ != longitude_ )
                {
                    return false;
                }
                if ( dataObject.altitude_ != altitude_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        Int64 RowVersion( ) const
        {
            return rowVersion_;
        }
        void SetRowVersion( const Int64& rowVersion )
        {
            rowVersion_ = rowVersion;
        }
        const Guid& Timeseries( ) const
        {
            return timeseries_;
        }
        void SetTimeseries( const Guid& timeseries )
        {
            timeseries_ = timeseries;
        }
        const DateTime& Timestamp( ) const
        {
            return timestamp_;
        }
        void SetTimestamp( const DateTime& timestamp )
        {
            timestamp_ = timestamp;
        }
        const DBDouble& Latitude( ) const
        {
            return latitude_;
        }
        void SetLatitude( const DBDouble& latitude )
        {
            latitude_ = latitude;
        }
        const DBDouble& Longitude( ) const
        {
            return longitude_;
        }
        void SetLongitude( const DBDouble& longitude )
        {
            longitude_ = longitude;
        }
        const DBDouble& Altitude( ) const
        {
            return altitude_;
        }
        void SetAltitude( const DBDouble& altitude )
        {
            altitude_ = altitude;
        }
    };
    class GNSSDeviceCommandData : public BaseData<Kind, Guid>
    {
    public:
        using Base = BaseData<Kind, Guid>;
        static constexpr Kind KIND = Kind::GNSSDeviceCommand;
    private:
        Int64 rowVersion_ = 0;
        Guid gNSSDevice_;
        DateTime timestamp_;
        Data::DeviceCommandSourceType deviceCommandSourceType_ = Data::DeviceCommandSourceType::Unknown;
        Guid deviceCommandSourceId_;
        Guid reply_;
    public:
        GNSSDeviceCommandData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(rowVersion_);
            destination.Write(gNSSDevice_);
            destination.Write(timestamp_);
            destination.Write(deviceCommandSourceType_);
            destination.Write(deviceCommandSourceId_);
            destination.Write(reply_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(rowVersion_);
            source.Read(gNSSDevice_);
            source.Read(timestamp_);
            source.Read(deviceCommandSourceType_);
            source.Read(deviceCommandSourceId_);
            source.Read(reply_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<GNSSDeviceCommandData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<GNSSDeviceCommandData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const GNSSDeviceCommandData& >( other );
                if ( dataObject.rowVersion_ != rowVersion_ )
                {
                    return false;
                }
                if ( dataObject.gNSSDevice_ != gNSSDevice_ )
                {
                    return false;
                }
                if ( dataObject.timestamp_ != timestamp_ )
                {
                    return false;
                }
                if ( dataObject.deviceCommandSourceType_ != deviceCommandSourceType_ )
                {
                    return false;
                }
                if ( dataObject.deviceCommandSourceId_ != deviceCommandSourceId_ )
                {
                    return false;
                }
                if ( dataObject.reply_ != reply_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        Int64 RowVersion( ) const
        {
            return rowVersion_;
        }
        void SetRowVersion( const Int64& rowVersion )
        {
            rowVersion_ = rowVersion;
        }
        const Guid& GNSSDevice( ) const
        {
            return gNSSDevice_;
        }
        void SetGNSSDevice( const Guid& gNSSDevice )
        {
            gNSSDevice_ = gNSSDevice;
        }
        const DateTime& Timestamp( ) const
        {
            return timestamp_;
        }
        void SetTimestamp( const DateTime& timestamp )
        {
            timestamp_ = timestamp;
        }
        Data::DeviceCommandSourceType DeviceCommandSourceType( ) const
        {
            return deviceCommandSourceType_;
        }
        void SetDeviceCommandSourceType( Data::DeviceCommandSourceType deviceCommandSourceType )
        {
            deviceCommandSourceType_ = deviceCommandSourceType;
        }
        const Guid& DeviceCommandSourceId( ) const
        {
            return deviceCommandSourceId_;
        }
        void SetDeviceCommandSourceId( const Guid& deviceCommandSourceId )
        {
            deviceCommandSourceId_ = deviceCommandSourceId;
        }
        const Guid& Reply( ) const
        {
            return reply_;
        }
        void SetReply( const Guid& reply )
        {
            reply_ = reply;
        }
    };
    class GNSSDeviceCommandReplyData : public BaseData<Kind, Guid>
    {
    public:
        using Base = BaseData<Kind, Guid>;
        static constexpr Kind KIND = Kind::GNSSDeviceCommandReply;
    private:
        Int64 rowVersion_ = 0;
        Guid gNSSDevice_;
        DateTime timestamp_;
        Guid command_;
        Data::DeviceCommandReplyStatus status_ = Data::DeviceCommandReplyStatus::Unknown;
        WideString message_;
        SQLLEN messageLength_ = SQL_NULL_DATA;
    public:
        GNSSDeviceCommandReplyData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(rowVersion_);
            destination.Write(gNSSDevice_);
            destination.Write(timestamp_);
            destination.Write(command_);
            destination.Write(status_);
            destination.Write(message_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(rowVersion_);
            source.Read(gNSSDevice_);
            source.Read(timestamp_);
            source.Read(command_);
            source.Read(status_);
            source.Read(message_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<GNSSDeviceCommandReplyData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<GNSSDeviceCommandReplyData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const GNSSDeviceCommandReplyData& >( other );
                if ( dataObject.rowVersion_ != rowVersion_ )
                {
                    return false;
                }
                if ( dataObject.gNSSDevice_ != gNSSDevice_ )
                {
                    return false;
                }
                if ( dataObject.timestamp_ != timestamp_ )
                {
                    return false;
                }
                if ( dataObject.command_ != command_ )
                {
                    return false;
                }
                if ( dataObject.status_ != status_ )
                {
                    return false;
                }
                if ( dataObject.message_ != message_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        Int64 RowVersion( ) const
        {
            return rowVersion_;
        }
        void SetRowVersion( const Int64& rowVersion )
        {
            rowVersion_ = rowVersion;
        }
        const Guid& GNSSDevice( ) const
        {
            return gNSSDevice_;
        }
        void SetGNSSDevice( const Guid& gNSSDevice )
        {
            gNSSDevice_ = gNSSDevice;
        }
        const DateTime& Timestamp( ) const
        {
            return timestamp_;
        }
        void SetTimestamp( const DateTime& timestamp )
        {
            timestamp_ = timestamp;
        }
        const Guid& Command( ) const
        {
            return command_;
        }
        void SetCommand( const Guid& command )
        {
            command_ = command;
        }
        Data::DeviceCommandReplyStatus Status( ) const
        {
            return status_;
        }
        void SetStatus( Data::DeviceCommandReplyStatus status )
        {
            status_ = status;
        }
        const WideString& Message( ) const
        {
            return message_;
        }
        void SetMessage( const WideString& message )
        {
            message_ = message;
        }
    };
    class GNSSDeviceConfigurationData : public BaseData<Kind, Guid>
    {
    public:
        using Base = BaseData<Kind, Guid>;
        static constexpr Kind KIND = Kind::GNSSDeviceConfiguration;
    private:
        Int64 rowVersion_ = 0;
        Guid gNSSDevice_;
        DateTime timestamp_;
        double defaultLatitude_ = 0.0;
        double defaultLongitude_ = 0.0;
        double defaultAltitude_ = 0.0;
        double latitudeOffset_ = 0.0;
        double longitudeOffset_ = 0.0;
        double altitudeOffset_ = 0.0;
    public:
        GNSSDeviceConfigurationData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(rowVersion_);
            destination.Write(gNSSDevice_);
            destination.Write(timestamp_);
            destination.Write(defaultLatitude_);
            destination.Write(defaultLongitude_);
            destination.Write(defaultAltitude_);
            destination.Write(latitudeOffset_);
            destination.Write(longitudeOffset_);
            destination.Write(altitudeOffset_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(rowVersion_);
            source.Read(gNSSDevice_);
            source.Read(timestamp_);
            source.Read(defaultLatitude_);
            source.Read(defaultLongitude_);
            source.Read(defaultAltitude_);
            source.Read(latitudeOffset_);
            source.Read(longitudeOffset_);
            source.Read(altitudeOffset_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<GNSSDeviceConfigurationData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<GNSSDeviceConfigurationData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const GNSSDeviceConfigurationData& >( other );
                if ( dataObject.rowVersion_ != rowVersion_ )
                {
                    return false;
                }
                if ( dataObject.gNSSDevice_ != gNSSDevice_ )
                {
                    return false;
                }
                if ( dataObject.timestamp_ != timestamp_ )
                {
                    return false;
                }
                if ( dataObject.defaultLatitude_ != defaultLatitude_ )
                {
                    return false;
                }
                if ( dataObject.defaultLongitude_ != defaultLongitude_ )
                {
                    return false;
                }
                if ( dataObject.defaultAltitude_ != defaultAltitude_ )
                {
                    return false;
                }
                if ( dataObject.latitudeOffset_ != latitudeOffset_ )
                {
                    return false;
                }
                if ( dataObject.longitudeOffset_ != longitudeOffset_ )
                {
                    return false;
                }
                if ( dataObject.altitudeOffset_ != altitudeOffset_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        Int64 RowVersion( ) const
        {
            return rowVersion_;
        }
        void SetRowVersion( const Int64& rowVersion )
        {
            rowVersion_ = rowVersion;
        }
        const Guid& GNSSDevice( ) const
        {
            return gNSSDevice_;
        }
        void SetGNSSDevice( const Guid& gNSSDevice )
        {
            gNSSDevice_ = gNSSDevice;
        }
        const DateTime& Timestamp( ) const
        {
            return timestamp_;
        }
        void SetTimestamp( const DateTime& timestamp )
        {
            timestamp_ = timestamp;
        }
        double DefaultLatitude( ) const
        {
            return defaultLatitude_;
        }
        void SetDefaultLatitude( double defaultLatitude )
        {
            defaultLatitude_ = defaultLatitude;
        }
        double DefaultLongitude( ) const
        {
            return defaultLongitude_;
        }
        void SetDefaultLongitude( double defaultLongitude )
        {
            defaultLongitude_ = defaultLongitude;
        }
        double DefaultAltitude( ) const
        {
            return defaultAltitude_;
        }
        void SetDefaultAltitude( double defaultAltitude )
        {
            defaultAltitude_ = defaultAltitude;
        }
        double LatitudeOffset( ) const
        {
            return latitudeOffset_;
        }
        void SetLatitudeOffset( double latitudeOffset )
        {
            latitudeOffset_ = latitudeOffset;
        }
        double LongitudeOffset( ) const
        {
            return longitudeOffset_;
        }
        void SetLongitudeOffset( double longitudeOffset )
        {
            longitudeOffset_ = longitudeOffset;
        }
        double AltitudeOffset( ) const
        {
            return altitudeOffset_;
        }
        void SetAltitudeOffset( double altitudeOffset )
        {
            altitudeOffset_ = altitudeOffset;
        }
    };
    class GuidTimeseriesValueData : public BaseData<Kind, Guid>
    {
    public:
        using Base = BaseData<Kind, Guid>;
        static constexpr Kind KIND = Kind::GuidTimeseriesValue;
    private:
        Int64 rowVersion_ = 0;
        Guid timeseries_;
        DateTime timestamp_;
        DBGuid value_;
    public:
        GuidTimeseriesValueData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(rowVersion_);
            destination.Write(timeseries_);
            destination.Write(timestamp_);
            value_.WriteTo( destination );
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(rowVersion_);
            source.Read(timeseries_);
            source.Read(timestamp_);
            value_.ReadFrom( source );
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<GuidTimeseriesValueData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<GuidTimeseriesValueData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const GuidTimeseriesValueData& >( other );
                if ( dataObject.rowVersion_ != rowVersion_ )
                {
                    return false;
                }
                if ( dataObject.timeseries_ != timeseries_ )
                {
                    return false;
                }
                if ( dataObject.timestamp_ != timestamp_ )
                {
                    return false;
                }
                if ( dataObject.value_ != value_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        Int64 RowVersion( ) const
        {
            return rowVersion_;
        }
        void SetRowVersion( const Int64& rowVersion )
        {
            rowVersion_ = rowVersion;
        }
        const Guid& Timeseries( ) const
        {
            return timeseries_;
        }
        void SetTimeseries( const Guid& timeseries )
        {
            timeseries_ = timeseries;
        }
        const DateTime& Timestamp( ) const
        {
            return timestamp_;
        }
        void SetTimestamp( const DateTime& timestamp )
        {
            timestamp_ = timestamp;
        }
        const DBGuid& Value( ) const
        {
            return value_;
        }
        void SetValue( const DBGuid& value )
        {
            value_ = value;
        }
    };
    class GyroDeviceCommandData : public BaseData<Kind, Guid>
    {
    public:
        using Base = BaseData<Kind, Guid>;
        static constexpr Kind KIND = Kind::GyroDeviceCommand;
    private:
        Int64 rowVersion_ = 0;
        Guid gyroDevice_;
        DateTime timestamp_;
        Data::DeviceCommandSourceType deviceCommandSourceType_ = Data::DeviceCommandSourceType::Unknown;
        Guid deviceCommandSourceId_;
        Guid reply_;
    public:
        GyroDeviceCommandData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(rowVersion_);
            destination.Write(gyroDevice_);
            destination.Write(timestamp_);
            destination.Write(deviceCommandSourceType_);
            destination.Write(deviceCommandSourceId_);
            destination.Write(reply_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(rowVersion_);
            source.Read(gyroDevice_);
            source.Read(timestamp_);
            source.Read(deviceCommandSourceType_);
            source.Read(deviceCommandSourceId_);
            source.Read(reply_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<GyroDeviceCommandData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<GyroDeviceCommandData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const GyroDeviceCommandData& >( other );
                if ( dataObject.rowVersion_ != rowVersion_ )
                {
                    return false;
                }
                if ( dataObject.gyroDevice_ != gyroDevice_ )
                {
                    return false;
                }
                if ( dataObject.timestamp_ != timestamp_ )
                {
                    return false;
                }
                if ( dataObject.deviceCommandSourceType_ != deviceCommandSourceType_ )
                {
                    return false;
                }
                if ( dataObject.deviceCommandSourceId_ != deviceCommandSourceId_ )
                {
                    return false;
                }
                if ( dataObject.reply_ != reply_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        Int64 RowVersion( ) const
        {
            return rowVersion_;
        }
        void SetRowVersion( const Int64& rowVersion )
        {
            rowVersion_ = rowVersion;
        }
        const Guid& GyroDevice( ) const
        {
            return gyroDevice_;
        }
        void SetGyroDevice( const Guid& gyroDevice )
        {
            gyroDevice_ = gyroDevice;
        }
        const DateTime& Timestamp( ) const
        {
            return timestamp_;
        }
        void SetTimestamp( const DateTime& timestamp )
        {
            timestamp_ = timestamp;
        }
        Data::DeviceCommandSourceType DeviceCommandSourceType( ) const
        {
            return deviceCommandSourceType_;
        }
        void SetDeviceCommandSourceType( Data::DeviceCommandSourceType deviceCommandSourceType )
        {
            deviceCommandSourceType_ = deviceCommandSourceType;
        }
        const Guid& DeviceCommandSourceId( ) const
        {
            return deviceCommandSourceId_;
        }
        void SetDeviceCommandSourceId( const Guid& deviceCommandSourceId )
        {
            deviceCommandSourceId_ = deviceCommandSourceId;
        }
        const Guid& Reply( ) const
        {
            return reply_;
        }
        void SetReply( const Guid& reply )
        {
            reply_ = reply;
        }
    };
    class GyroDeviceCommandReplyData : public BaseData<Kind, Guid>
    {
    public:
        using Base = BaseData<Kind, Guid>;
        static constexpr Kind KIND = Kind::GyroDeviceCommandReply;
    private:
        Int64 rowVersion_ = 0;
        Guid gyroDevice_;
        DateTime timestamp_;
        Guid command_;
        Data::DeviceCommandReplyStatus status_ = Data::DeviceCommandReplyStatus::Unknown;
        WideString message_;
        SQLLEN messageLength_ = SQL_NULL_DATA;
    public:
        GyroDeviceCommandReplyData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(rowVersion_);
            destination.Write(gyroDevice_);
            destination.Write(timestamp_);
            destination.Write(command_);
            destination.Write(status_);
            destination.Write(message_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(rowVersion_);
            source.Read(gyroDevice_);
            source.Read(timestamp_);
            source.Read(command_);
            source.Read(status_);
            source.Read(message_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<GyroDeviceCommandReplyData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<GyroDeviceCommandReplyData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const GyroDeviceCommandReplyData& >( other );
                if ( dataObject.rowVersion_ != rowVersion_ )
                {
                    return false;
                }
                if ( dataObject.gyroDevice_ != gyroDevice_ )
                {
                    return false;
                }
                if ( dataObject.timestamp_ != timestamp_ )
                {
                    return false;
                }
                if ( dataObject.command_ != command_ )
                {
                    return false;
                }
                if ( dataObject.status_ != status_ )
                {
                    return false;
                }
                if ( dataObject.message_ != message_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        Int64 RowVersion( ) const
        {
            return rowVersion_;
        }
        void SetRowVersion( const Int64& rowVersion )
        {
            rowVersion_ = rowVersion;
        }
        const Guid& GyroDevice( ) const
        {
            return gyroDevice_;
        }
        void SetGyroDevice( const Guid& gyroDevice )
        {
            gyroDevice_ = gyroDevice;
        }
        const DateTime& Timestamp( ) const
        {
            return timestamp_;
        }
        void SetTimestamp( const DateTime& timestamp )
        {
            timestamp_ = timestamp;
        }
        const Guid& Command( ) const
        {
            return command_;
        }
        void SetCommand( const Guid& command )
        {
            command_ = command;
        }
        Data::DeviceCommandReplyStatus Status( ) const
        {
            return status_;
        }
        void SetStatus( Data::DeviceCommandReplyStatus status )
        {
            status_ = status;
        }
        const WideString& Message( ) const
        {
            return message_;
        }
        void SetMessage( const WideString& message )
        {
            message_ = message;
        }
    };
    class GyroDeviceConfigurationData : public BaseData<Kind, Guid>
    {
    public:
        using Base = BaseData<Kind, Guid>;
        static constexpr Kind KIND = Kind::GyroDeviceConfiguration;
    private:
        Int64 rowVersion_ = 0;
        Guid gyroDevice_;
        DateTime timestamp_;
        double defaultHeadingTrueNorth_ = 0.0;
        double defaultMagneticTrueNorth_ = 0.0;
        double headingTrueNorthOffset_ = 0.0;
        double headingMagneticNorthOffset_ = 0.0;
        FixedDBWideString<64> pitchTransducerName_;
        FixedDBWideString<64> rollTransducerName_;
    public:
        GyroDeviceConfigurationData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(rowVersion_);
            destination.Write(gyroDevice_);
            destination.Write(timestamp_);
            destination.Write(defaultHeadingTrueNorth_);
            destination.Write(defaultMagneticTrueNorth_);
            destination.Write(headingTrueNorthOffset_);
            destination.Write(headingMagneticNorthOffset_);
            pitchTransducerName_.WriteTo( destination );
            rollTransducerName_.WriteTo( destination );
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(rowVersion_);
            source.Read(gyroDevice_);
            source.Read(timestamp_);
            source.Read(defaultHeadingTrueNorth_);
            source.Read(defaultMagneticTrueNorth_);
            source.Read(headingTrueNorthOffset_);
            source.Read(headingMagneticNorthOffset_);
            pitchTransducerName_.ReadFrom( source );
            rollTransducerName_.ReadFrom( source );
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<GyroDeviceConfigurationData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<GyroDeviceConfigurationData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const GyroDeviceConfigurationData& >( other );
                if ( dataObject.rowVersion_ != rowVersion_ )
                {
                    return false;
                }
                if ( dataObject.gyroDevice_ != gyroDevice_ )
                {
                    return false;
                }
                if ( dataObject.timestamp_ != timestamp_ )
                {
                    return false;
                }
                if ( dataObject.defaultHeadingTrueNorth_ != defaultHeadingTrueNorth_ )
                {
                    return false;
                }
                if ( dataObject.defaultMagneticTrueNorth_ != defaultMagneticTrueNorth_ )
                {
                    return false;
                }
                if ( dataObject.headingTrueNorthOffset_ != headingTrueNorthOffset_ )
                {
                    return false;
                }
                if ( dataObject.headingMagneticNorthOffset_ != headingMagneticNorthOffset_ )
                {
                    return false;
                }
                if ( dataObject.pitchTransducerName_ != pitchTransducerName_ )
                {
                    return false;
                }
                if ( dataObject.rollTransducerName_ != rollTransducerName_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        Int64 RowVersion( ) const
        {
            return rowVersion_;
        }
        void SetRowVersion( const Int64& rowVersion )
        {
            rowVersion_ = rowVersion;
        }
        const Guid& GyroDevice( ) const
        {
            return gyroDevice_;
        }
        void SetGyroDevice( const Guid& gyroDevice )
        {
            gyroDevice_ = gyroDevice;
        }
        const DateTime& Timestamp( ) const
        {
            return timestamp_;
        }
        void SetTimestamp( const DateTime& timestamp )
        {
            timestamp_ = timestamp;
        }
        double DefaultHeadingTrueNorth( ) const
        {
            return defaultHeadingTrueNorth_;
        }
        void SetDefaultHeadingTrueNorth( double defaultHeadingTrueNorth )
        {
            defaultHeadingTrueNorth_ = defaultHeadingTrueNorth;
        }
        double DefaultMagneticTrueNorth( ) const
        {
            return defaultMagneticTrueNorth_;
        }
        void SetDefaultMagneticTrueNorth( double defaultMagneticTrueNorth )
        {
            defaultMagneticTrueNorth_ = defaultMagneticTrueNorth;
        }
        double HeadingTrueNorthOffset( ) const
        {
            return headingTrueNorthOffset_;
        }
        void SetHeadingTrueNorthOffset( double headingTrueNorthOffset )
        {
            headingTrueNorthOffset_ = headingTrueNorthOffset;
        }
        double HeadingMagneticNorthOffset( ) const
        {
            return headingMagneticNorthOffset_;
        }
        void SetHeadingMagneticNorthOffset( double headingMagneticNorthOffset )
        {
            headingMagneticNorthOffset_ = headingMagneticNorthOffset;
        }
        const FixedDBWideString<64>& PitchTransducerName( ) const
        {
            return pitchTransducerName_;
        }
        void SetPitchTransducerName( const WideString& pitchTransducerName )
        {
            pitchTransducerName_ = pitchTransducerName;
        }
        const FixedDBWideString<64>& RollTransducerName( ) const
        {
            return rollTransducerName_;
        }
        void SetRollTransducerName( const WideString& rollTransducerName )
        {
            rollTransducerName_ = rollTransducerName;
        }
    };
    class IdentityData : public BaseData<Kind, Guid>
    {
    public:
        using Base = BaseData<Kind, Guid>;
        static constexpr Kind KIND = Kind::Identity;
    private:
        Int64 rowVersion_ = 0;
    public:
        IdentityData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(rowVersion_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(rowVersion_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<IdentityData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<IdentityData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const IdentityData& >( other );
                if ( dataObject.rowVersion_ != rowVersion_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        Int64 RowVersion( ) const
        {
            return rowVersion_;
        }
        void SetRowVersion( const Int64& rowVersion )
        {
            rowVersion_ = rowVersion;
        }
    };
    class CallsignData : public IdentityData
    {
    public:
        using Base = IdentityData;
        static constexpr Kind KIND = Kind::Callsign;
    private:
        FixedDBWideString<127> identifier_;
    public:
        CallsignData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            identifier_.WriteTo( destination );
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            identifier_.ReadFrom( source );
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<CallsignData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<CallsignData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const CallsignData& >( other );
                if ( dataObject.identifier_ != identifier_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        const FixedDBWideString<127>& Identifier( ) const
        {
            return identifier_;
        }
        void SetIdentifier( const WideString& identifier )
        {
            identifier_ = identifier;
        }
    };
    class InternationalMaritimeOrganizationNumberData : public IdentityData
    {
    public:
        using Base = IdentityData;
        static constexpr Kind KIND = Kind::InternationalMaritimeOrganizationNumber;
    private:
        Int64 identifier_ = 0;
    public:
        InternationalMaritimeOrganizationNumberData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(identifier_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(identifier_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<InternationalMaritimeOrganizationNumberData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<InternationalMaritimeOrganizationNumberData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const InternationalMaritimeOrganizationNumberData& >( other );
                if ( dataObject.identifier_ != identifier_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        Int64 Identifier( ) const
        {
            return identifier_;
        }
        void SetIdentifier( Int64 identifier )
        {
            identifier_ = identifier;
        }
    };
    class MaritimeMobileServiceIdentityData : public IdentityData
    {
    public:
        using Base = IdentityData;
        static constexpr Kind KIND = Kind::MaritimeMobileServiceIdentity;
    private:
        Int64 identifier_ = 0;
    public:
        MaritimeMobileServiceIdentityData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(identifier_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(identifier_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<MaritimeMobileServiceIdentityData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<MaritimeMobileServiceIdentityData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const MaritimeMobileServiceIdentityData& >( other );
                if ( dataObject.identifier_ != identifier_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        Int64 Identifier( ) const
        {
            return identifier_;
        }
        void SetIdentifier( Int64 identifier )
        {
            identifier_ = identifier;
        }
    };
    class NameData : public IdentityData
    {
    public:
        using Base = IdentityData;
        static constexpr Kind KIND = Kind::Name;
    private:
        FixedDBWideString<100> text_;
    public:
        NameData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            text_.WriteTo( destination );
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            text_.ReadFrom( source );
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<NameData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<NameData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const NameData& >( other );
                if ( dataObject.text_ != text_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        const FixedDBWideString<100>& Text( ) const
        {
            return text_;
        }
        void SetText( const WideString& text )
        {
            text_ = text;
        }
    };
    class Int16TimeseriesValueData : public BaseData<Kind, Guid>
    {
    public:
        using Base = BaseData<Kind, Guid>;
        static constexpr Kind KIND = Kind::Int16TimeseriesValue;
    private:
        Int64 rowVersion_ = 0;
        Guid timeseries_;
        DateTime timestamp_;
        DBInt16 value_;
    public:
        Int16TimeseriesValueData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(rowVersion_);
            destination.Write(timeseries_);
            destination.Write(timestamp_);
            value_.WriteTo( destination );
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(rowVersion_);
            source.Read(timeseries_);
            source.Read(timestamp_);
            value_.ReadFrom( source );
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<Int16TimeseriesValueData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<Int16TimeseriesValueData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const Int16TimeseriesValueData& >( other );
                if ( dataObject.rowVersion_ != rowVersion_ )
                {
                    return false;
                }
                if ( dataObject.timeseries_ != timeseries_ )
                {
                    return false;
                }
                if ( dataObject.timestamp_ != timestamp_ )
                {
                    return false;
                }
                if ( dataObject.value_ != value_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        Int64 RowVersion( ) const
        {
            return rowVersion_;
        }
        void SetRowVersion( const Int64& rowVersion )
        {
            rowVersion_ = rowVersion;
        }
        const Guid& Timeseries( ) const
        {
            return timeseries_;
        }
        void SetTimeseries( const Guid& timeseries )
        {
            timeseries_ = timeseries;
        }
        const DateTime& Timestamp( ) const
        {
            return timestamp_;
        }
        void SetTimestamp( const DateTime& timestamp )
        {
            timestamp_ = timestamp;
        }
        const DBInt16& Value( ) const
        {
            return value_;
        }
        void SetValue( const DBInt16& value )
        {
            value_ = value;
        }
    };
    class Int32TimeseriesValueData : public BaseData<Kind, Guid>
    {
    public:
        using Base = BaseData<Kind, Guid>;
        static constexpr Kind KIND = Kind::Int32TimeseriesValue;
    private:
        Int64 rowVersion_ = 0;
        Guid timeseries_;
        DateTime timestamp_;
        DBInt32 value_;
    public:
        Int32TimeseriesValueData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(rowVersion_);
            destination.Write(timeseries_);
            destination.Write(timestamp_);
            value_.WriteTo( destination );
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(rowVersion_);
            source.Read(timeseries_);
            source.Read(timestamp_);
            value_.ReadFrom( source );
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<Int32TimeseriesValueData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<Int32TimeseriesValueData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const Int32TimeseriesValueData& >( other );
                if ( dataObject.rowVersion_ != rowVersion_ )
                {
                    return false;
                }
                if ( dataObject.timeseries_ != timeseries_ )
                {
                    return false;
                }
                if ( dataObject.timestamp_ != timestamp_ )
                {
                    return false;
                }
                if ( dataObject.value_ != value_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        Int64 RowVersion( ) const
        {
            return rowVersion_;
        }
        void SetRowVersion( const Int64& rowVersion )
        {
            rowVersion_ = rowVersion;
        }
        const Guid& Timeseries( ) const
        {
            return timeseries_;
        }
        void SetTimeseries( const Guid& timeseries )
        {
            timeseries_ = timeseries;
        }
        const DateTime& Timestamp( ) const
        {
            return timestamp_;
        }
        void SetTimestamp( const DateTime& timestamp )
        {
            timestamp_ = timestamp;
        }
        const DBInt32& Value( ) const
        {
            return value_;
        }
        void SetValue( const DBInt32& value )
        {
            value_ = value;
        }
    };
    class Int64TimeseriesValueData : public BaseData<Kind, Guid>
    {
    public:
        using Base = BaseData<Kind, Guid>;
        static constexpr Kind KIND = Kind::Int64TimeseriesValue;
    private:
        Int64 rowVersion_ = 0;
        Guid timeseries_;
        DateTime timestamp_;
        DBInt64 value_;
    public:
        Int64TimeseriesValueData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(rowVersion_);
            destination.Write(timeseries_);
            destination.Write(timestamp_);
            value_.WriteTo( destination );
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(rowVersion_);
            source.Read(timeseries_);
            source.Read(timestamp_);
            value_.ReadFrom( source );
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<Int64TimeseriesValueData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<Int64TimeseriesValueData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const Int64TimeseriesValueData& >( other );
                if ( dataObject.rowVersion_ != rowVersion_ )
                {
                    return false;
                }
                if ( dataObject.timeseries_ != timeseries_ )
                {
                    return false;
                }
                if ( dataObject.timestamp_ != timestamp_ )
                {
                    return false;
                }
                if ( dataObject.value_ != value_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        Int64 RowVersion( ) const
        {
            return rowVersion_;
        }
        void SetRowVersion( const Int64& rowVersion )
        {
            rowVersion_ = rowVersion;
        }
        const Guid& Timeseries( ) const
        {
            return timeseries_;
        }
        void SetTimeseries( const Guid& timeseries )
        {
            timeseries_ = timeseries;
        }
        const DateTime& Timestamp( ) const
        {
            return timestamp_;
        }
        void SetTimestamp( const DateTime& timestamp )
        {
            timestamp_ = timestamp;
        }
        const DBInt64& Value( ) const
        {
            return value_;
        }
        void SetValue( const DBInt64& value )
        {
            value_ = value;
        }
    };
    class ItemData : public BaseData<Kind, Guid>
    {
    public:
        using Base = BaseData<Kind, Guid>;
        static constexpr Kind KIND = Kind::Item;
    private:
        Int64 rowVersion_ = 0;
    public:
        ItemData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(rowVersion_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(rowVersion_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<ItemData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<ItemData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const ItemData& >( other );
                if ( dataObject.rowVersion_ != rowVersion_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        Int64 RowVersion( ) const
        {
            return rowVersion_;
        }
        void SetRowVersion( const Int64& rowVersion )
        {
            rowVersion_ = rowVersion;
        }
    };
    class BaseStationData : public ItemData
    {
    public:
        using Base = ItemData;
        static constexpr Kind KIND = Kind::BaseStation;
    private:
        FixedDBWideString<127> name_;
        Guid type_;
    public:
        BaseStationData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            name_.WriteTo( destination );
            destination.Write(type_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            name_.ReadFrom( source );
            source.Read(type_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<BaseStationData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<BaseStationData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const BaseStationData& >( other );
                if ( dataObject.name_ != name_ )
                {
                    return false;
                }
                if ( dataObject.type_ != type_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        const FixedDBWideString<127>& Name( ) const
        {
            return name_;
        }
        void SetName( const WideString& name )
        {
            name_ = name;
        }
        const Guid& Type( ) const
        {
            return type_;
        }
        void SetType( const Guid& type )
        {
            type_ = type;
        }
    };
    class DeviceData : public ItemData
    {
    public:
        using Base = ItemData;
        static constexpr Kind KIND = Kind::Device;
    private:
        Guid host_;
        FixedDBWideString<127> name_;
        WideString description_;
        SQLLEN descriptionLength_ = SQL_NULL_DATA;
        Guid enabledTimeseries_;
    public:
        DeviceData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(host_);
            name_.WriteTo( destination );
            destination.Write(description_);
            destination.Write(enabledTimeseries_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(host_);
            name_.ReadFrom( source );
            source.Read(description_);
            source.Read(enabledTimeseries_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<DeviceData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<DeviceData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const DeviceData& >( other );
                if ( dataObject.host_ != host_ )
                {
                    return false;
                }
                if ( dataObject.name_ != name_ )
                {
                    return false;
                }
                if ( dataObject.description_ != description_ )
                {
                    return false;
                }
                if ( dataObject.enabledTimeseries_ != enabledTimeseries_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        const Guid& Host( ) const
        {
            return host_;
        }
        void SetHost( const Guid& host )
        {
            host_ = host;
        }
        const FixedDBWideString<127>& Name( ) const
        {
            return name_;
        }
        void SetName( const WideString& name )
        {
            name_ = name;
        }
        const WideString& Description( ) const
        {
            return description_;
        }
        void SetDescription( const WideString& description )
        {
            description_ = description;
        }
        const Guid& EnabledTimeseries( ) const
        {
            return enabledTimeseries_;
        }
        void SetEnabledTimeseries( const Guid& enabledTimeseries )
        {
            enabledTimeseries_ = enabledTimeseries;
        }
    };
    class CameraData : public DeviceData
    {
    public:
        using Base = DeviceData;
        static constexpr Kind KIND = Kind::Camera;
    private:
    public:
        CameraData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<CameraData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<CameraData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const CameraData& >( other );
                return true;
            }
            return false;
        }
    };
    class GNSSDeviceData : public DeviceData
    {
    public:
        using Base = DeviceData;
        static constexpr Kind KIND = Kind::GNSSDevice;
    private:
        Guid latitudeTimeseries_;
        Guid longitudeTimeseries_;
        Guid altitudeTimeseries_;
    public:
        GNSSDeviceData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(latitudeTimeseries_);
            destination.Write(longitudeTimeseries_);
            destination.Write(altitudeTimeseries_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(latitudeTimeseries_);
            source.Read(longitudeTimeseries_);
            source.Read(altitudeTimeseries_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<GNSSDeviceData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<GNSSDeviceData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const GNSSDeviceData& >( other );
                if ( dataObject.latitudeTimeseries_ != latitudeTimeseries_ )
                {
                    return false;
                }
                if ( dataObject.longitudeTimeseries_ != longitudeTimeseries_ )
                {
                    return false;
                }
                if ( dataObject.altitudeTimeseries_ != altitudeTimeseries_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        const Guid& LatitudeTimeseries( ) const
        {
            return latitudeTimeseries_;
        }
        void SetLatitudeTimeseries( const Guid& latitudeTimeseries )
        {
            latitudeTimeseries_ = latitudeTimeseries;
        }
        const Guid& LongitudeTimeseries( ) const
        {
            return longitudeTimeseries_;
        }
        void SetLongitudeTimeseries( const Guid& longitudeTimeseries )
        {
            longitudeTimeseries_ = longitudeTimeseries;
        }
        const Guid& AltitudeTimeseries( ) const
        {
            return altitudeTimeseries_;
        }
        void SetAltitudeTimeseries( const Guid& altitudeTimeseries )
        {
            altitudeTimeseries_ = altitudeTimeseries;
        }
    };
    class GyroDeviceData : public DeviceData
    {
    public:
        using Base = DeviceData;
        static constexpr Kind KIND = Kind::GyroDevice;
    private:
        Guid headingTrueNorthTimeseries_;
        Guid headingMagneticNorthTimeseries_;
        Guid pitchTimeseries_;
        Guid rateOfTurnTimeseries_;
        Guid rollTimeseries_;
        Guid courseTimeseries_;
        Guid speedTimeseries_;
        Guid gNSSDevice_;
    public:
        GyroDeviceData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(headingTrueNorthTimeseries_);
            destination.Write(headingMagneticNorthTimeseries_);
            destination.Write(pitchTimeseries_);
            destination.Write(rateOfTurnTimeseries_);
            destination.Write(rollTimeseries_);
            destination.Write(courseTimeseries_);
            destination.Write(speedTimeseries_);
            destination.Write(gNSSDevice_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(headingTrueNorthTimeseries_);
            source.Read(headingMagneticNorthTimeseries_);
            source.Read(pitchTimeseries_);
            source.Read(rateOfTurnTimeseries_);
            source.Read(rollTimeseries_);
            source.Read(courseTimeseries_);
            source.Read(speedTimeseries_);
            source.Read(gNSSDevice_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<GyroDeviceData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<GyroDeviceData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const GyroDeviceData& >( other );
                if ( dataObject.headingTrueNorthTimeseries_ != headingTrueNorthTimeseries_ )
                {
                    return false;
                }
                if ( dataObject.headingMagneticNorthTimeseries_ != headingMagneticNorthTimeseries_ )
                {
                    return false;
                }
                if ( dataObject.pitchTimeseries_ != pitchTimeseries_ )
                {
                    return false;
                }
                if ( dataObject.rateOfTurnTimeseries_ != rateOfTurnTimeseries_ )
                {
                    return false;
                }
                if ( dataObject.rollTimeseries_ != rollTimeseries_ )
                {
                    return false;
                }
                if ( dataObject.courseTimeseries_ != courseTimeseries_ )
                {
                    return false;
                }
                if ( dataObject.speedTimeseries_ != speedTimeseries_ )
                {
                    return false;
                }
                if ( dataObject.gNSSDevice_ != gNSSDevice_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        const Guid& HeadingTrueNorthTimeseries( ) const
        {
            return headingTrueNorthTimeseries_;
        }
        void SetHeadingTrueNorthTimeseries( const Guid& headingTrueNorthTimeseries )
        {
            headingTrueNorthTimeseries_ = headingTrueNorthTimeseries;
        }
        const Guid& HeadingMagneticNorthTimeseries( ) const
        {
            return headingMagneticNorthTimeseries_;
        }
        void SetHeadingMagneticNorthTimeseries( const Guid& headingMagneticNorthTimeseries )
        {
            headingMagneticNorthTimeseries_ = headingMagneticNorthTimeseries;
        }
        const Guid& PitchTimeseries( ) const
        {
            return pitchTimeseries_;
        }
        void SetPitchTimeseries( const Guid& pitchTimeseries )
        {
            pitchTimeseries_ = pitchTimeseries;
        }
        const Guid& RateOfTurnTimeseries( ) const
        {
            return rateOfTurnTimeseries_;
        }
        void SetRateOfTurnTimeseries( const Guid& rateOfTurnTimeseries )
        {
            rateOfTurnTimeseries_ = rateOfTurnTimeseries;
        }
        const Guid& RollTimeseries( ) const
        {
            return rollTimeseries_;
        }
        void SetRollTimeseries( const Guid& rollTimeseries )
        {
            rollTimeseries_ = rollTimeseries;
        }
        const Guid& CourseTimeseries( ) const
        {
            return courseTimeseries_;
        }
        void SetCourseTimeseries( const Guid& courseTimeseries )
        {
            courseTimeseries_ = courseTimeseries;
        }
        const Guid& SpeedTimeseries( ) const
        {
            return speedTimeseries_;
        }
        void SetSpeedTimeseries( const Guid& speedTimeseries )
        {
            speedTimeseries_ = speedTimeseries;
        }
        const Guid& GNSSDevice( ) const
        {
            return gNSSDevice_;
        }
        void SetGNSSDevice( const Guid& gNSSDevice )
        {
            gNSSDevice_ = gNSSDevice;
        }
    };
    class LineInputDeviceData : public DeviceData
    {
    public:
        using Base = DeviceData;
        static constexpr Kind KIND = Kind::LineInputDevice;
    private:
    public:
        LineInputDeviceData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<LineInputDeviceData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<LineInputDeviceData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const LineInputDeviceData& >( other );
                return true;
            }
            return false;
        }
    };
    class OilspillDetectorData : public DeviceData
    {
    public:
        using Base = DeviceData;
        static constexpr Kind KIND = Kind::OilspillDetector;
    private:
    public:
        OilspillDetectorData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<OilspillDetectorData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<OilspillDetectorData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const OilspillDetectorData& >( other );
                return true;
            }
            return false;
        }
    };
    class RadioData : public DeviceData
    {
    public:
        using Base = DeviceData;
        static constexpr Kind KIND = Kind::Radio;
    private:
    public:
        RadioData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<RadioData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<RadioData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const RadioData& >( other );
                return true;
            }
            return false;
        }
    };
    class RadomeData : public DeviceData
    {
    public:
        using Base = DeviceData;
        static constexpr Kind KIND = Kind::Radome;
    private:
        Guid radar_;
        Guid pressureTimeseries_;
        Guid temperatureTimeseries_;
        Guid dewPointTimeseries_;
        Guid statusTimeseries_;
    public:
        RadomeData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(radar_);
            destination.Write(pressureTimeseries_);
            destination.Write(temperatureTimeseries_);
            destination.Write(dewPointTimeseries_);
            destination.Write(statusTimeseries_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(radar_);
            source.Read(pressureTimeseries_);
            source.Read(temperatureTimeseries_);
            source.Read(dewPointTimeseries_);
            source.Read(statusTimeseries_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<RadomeData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<RadomeData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const RadomeData& >( other );
                if ( dataObject.radar_ != radar_ )
                {
                    return false;
                }
                if ( dataObject.pressureTimeseries_ != pressureTimeseries_ )
                {
                    return false;
                }
                if ( dataObject.temperatureTimeseries_ != temperatureTimeseries_ )
                {
                    return false;
                }
                if ( dataObject.dewPointTimeseries_ != dewPointTimeseries_ )
                {
                    return false;
                }
                if ( dataObject.statusTimeseries_ != statusTimeseries_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        const Guid& Radar( ) const
        {
            return radar_;
        }
        void SetRadar( const Guid& radar )
        {
            radar_ = radar;
        }
        const Guid& PressureTimeseries( ) const
        {
            return pressureTimeseries_;
        }
        void SetPressureTimeseries( const Guid& pressureTimeseries )
        {
            pressureTimeseries_ = pressureTimeseries;
        }
        const Guid& TemperatureTimeseries( ) const
        {
            return temperatureTimeseries_;
        }
        void SetTemperatureTimeseries( const Guid& temperatureTimeseries )
        {
            temperatureTimeseries_ = temperatureTimeseries;
        }
        const Guid& DewPointTimeseries( ) const
        {
            return dewPointTimeseries_;
        }
        void SetDewPointTimeseries( const Guid& dewPointTimeseries )
        {
            dewPointTimeseries_ = dewPointTimeseries;
        }
        const Guid& StatusTimeseries( ) const
        {
            return statusTimeseries_;
        }
        void SetStatusTimeseries( const Guid& statusTimeseries )
        {
            statusTimeseries_ = statusTimeseries;
        }
    };
    class TrackerData : public DeviceData
    {
    public:
        using Base = DeviceData;
        static constexpr Kind KIND = Kind::Tracker;
    private:
    public:
        TrackerData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<TrackerData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<TrackerData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const TrackerData& >( other );
                return true;
            }
            return false;
        }
    };
    class AisTransceiverData : public TrackerData
    {
    public:
        using Base = TrackerData;
        static constexpr Kind KIND = Kind::AisTransceiver;
    private:
    public:
        AisTransceiverData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<AisTransceiverData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<AisTransceiverData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const AisTransceiverData& >( other );
                return true;
            }
            return false;
        }
    };
    class RadarData : public TrackerData
    {
    public:
        using Base = TrackerData;
        static constexpr Kind KIND = Kind::Radar;
    private:
        Guid saveSettingsTimeseries_;
        Guid powerOnTimeseries_;
        Guid trackingOnTimeseries_;
        Guid radarPulseTimeseries_;
        Guid tuningTimeseries_;
        Guid blankSector1Timeseries_;
        Guid sector1StartTimeseries_;
        Guid sector1EndTimeseries_;
        Guid blankSector2Timeseries_;
        Guid sector2StartTimeseries_;
        Guid sector2EndTimeseries_;
        Guid enableAutomaticFrequencyControlTimeseries_;
        Guid azimuthOffsetTimeseries_;
        Guid enableSensitivityTimeControlTimeseries_;
        Guid automaticSensitivityTimeControlTimeseries_;
        Guid sensitivityTimeControlLevelTimeseries_;
        Guid enableFastTimeConstantTimeseries_;
        Guid fastTimeConstantLevelTimeseries_;
        Guid fastTimeConstantModeTimeseries_;
        Guid latitudeTimeseries_;
        Guid longitudeTimeseries_;
        Guid radome_;
        Guid gNSSDevice_;
    public:
        RadarData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(saveSettingsTimeseries_);
            destination.Write(powerOnTimeseries_);
            destination.Write(trackingOnTimeseries_);
            destination.Write(radarPulseTimeseries_);
            destination.Write(tuningTimeseries_);
            destination.Write(blankSector1Timeseries_);
            destination.Write(sector1StartTimeseries_);
            destination.Write(sector1EndTimeseries_);
            destination.Write(blankSector2Timeseries_);
            destination.Write(sector2StartTimeseries_);
            destination.Write(sector2EndTimeseries_);
            destination.Write(enableAutomaticFrequencyControlTimeseries_);
            destination.Write(azimuthOffsetTimeseries_);
            destination.Write(enableSensitivityTimeControlTimeseries_);
            destination.Write(automaticSensitivityTimeControlTimeseries_);
            destination.Write(sensitivityTimeControlLevelTimeseries_);
            destination.Write(enableFastTimeConstantTimeseries_);
            destination.Write(fastTimeConstantLevelTimeseries_);
            destination.Write(fastTimeConstantModeTimeseries_);
            destination.Write(latitudeTimeseries_);
            destination.Write(longitudeTimeseries_);
            destination.Write(radome_);
            destination.Write(gNSSDevice_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(saveSettingsTimeseries_);
            source.Read(powerOnTimeseries_);
            source.Read(trackingOnTimeseries_);
            source.Read(radarPulseTimeseries_);
            source.Read(tuningTimeseries_);
            source.Read(blankSector1Timeseries_);
            source.Read(sector1StartTimeseries_);
            source.Read(sector1EndTimeseries_);
            source.Read(blankSector2Timeseries_);
            source.Read(sector2StartTimeseries_);
            source.Read(sector2EndTimeseries_);
            source.Read(enableAutomaticFrequencyControlTimeseries_);
            source.Read(azimuthOffsetTimeseries_);
            source.Read(enableSensitivityTimeControlTimeseries_);
            source.Read(automaticSensitivityTimeControlTimeseries_);
            source.Read(sensitivityTimeControlLevelTimeseries_);
            source.Read(enableFastTimeConstantTimeseries_);
            source.Read(fastTimeConstantLevelTimeseries_);
            source.Read(fastTimeConstantModeTimeseries_);
            source.Read(latitudeTimeseries_);
            source.Read(longitudeTimeseries_);
            source.Read(radome_);
            source.Read(gNSSDevice_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<RadarData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<RadarData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const RadarData& >( other );
                if ( dataObject.saveSettingsTimeseries_ != saveSettingsTimeseries_ )
                {
                    return false;
                }
                if ( dataObject.powerOnTimeseries_ != powerOnTimeseries_ )
                {
                    return false;
                }
                if ( dataObject.trackingOnTimeseries_ != trackingOnTimeseries_ )
                {
                    return false;
                }
                if ( dataObject.radarPulseTimeseries_ != radarPulseTimeseries_ )
                {
                    return false;
                }
                if ( dataObject.tuningTimeseries_ != tuningTimeseries_ )
                {
                    return false;
                }
                if ( dataObject.blankSector1Timeseries_ != blankSector1Timeseries_ )
                {
                    return false;
                }
                if ( dataObject.sector1StartTimeseries_ != sector1StartTimeseries_ )
                {
                    return false;
                }
                if ( dataObject.sector1EndTimeseries_ != sector1EndTimeseries_ )
                {
                    return false;
                }
                if ( dataObject.blankSector2Timeseries_ != blankSector2Timeseries_ )
                {
                    return false;
                }
                if ( dataObject.sector2StartTimeseries_ != sector2StartTimeseries_ )
                {
                    return false;
                }
                if ( dataObject.sector2EndTimeseries_ != sector2EndTimeseries_ )
                {
                    return false;
                }
                if ( dataObject.enableAutomaticFrequencyControlTimeseries_ != enableAutomaticFrequencyControlTimeseries_ )
                {
                    return false;
                }
                if ( dataObject.azimuthOffsetTimeseries_ != azimuthOffsetTimeseries_ )
                {
                    return false;
                }
                if ( dataObject.enableSensitivityTimeControlTimeseries_ != enableSensitivityTimeControlTimeseries_ )
                {
                    return false;
                }
                if ( dataObject.automaticSensitivityTimeControlTimeseries_ != automaticSensitivityTimeControlTimeseries_ )
                {
                    return false;
                }
                if ( dataObject.sensitivityTimeControlLevelTimeseries_ != sensitivityTimeControlLevelTimeseries_ )
                {
                    return false;
                }
                if ( dataObject.enableFastTimeConstantTimeseries_ != enableFastTimeConstantTimeseries_ )
                {
                    return false;
                }
                if ( dataObject.fastTimeConstantLevelTimeseries_ != fastTimeConstantLevelTimeseries_ )
                {
                    return false;
                }
                if ( dataObject.fastTimeConstantModeTimeseries_ != fastTimeConstantModeTimeseries_ )
                {
                    return false;
                }
                if ( dataObject.latitudeTimeseries_ != latitudeTimeseries_ )
                {
                    return false;
                }
                if ( dataObject.longitudeTimeseries_ != longitudeTimeseries_ )
                {
                    return false;
                }
                if ( dataObject.radome_ != radome_ )
                {
                    return false;
                }
                if ( dataObject.gNSSDevice_ != gNSSDevice_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        const Guid& SaveSettingsTimeseries( ) const
        {
            return saveSettingsTimeseries_;
        }
        void SetSaveSettingsTimeseries( const Guid& saveSettingsTimeseries )
        {
            saveSettingsTimeseries_ = saveSettingsTimeseries;
        }
        const Guid& PowerOnTimeseries( ) const
        {
            return powerOnTimeseries_;
        }
        void SetPowerOnTimeseries( const Guid& powerOnTimeseries )
        {
            powerOnTimeseries_ = powerOnTimeseries;
        }
        const Guid& TrackingOnTimeseries( ) const
        {
            return trackingOnTimeseries_;
        }
        void SetTrackingOnTimeseries( const Guid& trackingOnTimeseries )
        {
            trackingOnTimeseries_ = trackingOnTimeseries;
        }
        const Guid& RadarPulseTimeseries( ) const
        {
            return radarPulseTimeseries_;
        }
        void SetRadarPulseTimeseries( const Guid& radarPulseTimeseries )
        {
            radarPulseTimeseries_ = radarPulseTimeseries;
        }
        const Guid& TuningTimeseries( ) const
        {
            return tuningTimeseries_;
        }
        void SetTuningTimeseries( const Guid& tuningTimeseries )
        {
            tuningTimeseries_ = tuningTimeseries;
        }
        const Guid& BlankSector1Timeseries( ) const
        {
            return blankSector1Timeseries_;
        }
        void SetBlankSector1Timeseries( const Guid& blankSector1Timeseries )
        {
            blankSector1Timeseries_ = blankSector1Timeseries;
        }
        const Guid& Sector1StartTimeseries( ) const
        {
            return sector1StartTimeseries_;
        }
        void SetSector1StartTimeseries( const Guid& sector1StartTimeseries )
        {
            sector1StartTimeseries_ = sector1StartTimeseries;
        }
        const Guid& Sector1EndTimeseries( ) const
        {
            return sector1EndTimeseries_;
        }
        void SetSector1EndTimeseries( const Guid& sector1EndTimeseries )
        {
            sector1EndTimeseries_ = sector1EndTimeseries;
        }
        const Guid& BlankSector2Timeseries( ) const
        {
            return blankSector2Timeseries_;
        }
        void SetBlankSector2Timeseries( const Guid& blankSector2Timeseries )
        {
            blankSector2Timeseries_ = blankSector2Timeseries;
        }
        const Guid& Sector2StartTimeseries( ) const
        {
            return sector2StartTimeseries_;
        }
        void SetSector2StartTimeseries( const Guid& sector2StartTimeseries )
        {
            sector2StartTimeseries_ = sector2StartTimeseries;
        }
        const Guid& Sector2EndTimeseries( ) const
        {
            return sector2EndTimeseries_;
        }
        void SetSector2EndTimeseries( const Guid& sector2EndTimeseries )
        {
            sector2EndTimeseries_ = sector2EndTimeseries;
        }
        const Guid& EnableAutomaticFrequencyControlTimeseries( ) const
        {
            return enableAutomaticFrequencyControlTimeseries_;
        }
        void SetEnableAutomaticFrequencyControlTimeseries( const Guid& enableAutomaticFrequencyControlTimeseries )
        {
            enableAutomaticFrequencyControlTimeseries_ = enableAutomaticFrequencyControlTimeseries;
        }
        const Guid& AzimuthOffsetTimeseries( ) const
        {
            return azimuthOffsetTimeseries_;
        }
        void SetAzimuthOffsetTimeseries( const Guid& azimuthOffsetTimeseries )
        {
            azimuthOffsetTimeseries_ = azimuthOffsetTimeseries;
        }
        const Guid& EnableSensitivityTimeControlTimeseries( ) const
        {
            return enableSensitivityTimeControlTimeseries_;
        }
        void SetEnableSensitivityTimeControlTimeseries( const Guid& enableSensitivityTimeControlTimeseries )
        {
            enableSensitivityTimeControlTimeseries_ = enableSensitivityTimeControlTimeseries;
        }
        const Guid& AutomaticSensitivityTimeControlTimeseries( ) const
        {
            return automaticSensitivityTimeControlTimeseries_;
        }
        void SetAutomaticSensitivityTimeControlTimeseries( const Guid& automaticSensitivityTimeControlTimeseries )
        {
            automaticSensitivityTimeControlTimeseries_ = automaticSensitivityTimeControlTimeseries;
        }
        const Guid& SensitivityTimeControlLevelTimeseries( ) const
        {
            return sensitivityTimeControlLevelTimeseries_;
        }
        void SetSensitivityTimeControlLevelTimeseries( const Guid& sensitivityTimeControlLevelTimeseries )
        {
            sensitivityTimeControlLevelTimeseries_ = sensitivityTimeControlLevelTimeseries;
        }
        const Guid& EnableFastTimeConstantTimeseries( ) const
        {
            return enableFastTimeConstantTimeseries_;
        }
        void SetEnableFastTimeConstantTimeseries( const Guid& enableFastTimeConstantTimeseries )
        {
            enableFastTimeConstantTimeseries_ = enableFastTimeConstantTimeseries;
        }
        const Guid& FastTimeConstantLevelTimeseries( ) const
        {
            return fastTimeConstantLevelTimeseries_;
        }
        void SetFastTimeConstantLevelTimeseries( const Guid& fastTimeConstantLevelTimeseries )
        {
            fastTimeConstantLevelTimeseries_ = fastTimeConstantLevelTimeseries;
        }
        const Guid& FastTimeConstantModeTimeseries( ) const
        {
            return fastTimeConstantModeTimeseries_;
        }
        void SetFastTimeConstantModeTimeseries( const Guid& fastTimeConstantModeTimeseries )
        {
            fastTimeConstantModeTimeseries_ = fastTimeConstantModeTimeseries;
        }
        const Guid& LatitudeTimeseries( ) const
        {
            return latitudeTimeseries_;
        }
        void SetLatitudeTimeseries( const Guid& latitudeTimeseries )
        {
            latitudeTimeseries_ = latitudeTimeseries;
        }
        const Guid& LongitudeTimeseries( ) const
        {
            return longitudeTimeseries_;
        }
        void SetLongitudeTimeseries( const Guid& longitudeTimeseries )
        {
            longitudeTimeseries_ = longitudeTimeseries;
        }
        const Guid& Radome( ) const
        {
            return radome_;
        }
        void SetRadome( const Guid& radome )
        {
            radome_ = radome;
        }
        const Guid& GNSSDevice( ) const
        {
            return gNSSDevice_;
        }
        void SetGNSSDevice( const Guid& gNSSDevice )
        {
            gNSSDevice_ = gNSSDevice;
        }
    };
    class WeatherStationData : public DeviceData
    {
    public:
        using Base = DeviceData;
        static constexpr Kind KIND = Kind::WeatherStation;
    private:
        Guid barometricPressureTimeseries_;
        Guid airTemperatureTimeseries_;
        Guid waterTemperatureTimeseries_;
        Guid relativeHumidityTimeseries_;
        Guid absoluteHumidityTimeseries_;
        Guid dewPointTimeseries_;
        Guid windDirectionTimeseries_;
        Guid windSpeedTimeseries_;
        Guid gyro_;
    public:
        WeatherStationData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(barometricPressureTimeseries_);
            destination.Write(airTemperatureTimeseries_);
            destination.Write(waterTemperatureTimeseries_);
            destination.Write(relativeHumidityTimeseries_);
            destination.Write(absoluteHumidityTimeseries_);
            destination.Write(dewPointTimeseries_);
            destination.Write(windDirectionTimeseries_);
            destination.Write(windSpeedTimeseries_);
            destination.Write(gyro_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(barometricPressureTimeseries_);
            source.Read(airTemperatureTimeseries_);
            source.Read(waterTemperatureTimeseries_);
            source.Read(relativeHumidityTimeseries_);
            source.Read(absoluteHumidityTimeseries_);
            source.Read(dewPointTimeseries_);
            source.Read(windDirectionTimeseries_);
            source.Read(windSpeedTimeseries_);
            source.Read(gyro_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<WeatherStationData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<WeatherStationData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const WeatherStationData& >( other );
                if ( dataObject.barometricPressureTimeseries_ != barometricPressureTimeseries_ )
                {
                    return false;
                }
                if ( dataObject.airTemperatureTimeseries_ != airTemperatureTimeseries_ )
                {
                    return false;
                }
                if ( dataObject.waterTemperatureTimeseries_ != waterTemperatureTimeseries_ )
                {
                    return false;
                }
                if ( dataObject.relativeHumidityTimeseries_ != relativeHumidityTimeseries_ )
                {
                    return false;
                }
                if ( dataObject.absoluteHumidityTimeseries_ != absoluteHumidityTimeseries_ )
                {
                    return false;
                }
                if ( dataObject.dewPointTimeseries_ != dewPointTimeseries_ )
                {
                    return false;
                }
                if ( dataObject.windDirectionTimeseries_ != windDirectionTimeseries_ )
                {
                    return false;
                }
                if ( dataObject.windSpeedTimeseries_ != windSpeedTimeseries_ )
                {
                    return false;
                }
                if ( dataObject.gyro_ != gyro_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        const Guid& BarometricPressureTimeseries( ) const
        {
            return barometricPressureTimeseries_;
        }
        void SetBarometricPressureTimeseries( const Guid& barometricPressureTimeseries )
        {
            barometricPressureTimeseries_ = barometricPressureTimeseries;
        }
        const Guid& AirTemperatureTimeseries( ) const
        {
            return airTemperatureTimeseries_;
        }
        void SetAirTemperatureTimeseries( const Guid& airTemperatureTimeseries )
        {
            airTemperatureTimeseries_ = airTemperatureTimeseries;
        }
        const Guid& WaterTemperatureTimeseries( ) const
        {
            return waterTemperatureTimeseries_;
        }
        void SetWaterTemperatureTimeseries( const Guid& waterTemperatureTimeseries )
        {
            waterTemperatureTimeseries_ = waterTemperatureTimeseries;
        }
        const Guid& RelativeHumidityTimeseries( ) const
        {
            return relativeHumidityTimeseries_;
        }
        void SetRelativeHumidityTimeseries( const Guid& relativeHumidityTimeseries )
        {
            relativeHumidityTimeseries_ = relativeHumidityTimeseries;
        }
        const Guid& AbsoluteHumidityTimeseries( ) const
        {
            return absoluteHumidityTimeseries_;
        }
        void SetAbsoluteHumidityTimeseries( const Guid& absoluteHumidityTimeseries )
        {
            absoluteHumidityTimeseries_ = absoluteHumidityTimeseries;
        }
        const Guid& DewPointTimeseries( ) const
        {
            return dewPointTimeseries_;
        }
        void SetDewPointTimeseries( const Guid& dewPointTimeseries )
        {
            dewPointTimeseries_ = dewPointTimeseries;
        }
        const Guid& WindDirectionTimeseries( ) const
        {
            return windDirectionTimeseries_;
        }
        void SetWindDirectionTimeseries( const Guid& windDirectionTimeseries )
        {
            windDirectionTimeseries_ = windDirectionTimeseries;
        }
        const Guid& WindSpeedTimeseries( ) const
        {
            return windSpeedTimeseries_;
        }
        void SetWindSpeedTimeseries( const Guid& windSpeedTimeseries )
        {
            windSpeedTimeseries_ = windSpeedTimeseries;
        }
        const Guid& Gyro( ) const
        {
            return gyro_;
        }
        void SetGyro( const Guid& gyro )
        {
            gyro_ = gyro;
        }
    };
    class FacilityData : public ItemData
    {
    public:
        using Base = ItemData;
        static constexpr Kind KIND = Kind::Facility;
    private:
        FixedDBWideString<127> name_;
        Guid type_;
        double longitude_ = 0.0;
        double latitude_ = 0.0;
        double altitude_ = 0.0;
    public:
        FacilityData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            name_.WriteTo( destination );
            destination.Write(type_);
            destination.Write(longitude_);
            destination.Write(latitude_);
            destination.Write(altitude_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            name_.ReadFrom( source );
            source.Read(type_);
            source.Read(longitude_);
            source.Read(latitude_);
            source.Read(altitude_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<FacilityData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<FacilityData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const FacilityData& >( other );
                if ( dataObject.name_ != name_ )
                {
                    return false;
                }
                if ( dataObject.type_ != type_ )
                {
                    return false;
                }
                if ( dataObject.longitude_ != longitude_ )
                {
                    return false;
                }
                if ( dataObject.latitude_ != latitude_ )
                {
                    return false;
                }
                if ( dataObject.altitude_ != altitude_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        const FixedDBWideString<127>& Name( ) const
        {
            return name_;
        }
        void SetName( const WideString& name )
        {
            name_ = name;
        }
        const Guid& Type( ) const
        {
            return type_;
        }
        void SetType( const Guid& type )
        {
            type_ = type;
        }
        double Longitude( ) const
        {
            return longitude_;
        }
        void SetLongitude( double longitude )
        {
            longitude_ = longitude;
        }
        double Latitude( ) const
        {
            return latitude_;
        }
        void SetLatitude( double latitude )
        {
            latitude_ = latitude;
        }
        double Altitude( ) const
        {
            return altitude_;
        }
        void SetAltitude( double altitude )
        {
            altitude_ = altitude;
        }
    };
    class TrackableItemData : public ItemData
    {
    public:
        using Base = ItemData;
        static constexpr Kind KIND = Kind::TrackableItem;
    private:
    public:
        TrackableItemData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<TrackableItemData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<TrackableItemData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const TrackableItemData& >( other );
                return true;
            }
            return false;
        }
    };
    class AircraftData : public TrackableItemData
    {
    public:
        using Base = TrackableItemData;
        static constexpr Kind KIND = Kind::Aircraft;
    private:
        FixedDBWideString<127> name_;
        Guid type_;
    public:
        AircraftData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            name_.WriteTo( destination );
            destination.Write(type_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            name_.ReadFrom( source );
            source.Read(type_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<AircraftData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<AircraftData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const AircraftData& >( other );
                if ( dataObject.name_ != name_ )
                {
                    return false;
                }
                if ( dataObject.type_ != type_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        const FixedDBWideString<127>& Name( ) const
        {
            return name_;
        }
        void SetName( const WideString& name )
        {
            name_ = name;
        }
        const Guid& Type( ) const
        {
            return type_;
        }
        void SetType( const Guid& type )
        {
            type_ = type;
        }
    };
    class AisAidToNavigationData : public TrackableItemData
    {
    public:
        using Base = TrackableItemData;
        static constexpr Kind KIND = Kind::AisAidToNavigation;
    private:
        FixedDBWideString<127> name_;
        Guid mMSI_;
        Data::NavigationalAidType navigationalAidType_ = Data::NavigationalAidType::NotSpecified;
        Guid position_;
        bool isVirtual_ = false;
        Int32 toBow_ = 0;
        Int32 toStern_ = 0;
        Int32 toPort_ = 0;
        Int32 toStarboard_ = 0;
        Guid offPositionTimeseries_;
    public:
        AisAidToNavigationData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            name_.WriteTo( destination );
            destination.Write(mMSI_);
            destination.Write(navigationalAidType_);
            destination.Write(position_);
            destination.Write(isVirtual_);
            destination.Write(toBow_);
            destination.Write(toStern_);
            destination.Write(toPort_);
            destination.Write(toStarboard_);
            destination.Write(offPositionTimeseries_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            name_.ReadFrom( source );
            source.Read(mMSI_);
            source.Read(navigationalAidType_);
            source.Read(position_);
            source.Read(isVirtual_);
            source.Read(toBow_);
            source.Read(toStern_);
            source.Read(toPort_);
            source.Read(toStarboard_);
            source.Read(offPositionTimeseries_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<AisAidToNavigationData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<AisAidToNavigationData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const AisAidToNavigationData& >( other );
                if ( dataObject.name_ != name_ )
                {
                    return false;
                }
                if ( dataObject.mMSI_ != mMSI_ )
                {
                    return false;
                }
                if ( dataObject.navigationalAidType_ != navigationalAidType_ )
                {
                    return false;
                }
                if ( dataObject.position_ != position_ )
                {
                    return false;
                }
                if ( dataObject.isVirtual_ != isVirtual_ )
                {
                    return false;
                }
                if ( dataObject.toBow_ != toBow_ )
                {
                    return false;
                }
                if ( dataObject.toStern_ != toStern_ )
                {
                    return false;
                }
                if ( dataObject.toPort_ != toPort_ )
                {
                    return false;
                }
                if ( dataObject.toStarboard_ != toStarboard_ )
                {
                    return false;
                }
                if ( dataObject.offPositionTimeseries_ != offPositionTimeseries_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        const FixedDBWideString<127>& Name( ) const
        {
            return name_;
        }
        void SetName( const WideString& name )
        {
            name_ = name;
        }
        const Guid& MMSI( ) const
        {
            return mMSI_;
        }
        void SetMMSI( const Guid& mMSI )
        {
            mMSI_ = mMSI;
        }
        Data::NavigationalAidType NavigationalAidType( ) const
        {
            return navigationalAidType_;
        }
        void SetNavigationalAidType( Data::NavigationalAidType navigationalAidType )
        {
            navigationalAidType_ = navigationalAidType;
        }
        const Guid& Position( ) const
        {
            return position_;
        }
        void SetPosition( const Guid& position )
        {
            position_ = position;
        }
        bool IsVirtual( ) const
        {
            return isVirtual_;
        }
        void SetIsVirtual( bool isVirtual )
        {
            isVirtual_ = isVirtual;
        }
        Int32 ToBow( ) const
        {
            return toBow_;
        }
        void SetToBow( Int32 toBow )
        {
            toBow_ = toBow;
        }
        Int32 ToStern( ) const
        {
            return toStern_;
        }
        void SetToStern( Int32 toStern )
        {
            toStern_ = toStern;
        }
        Int32 ToPort( ) const
        {
            return toPort_;
        }
        void SetToPort( Int32 toPort )
        {
            toPort_ = toPort;
        }
        Int32 ToStarboard( ) const
        {
            return toStarboard_;
        }
        void SetToStarboard( Int32 toStarboard )
        {
            toStarboard_ = toStarboard;
        }
        const Guid& OffPositionTimeseries( ) const
        {
            return offPositionTimeseries_;
        }
        void SetOffPositionTimeseries( const Guid& offPositionTimeseries )
        {
            offPositionTimeseries_ = offPositionTimeseries;
        }
    };
    class VehicleData : public TrackableItemData
    {
    public:
        using Base = TrackableItemData;
        static constexpr Kind KIND = Kind::Vehicle;
    private:
        FixedDBWideString<127> name_;
        Guid type_;
    public:
        VehicleData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            name_.WriteTo( destination );
            destination.Write(type_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            name_.ReadFrom( source );
            source.Read(type_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<VehicleData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<VehicleData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const VehicleData& >( other );
                if ( dataObject.name_ != name_ )
                {
                    return false;
                }
                if ( dataObject.type_ != type_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        const FixedDBWideString<127>& Name( ) const
        {
            return name_;
        }
        void SetName( const WideString& name )
        {
            name_ = name;
        }
        const Guid& Type( ) const
        {
            return type_;
        }
        void SetType( const Guid& type )
        {
            type_ = type;
        }
    };
    class VesselData : public TrackableItemData
    {
    public:
        using Base = TrackableItemData;
        static constexpr Kind KIND = Kind::Vessel;
    private:
        FixedDBWideString<127> name_;
        Guid type_;
        Int32 toBow_ = 0;
        Int32 toStern_ = 0;
        Int32 toPort_ = 0;
        Int32 toStarboard_ = 0;
        Guid draughtTimeseries_;
        Guid personsOnBoardTimeseries_;
    public:
        VesselData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            name_.WriteTo( destination );
            destination.Write(type_);
            destination.Write(toBow_);
            destination.Write(toStern_);
            destination.Write(toPort_);
            destination.Write(toStarboard_);
            destination.Write(draughtTimeseries_);
            destination.Write(personsOnBoardTimeseries_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            name_.ReadFrom( source );
            source.Read(type_);
            source.Read(toBow_);
            source.Read(toStern_);
            source.Read(toPort_);
            source.Read(toStarboard_);
            source.Read(draughtTimeseries_);
            source.Read(personsOnBoardTimeseries_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<VesselData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<VesselData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const VesselData& >( other );
                if ( dataObject.name_ != name_ )
                {
                    return false;
                }
                if ( dataObject.type_ != type_ )
                {
                    return false;
                }
                if ( dataObject.toBow_ != toBow_ )
                {
                    return false;
                }
                if ( dataObject.toStern_ != toStern_ )
                {
                    return false;
                }
                if ( dataObject.toPort_ != toPort_ )
                {
                    return false;
                }
                if ( dataObject.toStarboard_ != toStarboard_ )
                {
                    return false;
                }
                if ( dataObject.draughtTimeseries_ != draughtTimeseries_ )
                {
                    return false;
                }
                if ( dataObject.personsOnBoardTimeseries_ != personsOnBoardTimeseries_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        const FixedDBWideString<127>& Name( ) const
        {
            return name_;
        }
        void SetName( const WideString& name )
        {
            name_ = name;
        }
        const Guid& Type( ) const
        {
            return type_;
        }
        void SetType( const Guid& type )
        {
            type_ = type;
        }
        Int32 ToBow( ) const
        {
            return toBow_;
        }
        void SetToBow( Int32 toBow )
        {
            toBow_ = toBow;
        }
        Int32 ToStern( ) const
        {
            return toStern_;
        }
        void SetToStern( Int32 toStern )
        {
            toStern_ = toStern;
        }
        Int32 ToPort( ) const
        {
            return toPort_;
        }
        void SetToPort( Int32 toPort )
        {
            toPort_ = toPort;
        }
        Int32 ToStarboard( ) const
        {
            return toStarboard_;
        }
        void SetToStarboard( Int32 toStarboard )
        {
            toStarboard_ = toStarboard;
        }
        const Guid& DraughtTimeseries( ) const
        {
            return draughtTimeseries_;
        }
        void SetDraughtTimeseries( const Guid& draughtTimeseries )
        {
            draughtTimeseries_ = draughtTimeseries;
        }
        const Guid& PersonsOnBoardTimeseries( ) const
        {
            return personsOnBoardTimeseries_;
        }
        void SetPersonsOnBoardTimeseries( const Guid& personsOnBoardTimeseries )
        {
            personsOnBoardTimeseries_ = personsOnBoardTimeseries;
        }
    };
    class ItemIdentityLinkData : public BaseData<Kind, Guid>
    {
    public:
        using Base = BaseData<Kind, Guid>;
        static constexpr Kind KIND = Kind::ItemIdentityLink;
    private:
        Int64 rowVersion_ = 0;
        Guid item_;
        Guid identity_;
        DateTime start_;
        DBDateTime end_;
    public:
        ItemIdentityLinkData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(rowVersion_);
            destination.Write(item_);
            destination.Write(identity_);
            destination.Write(start_);
            end_.WriteTo( destination );
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(rowVersion_);
            source.Read(item_);
            source.Read(identity_);
            source.Read(start_);
            end_.ReadFrom( source );
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<ItemIdentityLinkData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<ItemIdentityLinkData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const ItemIdentityLinkData& >( other );
                if ( dataObject.rowVersion_ != rowVersion_ )
                {
                    return false;
                }
                if ( dataObject.item_ != item_ )
                {
                    return false;
                }
                if ( dataObject.identity_ != identity_ )
                {
                    return false;
                }
                if ( dataObject.start_ != start_ )
                {
                    return false;
                }
                if ( dataObject.end_ != end_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        Int64 RowVersion( ) const
        {
            return rowVersion_;
        }
        void SetRowVersion( const Int64& rowVersion )
        {
            rowVersion_ = rowVersion;
        }
        const Guid& Item( ) const
        {
            return item_;
        }
        void SetItem( const Guid& item )
        {
            item_ = item;
        }
        const Guid& Identity( ) const
        {
            return identity_;
        }
        void SetIdentity( const Guid& identity )
        {
            identity_ = identity;
        }
        const DateTime& Start( ) const
        {
            return start_;
        }
        void SetStart( const DateTime& start )
        {
            start_ = start;
        }
        const DBDateTime& End( ) const
        {
            return end_;
        }
        void SetEnd( const DBDateTime& end )
        {
            end_ = end;
        }
    };
    class ItemParentChildLinkData : public BaseData<Kind, Guid>
    {
    public:
        using Base = BaseData<Kind, Guid>;
        static constexpr Kind KIND = Kind::ItemParentChildLink;
    private:
        Int64 rowVersion_ = 0;
        Guid parent_;
        Guid child_;
        DateTime timestamp_;
    public:
        ItemParentChildLinkData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(rowVersion_);
            destination.Write(parent_);
            destination.Write(child_);
            destination.Write(timestamp_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(rowVersion_);
            source.Read(parent_);
            source.Read(child_);
            source.Read(timestamp_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<ItemParentChildLinkData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<ItemParentChildLinkData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const ItemParentChildLinkData& >( other );
                if ( dataObject.rowVersion_ != rowVersion_ )
                {
                    return false;
                }
                if ( dataObject.parent_ != parent_ )
                {
                    return false;
                }
                if ( dataObject.child_ != child_ )
                {
                    return false;
                }
                if ( dataObject.timestamp_ != timestamp_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        Int64 RowVersion( ) const
        {
            return rowVersion_;
        }
        void SetRowVersion( const Int64& rowVersion )
        {
            rowVersion_ = rowVersion;
        }
        const Guid& Parent( ) const
        {
            return parent_;
        }
        void SetParent( const Guid& parent )
        {
            parent_ = parent;
        }
        const Guid& Child( ) const
        {
            return child_;
        }
        void SetChild( const Guid& child )
        {
            child_ = child;
        }
        const DateTime& Timestamp( ) const
        {
            return timestamp_;
        }
        void SetTimestamp( const DateTime& timestamp )
        {
            timestamp_ = timestamp;
        }
    };
    class LineInputDeviceCommandData : public BaseData<Kind, Guid>
    {
    public:
        using Base = BaseData<Kind, Guid>;
        static constexpr Kind KIND = Kind::LineInputDeviceCommand;
    private:
        Int64 rowVersion_ = 0;
        Guid lineInputDevice_;
        DateTime timestamp_;
        Data::DeviceCommandSourceType deviceCommandSourceType_ = Data::DeviceCommandSourceType::Unknown;
        Guid deviceCommandSourceId_;
        Guid reply_;
    public:
        LineInputDeviceCommandData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(rowVersion_);
            destination.Write(lineInputDevice_);
            destination.Write(timestamp_);
            destination.Write(deviceCommandSourceType_);
            destination.Write(deviceCommandSourceId_);
            destination.Write(reply_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(rowVersion_);
            source.Read(lineInputDevice_);
            source.Read(timestamp_);
            source.Read(deviceCommandSourceType_);
            source.Read(deviceCommandSourceId_);
            source.Read(reply_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<LineInputDeviceCommandData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<LineInputDeviceCommandData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const LineInputDeviceCommandData& >( other );
                if ( dataObject.rowVersion_ != rowVersion_ )
                {
                    return false;
                }
                if ( dataObject.lineInputDevice_ != lineInputDevice_ )
                {
                    return false;
                }
                if ( dataObject.timestamp_ != timestamp_ )
                {
                    return false;
                }
                if ( dataObject.deviceCommandSourceType_ != deviceCommandSourceType_ )
                {
                    return false;
                }
                if ( dataObject.deviceCommandSourceId_ != deviceCommandSourceId_ )
                {
                    return false;
                }
                if ( dataObject.reply_ != reply_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        Int64 RowVersion( ) const
        {
            return rowVersion_;
        }
        void SetRowVersion( const Int64& rowVersion )
        {
            rowVersion_ = rowVersion;
        }
        const Guid& LineInputDevice( ) const
        {
            return lineInputDevice_;
        }
        void SetLineInputDevice( const Guid& lineInputDevice )
        {
            lineInputDevice_ = lineInputDevice;
        }
        const DateTime& Timestamp( ) const
        {
            return timestamp_;
        }
        void SetTimestamp( const DateTime& timestamp )
        {
            timestamp_ = timestamp;
        }
        Data::DeviceCommandSourceType DeviceCommandSourceType( ) const
        {
            return deviceCommandSourceType_;
        }
        void SetDeviceCommandSourceType( Data::DeviceCommandSourceType deviceCommandSourceType )
        {
            deviceCommandSourceType_ = deviceCommandSourceType;
        }
        const Guid& DeviceCommandSourceId( ) const
        {
            return deviceCommandSourceId_;
        }
        void SetDeviceCommandSourceId( const Guid& deviceCommandSourceId )
        {
            deviceCommandSourceId_ = deviceCommandSourceId;
        }
        const Guid& Reply( ) const
        {
            return reply_;
        }
        void SetReply( const Guid& reply )
        {
            reply_ = reply;
        }
    };
    class LineInputDeviceCommandReplyData : public BaseData<Kind, Guid>
    {
    public:
        using Base = BaseData<Kind, Guid>;
        static constexpr Kind KIND = Kind::LineInputDeviceCommandReply;
    private:
        Int64 rowVersion_ = 0;
        Guid lineInputDevice_;
        DateTime timestamp_;
        Guid command_;
        Data::DeviceCommandReplyStatus status_ = Data::DeviceCommandReplyStatus::Unknown;
        WideString message_;
        SQLLEN messageLength_ = SQL_NULL_DATA;
    public:
        LineInputDeviceCommandReplyData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(rowVersion_);
            destination.Write(lineInputDevice_);
            destination.Write(timestamp_);
            destination.Write(command_);
            destination.Write(status_);
            destination.Write(message_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(rowVersion_);
            source.Read(lineInputDevice_);
            source.Read(timestamp_);
            source.Read(command_);
            source.Read(status_);
            source.Read(message_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<LineInputDeviceCommandReplyData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<LineInputDeviceCommandReplyData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const LineInputDeviceCommandReplyData& >( other );
                if ( dataObject.rowVersion_ != rowVersion_ )
                {
                    return false;
                }
                if ( dataObject.lineInputDevice_ != lineInputDevice_ )
                {
                    return false;
                }
                if ( dataObject.timestamp_ != timestamp_ )
                {
                    return false;
                }
                if ( dataObject.command_ != command_ )
                {
                    return false;
                }
                if ( dataObject.status_ != status_ )
                {
                    return false;
                }
                if ( dataObject.message_ != message_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        Int64 RowVersion( ) const
        {
            return rowVersion_;
        }
        void SetRowVersion( const Int64& rowVersion )
        {
            rowVersion_ = rowVersion;
        }
        const Guid& LineInputDevice( ) const
        {
            return lineInputDevice_;
        }
        void SetLineInputDevice( const Guid& lineInputDevice )
        {
            lineInputDevice_ = lineInputDevice;
        }
        const DateTime& Timestamp( ) const
        {
            return timestamp_;
        }
        void SetTimestamp( const DateTime& timestamp )
        {
            timestamp_ = timestamp;
        }
        const Guid& Command( ) const
        {
            return command_;
        }
        void SetCommand( const Guid& command )
        {
            command_ = command;
        }
        Data::DeviceCommandReplyStatus Status( ) const
        {
            return status_;
        }
        void SetStatus( Data::DeviceCommandReplyStatus status )
        {
            status_ = status;
        }
        const WideString& Message( ) const
        {
            return message_;
        }
        void SetMessage( const WideString& message )
        {
            message_ = message;
        }
    };
    class LineInputDeviceConfigurationData : public BaseData<Kind, Guid>
    {
    public:
        using Base = BaseData<Kind, Guid>;
        static constexpr Kind KIND = Kind::LineInputDeviceConfiguration;
    private:
        Int64 rowVersion_ = 0;
        Guid lineInputDevice_;
        DateTime timestamp_;
        bool storeReceivedSentences_ = false;
        bool storeSentMessages_ = false;
        bool storeUnsentMessages_ = false;
        bool nMEA_ = false;
        bool strictNMEA_ = false;
        Data::LineInputDeviceConnectionType connectionType_ = Data::LineInputDeviceConnectionType::Unknown;
        Int32 udpReceivePort_ = 0;
        FixedDBWideString<100> udpSendHostname_;
        Int32 udpSendPort_ = 0;
        FixedDBWideString<100> tcpHostname_;
        Int32 tcpPort_ = 0;
        bool useHttpLogin_ = false;
        FixedDBWideString<100> loginHostname_;
        Int32 loginPort_ = 0;
        FixedDBWideString<100> userName_;
        FixedDBWideString<100> password_;
        FixedDBWideString<100> comPort_;
        Int32 baudRate_ = 0;
        Int32 dataBits_ = 0;
        bool discardNull_ = false;
        bool dtrEnable_ = false;
        Data::Handshake handshake_ = Data::Handshake::None;
        FixedDBWideString<100> newLine_;
        Data::Parity parity_ = Data::Parity::None;
        Byte parityReplace_ = 0;
        Int32 readBufferSize_ = 0;
        TimeSpan readTimeout_;
        Int32 receivedBytesThreshold_ = 0;
        bool rtsEnable_ = false;
        Data::StopBits stopBits_ = Data::StopBits::None;
        Int32 writeBufferSize_ = 0;
        TimeSpan writeTimeout_;
        FixedDBWideString<100> pairedComPort_;
    public:
        LineInputDeviceConfigurationData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(rowVersion_);
            destination.Write(lineInputDevice_);
            destination.Write(timestamp_);
            destination.Write(storeReceivedSentences_);
            destination.Write(storeSentMessages_);
            destination.Write(storeUnsentMessages_);
            destination.Write(nMEA_);
            destination.Write(strictNMEA_);
            destination.Write(connectionType_);
            destination.Write(udpReceivePort_);
            udpSendHostname_.WriteTo( destination );
            destination.Write(udpSendPort_);
            tcpHostname_.WriteTo( destination );
            destination.Write(tcpPort_);
            destination.Write(useHttpLogin_);
            loginHostname_.WriteTo( destination );
            destination.Write(loginPort_);
            userName_.WriteTo( destination );
            password_.WriteTo( destination );
            comPort_.WriteTo( destination );
            destination.Write(baudRate_);
            destination.Write(dataBits_);
            destination.Write(discardNull_);
            destination.Write(dtrEnable_);
            destination.Write(handshake_);
            newLine_.WriteTo( destination );
            destination.Write(parity_);
            destination.Write(parityReplace_);
            destination.Write(readBufferSize_);
            destination.Write(readTimeout_);
            destination.Write(receivedBytesThreshold_);
            destination.Write(rtsEnable_);
            destination.Write(stopBits_);
            destination.Write(writeBufferSize_);
            destination.Write(writeTimeout_);
            pairedComPort_.WriteTo( destination );
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(rowVersion_);
            source.Read(lineInputDevice_);
            source.Read(timestamp_);
            source.Read(storeReceivedSentences_);
            source.Read(storeSentMessages_);
            source.Read(storeUnsentMessages_);
            source.Read(nMEA_);
            source.Read(strictNMEA_);
            source.Read(connectionType_);
            source.Read(udpReceivePort_);
            udpSendHostname_.ReadFrom( source );
            source.Read(udpSendPort_);
            tcpHostname_.ReadFrom( source );
            source.Read(tcpPort_);
            source.Read(useHttpLogin_);
            loginHostname_.ReadFrom( source );
            source.Read(loginPort_);
            userName_.ReadFrom( source );
            password_.ReadFrom( source );
            comPort_.ReadFrom( source );
            source.Read(baudRate_);
            source.Read(dataBits_);
            source.Read(discardNull_);
            source.Read(dtrEnable_);
            source.Read(handshake_);
            newLine_.ReadFrom( source );
            source.Read(parity_);
            source.Read(parityReplace_);
            source.Read(readBufferSize_);
            source.Read(readTimeout_);
            source.Read(receivedBytesThreshold_);
            source.Read(rtsEnable_);
            source.Read(stopBits_);
            source.Read(writeBufferSize_);
            source.Read(writeTimeout_);
            pairedComPort_.ReadFrom( source );
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<LineInputDeviceConfigurationData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<LineInputDeviceConfigurationData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const LineInputDeviceConfigurationData& >( other );
                if ( dataObject.rowVersion_ != rowVersion_ )
                {
                    return false;
                }
                if ( dataObject.lineInputDevice_ != lineInputDevice_ )
                {
                    return false;
                }
                if ( dataObject.timestamp_ != timestamp_ )
                {
                    return false;
                }
                if ( dataObject.storeReceivedSentences_ != storeReceivedSentences_ )
                {
                    return false;
                }
                if ( dataObject.storeSentMessages_ != storeSentMessages_ )
                {
                    return false;
                }
                if ( dataObject.storeUnsentMessages_ != storeUnsentMessages_ )
                {
                    return false;
                }
                if ( dataObject.nMEA_ != nMEA_ )
                {
                    return false;
                }
                if ( dataObject.strictNMEA_ != strictNMEA_ )
                {
                    return false;
                }
                if ( dataObject.connectionType_ != connectionType_ )
                {
                    return false;
                }
                if ( dataObject.udpReceivePort_ != udpReceivePort_ )
                {
                    return false;
                }
                if ( dataObject.udpSendHostname_ != udpSendHostname_ )
                {
                    return false;
                }
                if ( dataObject.udpSendPort_ != udpSendPort_ )
                {
                    return false;
                }
                if ( dataObject.tcpHostname_ != tcpHostname_ )
                {
                    return false;
                }
                if ( dataObject.tcpPort_ != tcpPort_ )
                {
                    return false;
                }
                if ( dataObject.useHttpLogin_ != useHttpLogin_ )
                {
                    return false;
                }
                if ( dataObject.loginHostname_ != loginHostname_ )
                {
                    return false;
                }
                if ( dataObject.loginPort_ != loginPort_ )
                {
                    return false;
                }
                if ( dataObject.userName_ != userName_ )
                {
                    return false;
                }
                if ( dataObject.password_ != password_ )
                {
                    return false;
                }
                if ( dataObject.comPort_ != comPort_ )
                {
                    return false;
                }
                if ( dataObject.baudRate_ != baudRate_ )
                {
                    return false;
                }
                if ( dataObject.dataBits_ != dataBits_ )
                {
                    return false;
                }
                if ( dataObject.discardNull_ != discardNull_ )
                {
                    return false;
                }
                if ( dataObject.dtrEnable_ != dtrEnable_ )
                {
                    return false;
                }
                if ( dataObject.handshake_ != handshake_ )
                {
                    return false;
                }
                if ( dataObject.newLine_ != newLine_ )
                {
                    return false;
                }
                if ( dataObject.parity_ != parity_ )
                {
                    return false;
                }
                if ( dataObject.parityReplace_ != parityReplace_ )
                {
                    return false;
                }
                if ( dataObject.readBufferSize_ != readBufferSize_ )
                {
                    return false;
                }
                if ( dataObject.readTimeout_ != readTimeout_ )
                {
                    return false;
                }
                if ( dataObject.receivedBytesThreshold_ != receivedBytesThreshold_ )
                {
                    return false;
                }
                if ( dataObject.rtsEnable_ != rtsEnable_ )
                {
                    return false;
                }
                if ( dataObject.stopBits_ != stopBits_ )
                {
                    return false;
                }
                if ( dataObject.writeBufferSize_ != writeBufferSize_ )
                {
                    return false;
                }
                if ( dataObject.writeTimeout_ != writeTimeout_ )
                {
                    return false;
                }
                if ( dataObject.pairedComPort_ != pairedComPort_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        Int64 RowVersion( ) const
        {
            return rowVersion_;
        }
        void SetRowVersion( const Int64& rowVersion )
        {
            rowVersion_ = rowVersion;
        }
        const Guid& LineInputDevice( ) const
        {
            return lineInputDevice_;
        }
        void SetLineInputDevice( const Guid& lineInputDevice )
        {
            lineInputDevice_ = lineInputDevice;
        }
        const DateTime& Timestamp( ) const
        {
            return timestamp_;
        }
        void SetTimestamp( const DateTime& timestamp )
        {
            timestamp_ = timestamp;
        }
        bool StoreReceivedSentences( ) const
        {
            return storeReceivedSentences_;
        }
        void SetStoreReceivedSentences( bool storeReceivedSentences )
        {
            storeReceivedSentences_ = storeReceivedSentences;
        }
        bool StoreSentMessages( ) const
        {
            return storeSentMessages_;
        }
        void SetStoreSentMessages( bool storeSentMessages )
        {
            storeSentMessages_ = storeSentMessages;
        }
        bool StoreUnsentMessages( ) const
        {
            return storeUnsentMessages_;
        }
        void SetStoreUnsentMessages( bool storeUnsentMessages )
        {
            storeUnsentMessages_ = storeUnsentMessages;
        }
        bool NMEA( ) const
        {
            return nMEA_;
        }
        void SetNMEA( bool nMEA )
        {
            nMEA_ = nMEA;
        }
        bool StrictNMEA( ) const
        {
            return strictNMEA_;
        }
        void SetStrictNMEA( bool strictNMEA )
        {
            strictNMEA_ = strictNMEA;
        }
        Data::LineInputDeviceConnectionType ConnectionType( ) const
        {
            return connectionType_;
        }
        void SetConnectionType( Data::LineInputDeviceConnectionType connectionType )
        {
            connectionType_ = connectionType;
        }
        Int32 UdpReceivePort( ) const
        {
            return udpReceivePort_;
        }
        void SetUdpReceivePort( Int32 udpReceivePort )
        {
            udpReceivePort_ = udpReceivePort;
        }
        const FixedDBWideString<100>& UdpSendHostname( ) const
        {
            return udpSendHostname_;
        }
        void SetUdpSendHostname( const WideString& udpSendHostname )
        {
            udpSendHostname_ = udpSendHostname;
        }
        Int32 UdpSendPort( ) const
        {
            return udpSendPort_;
        }
        void SetUdpSendPort( Int32 udpSendPort )
        {
            udpSendPort_ = udpSendPort;
        }
        const FixedDBWideString<100>& TcpHostname( ) const
        {
            return tcpHostname_;
        }
        void SetTcpHostname( const WideString& tcpHostname )
        {
            tcpHostname_ = tcpHostname;
        }
        Int32 TcpPort( ) const
        {
            return tcpPort_;
        }
        void SetTcpPort( Int32 tcpPort )
        {
            tcpPort_ = tcpPort;
        }
        bool UseHttpLogin( ) const
        {
            return useHttpLogin_;
        }
        void SetUseHttpLogin( bool useHttpLogin )
        {
            useHttpLogin_ = useHttpLogin;
        }
        const FixedDBWideString<100>& LoginHostname( ) const
        {
            return loginHostname_;
        }
        void SetLoginHostname( const WideString& loginHostname )
        {
            loginHostname_ = loginHostname;
        }
        Int32 LoginPort( ) const
        {
            return loginPort_;
        }
        void SetLoginPort( Int32 loginPort )
        {
            loginPort_ = loginPort;
        }
        const FixedDBWideString<100>& UserName( ) const
        {
            return userName_;
        }
        void SetUserName( const WideString& userName )
        {
            userName_ = userName;
        }
        const FixedDBWideString<100>& Password( ) const
        {
            return password_;
        }
        void SetPassword( const WideString& password )
        {
            password_ = password;
        }
        const FixedDBWideString<100>& ComPort( ) const
        {
            return comPort_;
        }
        void SetComPort( const WideString& comPort )
        {
            comPort_ = comPort;
        }
        Int32 BaudRate( ) const
        {
            return baudRate_;
        }
        void SetBaudRate( Int32 baudRate )
        {
            baudRate_ = baudRate;
        }
        Int32 DataBits( ) const
        {
            return dataBits_;
        }
        void SetDataBits( Int32 dataBits )
        {
            dataBits_ = dataBits;
        }
        bool DiscardNull( ) const
        {
            return discardNull_;
        }
        void SetDiscardNull( bool discardNull )
        {
            discardNull_ = discardNull;
        }
        bool DtrEnable( ) const
        {
            return dtrEnable_;
        }
        void SetDtrEnable( bool dtrEnable )
        {
            dtrEnable_ = dtrEnable;
        }
        Data::Handshake Handshake( ) const
        {
            return handshake_;
        }
        void SetHandshake( Data::Handshake handshake )
        {
            handshake_ = handshake;
        }
        const FixedDBWideString<100>& NewLine( ) const
        {
            return newLine_;
        }
        void SetNewLine( const WideString& newLine )
        {
            newLine_ = newLine;
        }
        Data::Parity Parity( ) const
        {
            return parity_;
        }
        void SetParity( Data::Parity parity )
        {
            parity_ = parity;
        }
        Byte ParityReplace( ) const
        {
            return parityReplace_;
        }
        void SetParityReplace( Byte parityReplace )
        {
            parityReplace_ = parityReplace;
        }
        Int32 ReadBufferSize( ) const
        {
            return readBufferSize_;
        }
        void SetReadBufferSize( Int32 readBufferSize )
        {
            readBufferSize_ = readBufferSize;
        }
        const TimeSpan& ReadTimeout( ) const
        {
            return readTimeout_;
        }
        void SetReadTimeout( const TimeSpan& readTimeout )
        {
            readTimeout_ = readTimeout;
        }
        Int32 ReceivedBytesThreshold( ) const
        {
            return receivedBytesThreshold_;
        }
        void SetReceivedBytesThreshold( Int32 receivedBytesThreshold )
        {
            receivedBytesThreshold_ = receivedBytesThreshold;
        }
        bool RtsEnable( ) const
        {
            return rtsEnable_;
        }
        void SetRtsEnable( bool rtsEnable )
        {
            rtsEnable_ = rtsEnable;
        }
        Data::StopBits StopBits( ) const
        {
            return stopBits_;
        }
        void SetStopBits( Data::StopBits stopBits )
        {
            stopBits_ = stopBits;
        }
        Int32 WriteBufferSize( ) const
        {
            return writeBufferSize_;
        }
        void SetWriteBufferSize( Int32 writeBufferSize )
        {
            writeBufferSize_ = writeBufferSize;
        }
        const TimeSpan& WriteTimeout( ) const
        {
            return writeTimeout_;
        }
        void SetWriteTimeout( const TimeSpan& writeTimeout )
        {
            writeTimeout_ = writeTimeout;
        }
        const FixedDBWideString<100>& PairedComPort( ) const
        {
            return pairedComPort_;
        }
        void SetPairedComPort( const WideString& pairedComPort )
        {
            pairedComPort_ = pairedComPort;
        }
    };
    class LineInputMessageRoutingData : public BaseData<Kind, Guid>
    {
    public:
        using Base = BaseData<Kind, Guid>;
        static constexpr Kind KIND = Kind::LineInputMessageRouting;
    private:
        Int64 rowVersion_ = 0;
        Guid lineInputDevice_;
        FixedDBWideString<100> type_;
    public:
        LineInputMessageRoutingData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(rowVersion_);
            destination.Write(lineInputDevice_);
            type_.WriteTo( destination );
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(rowVersion_);
            source.Read(lineInputDevice_);
            type_.ReadFrom( source );
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<LineInputMessageRoutingData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<LineInputMessageRoutingData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const LineInputMessageRoutingData& >( other );
                if ( dataObject.rowVersion_ != rowVersion_ )
                {
                    return false;
                }
                if ( dataObject.lineInputDevice_ != lineInputDevice_ )
                {
                    return false;
                }
                if ( dataObject.type_ != type_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        Int64 RowVersion( ) const
        {
            return rowVersion_;
        }
        void SetRowVersion( const Int64& rowVersion )
        {
            rowVersion_ = rowVersion;
        }
        const Guid& LineInputDevice( ) const
        {
            return lineInputDevice_;
        }
        void SetLineInputDevice( const Guid& lineInputDevice )
        {
            lineInputDevice_ = lineInputDevice;
        }
        const FixedDBWideString<100>& Type( ) const
        {
            return type_;
        }
        void SetType( const WideString& type )
        {
            type_ = type;
        }
    };
    class LineInputMessageRoutingDestinationData : public BaseData<Kind, Guid>
    {
    public:
        using Base = BaseData<Kind, Guid>;
        static constexpr Kind KIND = Kind::LineInputMessageRoutingDestination;
    private:
        Int64 rowVersion_ = 0;
        Guid routing_;
        Guid listener_;
    public:
        LineInputMessageRoutingDestinationData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(rowVersion_);
            destination.Write(routing_);
            destination.Write(listener_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(rowVersion_);
            source.Read(routing_);
            source.Read(listener_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<LineInputMessageRoutingDestinationData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<LineInputMessageRoutingDestinationData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const LineInputMessageRoutingDestinationData& >( other );
                if ( dataObject.rowVersion_ != rowVersion_ )
                {
                    return false;
                }
                if ( dataObject.routing_ != routing_ )
                {
                    return false;
                }
                if ( dataObject.listener_ != listener_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        Int64 RowVersion( ) const
        {
            return rowVersion_;
        }
        void SetRowVersion( const Int64& rowVersion )
        {
            rowVersion_ = rowVersion;
        }
        const Guid& Routing( ) const
        {
            return routing_;
        }
        void SetRouting( const Guid& routing )
        {
            routing_ = routing;
        }
        const Guid& Listener( ) const
        {
            return listener_;
        }
        void SetListener( const Guid& listener )
        {
            listener_ = listener;
        }
    };
    class LineInputWhiteListEntryData : public BaseData<Kind, Guid>
    {
    public:
        using Base = BaseData<Kind, Guid>;
        static constexpr Kind KIND = Kind::LineInputWhiteListEntry;
    private:
        Int64 rowVersion_ = 0;
        Guid lineInputDevice_;
        FixedDBWideString<128> hostName_;
        Int32 port_ = 0;
    public:
        LineInputWhiteListEntryData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(rowVersion_);
            destination.Write(lineInputDevice_);
            hostName_.WriteTo( destination );
            destination.Write(port_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(rowVersion_);
            source.Read(lineInputDevice_);
            hostName_.ReadFrom( source );
            source.Read(port_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<LineInputWhiteListEntryData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<LineInputWhiteListEntryData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const LineInputWhiteListEntryData& >( other );
                if ( dataObject.rowVersion_ != rowVersion_ )
                {
                    return false;
                }
                if ( dataObject.lineInputDevice_ != lineInputDevice_ )
                {
                    return false;
                }
                if ( dataObject.hostName_ != hostName_ )
                {
                    return false;
                }
                if ( dataObject.port_ != port_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        Int64 RowVersion( ) const
        {
            return rowVersion_;
        }
        void SetRowVersion( const Int64& rowVersion )
        {
            rowVersion_ = rowVersion;
        }
        const Guid& LineInputDevice( ) const
        {
            return lineInputDevice_;
        }
        void SetLineInputDevice( const Guid& lineInputDevice )
        {
            lineInputDevice_ = lineInputDevice;
        }
        const FixedDBWideString<128>& HostName( ) const
        {
            return hostName_;
        }
        void SetHostName( const WideString& hostName )
        {
            hostName_ = hostName;
        }
        Int32 Port( ) const
        {
            return port_;
        }
        void SetPort( Int32 port )
        {
            port_ = port;
        }
    };
    class LogApplicationData : public BaseData<Kind, Guid>
    {
    public:
        using Base = BaseData<Kind, Guid>;
        static constexpr Kind KIND = Kind::LogApplication;
    private:
        Int64 rowVersion_ = 0;
        FixedDBWideString<127> name_;
        WideString description_;
        SQLLEN descriptionLength_ = SQL_NULL_DATA;
    public:
        LogApplicationData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(rowVersion_);
            name_.WriteTo( destination );
            destination.Write(description_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(rowVersion_);
            name_.ReadFrom( source );
            source.Read(description_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<LogApplicationData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<LogApplicationData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const LogApplicationData& >( other );
                if ( dataObject.rowVersion_ != rowVersion_ )
                {
                    return false;
                }
                if ( dataObject.name_ != name_ )
                {
                    return false;
                }
                if ( dataObject.description_ != description_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        Int64 RowVersion( ) const
        {
            return rowVersion_;
        }
        void SetRowVersion( const Int64& rowVersion )
        {
            rowVersion_ = rowVersion;
        }
        const FixedDBWideString<127>& Name( ) const
        {
            return name_;
        }
        void SetName( const WideString& name )
        {
            name_ = name;
        }
        const WideString& Description( ) const
        {
            return description_;
        }
        void SetDescription( const WideString& description )
        {
            description_ = description;
        }
    };
    class LogApplicationConfigurationData : public BaseData<Kind, Guid>
    {
    public:
        using Base = BaseData<Kind, Guid>;
        static constexpr Kind KIND = Kind::LogApplicationConfiguration;
    private:
        Int64 rowVersion_ = 0;
        Guid application_;
        DateTime timestamp_;
        bool finest_ = false;
        bool finer_ = false;
        bool fine_ = false;
        bool info_ = false;
        bool notice_ = false;
        bool warn_ = false;
        bool error_ = false;
        bool severe_ = false;
        bool critical_ = false;
        bool alert_ = false;
        bool fatal_ = false;
        bool emergency_ = false;
    public:
        LogApplicationConfigurationData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(rowVersion_);
            destination.Write(application_);
            destination.Write(timestamp_);
            destination.Write(finest_);
            destination.Write(finer_);
            destination.Write(fine_);
            destination.Write(info_);
            destination.Write(notice_);
            destination.Write(warn_);
            destination.Write(error_);
            destination.Write(severe_);
            destination.Write(critical_);
            destination.Write(alert_);
            destination.Write(fatal_);
            destination.Write(emergency_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(rowVersion_);
            source.Read(application_);
            source.Read(timestamp_);
            source.Read(finest_);
            source.Read(finer_);
            source.Read(fine_);
            source.Read(info_);
            source.Read(notice_);
            source.Read(warn_);
            source.Read(error_);
            source.Read(severe_);
            source.Read(critical_);
            source.Read(alert_);
            source.Read(fatal_);
            source.Read(emergency_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<LogApplicationConfigurationData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<LogApplicationConfigurationData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const LogApplicationConfigurationData& >( other );
                if ( dataObject.rowVersion_ != rowVersion_ )
                {
                    return false;
                }
                if ( dataObject.application_ != application_ )
                {
                    return false;
                }
                if ( dataObject.timestamp_ != timestamp_ )
                {
                    return false;
                }
                if ( dataObject.finest_ != finest_ )
                {
                    return false;
                }
                if ( dataObject.finer_ != finer_ )
                {
                    return false;
                }
                if ( dataObject.fine_ != fine_ )
                {
                    return false;
                }
                if ( dataObject.info_ != info_ )
                {
                    return false;
                }
                if ( dataObject.notice_ != notice_ )
                {
                    return false;
                }
                if ( dataObject.warn_ != warn_ )
                {
                    return false;
                }
                if ( dataObject.error_ != error_ )
                {
                    return false;
                }
                if ( dataObject.severe_ != severe_ )
                {
                    return false;
                }
                if ( dataObject.critical_ != critical_ )
                {
                    return false;
                }
                if ( dataObject.alert_ != alert_ )
                {
                    return false;
                }
                if ( dataObject.fatal_ != fatal_ )
                {
                    return false;
                }
                if ( dataObject.emergency_ != emergency_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        Int64 RowVersion( ) const
        {
            return rowVersion_;
        }
        void SetRowVersion( const Int64& rowVersion )
        {
            rowVersion_ = rowVersion;
        }
        const Guid& Application( ) const
        {
            return application_;
        }
        void SetApplication( const Guid& application )
        {
            application_ = application;
        }
        const DateTime& Timestamp( ) const
        {
            return timestamp_;
        }
        void SetTimestamp( const DateTime& timestamp )
        {
            timestamp_ = timestamp;
        }
        bool Finest( ) const
        {
            return finest_;
        }
        void SetFinest( bool finest )
        {
            finest_ = finest;
        }
        bool Finer( ) const
        {
            return finer_;
        }
        void SetFiner( bool finer )
        {
            finer_ = finer;
        }
        bool Fine( ) const
        {
            return fine_;
        }
        void SetFine( bool fine )
        {
            fine_ = fine;
        }
        bool Info( ) const
        {
            return info_;
        }
        void SetInfo( bool info )
        {
            info_ = info;
        }
        bool Notice( ) const
        {
            return notice_;
        }
        void SetNotice( bool notice )
        {
            notice_ = notice;
        }
        bool Warn( ) const
        {
            return warn_;
        }
        void SetWarn( bool warn )
        {
            warn_ = warn;
        }
        bool Error( ) const
        {
            return error_;
        }
        void SetError( bool error )
        {
            error_ = error;
        }
        bool Severe( ) const
        {
            return severe_;
        }
        void SetSevere( bool severe )
        {
            severe_ = severe;
        }
        bool Critical( ) const
        {
            return critical_;
        }
        void SetCritical( bool critical )
        {
            critical_ = critical;
        }
        bool Alert( ) const
        {
            return alert_;
        }
        void SetAlert( bool alert )
        {
            alert_ = alert;
        }
        bool Fatal( ) const
        {
            return fatal_;
        }
        void SetFatal( bool fatal )
        {
            fatal_ = fatal;
        }
        bool Emergency( ) const
        {
            return emergency_;
        }
        void SetEmergency( bool emergency )
        {
            emergency_ = emergency;
        }
    };
    class LogHostData : public BaseData<Kind, Guid>
    {
    public:
        using Base = BaseData<Kind, Guid>;
        static constexpr Kind KIND = Kind::LogHost;
    private:
        Int64 rowVersion_ = 0;
        FixedDBWideString<127> computerName_;
        WideString description_;
        SQLLEN descriptionLength_ = SQL_NULL_DATA;
    public:
        LogHostData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(rowVersion_);
            computerName_.WriteTo( destination );
            destination.Write(description_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(rowVersion_);
            computerName_.ReadFrom( source );
            source.Read(description_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<LogHostData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<LogHostData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const LogHostData& >( other );
                if ( dataObject.rowVersion_ != rowVersion_ )
                {
                    return false;
                }
                if ( dataObject.computerName_ != computerName_ )
                {
                    return false;
                }
                if ( dataObject.description_ != description_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        Int64 RowVersion( ) const
        {
            return rowVersion_;
        }
        void SetRowVersion( const Int64& rowVersion )
        {
            rowVersion_ = rowVersion;
        }
        const FixedDBWideString<127>& ComputerName( ) const
        {
            return computerName_;
        }
        void SetComputerName( const WideString& computerName )
        {
            computerName_ = computerName;
        }
        const WideString& Description( ) const
        {
            return description_;
        }
        void SetDescription( const WideString& description )
        {
            description_ = description;
        }
    };
    class LogHostConfigurationData : public BaseData<Kind, Guid>
    {
    public:
        using Base = BaseData<Kind, Guid>;
        static constexpr Kind KIND = Kind::LogHostConfiguration;
    private:
        Int64 rowVersion_ = 0;
        Guid host_;
        DateTime timestamp_;
        bool finest_ = false;
        bool finer_ = false;
        bool fine_ = false;
        bool info_ = false;
        bool notice_ = false;
        bool warn_ = false;
        bool error_ = false;
        bool severe_ = false;
        bool critical_ = false;
        bool alert_ = false;
        bool fatal_ = false;
        bool emergency_ = false;
    public:
        LogHostConfigurationData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(rowVersion_);
            destination.Write(host_);
            destination.Write(timestamp_);
            destination.Write(finest_);
            destination.Write(finer_);
            destination.Write(fine_);
            destination.Write(info_);
            destination.Write(notice_);
            destination.Write(warn_);
            destination.Write(error_);
            destination.Write(severe_);
            destination.Write(critical_);
            destination.Write(alert_);
            destination.Write(fatal_);
            destination.Write(emergency_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(rowVersion_);
            source.Read(host_);
            source.Read(timestamp_);
            source.Read(finest_);
            source.Read(finer_);
            source.Read(fine_);
            source.Read(info_);
            source.Read(notice_);
            source.Read(warn_);
            source.Read(error_);
            source.Read(severe_);
            source.Read(critical_);
            source.Read(alert_);
            source.Read(fatal_);
            source.Read(emergency_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<LogHostConfigurationData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<LogHostConfigurationData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const LogHostConfigurationData& >( other );
                if ( dataObject.rowVersion_ != rowVersion_ )
                {
                    return false;
                }
                if ( dataObject.host_ != host_ )
                {
                    return false;
                }
                if ( dataObject.timestamp_ != timestamp_ )
                {
                    return false;
                }
                if ( dataObject.finest_ != finest_ )
                {
                    return false;
                }
                if ( dataObject.finer_ != finer_ )
                {
                    return false;
                }
                if ( dataObject.fine_ != fine_ )
                {
                    return false;
                }
                if ( dataObject.info_ != info_ )
                {
                    return false;
                }
                if ( dataObject.notice_ != notice_ )
                {
                    return false;
                }
                if ( dataObject.warn_ != warn_ )
                {
                    return false;
                }
                if ( dataObject.error_ != error_ )
                {
                    return false;
                }
                if ( dataObject.severe_ != severe_ )
                {
                    return false;
                }
                if ( dataObject.critical_ != critical_ )
                {
                    return false;
                }
                if ( dataObject.alert_ != alert_ )
                {
                    return false;
                }
                if ( dataObject.fatal_ != fatal_ )
                {
                    return false;
                }
                if ( dataObject.emergency_ != emergency_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        Int64 RowVersion( ) const
        {
            return rowVersion_;
        }
        void SetRowVersion( const Int64& rowVersion )
        {
            rowVersion_ = rowVersion;
        }
        const Guid& Host( ) const
        {
            return host_;
        }
        void SetHost( const Guid& host )
        {
            host_ = host;
        }
        const DateTime& Timestamp( ) const
        {
            return timestamp_;
        }
        void SetTimestamp( const DateTime& timestamp )
        {
            timestamp_ = timestamp;
        }
        bool Finest( ) const
        {
            return finest_;
        }
        void SetFinest( bool finest )
        {
            finest_ = finest;
        }
        bool Finer( ) const
        {
            return finer_;
        }
        void SetFiner( bool finer )
        {
            finer_ = finer;
        }
        bool Fine( ) const
        {
            return fine_;
        }
        void SetFine( bool fine )
        {
            fine_ = fine;
        }
        bool Info( ) const
        {
            return info_;
        }
        void SetInfo( bool info )
        {
            info_ = info;
        }
        bool Notice( ) const
        {
            return notice_;
        }
        void SetNotice( bool notice )
        {
            notice_ = notice;
        }
        bool Warn( ) const
        {
            return warn_;
        }
        void SetWarn( bool warn )
        {
            warn_ = warn;
        }
        bool Error( ) const
        {
            return error_;
        }
        void SetError( bool error )
        {
            error_ = error;
        }
        bool Severe( ) const
        {
            return severe_;
        }
        void SetSevere( bool severe )
        {
            severe_ = severe;
        }
        bool Critical( ) const
        {
            return critical_;
        }
        void SetCritical( bool critical )
        {
            critical_ = critical;
        }
        bool Alert( ) const
        {
            return alert_;
        }
        void SetAlert( bool alert )
        {
            alert_ = alert;
        }
        bool Fatal( ) const
        {
            return fatal_;
        }
        void SetFatal( bool fatal )
        {
            fatal_ = fatal;
        }
        bool Emergency( ) const
        {
            return emergency_;
        }
        void SetEmergency( bool emergency )
        {
            emergency_ = emergency;
        }
    };
    class LogLocationData : public BaseData<Kind, Guid>
    {
    public:
        using Base = BaseData<Kind, Guid>;
        static constexpr Kind KIND = Kind::LogLocation;
    private:
        Int64 rowVersion_ = 0;
        FixedDBWideString<260> fileName_;
        Int32 lineNumber_ = 0;
        WideString namespace_;
        SQLLEN namespaceLength_ = SQL_NULL_DATA;
        WideString className_;
        SQLLEN classNameLength_ = SQL_NULL_DATA;
        FixedDBWideString<255> methodName_;
    public:
        LogLocationData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(rowVersion_);
            fileName_.WriteTo( destination );
            destination.Write(lineNumber_);
            destination.Write(namespace_);
            destination.Write(className_);
            methodName_.WriteTo( destination );
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(rowVersion_);
            fileName_.ReadFrom( source );
            source.Read(lineNumber_);
            source.Read(namespace_);
            source.Read(className_);
            methodName_.ReadFrom( source );
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<LogLocationData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<LogLocationData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const LogLocationData& >( other );
                if ( dataObject.rowVersion_ != rowVersion_ )
                {
                    return false;
                }
                if ( dataObject.fileName_ != fileName_ )
                {
                    return false;
                }
                if ( dataObject.lineNumber_ != lineNumber_ )
                {
                    return false;
                }
                if ( dataObject.namespace_ != namespace_ )
                {
                    return false;
                }
                if ( dataObject.className_ != className_ )
                {
                    return false;
                }
                if ( dataObject.methodName_ != methodName_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        Int64 RowVersion( ) const
        {
            return rowVersion_;
        }
        void SetRowVersion( const Int64& rowVersion )
        {
            rowVersion_ = rowVersion;
        }
        const FixedDBWideString<260>& FileName( ) const
        {
            return fileName_;
        }
        void SetFileName( const WideString& fileName )
        {
            fileName_ = fileName;
        }
        Int32 LineNumber( ) const
        {
            return lineNumber_;
        }
        void SetLineNumber( Int32 lineNumber )
        {
            lineNumber_ = lineNumber;
        }
        const WideString& Namespace( ) const
        {
            return namespace_;
        }
        void SetNamespace( const WideString& namespace__ )
        {
            namespace_ = namespace__;
        }
        const WideString& ClassName( ) const
        {
            return className_;
        }
        void SetClassName( const WideString& className )
        {
            className_ = className;
        }
        const FixedDBWideString<255>& MethodName( ) const
        {
            return methodName_;
        }
        void SetMethodName( const WideString& methodName )
        {
            methodName_ = methodName;
        }
    };
    class LogProcessData : public BaseData<Kind, Guid>
    {
    public:
        using Base = BaseData<Kind, Guid>;
        static constexpr Kind KIND = Kind::LogProcess;
    private:
        Int64 rowVersion_ = 0;
        Guid application_;
        Guid host_;
        DateTime started_;
        DBDateTime stopped_;
        Int64 processId_ = 0;
        WideString path_;
        SQLLEN pathLength_ = SQL_NULL_DATA;
        FixedDBWideString<127> identity_;
    public:
        LogProcessData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(rowVersion_);
            destination.Write(application_);
            destination.Write(host_);
            destination.Write(started_);
            stopped_.WriteTo( destination );
            destination.Write(processId_);
            destination.Write(path_);
            identity_.WriteTo( destination );
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(rowVersion_);
            source.Read(application_);
            source.Read(host_);
            source.Read(started_);
            stopped_.ReadFrom( source );
            source.Read(processId_);
            source.Read(path_);
            identity_.ReadFrom( source );
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<LogProcessData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<LogProcessData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const LogProcessData& >( other );
                if ( dataObject.rowVersion_ != rowVersion_ )
                {
                    return false;
                }
                if ( dataObject.application_ != application_ )
                {
                    return false;
                }
                if ( dataObject.host_ != host_ )
                {
                    return false;
                }
                if ( dataObject.started_ != started_ )
                {
                    return false;
                }
                if ( dataObject.stopped_ != stopped_ )
                {
                    return false;
                }
                if ( dataObject.processId_ != processId_ )
                {
                    return false;
                }
                if ( dataObject.path_ != path_ )
                {
                    return false;
                }
                if ( dataObject.identity_ != identity_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        Int64 RowVersion( ) const
        {
            return rowVersion_;
        }
        void SetRowVersion( const Int64& rowVersion )
        {
            rowVersion_ = rowVersion;
        }
        const Guid& Application( ) const
        {
            return application_;
        }
        void SetApplication( const Guid& application )
        {
            application_ = application;
        }
        const Guid& Host( ) const
        {
            return host_;
        }
        void SetHost( const Guid& host )
        {
            host_ = host;
        }
        const DateTime& Started( ) const
        {
            return started_;
        }
        void SetStarted( const DateTime& started )
        {
            started_ = started;
        }
        const DBDateTime& Stopped( ) const
        {
            return stopped_;
        }
        void SetStopped( const DBDateTime& stopped )
        {
            stopped_ = stopped;
        }
        Int64 ProcessId( ) const
        {
            return processId_;
        }
        void SetProcessId( Int64 processId )
        {
            processId_ = processId;
        }
        const WideString& Path( ) const
        {
            return path_;
        }
        void SetPath( const WideString& path )
        {
            path_ = path;
        }
        const FixedDBWideString<127>& Identity( ) const
        {
            return identity_;
        }
        void SetIdentity( const WideString& identity )
        {
            identity_ = identity;
        }
    };
    class LogRecordData : public BaseData<Kind, Guid>
    {
    public:
        using Base = BaseData<Kind, Guid>;
        static constexpr Kind KIND = Kind::LogRecord;
    private:
        Int64 rowVersion_ = 0;
        Guid thread_;
        Int64 sequenceNumber_ = 0;
        Data::LogLevel level_ = Data::LogLevel::Unknown;
        DateTime timestamp_;
        Int32 depth_ = 0;
        Guid location_;
        WideString message_;
        SQLLEN messageLength_ = SQL_NULL_DATA;
        WideString exceptionString_;
        SQLLEN exceptionStringLength_ = SQL_NULL_DATA;
        Binary propertiesData_;
        SQLLEN propertiesDataLength_ = SQL_NULL_DATA;
    public:
        LogRecordData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(rowVersion_);
            destination.Write(thread_);
            destination.Write(sequenceNumber_);
            destination.Write(level_);
            destination.Write(timestamp_);
            destination.Write(depth_);
            destination.Write(location_);
            destination.Write(message_);
            destination.Write(exceptionString_);
            destination.Write(propertiesData_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(rowVersion_);
            source.Read(thread_);
            source.Read(sequenceNumber_);
            source.Read(level_);
            source.Read(timestamp_);
            source.Read(depth_);
            source.Read(location_);
            source.Read(message_);
            source.Read(exceptionString_);
            source.Read(propertiesData_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<LogRecordData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<LogRecordData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const LogRecordData& >( other );
                if ( dataObject.rowVersion_ != rowVersion_ )
                {
                    return false;
                }
                if ( dataObject.thread_ != thread_ )
                {
                    return false;
                }
                if ( dataObject.sequenceNumber_ != sequenceNumber_ )
                {
                    return false;
                }
                if ( dataObject.level_ != level_ )
                {
                    return false;
                }
                if ( dataObject.timestamp_ != timestamp_ )
                {
                    return false;
                }
                if ( dataObject.depth_ != depth_ )
                {
                    return false;
                }
                if ( dataObject.location_ != location_ )
                {
                    return false;
                }
                if ( dataObject.message_ != message_ )
                {
                    return false;
                }
                if ( dataObject.exceptionString_ != exceptionString_ )
                {
                    return false;
                }
                if ( dataObject.propertiesData_ != propertiesData_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        Int64 RowVersion( ) const
        {
            return rowVersion_;
        }
        void SetRowVersion( const Int64& rowVersion )
        {
            rowVersion_ = rowVersion;
        }
        const Guid& Thread( ) const
        {
            return thread_;
        }
        void SetThread( const Guid& thread )
        {
            thread_ = thread;
        }
        Int64 SequenceNumber( ) const
        {
            return sequenceNumber_;
        }
        void SetSequenceNumber( Int64 sequenceNumber )
        {
            sequenceNumber_ = sequenceNumber;
        }
        Data::LogLevel Level( ) const
        {
            return level_;
        }
        void SetLevel( Data::LogLevel level )
        {
            level_ = level;
        }
        const DateTime& Timestamp( ) const
        {
            return timestamp_;
        }
        void SetTimestamp( const DateTime& timestamp )
        {
            timestamp_ = timestamp;
        }
        Int32 Depth( ) const
        {
            return depth_;
        }
        void SetDepth( Int32 depth )
        {
            depth_ = depth;
        }
        const Guid& Location( ) const
        {
            return location_;
        }
        void SetLocation( const Guid& location )
        {
            location_ = location;
        }
        const WideString& Message( ) const
        {
            return message_;
        }
        void SetMessage( const WideString& message )
        {
            message_ = message;
        }
        const WideString& ExceptionString( ) const
        {
            return exceptionString_;
        }
        void SetExceptionString( const WideString& exceptionString )
        {
            exceptionString_ = exceptionString;
        }
        const Binary& PropertiesData( ) const
        {
            return propertiesData_;
        }
        void SetPropertiesData( const Binary& propertiesData )
        {
            propertiesData_ = propertiesData;
        }
    };
    class LogThreadData : public BaseData<Kind, Guid>
    {
    public:
        using Base = BaseData<Kind, Guid>;
        static constexpr Kind KIND = Kind::LogThread;
    private:
        Int64 rowVersion_ = 0;
        Guid process_;
        DateTime started_;
        DBDateTime stopped_;
        Int64 threadId_ = 0;
        FixedDBWideString<127> name_;
    public:
        LogThreadData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(rowVersion_);
            destination.Write(process_);
            destination.Write(started_);
            stopped_.WriteTo( destination );
            destination.Write(threadId_);
            name_.WriteTo( destination );
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(rowVersion_);
            source.Read(process_);
            source.Read(started_);
            stopped_.ReadFrom( source );
            source.Read(threadId_);
            name_.ReadFrom( source );
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<LogThreadData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<LogThreadData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const LogThreadData& >( other );
                if ( dataObject.rowVersion_ != rowVersion_ )
                {
                    return false;
                }
                if ( dataObject.process_ != process_ )
                {
                    return false;
                }
                if ( dataObject.started_ != started_ )
                {
                    return false;
                }
                if ( dataObject.stopped_ != stopped_ )
                {
                    return false;
                }
                if ( dataObject.threadId_ != threadId_ )
                {
                    return false;
                }
                if ( dataObject.name_ != name_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        Int64 RowVersion( ) const
        {
            return rowVersion_;
        }
        void SetRowVersion( const Int64& rowVersion )
        {
            rowVersion_ = rowVersion;
        }
        const Guid& Process( ) const
        {
            return process_;
        }
        void SetProcess( const Guid& process )
        {
            process_ = process;
        }
        const DateTime& Started( ) const
        {
            return started_;
        }
        void SetStarted( const DateTime& started )
        {
            started_ = started;
        }
        const DBDateTime& Stopped( ) const
        {
            return stopped_;
        }
        void SetStopped( const DBDateTime& stopped )
        {
            stopped_ = stopped;
        }
        Int64 ThreadId( ) const
        {
            return threadId_;
        }
        void SetThreadId( Int64 threadId )
        {
            threadId_ = threadId;
        }
        const FixedDBWideString<127>& Name( ) const
        {
            return name_;
        }
        void SetName( const WideString& name )
        {
            name_ = name;
        }
    };
    class LogTraceEntryData : public BaseData<Kind, Guid>
    {
    public:
        using Base = BaseData<Kind, Guid>;
        static constexpr Kind KIND = Kind::LogTraceEntry;
    private:
        Int64 rowVersion_ = 0;
        Guid thread_;
        Int64 sequenceNumber_ = 0;
        Guid location_;
        Int32 depth_ = 0;
        DateTime entered_;
        DBDateTime ended_;
    public:
        LogTraceEntryData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(rowVersion_);
            destination.Write(thread_);
            destination.Write(sequenceNumber_);
            destination.Write(location_);
            destination.Write(depth_);
            destination.Write(entered_);
            ended_.WriteTo( destination );
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(rowVersion_);
            source.Read(thread_);
            source.Read(sequenceNumber_);
            source.Read(location_);
            source.Read(depth_);
            source.Read(entered_);
            ended_.ReadFrom( source );
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<LogTraceEntryData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<LogTraceEntryData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const LogTraceEntryData& >( other );
                if ( dataObject.rowVersion_ != rowVersion_ )
                {
                    return false;
                }
                if ( dataObject.thread_ != thread_ )
                {
                    return false;
                }
                if ( dataObject.sequenceNumber_ != sequenceNumber_ )
                {
                    return false;
                }
                if ( dataObject.location_ != location_ )
                {
                    return false;
                }
                if ( dataObject.depth_ != depth_ )
                {
                    return false;
                }
                if ( dataObject.entered_ != entered_ )
                {
                    return false;
                }
                if ( dataObject.ended_ != ended_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        Int64 RowVersion( ) const
        {
            return rowVersion_;
        }
        void SetRowVersion( const Int64& rowVersion )
        {
            rowVersion_ = rowVersion;
        }
        const Guid& Thread( ) const
        {
            return thread_;
        }
        void SetThread( const Guid& thread )
        {
            thread_ = thread;
        }
        Int64 SequenceNumber( ) const
        {
            return sequenceNumber_;
        }
        void SetSequenceNumber( Int64 sequenceNumber )
        {
            sequenceNumber_ = sequenceNumber;
        }
        const Guid& Location( ) const
        {
            return location_;
        }
        void SetLocation( const Guid& location )
        {
            location_ = location;
        }
        Int32 Depth( ) const
        {
            return depth_;
        }
        void SetDepth( Int32 depth )
        {
            depth_ = depth;
        }
        const DateTime& Entered( ) const
        {
            return entered_;
        }
        void SetEntered( const DateTime& entered )
        {
            entered_ = entered;
        }
        const DBDateTime& Ended( ) const
        {
            return ended_;
        }
        void SetEnded( const DBDateTime& ended )
        {
            ended_ = ended;
        }
    };
    class MapElementData : public BaseData<Kind, Guid>
    {
    public:
        using Base = BaseData<Kind, Guid>;
        static constexpr Kind KIND = Kind::MapElement;
    private:
        Int64 rowVersion_ = 0;
        Guid item_;
        Data::MapElementType elementType_ = Data::MapElementType::Unknown;
        double latitude_ = 0.0;
        double longitude_ = 0.0;
        double angle_ = 0.0;
        double left_ = 0.0;
        double top_ = 0.0;
        double width_ = 0.0;
        double height_ = 0.0;
        FixedDBWideString<100> label_;
        Binary data_;
        SQLLEN dataLength_ = SQL_NULL_DATA;
    public:
        MapElementData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(rowVersion_);
            destination.Write(item_);
            destination.Write(elementType_);
            destination.Write(latitude_);
            destination.Write(longitude_);
            destination.Write(angle_);
            destination.Write(left_);
            destination.Write(top_);
            destination.Write(width_);
            destination.Write(height_);
            label_.WriteTo( destination );
            destination.Write(data_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(rowVersion_);
            source.Read(item_);
            source.Read(elementType_);
            source.Read(latitude_);
            source.Read(longitude_);
            source.Read(angle_);
            source.Read(left_);
            source.Read(top_);
            source.Read(width_);
            source.Read(height_);
            label_.ReadFrom( source );
            source.Read(data_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<MapElementData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<MapElementData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const MapElementData& >( other );
                if ( dataObject.rowVersion_ != rowVersion_ )
                {
                    return false;
                }
                if ( dataObject.item_ != item_ )
                {
                    return false;
                }
                if ( dataObject.elementType_ != elementType_ )
                {
                    return false;
                }
                if ( dataObject.latitude_ != latitude_ )
                {
                    return false;
                }
                if ( dataObject.longitude_ != longitude_ )
                {
                    return false;
                }
                if ( dataObject.angle_ != angle_ )
                {
                    return false;
                }
                if ( dataObject.left_ != left_ )
                {
                    return false;
                }
                if ( dataObject.top_ != top_ )
                {
                    return false;
                }
                if ( dataObject.width_ != width_ )
                {
                    return false;
                }
                if ( dataObject.height_ != height_ )
                {
                    return false;
                }
                if ( dataObject.label_ != label_ )
                {
                    return false;
                }
                if ( dataObject.data_ != data_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        Int64 RowVersion( ) const
        {
            return rowVersion_;
        }
        void SetRowVersion( const Int64& rowVersion )
        {
            rowVersion_ = rowVersion;
        }
        const Guid& Item( ) const
        {
            return item_;
        }
        void SetItem( const Guid& item )
        {
            item_ = item;
        }
        Data::MapElementType ElementType( ) const
        {
            return elementType_;
        }
        void SetElementType( Data::MapElementType elementType )
        {
            elementType_ = elementType;
        }
        double Latitude( ) const
        {
            return latitude_;
        }
        void SetLatitude( double latitude )
        {
            latitude_ = latitude;
        }
        double Longitude( ) const
        {
            return longitude_;
        }
        void SetLongitude( double longitude )
        {
            longitude_ = longitude;
        }
        double Angle( ) const
        {
            return angle_;
        }
        void SetAngle( double angle )
        {
            angle_ = angle;
        }
        double Left( ) const
        {
            return left_;
        }
        void SetLeft( double left )
        {
            left_ = left;
        }
        double Top( ) const
        {
            return top_;
        }
        void SetTop( double top )
        {
            top_ = top;
        }
        double Width( ) const
        {
            return width_;
        }
        void SetWidth( double width )
        {
            width_ = width;
        }
        double Height( ) const
        {
            return height_;
        }
        void SetHeight( double height )
        {
            height_ = height;
        }
        const FixedDBWideString<100>& Label( ) const
        {
            return label_;
        }
        void SetLabel( const WideString& label )
        {
            label_ = label;
        }
        const Binary& Data( ) const
        {
            return data_;
        }
        void SetData( const Binary& data )
        {
            data_ = data;
        }
    };
    class MapInfoData : public BaseData<Kind, Guid>
    {
    public:
        using Base = BaseData<Kind, Guid>;
        static constexpr Kind KIND = Kind::MapInfo;
    private:
        Int64 rowVersion_ = 0;
        Int32 scale_ = 0;
        double latitude_ = 0.0;
        double longitude_ = 0.0;
        double northWestLatitude_ = 0.0;
        double northWestLongitude_ = 0.0;
        double southEastLatitude_ = 0.0;
        double southEastLongitude_ = 0.0;
        Binary image_;
        SQLLEN imageLength_ = SQL_NULL_DATA;
    public:
        MapInfoData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(rowVersion_);
            destination.Write(scale_);
            destination.Write(latitude_);
            destination.Write(longitude_);
            destination.Write(northWestLatitude_);
            destination.Write(northWestLongitude_);
            destination.Write(southEastLatitude_);
            destination.Write(southEastLongitude_);
            destination.Write(image_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(rowVersion_);
            source.Read(scale_);
            source.Read(latitude_);
            source.Read(longitude_);
            source.Read(northWestLatitude_);
            source.Read(northWestLongitude_);
            source.Read(southEastLatitude_);
            source.Read(southEastLongitude_);
            source.Read(image_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<MapInfoData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<MapInfoData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const MapInfoData& >( other );
                if ( dataObject.rowVersion_ != rowVersion_ )
                {
                    return false;
                }
                if ( dataObject.scale_ != scale_ )
                {
                    return false;
                }
                if ( dataObject.latitude_ != latitude_ )
                {
                    return false;
                }
                if ( dataObject.longitude_ != longitude_ )
                {
                    return false;
                }
                if ( dataObject.northWestLatitude_ != northWestLatitude_ )
                {
                    return false;
                }
                if ( dataObject.northWestLongitude_ != northWestLongitude_ )
                {
                    return false;
                }
                if ( dataObject.southEastLatitude_ != southEastLatitude_ )
                {
                    return false;
                }
                if ( dataObject.southEastLongitude_ != southEastLongitude_ )
                {
                    return false;
                }
                if ( dataObject.image_ != image_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        Int64 RowVersion( ) const
        {
            return rowVersion_;
        }
        void SetRowVersion( const Int64& rowVersion )
        {
            rowVersion_ = rowVersion;
        }
        Int32 Scale( ) const
        {
            return scale_;
        }
        void SetScale( Int32 scale )
        {
            scale_ = scale;
        }
        double Latitude( ) const
        {
            return latitude_;
        }
        void SetLatitude( double latitude )
        {
            latitude_ = latitude;
        }
        double Longitude( ) const
        {
            return longitude_;
        }
        void SetLongitude( double longitude )
        {
            longitude_ = longitude;
        }
        double NorthWestLatitude( ) const
        {
            return northWestLatitude_;
        }
        void SetNorthWestLatitude( double northWestLatitude )
        {
            northWestLatitude_ = northWestLatitude;
        }
        double NorthWestLongitude( ) const
        {
            return northWestLongitude_;
        }
        void SetNorthWestLongitude( double northWestLongitude )
        {
            northWestLongitude_ = northWestLongitude;
        }
        double SouthEastLatitude( ) const
        {
            return southEastLatitude_;
        }
        void SetSouthEastLatitude( double southEastLatitude )
        {
            southEastLatitude_ = southEastLatitude;
        }
        double SouthEastLongitude( ) const
        {
            return southEastLongitude_;
        }
        void SetSouthEastLongitude( double southEastLongitude )
        {
            southEastLongitude_ = southEastLongitude;
        }
        const Binary& Image( ) const
        {
            return image_;
        }
        void SetImage( const Binary& image )
        {
            image_ = image;
        }
    };
    class MapServiceOptionsData : public BaseData<Kind, Guid>
    {
    public:
        using Base = BaseData<Kind, Guid>;
        static constexpr Kind KIND = Kind::MapServiceOptions;
    private:
        Int64 rowVersion_ = 0;
        DateTime timestamp_;
        FixedDBWideString<127> ipAddress_;
        Int32 port_ = 0;
        double imageScaleFactorX_ = 0.0;
        double imageOffsetX_ = 0.0;
        double imageScaleFactorY_ = 0.0;
        double imageOffsetY_ = 0.0;
    public:
        MapServiceOptionsData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(rowVersion_);
            destination.Write(timestamp_);
            ipAddress_.WriteTo( destination );
            destination.Write(port_);
            destination.Write(imageScaleFactorX_);
            destination.Write(imageOffsetX_);
            destination.Write(imageScaleFactorY_);
            destination.Write(imageOffsetY_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(rowVersion_);
            source.Read(timestamp_);
            ipAddress_.ReadFrom( source );
            source.Read(port_);
            source.Read(imageScaleFactorX_);
            source.Read(imageOffsetX_);
            source.Read(imageScaleFactorY_);
            source.Read(imageOffsetY_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<MapServiceOptionsData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<MapServiceOptionsData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const MapServiceOptionsData& >( other );
                if ( dataObject.rowVersion_ != rowVersion_ )
                {
                    return false;
                }
                if ( dataObject.timestamp_ != timestamp_ )
                {
                    return false;
                }
                if ( dataObject.ipAddress_ != ipAddress_ )
                {
                    return false;
                }
                if ( dataObject.port_ != port_ )
                {
                    return false;
                }
                if ( dataObject.imageScaleFactorX_ != imageScaleFactorX_ )
                {
                    return false;
                }
                if ( dataObject.imageOffsetX_ != imageOffsetX_ )
                {
                    return false;
                }
                if ( dataObject.imageScaleFactorY_ != imageScaleFactorY_ )
                {
                    return false;
                }
                if ( dataObject.imageOffsetY_ != imageOffsetY_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        Int64 RowVersion( ) const
        {
            return rowVersion_;
        }
        void SetRowVersion( const Int64& rowVersion )
        {
            rowVersion_ = rowVersion;
        }
        const DateTime& Timestamp( ) const
        {
            return timestamp_;
        }
        void SetTimestamp( const DateTime& timestamp )
        {
            timestamp_ = timestamp;
        }
        const FixedDBWideString<127>& IpAddress( ) const
        {
            return ipAddress_;
        }
        void SetIpAddress( const WideString& ipAddress )
        {
            ipAddress_ = ipAddress;
        }
        Int32 Port( ) const
        {
            return port_;
        }
        void SetPort( Int32 port )
        {
            port_ = port;
        }
        double ImageScaleFactorX( ) const
        {
            return imageScaleFactorX_;
        }
        void SetImageScaleFactorX( double imageScaleFactorX )
        {
            imageScaleFactorX_ = imageScaleFactorX;
        }
        double ImageOffsetX( ) const
        {
            return imageOffsetX_;
        }
        void SetImageOffsetX( double imageOffsetX )
        {
            imageOffsetX_ = imageOffsetX;
        }
        double ImageScaleFactorY( ) const
        {
            return imageScaleFactorY_;
        }
        void SetImageScaleFactorY( double imageScaleFactorY )
        {
            imageScaleFactorY_ = imageScaleFactorY;
        }
        double ImageOffsetY( ) const
        {
            return imageOffsetY_;
        }
        void SetImageOffsetY( double imageOffsetY )
        {
            imageOffsetY_ = imageOffsetY;
        }
    };
    class MaritimeIdentificationDigitsData : public BaseData<Kind, Guid>
    {
    public:
        using Base = BaseData<Kind, Guid>;
        static constexpr Kind KIND = Kind::MaritimeIdentificationDigits;
    private:
        Int64 rowVersion_ = 0;
        Int32 code_ = 0;
        Guid country_;
    public:
        MaritimeIdentificationDigitsData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(rowVersion_);
            destination.Write(code_);
            destination.Write(country_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(rowVersion_);
            source.Read(code_);
            source.Read(country_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<MaritimeIdentificationDigitsData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<MaritimeIdentificationDigitsData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const MaritimeIdentificationDigitsData& >( other );
                if ( dataObject.rowVersion_ != rowVersion_ )
                {
                    return false;
                }
                if ( dataObject.code_ != code_ )
                {
                    return false;
                }
                if ( dataObject.country_ != country_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        Int64 RowVersion( ) const
        {
            return rowVersion_;
        }
        void SetRowVersion( const Int64& rowVersion )
        {
            rowVersion_ = rowVersion;
        }
        Int32 Code( ) const
        {
            return code_;
        }
        void SetCode( Int32 code )
        {
            code_ = code;
        }
        const Guid& Country( ) const
        {
            return country_;
        }
        void SetCountry( const Guid& country )
        {
            country_ = country;
        }
    };
    class MediaProxySessionData : public BaseData<Kind, Guid>
    {
    public:
        using Base = BaseData<Kind, Guid>;
        static constexpr Kind KIND = Kind::MediaProxySession;
    private:
        Int64 rowVersion_ = 0;
        Guid service_;
        FixedDBWideString<128> name_;
        Guid enabledTimeseries_;
    public:
        MediaProxySessionData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(rowVersion_);
            destination.Write(service_);
            name_.WriteTo( destination );
            destination.Write(enabledTimeseries_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(rowVersion_);
            source.Read(service_);
            name_.ReadFrom( source );
            source.Read(enabledTimeseries_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<MediaProxySessionData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<MediaProxySessionData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const MediaProxySessionData& >( other );
                if ( dataObject.rowVersion_ != rowVersion_ )
                {
                    return false;
                }
                if ( dataObject.service_ != service_ )
                {
                    return false;
                }
                if ( dataObject.name_ != name_ )
                {
                    return false;
                }
                if ( dataObject.enabledTimeseries_ != enabledTimeseries_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        Int64 RowVersion( ) const
        {
            return rowVersion_;
        }
        void SetRowVersion( const Int64& rowVersion )
        {
            rowVersion_ = rowVersion;
        }
        const Guid& Service( ) const
        {
            return service_;
        }
        void SetService( const Guid& service )
        {
            service_ = service;
        }
        const FixedDBWideString<128>& Name( ) const
        {
            return name_;
        }
        void SetName( const WideString& name )
        {
            name_ = name;
        }
        const Guid& EnabledTimeseries( ) const
        {
            return enabledTimeseries_;
        }
        void SetEnabledTimeseries( const Guid& enabledTimeseries )
        {
            enabledTimeseries_ = enabledTimeseries;
        }
    };
    class MediaProxySessionFileData : public BaseData<Kind, Guid>
    {
    public:
        using Base = BaseData<Kind, Guid>;
        static constexpr Kind KIND = Kind::MediaProxySessionFile;
    private:
        Int64 rowVersion_ = 0;
        Guid proxySession_;
        DateTime timestamp_;
        FixedDBWideString<100> streamName_;
    public:
        MediaProxySessionFileData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(rowVersion_);
            destination.Write(proxySession_);
            destination.Write(timestamp_);
            streamName_.WriteTo( destination );
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(rowVersion_);
            source.Read(proxySession_);
            source.Read(timestamp_);
            streamName_.ReadFrom( source );
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<MediaProxySessionFileData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<MediaProxySessionFileData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const MediaProxySessionFileData& >( other );
                if ( dataObject.rowVersion_ != rowVersion_ )
                {
                    return false;
                }
                if ( dataObject.proxySession_ != proxySession_ )
                {
                    return false;
                }
                if ( dataObject.timestamp_ != timestamp_ )
                {
                    return false;
                }
                if ( dataObject.streamName_ != streamName_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        Int64 RowVersion( ) const
        {
            return rowVersion_;
        }
        void SetRowVersion( const Int64& rowVersion )
        {
            rowVersion_ = rowVersion;
        }
        const Guid& ProxySession( ) const
        {
            return proxySession_;
        }
        void SetProxySession( const Guid& proxySession )
        {
            proxySession_ = proxySession;
        }
        const DateTime& Timestamp( ) const
        {
            return timestamp_;
        }
        void SetTimestamp( const DateTime& timestamp )
        {
            timestamp_ = timestamp;
        }
        const FixedDBWideString<100>& StreamName( ) const
        {
            return streamName_;
        }
        void SetStreamName( const WideString& streamName )
        {
            streamName_ = streamName;
        }
    };
    class MediaProxySessionOptionsData : public BaseData<Kind, Guid>
    {
    public:
        using Base = BaseData<Kind, Guid>;
        static constexpr Kind KIND = Kind::MediaProxySessionOptions;
    private:
        Int64 rowVersion_ = 0;
        Guid proxySession_;
        DateTime timestamp_;
        FixedDBWideString<255> sourceStreamUrl_;
        FixedDBWideString<255> streamName_;
        Data::MediaProxySessionMode mode_ = Data::MediaProxySessionMode::Unknown;
        Int32 tunnelOverHTTPPortNumber_ = 0;
        FixedDBWideString<128> username_;
        FixedDBWideString<128> password_;
        Int32 recorderPortNumber_ = 0;
        Data::MediaProxySessionType sessionType_ = Data::MediaProxySessionType::Unknown;
        TimeSpan maxFileTime_;
        TimeSpan maxFileRetention_;
        FixedDBWideString<260> videoDirectory_;
    public:
        MediaProxySessionOptionsData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(rowVersion_);
            destination.Write(proxySession_);
            destination.Write(timestamp_);
            sourceStreamUrl_.WriteTo( destination );
            streamName_.WriteTo( destination );
            destination.Write(mode_);
            destination.Write(tunnelOverHTTPPortNumber_);
            username_.WriteTo( destination );
            password_.WriteTo( destination );
            destination.Write(recorderPortNumber_);
            destination.Write(sessionType_);
            destination.Write(maxFileTime_);
            destination.Write(maxFileRetention_);
            videoDirectory_.WriteTo( destination );
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(rowVersion_);
            source.Read(proxySession_);
            source.Read(timestamp_);
            sourceStreamUrl_.ReadFrom( source );
            streamName_.ReadFrom( source );
            source.Read(mode_);
            source.Read(tunnelOverHTTPPortNumber_);
            username_.ReadFrom( source );
            password_.ReadFrom( source );
            source.Read(recorderPortNumber_);
            source.Read(sessionType_);
            source.Read(maxFileTime_);
            source.Read(maxFileRetention_);
            videoDirectory_.ReadFrom( source );
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<MediaProxySessionOptionsData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<MediaProxySessionOptionsData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const MediaProxySessionOptionsData& >( other );
                if ( dataObject.rowVersion_ != rowVersion_ )
                {
                    return false;
                }
                if ( dataObject.proxySession_ != proxySession_ )
                {
                    return false;
                }
                if ( dataObject.timestamp_ != timestamp_ )
                {
                    return false;
                }
                if ( dataObject.sourceStreamUrl_ != sourceStreamUrl_ )
                {
                    return false;
                }
                if ( dataObject.streamName_ != streamName_ )
                {
                    return false;
                }
                if ( dataObject.mode_ != mode_ )
                {
                    return false;
                }
                if ( dataObject.tunnelOverHTTPPortNumber_ != tunnelOverHTTPPortNumber_ )
                {
                    return false;
                }
                if ( dataObject.username_ != username_ )
                {
                    return false;
                }
                if ( dataObject.password_ != password_ )
                {
                    return false;
                }
                if ( dataObject.recorderPortNumber_ != recorderPortNumber_ )
                {
                    return false;
                }
                if ( dataObject.sessionType_ != sessionType_ )
                {
                    return false;
                }
                if ( dataObject.maxFileTime_ != maxFileTime_ )
                {
                    return false;
                }
                if ( dataObject.maxFileRetention_ != maxFileRetention_ )
                {
                    return false;
                }
                if ( dataObject.videoDirectory_ != videoDirectory_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        Int64 RowVersion( ) const
        {
            return rowVersion_;
        }
        void SetRowVersion( const Int64& rowVersion )
        {
            rowVersion_ = rowVersion;
        }
        const Guid& ProxySession( ) const
        {
            return proxySession_;
        }
        void SetProxySession( const Guid& proxySession )
        {
            proxySession_ = proxySession;
        }
        const DateTime& Timestamp( ) const
        {
            return timestamp_;
        }
        void SetTimestamp( const DateTime& timestamp )
        {
            timestamp_ = timestamp;
        }
        const FixedDBWideString<255>& SourceStreamUrl( ) const
        {
            return sourceStreamUrl_;
        }
        void SetSourceStreamUrl( const WideString& sourceStreamUrl )
        {
            sourceStreamUrl_ = sourceStreamUrl;
        }
        const FixedDBWideString<255>& StreamName( ) const
        {
            return streamName_;
        }
        void SetStreamName( const WideString& streamName )
        {
            streamName_ = streamName;
        }
        Data::MediaProxySessionMode Mode( ) const
        {
            return mode_;
        }
        void SetMode( Data::MediaProxySessionMode mode )
        {
            mode_ = mode;
        }
        Int32 TunnelOverHTTPPortNumber( ) const
        {
            return tunnelOverHTTPPortNumber_;
        }
        void SetTunnelOverHTTPPortNumber( Int32 tunnelOverHTTPPortNumber )
        {
            tunnelOverHTTPPortNumber_ = tunnelOverHTTPPortNumber;
        }
        const FixedDBWideString<128>& Username( ) const
        {
            return username_;
        }
        void SetUsername( const WideString& username )
        {
            username_ = username;
        }
        const FixedDBWideString<128>& Password( ) const
        {
            return password_;
        }
        void SetPassword( const WideString& password )
        {
            password_ = password;
        }
        Int32 RecorderPortNumber( ) const
        {
            return recorderPortNumber_;
        }
        void SetRecorderPortNumber( Int32 recorderPortNumber )
        {
            recorderPortNumber_ = recorderPortNumber;
        }
        Data::MediaProxySessionType SessionType( ) const
        {
            return sessionType_;
        }
        void SetSessionType( Data::MediaProxySessionType sessionType )
        {
            sessionType_ = sessionType;
        }
        const TimeSpan& MaxFileTime( ) const
        {
            return maxFileTime_;
        }
        void SetMaxFileTime( const TimeSpan& maxFileTime )
        {
            maxFileTime_ = maxFileTime;
        }
        const TimeSpan& MaxFileRetention( ) const
        {
            return maxFileRetention_;
        }
        void SetMaxFileRetention( const TimeSpan& maxFileRetention )
        {
            maxFileRetention_ = maxFileRetention;
        }
        const FixedDBWideString<260>& VideoDirectory( ) const
        {
            return videoDirectory_;
        }
        void SetVideoDirectory( const WideString& videoDirectory )
        {
            videoDirectory_ = videoDirectory;
        }
    };
    class MediaServiceData : public BaseData<Kind, Guid>
    {
    public:
        using Base = BaseData<Kind, Guid>;
        static constexpr Kind KIND = Kind::MediaService;
    private:
        Int64 rowVersion_ = 0;
        Guid enabledTimeseries_;
    public:
        MediaServiceData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(rowVersion_);
            destination.Write(enabledTimeseries_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(rowVersion_);
            source.Read(enabledTimeseries_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<MediaServiceData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<MediaServiceData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const MediaServiceData& >( other );
                if ( dataObject.rowVersion_ != rowVersion_ )
                {
                    return false;
                }
                if ( dataObject.enabledTimeseries_ != enabledTimeseries_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        Int64 RowVersion( ) const
        {
            return rowVersion_;
        }
        void SetRowVersion( const Int64& rowVersion )
        {
            rowVersion_ = rowVersion;
        }
        const Guid& EnabledTimeseries( ) const
        {
            return enabledTimeseries_;
        }
        void SetEnabledTimeseries( const Guid& enabledTimeseries )
        {
            enabledTimeseries_ = enabledTimeseries;
        }
    };
    class MediaServiceOptionsData : public BaseData<Kind, Guid>
    {
    public:
        using Base = BaseData<Kind, Guid>;
        static constexpr Kind KIND = Kind::MediaServiceOptions;
    private:
        Int64 rowVersion_ = 0;
        Guid mediaService_;
        DateTime timestamp_;
        Int32 rtspPortNumber_ = 0;
        Int32 httpPortNumber_ = 0;
    public:
        MediaServiceOptionsData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(rowVersion_);
            destination.Write(mediaService_);
            destination.Write(timestamp_);
            destination.Write(rtspPortNumber_);
            destination.Write(httpPortNumber_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(rowVersion_);
            source.Read(mediaService_);
            source.Read(timestamp_);
            source.Read(rtspPortNumber_);
            source.Read(httpPortNumber_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<MediaServiceOptionsData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<MediaServiceOptionsData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const MediaServiceOptionsData& >( other );
                if ( dataObject.rowVersion_ != rowVersion_ )
                {
                    return false;
                }
                if ( dataObject.mediaService_ != mediaService_ )
                {
                    return false;
                }
                if ( dataObject.timestamp_ != timestamp_ )
                {
                    return false;
                }
                if ( dataObject.rtspPortNumber_ != rtspPortNumber_ )
                {
                    return false;
                }
                if ( dataObject.httpPortNumber_ != httpPortNumber_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        Int64 RowVersion( ) const
        {
            return rowVersion_;
        }
        void SetRowVersion( const Int64& rowVersion )
        {
            rowVersion_ = rowVersion;
        }
        const Guid& MediaService( ) const
        {
            return mediaService_;
        }
        void SetMediaService( const Guid& mediaService )
        {
            mediaService_ = mediaService;
        }
        const DateTime& Timestamp( ) const
        {
            return timestamp_;
        }
        void SetTimestamp( const DateTime& timestamp )
        {
            timestamp_ = timestamp;
        }
        Int32 RtspPortNumber( ) const
        {
            return rtspPortNumber_;
        }
        void SetRtspPortNumber( Int32 rtspPortNumber )
        {
            rtspPortNumber_ = rtspPortNumber;
        }
        Int32 HttpPortNumber( ) const
        {
            return httpPortNumber_;
        }
        void SetHttpPortNumber( Int32 httpPortNumber )
        {
            httpPortNumber_ = httpPortNumber;
        }
    };
    class NamespaceElementData : public BaseData<Kind, Guid>
    {
    public:
        using Base = BaseData<Kind, Guid>;
        static constexpr Kind KIND = Kind::NamespaceElement;
    private:
        Int64 rowVersion_ = 0;
        Guid namespace_;
        FixedDBWideString<127> name_;
        WideString description_;
        SQLLEN descriptionLength_ = SQL_NULL_DATA;
    public:
        NamespaceElementData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(rowVersion_);
            destination.Write(namespace_);
            name_.WriteTo( destination );
            destination.Write(description_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(rowVersion_);
            source.Read(namespace_);
            name_.ReadFrom( source );
            source.Read(description_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<NamespaceElementData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<NamespaceElementData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const NamespaceElementData& >( other );
                if ( dataObject.rowVersion_ != rowVersion_ )
                {
                    return false;
                }
                if ( dataObject.namespace_ != namespace_ )
                {
                    return false;
                }
                if ( dataObject.name_ != name_ )
                {
                    return false;
                }
                if ( dataObject.description_ != description_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        Int64 RowVersion( ) const
        {
            return rowVersion_;
        }
        void SetRowVersion( const Int64& rowVersion )
        {
            rowVersion_ = rowVersion;
        }
        const Guid& Namespace( ) const
        {
            return namespace_;
        }
        void SetNamespace( const Guid& namespace__ )
        {
            namespace_ = namespace__;
        }
        const FixedDBWideString<127>& Name( ) const
        {
            return name_;
        }
        void SetName( const WideString& name )
        {
            name_ = name;
        }
        const WideString& Description( ) const
        {
            return description_;
        }
        void SetDescription( const WideString& description )
        {
            description_ = description;
        }
    };
    class ElementTypeData : public NamespaceElementData
    {
    public:
        using Base = NamespaceElementData;
        static constexpr Kind KIND = Kind::ElementType;
    private:
    public:
        ElementTypeData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<ElementTypeData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<ElementTypeData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const ElementTypeData& >( other );
                return true;
            }
            return false;
        }
    };
    class NamespaceData : public NamespaceElementData
    {
    public:
        using Base = NamespaceElementData;
        static constexpr Kind KIND = Kind::Namespace;
    private:
    public:
        NamespaceData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<NamespaceData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<NamespaceData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const NamespaceData& >( other );
                return true;
            }
            return false;
        }
    };
    class OilspillData : public BaseData<Kind, Guid>
    {
    public:
        using Base = BaseData<Kind, Guid>;
        static constexpr Kind KIND = Kind::Oilspill;
    private:
        Int64 rowVersion_ = 0;
        Guid oilSpillDetector_;
        DateTime timestamp_;
        double oilArea_ = 0.0;
        Binary shape_;
        SQLLEN shapeLength_ = SQL_NULL_DATA;
        Binary bSI_;
        SQLLEN bSILength_ = SQL_NULL_DATA;
        Binary oil_;
        SQLLEN oilLength_ = SQL_NULL_DATA;
        Binary trace_;
        SQLLEN traceLength_ = SQL_NULL_DATA;
    public:
        OilspillData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(rowVersion_);
            destination.Write(oilSpillDetector_);
            destination.Write(timestamp_);
            destination.Write(oilArea_);
            destination.Write(shape_);
            destination.Write(bSI_);
            destination.Write(oil_);
            destination.Write(trace_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(rowVersion_);
            source.Read(oilSpillDetector_);
            source.Read(timestamp_);
            source.Read(oilArea_);
            source.Read(shape_);
            source.Read(bSI_);
            source.Read(oil_);
            source.Read(trace_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<OilspillData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<OilspillData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const OilspillData& >( other );
                if ( dataObject.rowVersion_ != rowVersion_ )
                {
                    return false;
                }
                if ( dataObject.oilSpillDetector_ != oilSpillDetector_ )
                {
                    return false;
                }
                if ( dataObject.timestamp_ != timestamp_ )
                {
                    return false;
                }
                if ( dataObject.oilArea_ != oilArea_ )
                {
                    return false;
                }
                if ( dataObject.shape_ != shape_ )
                {
                    return false;
                }
                if ( dataObject.bSI_ != bSI_ )
                {
                    return false;
                }
                if ( dataObject.oil_ != oil_ )
                {
                    return false;
                }
                if ( dataObject.trace_ != trace_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        Int64 RowVersion( ) const
        {
            return rowVersion_;
        }
        void SetRowVersion( const Int64& rowVersion )
        {
            rowVersion_ = rowVersion;
        }
        const Guid& OilSpillDetector( ) const
        {
            return oilSpillDetector_;
        }
        void SetOilSpillDetector( const Guid& oilSpillDetector )
        {
            oilSpillDetector_ = oilSpillDetector;
        }
        const DateTime& Timestamp( ) const
        {
            return timestamp_;
        }
        void SetTimestamp( const DateTime& timestamp )
        {
            timestamp_ = timestamp;
        }
        double OilArea( ) const
        {
            return oilArea_;
        }
        void SetOilArea( double oilArea )
        {
            oilArea_ = oilArea;
        }
        const Binary& Shape( ) const
        {
            return shape_;
        }
        void SetShape( const Binary& shape )
        {
            shape_ = shape;
        }
        const Binary& BSI( ) const
        {
            return bSI_;
        }
        void SetBSI( const Binary& bSI )
        {
            bSI_ = bSI;
        }
        const Binary& Oil( ) const
        {
            return oil_;
        }
        void SetOil( const Binary& oil )
        {
            oil_ = oil;
        }
        const Binary& Trace( ) const
        {
            return trace_;
        }
        void SetTrace( const Binary& trace )
        {
            trace_ = trace;
        }
    };
    class OilspillDetectorCommandData : public BaseData<Kind, Guid>
    {
    public:
        using Base = BaseData<Kind, Guid>;
        static constexpr Kind KIND = Kind::OilspillDetectorCommand;
    private:
        Int64 rowVersion_ = 0;
        Guid oilSpillDetector_;
        DateTime timestamp_;
        Data::DeviceCommandSourceType deviceCommandSourceType_ = Data::DeviceCommandSourceType::Unknown;
        Guid deviceCommandSourceId_;
        Guid reply_;
    public:
        OilspillDetectorCommandData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(rowVersion_);
            destination.Write(oilSpillDetector_);
            destination.Write(timestamp_);
            destination.Write(deviceCommandSourceType_);
            destination.Write(deviceCommandSourceId_);
            destination.Write(reply_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(rowVersion_);
            source.Read(oilSpillDetector_);
            source.Read(timestamp_);
            source.Read(deviceCommandSourceType_);
            source.Read(deviceCommandSourceId_);
            source.Read(reply_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<OilspillDetectorCommandData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<OilspillDetectorCommandData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const OilspillDetectorCommandData& >( other );
                if ( dataObject.rowVersion_ != rowVersion_ )
                {
                    return false;
                }
                if ( dataObject.oilSpillDetector_ != oilSpillDetector_ )
                {
                    return false;
                }
                if ( dataObject.timestamp_ != timestamp_ )
                {
                    return false;
                }
                if ( dataObject.deviceCommandSourceType_ != deviceCommandSourceType_ )
                {
                    return false;
                }
                if ( dataObject.deviceCommandSourceId_ != deviceCommandSourceId_ )
                {
                    return false;
                }
                if ( dataObject.reply_ != reply_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        Int64 RowVersion( ) const
        {
            return rowVersion_;
        }
        void SetRowVersion( const Int64& rowVersion )
        {
            rowVersion_ = rowVersion;
        }
        const Guid& OilSpillDetector( ) const
        {
            return oilSpillDetector_;
        }
        void SetOilSpillDetector( const Guid& oilSpillDetector )
        {
            oilSpillDetector_ = oilSpillDetector;
        }
        const DateTime& Timestamp( ) const
        {
            return timestamp_;
        }
        void SetTimestamp( const DateTime& timestamp )
        {
            timestamp_ = timestamp;
        }
        Data::DeviceCommandSourceType DeviceCommandSourceType( ) const
        {
            return deviceCommandSourceType_;
        }
        void SetDeviceCommandSourceType( Data::DeviceCommandSourceType deviceCommandSourceType )
        {
            deviceCommandSourceType_ = deviceCommandSourceType;
        }
        const Guid& DeviceCommandSourceId( ) const
        {
            return deviceCommandSourceId_;
        }
        void SetDeviceCommandSourceId( const Guid& deviceCommandSourceId )
        {
            deviceCommandSourceId_ = deviceCommandSourceId;
        }
        const Guid& Reply( ) const
        {
            return reply_;
        }
        void SetReply( const Guid& reply )
        {
            reply_ = reply;
        }
    };
    class OilspillDetectorCommandReplyData : public BaseData<Kind, Guid>
    {
    public:
        using Base = BaseData<Kind, Guid>;
        static constexpr Kind KIND = Kind::OilspillDetectorCommandReply;
    private:
        Int64 rowVersion_ = 0;
        Guid oilSpillDetector_;
        DateTime timestamp_;
        Guid command_;
        Data::DeviceCommandReplyStatus status_ = Data::DeviceCommandReplyStatus::Unknown;
        WideString message_;
        SQLLEN messageLength_ = SQL_NULL_DATA;
    public:
        OilspillDetectorCommandReplyData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(rowVersion_);
            destination.Write(oilSpillDetector_);
            destination.Write(timestamp_);
            destination.Write(command_);
            destination.Write(status_);
            destination.Write(message_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(rowVersion_);
            source.Read(oilSpillDetector_);
            source.Read(timestamp_);
            source.Read(command_);
            source.Read(status_);
            source.Read(message_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<OilspillDetectorCommandReplyData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<OilspillDetectorCommandReplyData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const OilspillDetectorCommandReplyData& >( other );
                if ( dataObject.rowVersion_ != rowVersion_ )
                {
                    return false;
                }
                if ( dataObject.oilSpillDetector_ != oilSpillDetector_ )
                {
                    return false;
                }
                if ( dataObject.timestamp_ != timestamp_ )
                {
                    return false;
                }
                if ( dataObject.command_ != command_ )
                {
                    return false;
                }
                if ( dataObject.status_ != status_ )
                {
                    return false;
                }
                if ( dataObject.message_ != message_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        Int64 RowVersion( ) const
        {
            return rowVersion_;
        }
        void SetRowVersion( const Int64& rowVersion )
        {
            rowVersion_ = rowVersion;
        }
        const Guid& OilSpillDetector( ) const
        {
            return oilSpillDetector_;
        }
        void SetOilSpillDetector( const Guid& oilSpillDetector )
        {
            oilSpillDetector_ = oilSpillDetector;
        }
        const DateTime& Timestamp( ) const
        {
            return timestamp_;
        }
        void SetTimestamp( const DateTime& timestamp )
        {
            timestamp_ = timestamp;
        }
        const Guid& Command( ) const
        {
            return command_;
        }
        void SetCommand( const Guid& command )
        {
            command_ = command;
        }
        Data::DeviceCommandReplyStatus Status( ) const
        {
            return status_;
        }
        void SetStatus( Data::DeviceCommandReplyStatus status )
        {
            status_ = status;
        }
        const WideString& Message( ) const
        {
            return message_;
        }
        void SetMessage( const WideString& message )
        {
            message_ = message;
        }
    };
    class OilspillDetectorConfigurationData : public BaseData<Kind, Guid>
    {
    public:
        using Base = BaseData<Kind, Guid>;
        static constexpr Kind KIND = Kind::OilspillDetectorConfiguration;
    private:
        Int64 rowVersion_ = 0;
        Guid oilSpillDetector_;
        DateTime timestamp_;
        double range_ = 0.0;
        double startAngle_ = 0.0;
        double endAngle_ = 0.0;
        double startRange_ = 0.0;
        double endRange_ = 0.0;
        Int32 updateRate_ = 0;
        TimeSpan statusSendTime_;
        bool drawBorder_ = false;
        Binary colors_;
        SQLLEN colorsLength_ = SQL_NULL_DATA;
        bool sendToServer_ = false;
        FixedDBWideString<100> directory_;
        bool transparentWater_ = false;
        bool savePictures_ = false;
        bool sendAsTarget_ = false;
        bool writeLog_ = false;
        FixedDBWideString<100> targetFilePrefix_;
        Guid targetMMSI_;
        double latitude_ = 0.0;
        double longitude_ = 0.0;
        bool testSourceEnabled_ = false;
        FixedDBWideString<100> proxyServer_;
        bool useProxyServer_ = false;
    public:
        OilspillDetectorConfigurationData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(rowVersion_);
            destination.Write(oilSpillDetector_);
            destination.Write(timestamp_);
            destination.Write(range_);
            destination.Write(startAngle_);
            destination.Write(endAngle_);
            destination.Write(startRange_);
            destination.Write(endRange_);
            destination.Write(updateRate_);
            destination.Write(statusSendTime_);
            destination.Write(drawBorder_);
            destination.Write(colors_);
            destination.Write(sendToServer_);
            directory_.WriteTo( destination );
            destination.Write(transparentWater_);
            destination.Write(savePictures_);
            destination.Write(sendAsTarget_);
            destination.Write(writeLog_);
            targetFilePrefix_.WriteTo( destination );
            destination.Write(targetMMSI_);
            destination.Write(latitude_);
            destination.Write(longitude_);
            destination.Write(testSourceEnabled_);
            proxyServer_.WriteTo( destination );
            destination.Write(useProxyServer_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(rowVersion_);
            source.Read(oilSpillDetector_);
            source.Read(timestamp_);
            source.Read(range_);
            source.Read(startAngle_);
            source.Read(endAngle_);
            source.Read(startRange_);
            source.Read(endRange_);
            source.Read(updateRate_);
            source.Read(statusSendTime_);
            source.Read(drawBorder_);
            source.Read(colors_);
            source.Read(sendToServer_);
            directory_.ReadFrom( source );
            source.Read(transparentWater_);
            source.Read(savePictures_);
            source.Read(sendAsTarget_);
            source.Read(writeLog_);
            targetFilePrefix_.ReadFrom( source );
            source.Read(targetMMSI_);
            source.Read(latitude_);
            source.Read(longitude_);
            source.Read(testSourceEnabled_);
            proxyServer_.ReadFrom( source );
            source.Read(useProxyServer_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<OilspillDetectorConfigurationData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<OilspillDetectorConfigurationData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const OilspillDetectorConfigurationData& >( other );
                if ( dataObject.rowVersion_ != rowVersion_ )
                {
                    return false;
                }
                if ( dataObject.oilSpillDetector_ != oilSpillDetector_ )
                {
                    return false;
                }
                if ( dataObject.timestamp_ != timestamp_ )
                {
                    return false;
                }
                if ( dataObject.range_ != range_ )
                {
                    return false;
                }
                if ( dataObject.startAngle_ != startAngle_ )
                {
                    return false;
                }
                if ( dataObject.endAngle_ != endAngle_ )
                {
                    return false;
                }
                if ( dataObject.startRange_ != startRange_ )
                {
                    return false;
                }
                if ( dataObject.endRange_ != endRange_ )
                {
                    return false;
                }
                if ( dataObject.updateRate_ != updateRate_ )
                {
                    return false;
                }
                if ( dataObject.statusSendTime_ != statusSendTime_ )
                {
                    return false;
                }
                if ( dataObject.drawBorder_ != drawBorder_ )
                {
                    return false;
                }
                if ( dataObject.colors_ != colors_ )
                {
                    return false;
                }
                if ( dataObject.sendToServer_ != sendToServer_ )
                {
                    return false;
                }
                if ( dataObject.directory_ != directory_ )
                {
                    return false;
                }
                if ( dataObject.transparentWater_ != transparentWater_ )
                {
                    return false;
                }
                if ( dataObject.savePictures_ != savePictures_ )
                {
                    return false;
                }
                if ( dataObject.sendAsTarget_ != sendAsTarget_ )
                {
                    return false;
                }
                if ( dataObject.writeLog_ != writeLog_ )
                {
                    return false;
                }
                if ( dataObject.targetFilePrefix_ != targetFilePrefix_ )
                {
                    return false;
                }
                if ( dataObject.targetMMSI_ != targetMMSI_ )
                {
                    return false;
                }
                if ( dataObject.latitude_ != latitude_ )
                {
                    return false;
                }
                if ( dataObject.longitude_ != longitude_ )
                {
                    return false;
                }
                if ( dataObject.testSourceEnabled_ != testSourceEnabled_ )
                {
                    return false;
                }
                if ( dataObject.proxyServer_ != proxyServer_ )
                {
                    return false;
                }
                if ( dataObject.useProxyServer_ != useProxyServer_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        Int64 RowVersion( ) const
        {
            return rowVersion_;
        }
        void SetRowVersion( const Int64& rowVersion )
        {
            rowVersion_ = rowVersion;
        }
        const Guid& OilSpillDetector( ) const
        {
            return oilSpillDetector_;
        }
        void SetOilSpillDetector( const Guid& oilSpillDetector )
        {
            oilSpillDetector_ = oilSpillDetector;
        }
        const DateTime& Timestamp( ) const
        {
            return timestamp_;
        }
        void SetTimestamp( const DateTime& timestamp )
        {
            timestamp_ = timestamp;
        }
        double Range( ) const
        {
            return range_;
        }
        void SetRange( double range )
        {
            range_ = range;
        }
        double StartAngle( ) const
        {
            return startAngle_;
        }
        void SetStartAngle( double startAngle )
        {
            startAngle_ = startAngle;
        }
        double EndAngle( ) const
        {
            return endAngle_;
        }
        void SetEndAngle( double endAngle )
        {
            endAngle_ = endAngle;
        }
        double StartRange( ) const
        {
            return startRange_;
        }
        void SetStartRange( double startRange )
        {
            startRange_ = startRange;
        }
        double EndRange( ) const
        {
            return endRange_;
        }
        void SetEndRange( double endRange )
        {
            endRange_ = endRange;
        }
        Int32 UpdateRate( ) const
        {
            return updateRate_;
        }
        void SetUpdateRate( Int32 updateRate )
        {
            updateRate_ = updateRate;
        }
        const TimeSpan& StatusSendTime( ) const
        {
            return statusSendTime_;
        }
        void SetStatusSendTime( const TimeSpan& statusSendTime )
        {
            statusSendTime_ = statusSendTime;
        }
        bool DrawBorder( ) const
        {
            return drawBorder_;
        }
        void SetDrawBorder( bool drawBorder )
        {
            drawBorder_ = drawBorder;
        }
        const Binary& Colors( ) const
        {
            return colors_;
        }
        void SetColors( const Binary& colors )
        {
            colors_ = colors;
        }
        bool SendToServer( ) const
        {
            return sendToServer_;
        }
        void SetSendToServer( bool sendToServer )
        {
            sendToServer_ = sendToServer;
        }
        const FixedDBWideString<100>& Directory( ) const
        {
            return directory_;
        }
        void SetDirectory( const WideString& directory )
        {
            directory_ = directory;
        }
        bool TransparentWater( ) const
        {
            return transparentWater_;
        }
        void SetTransparentWater( bool transparentWater )
        {
            transparentWater_ = transparentWater;
        }
        bool SavePictures( ) const
        {
            return savePictures_;
        }
        void SetSavePictures( bool savePictures )
        {
            savePictures_ = savePictures;
        }
        bool SendAsTarget( ) const
        {
            return sendAsTarget_;
        }
        void SetSendAsTarget( bool sendAsTarget )
        {
            sendAsTarget_ = sendAsTarget;
        }
        bool WriteLog( ) const
        {
            return writeLog_;
        }
        void SetWriteLog( bool writeLog )
        {
            writeLog_ = writeLog;
        }
        const FixedDBWideString<100>& TargetFilePrefix( ) const
        {
            return targetFilePrefix_;
        }
        void SetTargetFilePrefix( const WideString& targetFilePrefix )
        {
            targetFilePrefix_ = targetFilePrefix;
        }
        const Guid& TargetMMSI( ) const
        {
            return targetMMSI_;
        }
        void SetTargetMMSI( const Guid& targetMMSI )
        {
            targetMMSI_ = targetMMSI;
        }
        double Latitude( ) const
        {
            return latitude_;
        }
        void SetLatitude( double latitude )
        {
            latitude_ = latitude;
        }
        double Longitude( ) const
        {
            return longitude_;
        }
        void SetLongitude( double longitude )
        {
            longitude_ = longitude;
        }
        bool TestSourceEnabled( ) const
        {
            return testSourceEnabled_;
        }
        void SetTestSourceEnabled( bool testSourceEnabled )
        {
            testSourceEnabled_ = testSourceEnabled;
        }
        const FixedDBWideString<100>& ProxyServer( ) const
        {
            return proxyServer_;
        }
        void SetProxyServer( const WideString& proxyServer )
        {
            proxyServer_ = proxyServer;
        }
        bool UseProxyServer( ) const
        {
            return useProxyServer_;
        }
        void SetUseProxyServer( bool useProxyServer )
        {
            useProxyServer_ = useProxyServer;
        }
    };
    class Position2DTimeseriesValueData : public BaseData<Kind, Guid>
    {
    public:
        using Base = BaseData<Kind, Guid>;
        static constexpr Kind KIND = Kind::Position2DTimeseriesValue;
    private:
        Int64 rowVersion_ = 0;
        Guid timeseries_;
        DateTime timestamp_;
        DBDouble x_;
        DBDouble y_;
    public:
        Position2DTimeseriesValueData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(rowVersion_);
            destination.Write(timeseries_);
            destination.Write(timestamp_);
            x_.WriteTo( destination );
            y_.WriteTo( destination );
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(rowVersion_);
            source.Read(timeseries_);
            source.Read(timestamp_);
            x_.ReadFrom( source );
            y_.ReadFrom( source );
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<Position2DTimeseriesValueData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<Position2DTimeseriesValueData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const Position2DTimeseriesValueData& >( other );
                if ( dataObject.rowVersion_ != rowVersion_ )
                {
                    return false;
                }
                if ( dataObject.timeseries_ != timeseries_ )
                {
                    return false;
                }
                if ( dataObject.timestamp_ != timestamp_ )
                {
                    return false;
                }
                if ( dataObject.x_ != x_ )
                {
                    return false;
                }
                if ( dataObject.y_ != y_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        Int64 RowVersion( ) const
        {
            return rowVersion_;
        }
        void SetRowVersion( const Int64& rowVersion )
        {
            rowVersion_ = rowVersion;
        }
        const Guid& Timeseries( ) const
        {
            return timeseries_;
        }
        void SetTimeseries( const Guid& timeseries )
        {
            timeseries_ = timeseries;
        }
        const DateTime& Timestamp( ) const
        {
            return timestamp_;
        }
        void SetTimestamp( const DateTime& timestamp )
        {
            timestamp_ = timestamp;
        }
        const DBDouble& X( ) const
        {
            return x_;
        }
        void SetX( const DBDouble& x )
        {
            x_ = x;
        }
        const DBDouble& Y( ) const
        {
            return y_;
        }
        void SetY( const DBDouble& y )
        {
            y_ = y;
        }
    };
    class Position3DTimeseriesValueData : public BaseData<Kind, Guid>
    {
    public:
        using Base = BaseData<Kind, Guid>;
        static constexpr Kind KIND = Kind::Position3DTimeseriesValue;
    private:
        Int64 rowVersion_ = 0;
        Guid timeseries_;
        DateTime timestamp_;
        DBDouble x_;
        DBDouble y_;
        DBDouble z_;
    public:
        Position3DTimeseriesValueData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(rowVersion_);
            destination.Write(timeseries_);
            destination.Write(timestamp_);
            x_.WriteTo( destination );
            y_.WriteTo( destination );
            z_.WriteTo( destination );
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(rowVersion_);
            source.Read(timeseries_);
            source.Read(timestamp_);
            x_.ReadFrom( source );
            y_.ReadFrom( source );
            z_.ReadFrom( source );
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<Position3DTimeseriesValueData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<Position3DTimeseriesValueData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const Position3DTimeseriesValueData& >( other );
                if ( dataObject.rowVersion_ != rowVersion_ )
                {
                    return false;
                }
                if ( dataObject.timeseries_ != timeseries_ )
                {
                    return false;
                }
                if ( dataObject.timestamp_ != timestamp_ )
                {
                    return false;
                }
                if ( dataObject.x_ != x_ )
                {
                    return false;
                }
                if ( dataObject.y_ != y_ )
                {
                    return false;
                }
                if ( dataObject.z_ != z_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        Int64 RowVersion( ) const
        {
            return rowVersion_;
        }
        void SetRowVersion( const Int64& rowVersion )
        {
            rowVersion_ = rowVersion;
        }
        const Guid& Timeseries( ) const
        {
            return timeseries_;
        }
        void SetTimeseries( const Guid& timeseries )
        {
            timeseries_ = timeseries;
        }
        const DateTime& Timestamp( ) const
        {
            return timestamp_;
        }
        void SetTimestamp( const DateTime& timestamp )
        {
            timestamp_ = timestamp;
        }
        const DBDouble& X( ) const
        {
            return x_;
        }
        void SetX( const DBDouble& x )
        {
            x_ = x;
        }
        const DBDouble& Y( ) const
        {
            return y_;
        }
        void SetY( const DBDouble& y )
        {
            y_ = y;
        }
        const DBDouble& Z( ) const
        {
            return z_;
        }
        void SetZ( const DBDouble& z )
        {
            z_ = z;
        }
    };
    class ProcessTrackValueResultData : public BaseData<Kind, Guid>
    {
    public:
        using Base = BaseData<Kind, Guid>;
        static constexpr Kind KIND = Kind::ProcessTrackValueResult;
    private:
        Int64 rowVersion_ = 0;
        bool createdNewTrack_ = false;
        Guid trackId_;
    public:
        ProcessTrackValueResultData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(rowVersion_);
            destination.Write(createdNewTrack_);
            destination.Write(trackId_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(rowVersion_);
            source.Read(createdNewTrack_);
            source.Read(trackId_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<ProcessTrackValueResultData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<ProcessTrackValueResultData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const ProcessTrackValueResultData& >( other );
                if ( dataObject.rowVersion_ != rowVersion_ )
                {
                    return false;
                }
                if ( dataObject.createdNewTrack_ != createdNewTrack_ )
                {
                    return false;
                }
                if ( dataObject.trackId_ != trackId_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        Int64 RowVersion( ) const
        {
            return rowVersion_;
        }
        void SetRowVersion( const Int64& rowVersion )
        {
            rowVersion_ = rowVersion;
        }
        bool CreatedNewTrack( ) const
        {
            return createdNewTrack_;
        }
        void SetCreatedNewTrack( bool createdNewTrack )
        {
            createdNewTrack_ = createdNewTrack;
        }
        const Guid& TrackId( ) const
        {
            return trackId_;
        }
        void SetTrackId( const Guid& trackId )
        {
            trackId_ = trackId;
        }
    };
    class PropertyData : public BaseData<Kind, Guid>
    {
    public:
        using Base = BaseData<Kind, Guid>;
        static constexpr Kind KIND = Kind::Property;
    private:
        Int64 rowVersion_ = 0;
        Guid element_;
        Guid definition_;
    public:
        PropertyData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(rowVersion_);
            destination.Write(element_);
            destination.Write(definition_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(rowVersion_);
            source.Read(element_);
            source.Read(definition_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<PropertyData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<PropertyData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const PropertyData& >( other );
                if ( dataObject.rowVersion_ != rowVersion_ )
                {
                    return false;
                }
                if ( dataObject.element_ != element_ )
                {
                    return false;
                }
                if ( dataObject.definition_ != definition_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        Int64 RowVersion( ) const
        {
            return rowVersion_;
        }
        void SetRowVersion( const Int64& rowVersion )
        {
            rowVersion_ = rowVersion;
        }
        const Guid& Element( ) const
        {
            return element_;
        }
        void SetElement( const Guid& element )
        {
            element_ = element;
        }
        const Guid& Definition( ) const
        {
            return definition_;
        }
        void SetDefinition( const Guid& definition )
        {
            definition_ = definition;
        }
    };
    class BinaryPropertyData : public PropertyData
    {
    public:
        using Base = PropertyData;
        static constexpr Kind KIND = Kind::BinaryProperty;
    private:
        Binary value_;
        SQLLEN valueLength_ = SQL_NULL_DATA;
    public:
        BinaryPropertyData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(value_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(value_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<BinaryPropertyData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<BinaryPropertyData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const BinaryPropertyData& >( other );
                if ( dataObject.value_ != value_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        const Binary& Value( ) const
        {
            return value_;
        }
        void SetValue( const Binary& value )
        {
            value_ = value;
        }
    };
    class BooleanPropertyData : public PropertyData
    {
    public:
        using Base = PropertyData;
        static constexpr Kind KIND = Kind::BooleanProperty;
    private:
        bool value_ = false;
    public:
        BooleanPropertyData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(value_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(value_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<BooleanPropertyData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<BooleanPropertyData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const BooleanPropertyData& >( other );
                if ( dataObject.value_ != value_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        bool Value( ) const
        {
            return value_;
        }
        void SetValue( bool value )
        {
            value_ = value;
        }
    };
    class BytePropertyData : public PropertyData
    {
    public:
        using Base = PropertyData;
        static constexpr Kind KIND = Kind::ByteProperty;
    private:
        Byte value_ = 0;
    public:
        BytePropertyData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(value_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(value_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<BytePropertyData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<BytePropertyData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const BytePropertyData& >( other );
                if ( dataObject.value_ != value_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        Byte Value( ) const
        {
            return value_;
        }
        void SetValue( Byte value )
        {
            value_ = value;
        }
    };
    class DateTimePropertyData : public PropertyData
    {
    public:
        using Base = PropertyData;
        static constexpr Kind KIND = Kind::DateTimeProperty;
    private:
        DateTime value_;
    public:
        DateTimePropertyData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(value_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(value_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<DateTimePropertyData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<DateTimePropertyData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const DateTimePropertyData& >( other );
                if ( dataObject.value_ != value_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        const DateTime& Value( ) const
        {
            return value_;
        }
        void SetValue( const DateTime& value )
        {
            value_ = value;
        }
    };
    class DoublePropertyData : public PropertyData
    {
    public:
        using Base = PropertyData;
        static constexpr Kind KIND = Kind::DoubleProperty;
    private:
        double value_ = 0.0;
    public:
        DoublePropertyData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(value_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(value_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<DoublePropertyData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<DoublePropertyData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const DoublePropertyData& >( other );
                if ( dataObject.value_ != value_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        double Value( ) const
        {
            return value_;
        }
        void SetValue( double value )
        {
            value_ = value;
        }
    };
    class GuidPropertyData : public PropertyData
    {
    public:
        using Base = PropertyData;
        static constexpr Kind KIND = Kind::GuidProperty;
    private:
        Guid value_;
    public:
        GuidPropertyData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(value_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(value_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<GuidPropertyData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<GuidPropertyData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const GuidPropertyData& >( other );
                if ( dataObject.value_ != value_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        const Guid& Value( ) const
        {
            return value_;
        }
        void SetValue( const Guid& value )
        {
            value_ = value;
        }
    };
    class Int16PropertyData : public PropertyData
    {
    public:
        using Base = PropertyData;
        static constexpr Kind KIND = Kind::Int16Property;
    private:
        Int16 value_ = 0;
    public:
        Int16PropertyData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(value_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(value_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<Int16PropertyData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<Int16PropertyData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const Int16PropertyData& >( other );
                if ( dataObject.value_ != value_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        Int16 Value( ) const
        {
            return value_;
        }
        void SetValue( Int16 value )
        {
            value_ = value;
        }
    };
    class Int32PropertyData : public PropertyData
    {
    public:
        using Base = PropertyData;
        static constexpr Kind KIND = Kind::Int32Property;
    private:
        Int32 value_ = 0;
    public:
        Int32PropertyData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(value_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(value_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<Int32PropertyData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<Int32PropertyData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const Int32PropertyData& >( other );
                if ( dataObject.value_ != value_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        Int32 Value( ) const
        {
            return value_;
        }
        void SetValue( Int32 value )
        {
            value_ = value;
        }
    };
    class Int64PropertyData : public PropertyData
    {
    public:
        using Base = PropertyData;
        static constexpr Kind KIND = Kind::Int64Property;
    private:
        Int64 value_ = 0;
    public:
        Int64PropertyData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(value_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(value_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<Int64PropertyData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<Int64PropertyData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const Int64PropertyData& >( other );
                if ( dataObject.value_ != value_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        Int64 Value( ) const
        {
            return value_;
        }
        void SetValue( Int64 value )
        {
            value_ = value;
        }
    };
    class ReferencePropertyData : public PropertyData
    {
    public:
        using Base = PropertyData;
        static constexpr Kind KIND = Kind::ReferenceProperty;
    private:
        Guid value_;
    public:
        ReferencePropertyData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(value_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(value_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<ReferencePropertyData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<ReferencePropertyData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const ReferencePropertyData& >( other );
                if ( dataObject.value_ != value_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        const Guid& Value( ) const
        {
            return value_;
        }
        void SetValue( const Guid& value )
        {
            value_ = value;
        }
    };
    class SBytePropertyData : public PropertyData
    {
    public:
        using Base = PropertyData;
        static constexpr Kind KIND = Kind::SByteProperty;
    private:
        SByte value_ = 0;
    public:
        SBytePropertyData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(value_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(value_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<SBytePropertyData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<SBytePropertyData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const SBytePropertyData& >( other );
                if ( dataObject.value_ != value_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        SByte Value( ) const
        {
            return value_;
        }
        void SetValue( SByte value )
        {
            value_ = value;
        }
    };
    class SinglePropertyData : public PropertyData
    {
    public:
        using Base = PropertyData;
        static constexpr Kind KIND = Kind::SingleProperty;
    private:
        float value_ = 0.0f;
    public:
        SinglePropertyData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(value_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(value_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<SinglePropertyData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<SinglePropertyData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const SinglePropertyData& >( other );
                if ( dataObject.value_ != value_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        float Value( ) const
        {
            return value_;
        }
        void SetValue( float value )
        {
            value_ = value;
        }
    };
    class StringPropertyData : public PropertyData
    {
    public:
        using Base = PropertyData;
        static constexpr Kind KIND = Kind::StringProperty;
    private:
        FixedDBWideString<100> value_;
    public:
        StringPropertyData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            value_.WriteTo( destination );
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            value_.ReadFrom( source );
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<StringPropertyData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<StringPropertyData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const StringPropertyData& >( other );
                if ( dataObject.value_ != value_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        const FixedDBWideString<100>& Value( ) const
        {
            return value_;
        }
        void SetValue( const WideString& value )
        {
            value_ = value;
        }
    };
    class TimeseriesPropertyData : public PropertyData
    {
    public:
        using Base = PropertyData;
        static constexpr Kind KIND = Kind::TimeseriesProperty;
    private:
    public:
        TimeseriesPropertyData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<TimeseriesPropertyData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<TimeseriesPropertyData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const TimeseriesPropertyData& >( other );
                return true;
            }
            return false;
        }
    };
    class BinaryTimeseriesPropertyData : public TimeseriesPropertyData
    {
    public:
        using Base = TimeseriesPropertyData;
        static constexpr Kind KIND = Kind::BinaryTimeseriesProperty;
    private:
        Guid timeseries_;
    public:
        BinaryTimeseriesPropertyData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(timeseries_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(timeseries_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<BinaryTimeseriesPropertyData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<BinaryTimeseriesPropertyData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const BinaryTimeseriesPropertyData& >( other );
                if ( dataObject.timeseries_ != timeseries_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        const Guid& Timeseries( ) const
        {
            return timeseries_;
        }
        void SetTimeseries( const Guid& timeseries )
        {
            timeseries_ = timeseries;
        }
    };
    class BooleanTimeseriesPropertyData : public TimeseriesPropertyData
    {
    public:
        using Base = TimeseriesPropertyData;
        static constexpr Kind KIND = Kind::BooleanTimeseriesProperty;
    private:
        Guid timeseries_;
    public:
        BooleanTimeseriesPropertyData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(timeseries_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(timeseries_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<BooleanTimeseriesPropertyData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<BooleanTimeseriesPropertyData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const BooleanTimeseriesPropertyData& >( other );
                if ( dataObject.timeseries_ != timeseries_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        const Guid& Timeseries( ) const
        {
            return timeseries_;
        }
        void SetTimeseries( const Guid& timeseries )
        {
            timeseries_ = timeseries;
        }
    };
    class ByteTimeseriesPropertyData : public TimeseriesPropertyData
    {
    public:
        using Base = TimeseriesPropertyData;
        static constexpr Kind KIND = Kind::ByteTimeseriesProperty;
    private:
        Guid timeseries_;
    public:
        ByteTimeseriesPropertyData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(timeseries_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(timeseries_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<ByteTimeseriesPropertyData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<ByteTimeseriesPropertyData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const ByteTimeseriesPropertyData& >( other );
                if ( dataObject.timeseries_ != timeseries_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        const Guid& Timeseries( ) const
        {
            return timeseries_;
        }
        void SetTimeseries( const Guid& timeseries )
        {
            timeseries_ = timeseries;
        }
    };
    class DateTimeTimeseriesPropertyData : public TimeseriesPropertyData
    {
    public:
        using Base = TimeseriesPropertyData;
        static constexpr Kind KIND = Kind::DateTimeTimeseriesProperty;
    private:
        Guid timeseries_;
    public:
        DateTimeTimeseriesPropertyData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(timeseries_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(timeseries_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<DateTimeTimeseriesPropertyData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<DateTimeTimeseriesPropertyData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const DateTimeTimeseriesPropertyData& >( other );
                if ( dataObject.timeseries_ != timeseries_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        const Guid& Timeseries( ) const
        {
            return timeseries_;
        }
        void SetTimeseries( const Guid& timeseries )
        {
            timeseries_ = timeseries;
        }
    };
    class DoubleTimeseriesPropertyData : public TimeseriesPropertyData
    {
    public:
        using Base = TimeseriesPropertyData;
        static constexpr Kind KIND = Kind::DoubleTimeseriesProperty;
    private:
        Guid timeseries_;
    public:
        DoubleTimeseriesPropertyData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(timeseries_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(timeseries_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<DoubleTimeseriesPropertyData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<DoubleTimeseriesPropertyData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const DoubleTimeseriesPropertyData& >( other );
                if ( dataObject.timeseries_ != timeseries_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        const Guid& Timeseries( ) const
        {
            return timeseries_;
        }
        void SetTimeseries( const Guid& timeseries )
        {
            timeseries_ = timeseries;
        }
    };
    class GuidTimeseriesPropertyData : public TimeseriesPropertyData
    {
    public:
        using Base = TimeseriesPropertyData;
        static constexpr Kind KIND = Kind::GuidTimeseriesProperty;
    private:
        Guid timeseries_;
    public:
        GuidTimeseriesPropertyData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(timeseries_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(timeseries_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<GuidTimeseriesPropertyData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<GuidTimeseriesPropertyData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const GuidTimeseriesPropertyData& >( other );
                if ( dataObject.timeseries_ != timeseries_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        const Guid& Timeseries( ) const
        {
            return timeseries_;
        }
        void SetTimeseries( const Guid& timeseries )
        {
            timeseries_ = timeseries;
        }
    };
    class Int16TimeseriesPropertyData : public TimeseriesPropertyData
    {
    public:
        using Base = TimeseriesPropertyData;
        static constexpr Kind KIND = Kind::Int16TimeseriesProperty;
    private:
        Guid timeseries_;
    public:
        Int16TimeseriesPropertyData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(timeseries_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(timeseries_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<Int16TimeseriesPropertyData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<Int16TimeseriesPropertyData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const Int16TimeseriesPropertyData& >( other );
                if ( dataObject.timeseries_ != timeseries_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        const Guid& Timeseries( ) const
        {
            return timeseries_;
        }
        void SetTimeseries( const Guid& timeseries )
        {
            timeseries_ = timeseries;
        }
    };
    class Int32TimeseriesPropertyData : public TimeseriesPropertyData
    {
    public:
        using Base = TimeseriesPropertyData;
        static constexpr Kind KIND = Kind::Int32TimeseriesProperty;
    private:
        Guid timeseries_;
    public:
        Int32TimeseriesPropertyData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(timeseries_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(timeseries_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<Int32TimeseriesPropertyData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<Int32TimeseriesPropertyData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const Int32TimeseriesPropertyData& >( other );
                if ( dataObject.timeseries_ != timeseries_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        const Guid& Timeseries( ) const
        {
            return timeseries_;
        }
        void SetTimeseries( const Guid& timeseries )
        {
            timeseries_ = timeseries;
        }
    };
    class Int64TimeseriesPropertyData : public TimeseriesPropertyData
    {
    public:
        using Base = TimeseriesPropertyData;
        static constexpr Kind KIND = Kind::Int64TimeseriesProperty;
    private:
        Guid timeseries_;
    public:
        Int64TimeseriesPropertyData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(timeseries_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(timeseries_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<Int64TimeseriesPropertyData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<Int64TimeseriesPropertyData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const Int64TimeseriesPropertyData& >( other );
                if ( dataObject.timeseries_ != timeseries_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        const Guid& Timeseries( ) const
        {
            return timeseries_;
        }
        void SetTimeseries( const Guid& timeseries )
        {
            timeseries_ = timeseries;
        }
    };
    class ReferenceTimeseriesPropertyData : public TimeseriesPropertyData
    {
    public:
        using Base = TimeseriesPropertyData;
        static constexpr Kind KIND = Kind::ReferenceTimeseriesProperty;
    private:
        Guid timeseries_;
    public:
        ReferenceTimeseriesPropertyData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(timeseries_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(timeseries_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<ReferenceTimeseriesPropertyData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<ReferenceTimeseriesPropertyData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const ReferenceTimeseriesPropertyData& >( other );
                if ( dataObject.timeseries_ != timeseries_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        const Guid& Timeseries( ) const
        {
            return timeseries_;
        }
        void SetTimeseries( const Guid& timeseries )
        {
            timeseries_ = timeseries;
        }
    };
    class SByteTimeseriesPropertyData : public TimeseriesPropertyData
    {
    public:
        using Base = TimeseriesPropertyData;
        static constexpr Kind KIND = Kind::SByteTimeseriesProperty;
    private:
        Guid timeseries_;
    public:
        SByteTimeseriesPropertyData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(timeseries_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(timeseries_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<SByteTimeseriesPropertyData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<SByteTimeseriesPropertyData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const SByteTimeseriesPropertyData& >( other );
                if ( dataObject.timeseries_ != timeseries_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        const Guid& Timeseries( ) const
        {
            return timeseries_;
        }
        void SetTimeseries( const Guid& timeseries )
        {
            timeseries_ = timeseries;
        }
    };
    class SingleTimeseriesPropertyData : public TimeseriesPropertyData
    {
    public:
        using Base = TimeseriesPropertyData;
        static constexpr Kind KIND = Kind::SingleTimeseriesProperty;
    private:
        Guid timeseries_;
    public:
        SingleTimeseriesPropertyData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(timeseries_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(timeseries_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<SingleTimeseriesPropertyData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<SingleTimeseriesPropertyData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const SingleTimeseriesPropertyData& >( other );
                if ( dataObject.timeseries_ != timeseries_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        const Guid& Timeseries( ) const
        {
            return timeseries_;
        }
        void SetTimeseries( const Guid& timeseries )
        {
            timeseries_ = timeseries;
        }
    };
    class StringTimeseriesPropertyData : public TimeseriesPropertyData
    {
    public:
        using Base = TimeseriesPropertyData;
        static constexpr Kind KIND = Kind::StringTimeseriesProperty;
    private:
        Guid timeseries_;
    public:
        StringTimeseriesPropertyData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(timeseries_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(timeseries_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<StringTimeseriesPropertyData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<StringTimeseriesPropertyData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const StringTimeseriesPropertyData& >( other );
                if ( dataObject.timeseries_ != timeseries_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        const Guid& Timeseries( ) const
        {
            return timeseries_;
        }
        void SetTimeseries( const Guid& timeseries )
        {
            timeseries_ = timeseries;
        }
    };
    class TimeSpanTimeseriesPropertyData : public TimeseriesPropertyData
    {
    public:
        using Base = TimeseriesPropertyData;
        static constexpr Kind KIND = Kind::TimeSpanTimeseriesProperty;
    private:
        Guid timeseries_;
    public:
        TimeSpanTimeseriesPropertyData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(timeseries_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(timeseries_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<TimeSpanTimeseriesPropertyData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<TimeSpanTimeseriesPropertyData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const TimeSpanTimeseriesPropertyData& >( other );
                if ( dataObject.timeseries_ != timeseries_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        const Guid& Timeseries( ) const
        {
            return timeseries_;
        }
        void SetTimeseries( const Guid& timeseries )
        {
            timeseries_ = timeseries;
        }
    };
    class UInt16TimeseriesPropertyData : public TimeseriesPropertyData
    {
    public:
        using Base = TimeseriesPropertyData;
        static constexpr Kind KIND = Kind::UInt16TimeseriesProperty;
    private:
        Guid timeseries_;
    public:
        UInt16TimeseriesPropertyData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(timeseries_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(timeseries_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<UInt16TimeseriesPropertyData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<UInt16TimeseriesPropertyData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const UInt16TimeseriesPropertyData& >( other );
                if ( dataObject.timeseries_ != timeseries_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        const Guid& Timeseries( ) const
        {
            return timeseries_;
        }
        void SetTimeseries( const Guid& timeseries )
        {
            timeseries_ = timeseries;
        }
    };
    class UInt32TimeseriesPropertyData : public TimeseriesPropertyData
    {
    public:
        using Base = TimeseriesPropertyData;
        static constexpr Kind KIND = Kind::UInt32TimeseriesProperty;
    private:
        Guid timeseries_;
    public:
        UInt32TimeseriesPropertyData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(timeseries_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(timeseries_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<UInt32TimeseriesPropertyData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<UInt32TimeseriesPropertyData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const UInt32TimeseriesPropertyData& >( other );
                if ( dataObject.timeseries_ != timeseries_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        const Guid& Timeseries( ) const
        {
            return timeseries_;
        }
        void SetTimeseries( const Guid& timeseries )
        {
            timeseries_ = timeseries;
        }
    };
    class UInt64TimeseriesPropertyData : public TimeseriesPropertyData
    {
    public:
        using Base = TimeseriesPropertyData;
        static constexpr Kind KIND = Kind::UInt64TimeseriesProperty;
    private:
        Guid timeseries_;
    public:
        UInt64TimeseriesPropertyData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(timeseries_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(timeseries_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<UInt64TimeseriesPropertyData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<UInt64TimeseriesPropertyData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const UInt64TimeseriesPropertyData& >( other );
                if ( dataObject.timeseries_ != timeseries_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        const Guid& Timeseries( ) const
        {
            return timeseries_;
        }
        void SetTimeseries( const Guid& timeseries )
        {
            timeseries_ = timeseries;
        }
    };
    class TimeSpanPropertyData : public PropertyData
    {
    public:
        using Base = PropertyData;
        static constexpr Kind KIND = Kind::TimeSpanProperty;
    private:
        TimeSpan value_;
    public:
        TimeSpanPropertyData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(value_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(value_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<TimeSpanPropertyData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<TimeSpanPropertyData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const TimeSpanPropertyData& >( other );
                if ( dataObject.value_ != value_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        const TimeSpan& Value( ) const
        {
            return value_;
        }
        void SetValue( const TimeSpan& value )
        {
            value_ = value;
        }
    };
    class UInt16PropertyData : public PropertyData
    {
    public:
        using Base = PropertyData;
        static constexpr Kind KIND = Kind::UInt16Property;
    private:
        UInt16 value_ = 0;
    public:
        UInt16PropertyData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(value_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(value_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<UInt16PropertyData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<UInt16PropertyData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const UInt16PropertyData& >( other );
                if ( dataObject.value_ != value_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        UInt16 Value( ) const
        {
            return value_;
        }
        void SetValue( UInt16 value )
        {
            value_ = value;
        }
    };
    class UInt32PropertyData : public PropertyData
    {
    public:
        using Base = PropertyData;
        static constexpr Kind KIND = Kind::UInt32Property;
    private:
        UInt32 value_ = 0;
    public:
        UInt32PropertyData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(value_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(value_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<UInt32PropertyData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<UInt32PropertyData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const UInt32PropertyData& >( other );
                if ( dataObject.value_ != value_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        UInt32 Value( ) const
        {
            return value_;
        }
        void SetValue( UInt32 value )
        {
            value_ = value;
        }
    };
    class UInt64PropertyData : public PropertyData
    {
    public:
        using Base = PropertyData;
        static constexpr Kind KIND = Kind::UInt64Property;
    private:
        Int64 value_ = 0;
    public:
        UInt64PropertyData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(value_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(value_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<UInt64PropertyData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<UInt64PropertyData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const UInt64PropertyData& >( other );
                if ( dataObject.value_ != value_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        Int64 Value( ) const
        {
            return value_;
        }
        void SetValue( Int64 value )
        {
            value_ = value;
        }
    };
    class PropertyDefinitionData : public BaseData<Kind, Guid>
    {
    public:
        using Base = BaseData<Kind, Guid>;
        static constexpr Kind KIND = Kind::PropertyDefinition;
    private:
        Int64 rowVersion_ = 0;
        Guid elementType_;
        FixedDBWideString<127> name_;
        WideString description_;
        SQLLEN descriptionLength_ = SQL_NULL_DATA;
    public:
        PropertyDefinitionData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(rowVersion_);
            destination.Write(elementType_);
            name_.WriteTo( destination );
            destination.Write(description_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(rowVersion_);
            source.Read(elementType_);
            name_.ReadFrom( source );
            source.Read(description_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<PropertyDefinitionData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<PropertyDefinitionData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const PropertyDefinitionData& >( other );
                if ( dataObject.rowVersion_ != rowVersion_ )
                {
                    return false;
                }
                if ( dataObject.elementType_ != elementType_ )
                {
                    return false;
                }
                if ( dataObject.name_ != name_ )
                {
                    return false;
                }
                if ( dataObject.description_ != description_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        Int64 RowVersion( ) const
        {
            return rowVersion_;
        }
        void SetRowVersion( const Int64& rowVersion )
        {
            rowVersion_ = rowVersion;
        }
        const Guid& ElementType( ) const
        {
            return elementType_;
        }
        void SetElementType( const Guid& elementType )
        {
            elementType_ = elementType;
        }
        const FixedDBWideString<127>& Name( ) const
        {
            return name_;
        }
        void SetName( const WideString& name )
        {
            name_ = name;
        }
        const WideString& Description( ) const
        {
            return description_;
        }
        void SetDescription( const WideString& description )
        {
            description_ = description;
        }
    };
    class BinaryPropertyDefinitionData : public PropertyDefinitionData
    {
    public:
        using Base = PropertyDefinitionData;
        static constexpr Kind KIND = Kind::BinaryPropertyDefinition;
    private:
        Binary defaultValue_;
        SQLLEN defaultValueLength_ = SQL_NULL_DATA;
    public:
        BinaryPropertyDefinitionData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(defaultValue_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(defaultValue_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<BinaryPropertyDefinitionData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<BinaryPropertyDefinitionData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const BinaryPropertyDefinitionData& >( other );
                if ( dataObject.defaultValue_ != defaultValue_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        const Binary& DefaultValue( ) const
        {
            return defaultValue_;
        }
        void SetDefaultValue( const Binary& defaultValue )
        {
            defaultValue_ = defaultValue;
        }
    };
    class BooleanPropertyDefinitionData : public PropertyDefinitionData
    {
    public:
        using Base = PropertyDefinitionData;
        static constexpr Kind KIND = Kind::BooleanPropertyDefinition;
    private:
        bool defaultValue_ = false;
    public:
        BooleanPropertyDefinitionData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(defaultValue_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(defaultValue_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<BooleanPropertyDefinitionData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<BooleanPropertyDefinitionData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const BooleanPropertyDefinitionData& >( other );
                if ( dataObject.defaultValue_ != defaultValue_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        bool DefaultValue( ) const
        {
            return defaultValue_;
        }
        void SetDefaultValue( bool defaultValue )
        {
            defaultValue_ = defaultValue;
        }
    };
    class BytePropertyDefinitionData : public PropertyDefinitionData
    {
    public:
        using Base = PropertyDefinitionData;
        static constexpr Kind KIND = Kind::BytePropertyDefinition;
    private:
        Byte defaultValue_ = 0;
        Byte minValue_ = 0;
        Byte maxValue_ = 0;
    public:
        BytePropertyDefinitionData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(defaultValue_);
            destination.Write(minValue_);
            destination.Write(maxValue_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(defaultValue_);
            source.Read(minValue_);
            source.Read(maxValue_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<BytePropertyDefinitionData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<BytePropertyDefinitionData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const BytePropertyDefinitionData& >( other );
                if ( dataObject.defaultValue_ != defaultValue_ )
                {
                    return false;
                }
                if ( dataObject.minValue_ != minValue_ )
                {
                    return false;
                }
                if ( dataObject.maxValue_ != maxValue_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        Byte DefaultValue( ) const
        {
            return defaultValue_;
        }
        void SetDefaultValue( Byte defaultValue )
        {
            defaultValue_ = defaultValue;
        }
        Byte MinValue( ) const
        {
            return minValue_;
        }
        void SetMinValue( Byte minValue )
        {
            minValue_ = minValue;
        }
        Byte MaxValue( ) const
        {
            return maxValue_;
        }
        void SetMaxValue( Byte maxValue )
        {
            maxValue_ = maxValue;
        }
    };
    class DateTimePropertyDefinitionData : public PropertyDefinitionData
    {
    public:
        using Base = PropertyDefinitionData;
        static constexpr Kind KIND = Kind::DateTimePropertyDefinition;
    private:
        FixedDBWideString<100> defaultValue_;
        FixedDBWideString<100> minValue_;
        FixedDBWideString<100> maxValue_;
    public:
        DateTimePropertyDefinitionData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            defaultValue_.WriteTo( destination );
            minValue_.WriteTo( destination );
            maxValue_.WriteTo( destination );
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            defaultValue_.ReadFrom( source );
            minValue_.ReadFrom( source );
            maxValue_.ReadFrom( source );
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<DateTimePropertyDefinitionData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<DateTimePropertyDefinitionData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const DateTimePropertyDefinitionData& >( other );
                if ( dataObject.defaultValue_ != defaultValue_ )
                {
                    return false;
                }
                if ( dataObject.minValue_ != minValue_ )
                {
                    return false;
                }
                if ( dataObject.maxValue_ != maxValue_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        const FixedDBWideString<100>& DefaultValue( ) const
        {
            return defaultValue_;
        }
        void SetDefaultValue( const WideString& defaultValue )
        {
            defaultValue_ = defaultValue;
        }
        const FixedDBWideString<100>& MinValue( ) const
        {
            return minValue_;
        }
        void SetMinValue( const WideString& minValue )
        {
            minValue_ = minValue;
        }
        const FixedDBWideString<100>& MaxValue( ) const
        {
            return maxValue_;
        }
        void SetMaxValue( const WideString& maxValue )
        {
            maxValue_ = maxValue;
        }
    };
    class DoublePropertyDefinitionData : public PropertyDefinitionData
    {
    public:
        using Base = PropertyDefinitionData;
        static constexpr Kind KIND = Kind::DoublePropertyDefinition;
    private:
        double defaultValue_ = 0.0;
        double minValue_ = 0.0;
        double maxValue_ = 0.0;
    public:
        DoublePropertyDefinitionData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(defaultValue_);
            destination.Write(minValue_);
            destination.Write(maxValue_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(defaultValue_);
            source.Read(minValue_);
            source.Read(maxValue_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<DoublePropertyDefinitionData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<DoublePropertyDefinitionData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const DoublePropertyDefinitionData& >( other );
                if ( dataObject.defaultValue_ != defaultValue_ )
                {
                    return false;
                }
                if ( dataObject.minValue_ != minValue_ )
                {
                    return false;
                }
                if ( dataObject.maxValue_ != maxValue_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        double DefaultValue( ) const
        {
            return defaultValue_;
        }
        void SetDefaultValue( double defaultValue )
        {
            defaultValue_ = defaultValue;
        }
        double MinValue( ) const
        {
            return minValue_;
        }
        void SetMinValue( double minValue )
        {
            minValue_ = minValue;
        }
        double MaxValue( ) const
        {
            return maxValue_;
        }
        void SetMaxValue( double maxValue )
        {
            maxValue_ = maxValue;
        }
    };
    class GuidPropertyDefinitionData : public PropertyDefinitionData
    {
    public:
        using Base = PropertyDefinitionData;
        static constexpr Kind KIND = Kind::GuidPropertyDefinition;
    private:
        Guid defaultValue_;
    public:
        GuidPropertyDefinitionData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(defaultValue_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(defaultValue_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<GuidPropertyDefinitionData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<GuidPropertyDefinitionData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const GuidPropertyDefinitionData& >( other );
                if ( dataObject.defaultValue_ != defaultValue_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        const Guid& DefaultValue( ) const
        {
            return defaultValue_;
        }
        void SetDefaultValue( const Guid& defaultValue )
        {
            defaultValue_ = defaultValue;
        }
    };
    class Int16PropertyDefinitionData : public PropertyDefinitionData
    {
    public:
        using Base = PropertyDefinitionData;
        static constexpr Kind KIND = Kind::Int16PropertyDefinition;
    private:
        Int16 defaultValue_ = 0;
        Int16 minValue_ = 0;
        Int16 maxValue_ = 0;
    public:
        Int16PropertyDefinitionData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(defaultValue_);
            destination.Write(minValue_);
            destination.Write(maxValue_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(defaultValue_);
            source.Read(minValue_);
            source.Read(maxValue_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<Int16PropertyDefinitionData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<Int16PropertyDefinitionData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const Int16PropertyDefinitionData& >( other );
                if ( dataObject.defaultValue_ != defaultValue_ )
                {
                    return false;
                }
                if ( dataObject.minValue_ != minValue_ )
                {
                    return false;
                }
                if ( dataObject.maxValue_ != maxValue_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        Int16 DefaultValue( ) const
        {
            return defaultValue_;
        }
        void SetDefaultValue( Int16 defaultValue )
        {
            defaultValue_ = defaultValue;
        }
        Int16 MinValue( ) const
        {
            return minValue_;
        }
        void SetMinValue( Int16 minValue )
        {
            minValue_ = minValue;
        }
        Int16 MaxValue( ) const
        {
            return maxValue_;
        }
        void SetMaxValue( Int16 maxValue )
        {
            maxValue_ = maxValue;
        }
    };
    class Int32PropertyDefinitionData : public PropertyDefinitionData
    {
    public:
        using Base = PropertyDefinitionData;
        static constexpr Kind KIND = Kind::Int32PropertyDefinition;
    private:
        Int32 defaultValue_ = 0;
        Int32 minValue_ = 0;
        Int32 maxValue_ = 0;
    public:
        Int32PropertyDefinitionData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(defaultValue_);
            destination.Write(minValue_);
            destination.Write(maxValue_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(defaultValue_);
            source.Read(minValue_);
            source.Read(maxValue_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<Int32PropertyDefinitionData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<Int32PropertyDefinitionData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const Int32PropertyDefinitionData& >( other );
                if ( dataObject.defaultValue_ != defaultValue_ )
                {
                    return false;
                }
                if ( dataObject.minValue_ != minValue_ )
                {
                    return false;
                }
                if ( dataObject.maxValue_ != maxValue_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        Int32 DefaultValue( ) const
        {
            return defaultValue_;
        }
        void SetDefaultValue( Int32 defaultValue )
        {
            defaultValue_ = defaultValue;
        }
        Int32 MinValue( ) const
        {
            return minValue_;
        }
        void SetMinValue( Int32 minValue )
        {
            minValue_ = minValue;
        }
        Int32 MaxValue( ) const
        {
            return maxValue_;
        }
        void SetMaxValue( Int32 maxValue )
        {
            maxValue_ = maxValue;
        }
    };
    class Int64PropertyDefinitionData : public PropertyDefinitionData
    {
    public:
        using Base = PropertyDefinitionData;
        static constexpr Kind KIND = Kind::Int64PropertyDefinition;
    private:
        Int64 defaultValue_ = 0;
        Int64 minValue_ = 0;
        Int64 maxValue_ = 0;
    public:
        Int64PropertyDefinitionData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(defaultValue_);
            destination.Write(minValue_);
            destination.Write(maxValue_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(defaultValue_);
            source.Read(minValue_);
            source.Read(maxValue_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<Int64PropertyDefinitionData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<Int64PropertyDefinitionData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const Int64PropertyDefinitionData& >( other );
                if ( dataObject.defaultValue_ != defaultValue_ )
                {
                    return false;
                }
                if ( dataObject.minValue_ != minValue_ )
                {
                    return false;
                }
                if ( dataObject.maxValue_ != maxValue_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        Int64 DefaultValue( ) const
        {
            return defaultValue_;
        }
        void SetDefaultValue( Int64 defaultValue )
        {
            defaultValue_ = defaultValue;
        }
        Int64 MinValue( ) const
        {
            return minValue_;
        }
        void SetMinValue( Int64 minValue )
        {
            minValue_ = minValue;
        }
        Int64 MaxValue( ) const
        {
            return maxValue_;
        }
        void SetMaxValue( Int64 maxValue )
        {
            maxValue_ = maxValue;
        }
    };
    class ReferencePropertyDefinitionData : public PropertyDefinitionData
    {
    public:
        using Base = PropertyDefinitionData;
        static constexpr Kind KIND = Kind::ReferencePropertyDefinition;
    private:
        Guid defaultValue_;
        Guid referencedElementType_;
    public:
        ReferencePropertyDefinitionData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(defaultValue_);
            destination.Write(referencedElementType_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(defaultValue_);
            source.Read(referencedElementType_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<ReferencePropertyDefinitionData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<ReferencePropertyDefinitionData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const ReferencePropertyDefinitionData& >( other );
                if ( dataObject.defaultValue_ != defaultValue_ )
                {
                    return false;
                }
                if ( dataObject.referencedElementType_ != referencedElementType_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        const Guid& DefaultValue( ) const
        {
            return defaultValue_;
        }
        void SetDefaultValue( const Guid& defaultValue )
        {
            defaultValue_ = defaultValue;
        }
        const Guid& ReferencedElementType( ) const
        {
            return referencedElementType_;
        }
        void SetReferencedElementType( const Guid& referencedElementType )
        {
            referencedElementType_ = referencedElementType;
        }
    };
    class SBytePropertyDefinitionData : public PropertyDefinitionData
    {
    public:
        using Base = PropertyDefinitionData;
        static constexpr Kind KIND = Kind::SBytePropertyDefinition;
    private:
        SByte defaultValue_ = 0;
        SByte minValue_ = 0;
        SByte maxValue_ = 0;
    public:
        SBytePropertyDefinitionData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(defaultValue_);
            destination.Write(minValue_);
            destination.Write(maxValue_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(defaultValue_);
            source.Read(minValue_);
            source.Read(maxValue_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<SBytePropertyDefinitionData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<SBytePropertyDefinitionData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const SBytePropertyDefinitionData& >( other );
                if ( dataObject.defaultValue_ != defaultValue_ )
                {
                    return false;
                }
                if ( dataObject.minValue_ != minValue_ )
                {
                    return false;
                }
                if ( dataObject.maxValue_ != maxValue_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        SByte DefaultValue( ) const
        {
            return defaultValue_;
        }
        void SetDefaultValue( SByte defaultValue )
        {
            defaultValue_ = defaultValue;
        }
        SByte MinValue( ) const
        {
            return minValue_;
        }
        void SetMinValue( SByte minValue )
        {
            minValue_ = minValue;
        }
        SByte MaxValue( ) const
        {
            return maxValue_;
        }
        void SetMaxValue( SByte maxValue )
        {
            maxValue_ = maxValue;
        }
    };
    class SinglePropertyDefinitionData : public PropertyDefinitionData
    {
    public:
        using Base = PropertyDefinitionData;
        static constexpr Kind KIND = Kind::SinglePropertyDefinition;
    private:
        float defaultValue_ = 0.0f;
        float minValue_ = 0.0f;
        float maxValue_ = 0.0f;
    public:
        SinglePropertyDefinitionData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(defaultValue_);
            destination.Write(minValue_);
            destination.Write(maxValue_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(defaultValue_);
            source.Read(minValue_);
            source.Read(maxValue_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<SinglePropertyDefinitionData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<SinglePropertyDefinitionData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const SinglePropertyDefinitionData& >( other );
                if ( dataObject.defaultValue_ != defaultValue_ )
                {
                    return false;
                }
                if ( dataObject.minValue_ != minValue_ )
                {
                    return false;
                }
                if ( dataObject.maxValue_ != maxValue_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        float DefaultValue( ) const
        {
            return defaultValue_;
        }
        void SetDefaultValue( float defaultValue )
        {
            defaultValue_ = defaultValue;
        }
        float MinValue( ) const
        {
            return minValue_;
        }
        void SetMinValue( float minValue )
        {
            minValue_ = minValue;
        }
        float MaxValue( ) const
        {
            return maxValue_;
        }
        void SetMaxValue( float maxValue )
        {
            maxValue_ = maxValue;
        }
    };
    class StringPropertyDefinitionData : public PropertyDefinitionData
    {
    public:
        using Base = PropertyDefinitionData;
        static constexpr Kind KIND = Kind::StringPropertyDefinition;
    private:
        FixedDBWideString<100> defaultValue_;
        FixedDBWideString<100> pattern_;
    public:
        StringPropertyDefinitionData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            defaultValue_.WriteTo( destination );
            pattern_.WriteTo( destination );
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            defaultValue_.ReadFrom( source );
            pattern_.ReadFrom( source );
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<StringPropertyDefinitionData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<StringPropertyDefinitionData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const StringPropertyDefinitionData& >( other );
                if ( dataObject.defaultValue_ != defaultValue_ )
                {
                    return false;
                }
                if ( dataObject.pattern_ != pattern_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        const FixedDBWideString<100>& DefaultValue( ) const
        {
            return defaultValue_;
        }
        void SetDefaultValue( const WideString& defaultValue )
        {
            defaultValue_ = defaultValue;
        }
        const FixedDBWideString<100>& Pattern( ) const
        {
            return pattern_;
        }
        void SetPattern( const WideString& pattern )
        {
            pattern_ = pattern;
        }
    };
    class TimeseriesPropertyDefinitionData : public PropertyDefinitionData
    {
    public:
        using Base = PropertyDefinitionData;
        static constexpr Kind KIND = Kind::TimeseriesPropertyDefinition;
    private:
    public:
        TimeseriesPropertyDefinitionData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<TimeseriesPropertyDefinitionData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<TimeseriesPropertyDefinitionData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const TimeseriesPropertyDefinitionData& >( other );
                return true;
            }
            return false;
        }
    };
    class BinaryTimeseriesPropertyDefinitionData : public TimeseriesPropertyDefinitionData
    {
    public:
        using Base = TimeseriesPropertyDefinitionData;
        static constexpr Kind KIND = Kind::BinaryTimeseriesPropertyDefinition;
    private:
    public:
        BinaryTimeseriesPropertyDefinitionData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<BinaryTimeseriesPropertyDefinitionData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<BinaryTimeseriesPropertyDefinitionData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const BinaryTimeseriesPropertyDefinitionData& >( other );
                return true;
            }
            return false;
        }
    };
    class BooleanTimeseriesPropertyDefinitionData : public TimeseriesPropertyDefinitionData
    {
    public:
        using Base = TimeseriesPropertyDefinitionData;
        static constexpr Kind KIND = Kind::BooleanTimeseriesPropertyDefinition;
    private:
    public:
        BooleanTimeseriesPropertyDefinitionData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<BooleanTimeseriesPropertyDefinitionData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<BooleanTimeseriesPropertyDefinitionData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const BooleanTimeseriesPropertyDefinitionData& >( other );
                return true;
            }
            return false;
        }
    };
    class ByteTimeseriesPropertyDefinitionData : public TimeseriesPropertyDefinitionData
    {
    public:
        using Base = TimeseriesPropertyDefinitionData;
        static constexpr Kind KIND = Kind::ByteTimeseriesPropertyDefinition;
    private:
        Byte minValue_ = 0;
        Byte maxValue_ = 0;
    public:
        ByteTimeseriesPropertyDefinitionData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(minValue_);
            destination.Write(maxValue_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(minValue_);
            source.Read(maxValue_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<ByteTimeseriesPropertyDefinitionData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<ByteTimeseriesPropertyDefinitionData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const ByteTimeseriesPropertyDefinitionData& >( other );
                if ( dataObject.minValue_ != minValue_ )
                {
                    return false;
                }
                if ( dataObject.maxValue_ != maxValue_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        Byte MinValue( ) const
        {
            return minValue_;
        }
        void SetMinValue( Byte minValue )
        {
            minValue_ = minValue;
        }
        Byte MaxValue( ) const
        {
            return maxValue_;
        }
        void SetMaxValue( Byte maxValue )
        {
            maxValue_ = maxValue;
        }
    };
    class DateTimeTimeseriesPropertyDefinitionData : public TimeseriesPropertyDefinitionData
    {
    public:
        using Base = TimeseriesPropertyDefinitionData;
        static constexpr Kind KIND = Kind::DateTimeTimeseriesPropertyDefinition;
    private:
        FixedDBWideString<100> minValue_;
        FixedDBWideString<100> maxValue_;
    public:
        DateTimeTimeseriesPropertyDefinitionData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            minValue_.WriteTo( destination );
            maxValue_.WriteTo( destination );
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            minValue_.ReadFrom( source );
            maxValue_.ReadFrom( source );
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<DateTimeTimeseriesPropertyDefinitionData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<DateTimeTimeseriesPropertyDefinitionData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const DateTimeTimeseriesPropertyDefinitionData& >( other );
                if ( dataObject.minValue_ != minValue_ )
                {
                    return false;
                }
                if ( dataObject.maxValue_ != maxValue_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        const FixedDBWideString<100>& MinValue( ) const
        {
            return minValue_;
        }
        void SetMinValue( const WideString& minValue )
        {
            minValue_ = minValue;
        }
        const FixedDBWideString<100>& MaxValue( ) const
        {
            return maxValue_;
        }
        void SetMaxValue( const WideString& maxValue )
        {
            maxValue_ = maxValue;
        }
    };
    class DoubleTimeseriesPropertyDefinitionData : public TimeseriesPropertyDefinitionData
    {
    public:
        using Base = TimeseriesPropertyDefinitionData;
        static constexpr Kind KIND = Kind::DoubleTimeseriesPropertyDefinition;
    private:
        double minValue_ = 0.0;
        double maxValue_ = 0.0;
    public:
        DoubleTimeseriesPropertyDefinitionData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(minValue_);
            destination.Write(maxValue_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(minValue_);
            source.Read(maxValue_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<DoubleTimeseriesPropertyDefinitionData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<DoubleTimeseriesPropertyDefinitionData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const DoubleTimeseriesPropertyDefinitionData& >( other );
                if ( dataObject.minValue_ != minValue_ )
                {
                    return false;
                }
                if ( dataObject.maxValue_ != maxValue_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        double MinValue( ) const
        {
            return minValue_;
        }
        void SetMinValue( double minValue )
        {
            minValue_ = minValue;
        }
        double MaxValue( ) const
        {
            return maxValue_;
        }
        void SetMaxValue( double maxValue )
        {
            maxValue_ = maxValue;
        }
    };
    class GuidTimeseriesPropertyDefinitionData : public TimeseriesPropertyDefinitionData
    {
    public:
        using Base = TimeseriesPropertyDefinitionData;
        static constexpr Kind KIND = Kind::GuidTimeseriesPropertyDefinition;
    private:
    public:
        GuidTimeseriesPropertyDefinitionData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<GuidTimeseriesPropertyDefinitionData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<GuidTimeseriesPropertyDefinitionData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const GuidTimeseriesPropertyDefinitionData& >( other );
                return true;
            }
            return false;
        }
    };
    class Int16TimeseriesPropertyDefinitionData : public TimeseriesPropertyDefinitionData
    {
    public:
        using Base = TimeseriesPropertyDefinitionData;
        static constexpr Kind KIND = Kind::Int16TimeseriesPropertyDefinition;
    private:
        Int16 minValue_ = 0;
        Int16 maxValue_ = 0;
    public:
        Int16TimeseriesPropertyDefinitionData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(minValue_);
            destination.Write(maxValue_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(minValue_);
            source.Read(maxValue_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<Int16TimeseriesPropertyDefinitionData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<Int16TimeseriesPropertyDefinitionData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const Int16TimeseriesPropertyDefinitionData& >( other );
                if ( dataObject.minValue_ != minValue_ )
                {
                    return false;
                }
                if ( dataObject.maxValue_ != maxValue_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        Int16 MinValue( ) const
        {
            return minValue_;
        }
        void SetMinValue( Int16 minValue )
        {
            minValue_ = minValue;
        }
        Int16 MaxValue( ) const
        {
            return maxValue_;
        }
        void SetMaxValue( Int16 maxValue )
        {
            maxValue_ = maxValue;
        }
    };
    class Int32TimeseriesPropertyDefinitionData : public TimeseriesPropertyDefinitionData
    {
    public:
        using Base = TimeseriesPropertyDefinitionData;
        static constexpr Kind KIND = Kind::Int32TimeseriesPropertyDefinition;
    private:
        Int32 minValue_ = 0;
        Int32 maxValue_ = 0;
    public:
        Int32TimeseriesPropertyDefinitionData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(minValue_);
            destination.Write(maxValue_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(minValue_);
            source.Read(maxValue_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<Int32TimeseriesPropertyDefinitionData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<Int32TimeseriesPropertyDefinitionData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const Int32TimeseriesPropertyDefinitionData& >( other );
                if ( dataObject.minValue_ != minValue_ )
                {
                    return false;
                }
                if ( dataObject.maxValue_ != maxValue_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        Int32 MinValue( ) const
        {
            return minValue_;
        }
        void SetMinValue( Int32 minValue )
        {
            minValue_ = minValue;
        }
        Int32 MaxValue( ) const
        {
            return maxValue_;
        }
        void SetMaxValue( Int32 maxValue )
        {
            maxValue_ = maxValue;
        }
    };
    class Int64TimeseriesPropertyDefinitionData : public TimeseriesPropertyDefinitionData
    {
    public:
        using Base = TimeseriesPropertyDefinitionData;
        static constexpr Kind KIND = Kind::Int64TimeseriesPropertyDefinition;
    private:
        Int64 minValue_ = 0;
        Int64 maxValue_ = 0;
    public:
        Int64TimeseriesPropertyDefinitionData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(minValue_);
            destination.Write(maxValue_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(minValue_);
            source.Read(maxValue_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<Int64TimeseriesPropertyDefinitionData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<Int64TimeseriesPropertyDefinitionData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const Int64TimeseriesPropertyDefinitionData& >( other );
                if ( dataObject.minValue_ != minValue_ )
                {
                    return false;
                }
                if ( dataObject.maxValue_ != maxValue_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        Int64 MinValue( ) const
        {
            return minValue_;
        }
        void SetMinValue( Int64 minValue )
        {
            minValue_ = minValue;
        }
        Int64 MaxValue( ) const
        {
            return maxValue_;
        }
        void SetMaxValue( Int64 maxValue )
        {
            maxValue_ = maxValue;
        }
    };
    class ReferenceTimeseriesPropertyDefinitionData : public TimeseriesPropertyDefinitionData
    {
    public:
        using Base = TimeseriesPropertyDefinitionData;
        static constexpr Kind KIND = Kind::ReferenceTimeseriesPropertyDefinition;
    private:
        Guid referencedElementType_;
    public:
        ReferenceTimeseriesPropertyDefinitionData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(referencedElementType_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(referencedElementType_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<ReferenceTimeseriesPropertyDefinitionData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<ReferenceTimeseriesPropertyDefinitionData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const ReferenceTimeseriesPropertyDefinitionData& >( other );
                if ( dataObject.referencedElementType_ != referencedElementType_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        const Guid& ReferencedElementType( ) const
        {
            return referencedElementType_;
        }
        void SetReferencedElementType( const Guid& referencedElementType )
        {
            referencedElementType_ = referencedElementType;
        }
    };
    class SByteTimeseriesPropertyDefinitionData : public TimeseriesPropertyDefinitionData
    {
    public:
        using Base = TimeseriesPropertyDefinitionData;
        static constexpr Kind KIND = Kind::SByteTimeseriesPropertyDefinition;
    private:
        SByte minValue_ = 0;
        SByte maxValue_ = 0;
    public:
        SByteTimeseriesPropertyDefinitionData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(minValue_);
            destination.Write(maxValue_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(minValue_);
            source.Read(maxValue_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<SByteTimeseriesPropertyDefinitionData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<SByteTimeseriesPropertyDefinitionData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const SByteTimeseriesPropertyDefinitionData& >( other );
                if ( dataObject.minValue_ != minValue_ )
                {
                    return false;
                }
                if ( dataObject.maxValue_ != maxValue_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        SByte MinValue( ) const
        {
            return minValue_;
        }
        void SetMinValue( SByte minValue )
        {
            minValue_ = minValue;
        }
        SByte MaxValue( ) const
        {
            return maxValue_;
        }
        void SetMaxValue( SByte maxValue )
        {
            maxValue_ = maxValue;
        }
    };
    class SingleTimeseriesPropertyDefinitionData : public TimeseriesPropertyDefinitionData
    {
    public:
        using Base = TimeseriesPropertyDefinitionData;
        static constexpr Kind KIND = Kind::SingleTimeseriesPropertyDefinition;
    private:
        float minValue_ = 0.0f;
        float maxValue_ = 0.0f;
    public:
        SingleTimeseriesPropertyDefinitionData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(minValue_);
            destination.Write(maxValue_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(minValue_);
            source.Read(maxValue_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<SingleTimeseriesPropertyDefinitionData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<SingleTimeseriesPropertyDefinitionData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const SingleTimeseriesPropertyDefinitionData& >( other );
                if ( dataObject.minValue_ != minValue_ )
                {
                    return false;
                }
                if ( dataObject.maxValue_ != maxValue_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        float MinValue( ) const
        {
            return minValue_;
        }
        void SetMinValue( float minValue )
        {
            minValue_ = minValue;
        }
        float MaxValue( ) const
        {
            return maxValue_;
        }
        void SetMaxValue( float maxValue )
        {
            maxValue_ = maxValue;
        }
    };
    class StringTimeseriesPropertyDefinitionData : public TimeseriesPropertyDefinitionData
    {
    public:
        using Base = TimeseriesPropertyDefinitionData;
        static constexpr Kind KIND = Kind::StringTimeseriesPropertyDefinition;
    private:
        FixedDBWideString<100> pattern_;
    public:
        StringTimeseriesPropertyDefinitionData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            pattern_.WriteTo( destination );
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            pattern_.ReadFrom( source );
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<StringTimeseriesPropertyDefinitionData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<StringTimeseriesPropertyDefinitionData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const StringTimeseriesPropertyDefinitionData& >( other );
                if ( dataObject.pattern_ != pattern_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        const FixedDBWideString<100>& Pattern( ) const
        {
            return pattern_;
        }
        void SetPattern( const WideString& pattern )
        {
            pattern_ = pattern;
        }
    };
    class TimeSpanTimeseriesPropertyDefinitionData : public TimeseriesPropertyDefinitionData
    {
    public:
        using Base = TimeseriesPropertyDefinitionData;
        static constexpr Kind KIND = Kind::TimeSpanTimeseriesPropertyDefinition;
    private:
        TimeSpan minValue_;
        TimeSpan maxValue_;
    public:
        TimeSpanTimeseriesPropertyDefinitionData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(minValue_);
            destination.Write(maxValue_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(minValue_);
            source.Read(maxValue_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<TimeSpanTimeseriesPropertyDefinitionData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<TimeSpanTimeseriesPropertyDefinitionData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const TimeSpanTimeseriesPropertyDefinitionData& >( other );
                if ( dataObject.minValue_ != minValue_ )
                {
                    return false;
                }
                if ( dataObject.maxValue_ != maxValue_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        const TimeSpan& MinValue( ) const
        {
            return minValue_;
        }
        void SetMinValue( const TimeSpan& minValue )
        {
            minValue_ = minValue;
        }
        const TimeSpan& MaxValue( ) const
        {
            return maxValue_;
        }
        void SetMaxValue( const TimeSpan& maxValue )
        {
            maxValue_ = maxValue;
        }
    };
    class UInt16TimeseriesPropertyDefinitionData : public TimeseriesPropertyDefinitionData
    {
    public:
        using Base = TimeseriesPropertyDefinitionData;
        static constexpr Kind KIND = Kind::UInt16TimeseriesPropertyDefinition;
    private:
        UInt16 minValue_ = 0;
        UInt16 maxValue_ = 0;
    public:
        UInt16TimeseriesPropertyDefinitionData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(minValue_);
            destination.Write(maxValue_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(minValue_);
            source.Read(maxValue_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<UInt16TimeseriesPropertyDefinitionData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<UInt16TimeseriesPropertyDefinitionData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const UInt16TimeseriesPropertyDefinitionData& >( other );
                if ( dataObject.minValue_ != minValue_ )
                {
                    return false;
                }
                if ( dataObject.maxValue_ != maxValue_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        UInt16 MinValue( ) const
        {
            return minValue_;
        }
        void SetMinValue( UInt16 minValue )
        {
            minValue_ = minValue;
        }
        UInt16 MaxValue( ) const
        {
            return maxValue_;
        }
        void SetMaxValue( UInt16 maxValue )
        {
            maxValue_ = maxValue;
        }
    };
    class UInt32TimeseriesPropertyDefinitionData : public TimeseriesPropertyDefinitionData
    {
    public:
        using Base = TimeseriesPropertyDefinitionData;
        static constexpr Kind KIND = Kind::UInt32TimeseriesPropertyDefinition;
    private:
        UInt32 minValue_ = 0;
        UInt32 maxValue_ = 0;
    public:
        UInt32TimeseriesPropertyDefinitionData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(minValue_);
            destination.Write(maxValue_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(minValue_);
            source.Read(maxValue_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<UInt32TimeseriesPropertyDefinitionData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<UInt32TimeseriesPropertyDefinitionData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const UInt32TimeseriesPropertyDefinitionData& >( other );
                if ( dataObject.minValue_ != minValue_ )
                {
                    return false;
                }
                if ( dataObject.maxValue_ != maxValue_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        UInt32 MinValue( ) const
        {
            return minValue_;
        }
        void SetMinValue( UInt32 minValue )
        {
            minValue_ = minValue;
        }
        UInt32 MaxValue( ) const
        {
            return maxValue_;
        }
        void SetMaxValue( UInt32 maxValue )
        {
            maxValue_ = maxValue;
        }
    };
    class UInt64TimeseriesPropertyDefinitionData : public TimeseriesPropertyDefinitionData
    {
    public:
        using Base = TimeseriesPropertyDefinitionData;
        static constexpr Kind KIND = Kind::UInt64TimeseriesPropertyDefinition;
    private:
        Int64 minValue_ = 0;
        Int64 maxValue_ = 0;
    public:
        UInt64TimeseriesPropertyDefinitionData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(minValue_);
            destination.Write(maxValue_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(minValue_);
            source.Read(maxValue_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<UInt64TimeseriesPropertyDefinitionData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<UInt64TimeseriesPropertyDefinitionData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const UInt64TimeseriesPropertyDefinitionData& >( other );
                if ( dataObject.minValue_ != minValue_ )
                {
                    return false;
                }
                if ( dataObject.maxValue_ != maxValue_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        Int64 MinValue( ) const
        {
            return minValue_;
        }
        void SetMinValue( Int64 minValue )
        {
            minValue_ = minValue;
        }
        Int64 MaxValue( ) const
        {
            return maxValue_;
        }
        void SetMaxValue( Int64 maxValue )
        {
            maxValue_ = maxValue;
        }
    };
    class TimeSpanPropertyDefinitionData : public PropertyDefinitionData
    {
    public:
        using Base = PropertyDefinitionData;
        static constexpr Kind KIND = Kind::TimeSpanPropertyDefinition;
    private:
        TimeSpan defaultValue_;
        TimeSpan minValue_;
        TimeSpan maxValue_;
    public:
        TimeSpanPropertyDefinitionData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(defaultValue_);
            destination.Write(minValue_);
            destination.Write(maxValue_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(defaultValue_);
            source.Read(minValue_);
            source.Read(maxValue_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<TimeSpanPropertyDefinitionData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<TimeSpanPropertyDefinitionData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const TimeSpanPropertyDefinitionData& >( other );
                if ( dataObject.defaultValue_ != defaultValue_ )
                {
                    return false;
                }
                if ( dataObject.minValue_ != minValue_ )
                {
                    return false;
                }
                if ( dataObject.maxValue_ != maxValue_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        const TimeSpan& DefaultValue( ) const
        {
            return defaultValue_;
        }
        void SetDefaultValue( const TimeSpan& defaultValue )
        {
            defaultValue_ = defaultValue;
        }
        const TimeSpan& MinValue( ) const
        {
            return minValue_;
        }
        void SetMinValue( const TimeSpan& minValue )
        {
            minValue_ = minValue;
        }
        const TimeSpan& MaxValue( ) const
        {
            return maxValue_;
        }
        void SetMaxValue( const TimeSpan& maxValue )
        {
            maxValue_ = maxValue;
        }
    };
    class UInt16PropertyDefinitionData : public PropertyDefinitionData
    {
    public:
        using Base = PropertyDefinitionData;
        static constexpr Kind KIND = Kind::UInt16PropertyDefinition;
    private:
        UInt16 defaultValue_ = 0;
        UInt16 minValue_ = 0;
        UInt16 maxValue_ = 0;
    public:
        UInt16PropertyDefinitionData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(defaultValue_);
            destination.Write(minValue_);
            destination.Write(maxValue_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(defaultValue_);
            source.Read(minValue_);
            source.Read(maxValue_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<UInt16PropertyDefinitionData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<UInt16PropertyDefinitionData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const UInt16PropertyDefinitionData& >( other );
                if ( dataObject.defaultValue_ != defaultValue_ )
                {
                    return false;
                }
                if ( dataObject.minValue_ != minValue_ )
                {
                    return false;
                }
                if ( dataObject.maxValue_ != maxValue_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        UInt16 DefaultValue( ) const
        {
            return defaultValue_;
        }
        void SetDefaultValue( UInt16 defaultValue )
        {
            defaultValue_ = defaultValue;
        }
        UInt16 MinValue( ) const
        {
            return minValue_;
        }
        void SetMinValue( UInt16 minValue )
        {
            minValue_ = minValue;
        }
        UInt16 MaxValue( ) const
        {
            return maxValue_;
        }
        void SetMaxValue( UInt16 maxValue )
        {
            maxValue_ = maxValue;
        }
    };
    class UInt32PropertyDefinitionData : public PropertyDefinitionData
    {
    public:
        using Base = PropertyDefinitionData;
        static constexpr Kind KIND = Kind::UInt32PropertyDefinition;
    private:
        UInt32 defaultValue_ = 0;
        UInt32 minValue_ = 0;
        UInt32 maxValue_ = 0;
    public:
        UInt32PropertyDefinitionData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(defaultValue_);
            destination.Write(minValue_);
            destination.Write(maxValue_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(defaultValue_);
            source.Read(minValue_);
            source.Read(maxValue_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<UInt32PropertyDefinitionData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<UInt32PropertyDefinitionData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const UInt32PropertyDefinitionData& >( other );
                if ( dataObject.defaultValue_ != defaultValue_ )
                {
                    return false;
                }
                if ( dataObject.minValue_ != minValue_ )
                {
                    return false;
                }
                if ( dataObject.maxValue_ != maxValue_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        UInt32 DefaultValue( ) const
        {
            return defaultValue_;
        }
        void SetDefaultValue( UInt32 defaultValue )
        {
            defaultValue_ = defaultValue;
        }
        UInt32 MinValue( ) const
        {
            return minValue_;
        }
        void SetMinValue( UInt32 minValue )
        {
            minValue_ = minValue;
        }
        UInt32 MaxValue( ) const
        {
            return maxValue_;
        }
        void SetMaxValue( UInt32 maxValue )
        {
            maxValue_ = maxValue;
        }
    };
    class UInt64PropertyDefinitionData : public PropertyDefinitionData
    {
    public:
        using Base = PropertyDefinitionData;
        static constexpr Kind KIND = Kind::UInt64PropertyDefinition;
    private:
        Int64 defaultValue_ = 0;
        Int64 minValue_ = 0;
        Int64 maxValue_ = 0;
    public:
        UInt64PropertyDefinitionData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(defaultValue_);
            destination.Write(minValue_);
            destination.Write(maxValue_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(defaultValue_);
            source.Read(minValue_);
            source.Read(maxValue_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<UInt64PropertyDefinitionData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<UInt64PropertyDefinitionData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const UInt64PropertyDefinitionData& >( other );
                if ( dataObject.defaultValue_ != defaultValue_ )
                {
                    return false;
                }
                if ( dataObject.minValue_ != minValue_ )
                {
                    return false;
                }
                if ( dataObject.maxValue_ != maxValue_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        Int64 DefaultValue( ) const
        {
            return defaultValue_;
        }
        void SetDefaultValue( Int64 defaultValue )
        {
            defaultValue_ = defaultValue;
        }
        Int64 MinValue( ) const
        {
            return minValue_;
        }
        void SetMinValue( Int64 minValue )
        {
            minValue_ = minValue;
        }
        Int64 MaxValue( ) const
        {
            return maxValue_;
        }
        void SetMaxValue( Int64 maxValue )
        {
            maxValue_ = maxValue;
        }
    };
    class RadarAlarmStatusData : public BaseData<Kind, Guid>
    {
    public:
        using Base = BaseData<Kind, Guid>;
        static constexpr Kind KIND = Kind::RadarAlarmStatus;
    private:
        Int64 rowVersion_ = 0;
        Guid radar_;
        DateTime timestamp_;
        Data::AlarmState type_ = Data::AlarmState::Unknown;
    public:
        RadarAlarmStatusData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(rowVersion_);
            destination.Write(radar_);
            destination.Write(timestamp_);
            destination.Write(type_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(rowVersion_);
            source.Read(radar_);
            source.Read(timestamp_);
            source.Read(type_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<RadarAlarmStatusData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<RadarAlarmStatusData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const RadarAlarmStatusData& >( other );
                if ( dataObject.rowVersion_ != rowVersion_ )
                {
                    return false;
                }
                if ( dataObject.radar_ != radar_ )
                {
                    return false;
                }
                if ( dataObject.timestamp_ != timestamp_ )
                {
                    return false;
                }
                if ( dataObject.type_ != type_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        Int64 RowVersion( ) const
        {
            return rowVersion_;
        }
        void SetRowVersion( const Int64& rowVersion )
        {
            rowVersion_ = rowVersion;
        }
        const Guid& Radar( ) const
        {
            return radar_;
        }
        void SetRadar( const Guid& radar )
        {
            radar_ = radar;
        }
        const DateTime& Timestamp( ) const
        {
            return timestamp_;
        }
        void SetTimestamp( const DateTime& timestamp )
        {
            timestamp_ = timestamp;
        }
        Data::AlarmState Type( ) const
        {
            return type_;
        }
        void SetType( Data::AlarmState type )
        {
            type_ = type;
        }
    };
    class RadarCommandData : public BaseData<Kind, Guid>
    {
    public:
        using Base = BaseData<Kind, Guid>;
        static constexpr Kind KIND = Kind::RadarCommand;
    private:
        Int64 rowVersion_ = 0;
        Guid radar_;
        DateTime timestamp_;
        Data::DeviceCommandSourceType deviceCommandSourceType_ = Data::DeviceCommandSourceType::Unknown;
        Guid deviceCommandSourceId_;
        Guid reply_;
    public:
        RadarCommandData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(rowVersion_);
            destination.Write(radar_);
            destination.Write(timestamp_);
            destination.Write(deviceCommandSourceType_);
            destination.Write(deviceCommandSourceId_);
            destination.Write(reply_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(rowVersion_);
            source.Read(radar_);
            source.Read(timestamp_);
            source.Read(deviceCommandSourceType_);
            source.Read(deviceCommandSourceId_);
            source.Read(reply_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<RadarCommandData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<RadarCommandData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const RadarCommandData& >( other );
                if ( dataObject.rowVersion_ != rowVersion_ )
                {
                    return false;
                }
                if ( dataObject.radar_ != radar_ )
                {
                    return false;
                }
                if ( dataObject.timestamp_ != timestamp_ )
                {
                    return false;
                }
                if ( dataObject.deviceCommandSourceType_ != deviceCommandSourceType_ )
                {
                    return false;
                }
                if ( dataObject.deviceCommandSourceId_ != deviceCommandSourceId_ )
                {
                    return false;
                }
                if ( dataObject.reply_ != reply_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        Int64 RowVersion( ) const
        {
            return rowVersion_;
        }
        void SetRowVersion( const Int64& rowVersion )
        {
            rowVersion_ = rowVersion;
        }
        const Guid& Radar( ) const
        {
            return radar_;
        }
        void SetRadar( const Guid& radar )
        {
            radar_ = radar;
        }
        const DateTime& Timestamp( ) const
        {
            return timestamp_;
        }
        void SetTimestamp( const DateTime& timestamp )
        {
            timestamp_ = timestamp;
        }
        Data::DeviceCommandSourceType DeviceCommandSourceType( ) const
        {
            return deviceCommandSourceType_;
        }
        void SetDeviceCommandSourceType( Data::DeviceCommandSourceType deviceCommandSourceType )
        {
            deviceCommandSourceType_ = deviceCommandSourceType;
        }
        const Guid& DeviceCommandSourceId( ) const
        {
            return deviceCommandSourceId_;
        }
        void SetDeviceCommandSourceId( const Guid& deviceCommandSourceId )
        {
            deviceCommandSourceId_ = deviceCommandSourceId;
        }
        const Guid& Reply( ) const
        {
            return reply_;
        }
        void SetReply( const Guid& reply )
        {
            reply_ = reply;
        }
    };
    class RadarCommandGetStatusData : public RadarCommandData
    {
    public:
        using Base = RadarCommandData;
        static constexpr Kind KIND = Kind::RadarCommandGetStatus;
    private:
    public:
        RadarCommandGetStatusData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<RadarCommandGetStatusData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<RadarCommandGetStatusData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const RadarCommandGetStatusData& >( other );
                return true;
            }
            return false;
        }
    };
    class RadarCommandReplyData : public BaseData<Kind, Guid>
    {
    public:
        using Base = BaseData<Kind, Guid>;
        static constexpr Kind KIND = Kind::RadarCommandReply;
    private:
        Int64 rowVersion_ = 0;
        Guid radar_;
        DateTime timestamp_;
        Guid command_;
        Data::DeviceCommandReplyStatus status_ = Data::DeviceCommandReplyStatus::Unknown;
        WideString message_;
        SQLLEN messageLength_ = SQL_NULL_DATA;
    public:
        RadarCommandReplyData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(rowVersion_);
            destination.Write(radar_);
            destination.Write(timestamp_);
            destination.Write(command_);
            destination.Write(status_);
            destination.Write(message_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(rowVersion_);
            source.Read(radar_);
            source.Read(timestamp_);
            source.Read(command_);
            source.Read(status_);
            source.Read(message_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<RadarCommandReplyData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<RadarCommandReplyData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const RadarCommandReplyData& >( other );
                if ( dataObject.rowVersion_ != rowVersion_ )
                {
                    return false;
                }
                if ( dataObject.radar_ != radar_ )
                {
                    return false;
                }
                if ( dataObject.timestamp_ != timestamp_ )
                {
                    return false;
                }
                if ( dataObject.command_ != command_ )
                {
                    return false;
                }
                if ( dataObject.status_ != status_ )
                {
                    return false;
                }
                if ( dataObject.message_ != message_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        Int64 RowVersion( ) const
        {
            return rowVersion_;
        }
        void SetRowVersion( const Int64& rowVersion )
        {
            rowVersion_ = rowVersion;
        }
        const Guid& Radar( ) const
        {
            return radar_;
        }
        void SetRadar( const Guid& radar )
        {
            radar_ = radar;
        }
        const DateTime& Timestamp( ) const
        {
            return timestamp_;
        }
        void SetTimestamp( const DateTime& timestamp )
        {
            timestamp_ = timestamp;
        }
        const Guid& Command( ) const
        {
            return command_;
        }
        void SetCommand( const Guid& command )
        {
            command_ = command;
        }
        Data::DeviceCommandReplyStatus Status( ) const
        {
            return status_;
        }
        void SetStatus( Data::DeviceCommandReplyStatus status )
        {
            status_ = status;
        }
        const WideString& Message( ) const
        {
            return message_;
        }
        void SetMessage( const WideString& message )
        {
            message_ = message;
        }
    };
    class RadarCommandReplyGetStatusData : public RadarCommandReplyData
    {
    public:
        using Base = RadarCommandReplyData;
        static constexpr Kind KIND = Kind::RadarCommandReplyGetStatus;
    private:
        Int32 azimuthCount_ = 0;
        Int32 triggerCount_ = 0;
        TimeSpan rotationCount_;
        Data::RadarPulse pulse_ = Data::RadarPulse::Short;
        bool tx_ = false;
    public:
        RadarCommandReplyGetStatusData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(azimuthCount_);
            destination.Write(triggerCount_);
            destination.Write(rotationCount_);
            destination.Write(pulse_);
            destination.Write(tx_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(azimuthCount_);
            source.Read(triggerCount_);
            source.Read(rotationCount_);
            source.Read(pulse_);
            source.Read(tx_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<RadarCommandReplyGetStatusData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<RadarCommandReplyGetStatusData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const RadarCommandReplyGetStatusData& >( other );
                if ( dataObject.azimuthCount_ != azimuthCount_ )
                {
                    return false;
                }
                if ( dataObject.triggerCount_ != triggerCount_ )
                {
                    return false;
                }
                if ( dataObject.rotationCount_ != rotationCount_ )
                {
                    return false;
                }
                if ( dataObject.pulse_ != pulse_ )
                {
                    return false;
                }
                if ( dataObject.tx_ != tx_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        Int32 AzimuthCount( ) const
        {
            return azimuthCount_;
        }
        void SetAzimuthCount( Int32 azimuthCount )
        {
            azimuthCount_ = azimuthCount;
        }
        Int32 TriggerCount( ) const
        {
            return triggerCount_;
        }
        void SetTriggerCount( Int32 triggerCount )
        {
            triggerCount_ = triggerCount;
        }
        const TimeSpan& RotationCount( ) const
        {
            return rotationCount_;
        }
        void SetRotationCount( const TimeSpan& rotationCount )
        {
            rotationCount_ = rotationCount;
        }
        Data::RadarPulse Pulse( ) const
        {
            return pulse_;
        }
        void SetPulse( Data::RadarPulse pulse )
        {
            pulse_ = pulse;
        }
        bool Tx( ) const
        {
            return tx_;
        }
        void SetTx( bool tx )
        {
            tx_ = tx;
        }
    };
    class RadarConfigurationData : public BaseData<Kind, Guid>
    {
    public:
        using Base = BaseData<Kind, Guid>;
        static constexpr Kind KIND = Kind::RadarConfiguration;
    private:
        Int64 rowVersion_ = 0;
        Guid radar_;
        DateTime timestamp_;
        Int32 radarProtocolVersion_ = 0;
        FixedDBWideString<100> radarIPAddress_;
        Int32 radarPort_ = 0;
        Int32 radarConfigurationPort_ = 0;
        TimeSpan skipMagicTimeout_;
        TimeSpan readTimeout_;
        TimeSpan synchronizationInterval_;
        Int32 targetsRefreshRate_ = 0;
        Int32 range_ = 0;
        Int32 sectorCount_ = 0;
        Int32 sectorOffset_ = 0;
        UInt32 imageColor_ = 0;
        DBUInt32 imageSubstitutionColor_;
        UInt32 transparentColor_ = 0;
        double imageScaleFactorX_ = 0.0;
        double imageOffsetX_ = 0.0;
        double imageScaleFactorY_ = 0.0;
        double imageOffsetY_ = 0.0;
        Data::RadarImageType radarImageType_ = Data::RadarImageType::MaskedProcessed;
        UInt32 trackColor_ = 0;
        UInt32 vectorColor_ = 0;
        bool enableNmea_ = false;
        FixedDBWideString<100> nmeaReceiverIPAddress_;
        Int32 nmeaReceiverPort_ = 0;
        FixedDBWideString<100> nmeaReceiverSourceId_;
    public:
        RadarConfigurationData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(rowVersion_);
            destination.Write(radar_);
            destination.Write(timestamp_);
            destination.Write(radarProtocolVersion_);
            radarIPAddress_.WriteTo( destination );
            destination.Write(radarPort_);
            destination.Write(radarConfigurationPort_);
            destination.Write(skipMagicTimeout_);
            destination.Write(readTimeout_);
            destination.Write(synchronizationInterval_);
            destination.Write(targetsRefreshRate_);
            destination.Write(range_);
            destination.Write(sectorCount_);
            destination.Write(sectorOffset_);
            destination.Write(imageColor_);
            imageSubstitutionColor_.WriteTo( destination );
            destination.Write(transparentColor_);
            destination.Write(imageScaleFactorX_);
            destination.Write(imageOffsetX_);
            destination.Write(imageScaleFactorY_);
            destination.Write(imageOffsetY_);
            destination.Write(radarImageType_);
            destination.Write(trackColor_);
            destination.Write(vectorColor_);
            destination.Write(enableNmea_);
            nmeaReceiverIPAddress_.WriteTo( destination );
            destination.Write(nmeaReceiverPort_);
            nmeaReceiverSourceId_.WriteTo( destination );
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(rowVersion_);
            source.Read(radar_);
            source.Read(timestamp_);
            source.Read(radarProtocolVersion_);
            radarIPAddress_.ReadFrom( source );
            source.Read(radarPort_);
            source.Read(radarConfigurationPort_);
            source.Read(skipMagicTimeout_);
            source.Read(readTimeout_);
            source.Read(synchronizationInterval_);
            source.Read(targetsRefreshRate_);
            source.Read(range_);
            source.Read(sectorCount_);
            source.Read(sectorOffset_);
            source.Read(imageColor_);
            imageSubstitutionColor_.ReadFrom( source );
            source.Read(transparentColor_);
            source.Read(imageScaleFactorX_);
            source.Read(imageOffsetX_);
            source.Read(imageScaleFactorY_);
            source.Read(imageOffsetY_);
            source.Read(radarImageType_);
            source.Read(trackColor_);
            source.Read(vectorColor_);
            source.Read(enableNmea_);
            nmeaReceiverIPAddress_.ReadFrom( source );
            source.Read(nmeaReceiverPort_);
            nmeaReceiverSourceId_.ReadFrom( source );
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<RadarConfigurationData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<RadarConfigurationData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const RadarConfigurationData& >( other );
                if ( dataObject.rowVersion_ != rowVersion_ )
                {
                    return false;
                }
                if ( dataObject.radar_ != radar_ )
                {
                    return false;
                }
                if ( dataObject.timestamp_ != timestamp_ )
                {
                    return false;
                }
                if ( dataObject.radarProtocolVersion_ != radarProtocolVersion_ )
                {
                    return false;
                }
                if ( dataObject.radarIPAddress_ != radarIPAddress_ )
                {
                    return false;
                }
                if ( dataObject.radarPort_ != radarPort_ )
                {
                    return false;
                }
                if ( dataObject.radarConfigurationPort_ != radarConfigurationPort_ )
                {
                    return false;
                }
                if ( dataObject.skipMagicTimeout_ != skipMagicTimeout_ )
                {
                    return false;
                }
                if ( dataObject.readTimeout_ != readTimeout_ )
                {
                    return false;
                }
                if ( dataObject.synchronizationInterval_ != synchronizationInterval_ )
                {
                    return false;
                }
                if ( dataObject.targetsRefreshRate_ != targetsRefreshRate_ )
                {
                    return false;
                }
                if ( dataObject.range_ != range_ )
                {
                    return false;
                }
                if ( dataObject.sectorCount_ != sectorCount_ )
                {
                    return false;
                }
                if ( dataObject.sectorOffset_ != sectorOffset_ )
                {
                    return false;
                }
                if ( dataObject.imageColor_ != imageColor_ )
                {
                    return false;
                }
                if ( dataObject.imageSubstitutionColor_ != imageSubstitutionColor_ )
                {
                    return false;
                }
                if ( dataObject.transparentColor_ != transparentColor_ )
                {
                    return false;
                }
                if ( dataObject.imageScaleFactorX_ != imageScaleFactorX_ )
                {
                    return false;
                }
                if ( dataObject.imageOffsetX_ != imageOffsetX_ )
                {
                    return false;
                }
                if ( dataObject.imageScaleFactorY_ != imageScaleFactorY_ )
                {
                    return false;
                }
                if ( dataObject.imageOffsetY_ != imageOffsetY_ )
                {
                    return false;
                }
                if ( dataObject.radarImageType_ != radarImageType_ )
                {
                    return false;
                }
                if ( dataObject.trackColor_ != trackColor_ )
                {
                    return false;
                }
                if ( dataObject.vectorColor_ != vectorColor_ )
                {
                    return false;
                }
                if ( dataObject.enableNmea_ != enableNmea_ )
                {
                    return false;
                }
                if ( dataObject.nmeaReceiverIPAddress_ != nmeaReceiverIPAddress_ )
                {
                    return false;
                }
                if ( dataObject.nmeaReceiverPort_ != nmeaReceiverPort_ )
                {
                    return false;
                }
                if ( dataObject.nmeaReceiverSourceId_ != nmeaReceiverSourceId_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        Int64 RowVersion( ) const
        {
            return rowVersion_;
        }
        void SetRowVersion( const Int64& rowVersion )
        {
            rowVersion_ = rowVersion;
        }
        const Guid& Radar( ) const
        {
            return radar_;
        }
        void SetRadar( const Guid& radar )
        {
            radar_ = radar;
        }
        const DateTime& Timestamp( ) const
        {
            return timestamp_;
        }
        void SetTimestamp( const DateTime& timestamp )
        {
            timestamp_ = timestamp;
        }
        Int32 RadarProtocolVersion( ) const
        {
            return radarProtocolVersion_;
        }
        void SetRadarProtocolVersion( Int32 radarProtocolVersion )
        {
            radarProtocolVersion_ = radarProtocolVersion;
        }
        const FixedDBWideString<100>& RadarIPAddress( ) const
        {
            return radarIPAddress_;
        }
        void SetRadarIPAddress( const WideString& radarIPAddress )
        {
            radarIPAddress_ = radarIPAddress;
        }
        Int32 RadarPort( ) const
        {
            return radarPort_;
        }
        void SetRadarPort( Int32 radarPort )
        {
            radarPort_ = radarPort;
        }
        Int32 RadarConfigurationPort( ) const
        {
            return radarConfigurationPort_;
        }
        void SetRadarConfigurationPort( Int32 radarConfigurationPort )
        {
            radarConfigurationPort_ = radarConfigurationPort;
        }
        const TimeSpan& SkipMagicTimeout( ) const
        {
            return skipMagicTimeout_;
        }
        void SetSkipMagicTimeout( const TimeSpan& skipMagicTimeout )
        {
            skipMagicTimeout_ = skipMagicTimeout;
        }
        const TimeSpan& ReadTimeout( ) const
        {
            return readTimeout_;
        }
        void SetReadTimeout( const TimeSpan& readTimeout )
        {
            readTimeout_ = readTimeout;
        }
        const TimeSpan& SynchronizationInterval( ) const
        {
            return synchronizationInterval_;
        }
        void SetSynchronizationInterval( const TimeSpan& synchronizationInterval )
        {
            synchronizationInterval_ = synchronizationInterval;
        }
        Int32 TargetsRefreshRate( ) const
        {
            return targetsRefreshRate_;
        }
        void SetTargetsRefreshRate( Int32 targetsRefreshRate )
        {
            targetsRefreshRate_ = targetsRefreshRate;
        }
        Int32 Range( ) const
        {
            return range_;
        }
        void SetRange( Int32 range )
        {
            range_ = range;
        }
        Int32 SectorCount( ) const
        {
            return sectorCount_;
        }
        void SetSectorCount( Int32 sectorCount )
        {
            sectorCount_ = sectorCount;
        }
        Int32 SectorOffset( ) const
        {
            return sectorOffset_;
        }
        void SetSectorOffset( Int32 sectorOffset )
        {
            sectorOffset_ = sectorOffset;
        }
        UInt32 ImageColor( ) const
        {
            return imageColor_;
        }
        void SetImageColor( UInt32 imageColor )
        {
            imageColor_ = imageColor;
        }
        const DBUInt32& ImageSubstitutionColor( ) const
        {
            return imageSubstitutionColor_;
        }
        void SetImageSubstitutionColor( const DBUInt32& imageSubstitutionColor )
        {
            imageSubstitutionColor_ = imageSubstitutionColor;
        }
        UInt32 TransparentColor( ) const
        {
            return transparentColor_;
        }
        void SetTransparentColor( UInt32 transparentColor )
        {
            transparentColor_ = transparentColor;
        }
        double ImageScaleFactorX( ) const
        {
            return imageScaleFactorX_;
        }
        void SetImageScaleFactorX( double imageScaleFactorX )
        {
            imageScaleFactorX_ = imageScaleFactorX;
        }
        double ImageOffsetX( ) const
        {
            return imageOffsetX_;
        }
        void SetImageOffsetX( double imageOffsetX )
        {
            imageOffsetX_ = imageOffsetX;
        }
        double ImageScaleFactorY( ) const
        {
            return imageScaleFactorY_;
        }
        void SetImageScaleFactorY( double imageScaleFactorY )
        {
            imageScaleFactorY_ = imageScaleFactorY;
        }
        double ImageOffsetY( ) const
        {
            return imageOffsetY_;
        }
        void SetImageOffsetY( double imageOffsetY )
        {
            imageOffsetY_ = imageOffsetY;
        }
        Data::RadarImageType RadarImageType( ) const
        {
            return radarImageType_;
        }
        void SetRadarImageType( Data::RadarImageType radarImageType )
        {
            radarImageType_ = radarImageType;
        }
        UInt32 TrackColor( ) const
        {
            return trackColor_;
        }
        void SetTrackColor( UInt32 trackColor )
        {
            trackColor_ = trackColor;
        }
        UInt32 VectorColor( ) const
        {
            return vectorColor_;
        }
        void SetVectorColor( UInt32 vectorColor )
        {
            vectorColor_ = vectorColor;
        }
        bool EnableNmea( ) const
        {
            return enableNmea_;
        }
        void SetEnableNmea( bool enableNmea )
        {
            enableNmea_ = enableNmea;
        }
        const FixedDBWideString<100>& NmeaReceiverIPAddress( ) const
        {
            return nmeaReceiverIPAddress_;
        }
        void SetNmeaReceiverIPAddress( const WideString& nmeaReceiverIPAddress )
        {
            nmeaReceiverIPAddress_ = nmeaReceiverIPAddress;
        }
        Int32 NmeaReceiverPort( ) const
        {
            return nmeaReceiverPort_;
        }
        void SetNmeaReceiverPort( Int32 nmeaReceiverPort )
        {
            nmeaReceiverPort_ = nmeaReceiverPort;
        }
        const FixedDBWideString<100>& NmeaReceiverSourceId( ) const
        {
            return nmeaReceiverSourceId_;
        }
        void SetNmeaReceiverSourceId( const WideString& nmeaReceiverSourceId )
        {
            nmeaReceiverSourceId_ = nmeaReceiverSourceId;
        }
    };
    class RadarImageData : public BaseData<Kind, Guid>
    {
    public:
        using Base = BaseData<Kind, Guid>;
        static constexpr Kind KIND = Kind::RadarImage;
    private:
        Int64 rowVersion_ = 0;
        Guid radar_;
        DateTime timestamp_;
        UInt32 depth_ = 0;
        Int32 resolution_ = 0;
        Int32 range_ = 0;
        Binary image_;
        SQLLEN imageLength_ = SQL_NULL_DATA;
    public:
        RadarImageData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(rowVersion_);
            destination.Write(radar_);
            destination.Write(timestamp_);
            destination.Write(depth_);
            destination.Write(resolution_);
            destination.Write(range_);
            destination.Write(image_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(rowVersion_);
            source.Read(radar_);
            source.Read(timestamp_);
            source.Read(depth_);
            source.Read(resolution_);
            source.Read(range_);
            source.Read(image_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<RadarImageData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<RadarImageData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const RadarImageData& >( other );
                if ( dataObject.rowVersion_ != rowVersion_ )
                {
                    return false;
                }
                if ( dataObject.radar_ != radar_ )
                {
                    return false;
                }
                if ( dataObject.timestamp_ != timestamp_ )
                {
                    return false;
                }
                if ( dataObject.depth_ != depth_ )
                {
                    return false;
                }
                if ( dataObject.resolution_ != resolution_ )
                {
                    return false;
                }
                if ( dataObject.range_ != range_ )
                {
                    return false;
                }
                if ( dataObject.image_ != image_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        Int64 RowVersion( ) const
        {
            return rowVersion_;
        }
        void SetRowVersion( const Int64& rowVersion )
        {
            rowVersion_ = rowVersion;
        }
        const Guid& Radar( ) const
        {
            return radar_;
        }
        void SetRadar( const Guid& radar )
        {
            radar_ = radar;
        }
        const DateTime& Timestamp( ) const
        {
            return timestamp_;
        }
        void SetTimestamp( const DateTime& timestamp )
        {
            timestamp_ = timestamp;
        }
        UInt32 Depth( ) const
        {
            return depth_;
        }
        void SetDepth( UInt32 depth )
        {
            depth_ = depth;
        }
        Int32 Resolution( ) const
        {
            return resolution_;
        }
        void SetResolution( Int32 resolution )
        {
            resolution_ = resolution;
        }
        Int32 Range( ) const
        {
            return range_;
        }
        void SetRange( Int32 range )
        {
            range_ = range;
        }
        const Binary& Image( ) const
        {
            return image_;
        }
        void SetImage( const Binary& image )
        {
            image_ = image;
        }
    };
    class RadarRawTrackTableData : public BaseData<Kind, Guid>
    {
    public:
        using Base = BaseData<Kind, Guid>;
        static constexpr Kind KIND = Kind::RadarRawTrackTable;
    private:
        Int64 rowVersion_ = 0;
        Guid radar_;
        DateTime timestamp_;
        Int32 count_ = 0;
        Binary table_;
        SQLLEN tableLength_ = SQL_NULL_DATA;
    public:
        RadarRawTrackTableData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(rowVersion_);
            destination.Write(radar_);
            destination.Write(timestamp_);
            destination.Write(count_);
            destination.Write(table_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(rowVersion_);
            source.Read(radar_);
            source.Read(timestamp_);
            source.Read(count_);
            source.Read(table_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<RadarRawTrackTableData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<RadarRawTrackTableData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const RadarRawTrackTableData& >( other );
                if ( dataObject.rowVersion_ != rowVersion_ )
                {
                    return false;
                }
                if ( dataObject.radar_ != radar_ )
                {
                    return false;
                }
                if ( dataObject.timestamp_ != timestamp_ )
                {
                    return false;
                }
                if ( dataObject.count_ != count_ )
                {
                    return false;
                }
                if ( dataObject.table_ != table_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        Int64 RowVersion( ) const
        {
            return rowVersion_;
        }
        void SetRowVersion( const Int64& rowVersion )
        {
            rowVersion_ = rowVersion;
        }
        const Guid& Radar( ) const
        {
            return radar_;
        }
        void SetRadar( const Guid& radar )
        {
            radar_ = radar;
        }
        const DateTime& Timestamp( ) const
        {
            return timestamp_;
        }
        void SetTimestamp( const DateTime& timestamp )
        {
            timestamp_ = timestamp;
        }
        Int32 Count( ) const
        {
            return count_;
        }
        void SetCount( Int32 count )
        {
            count_ = count;
        }
        const Binary& Table( ) const
        {
            return table_;
        }
        void SetTable( const Binary& table )
        {
            table_ = table;
        }
    };
    class RadarStatusData : public BaseData<Kind, Guid>
    {
    public:
        using Base = BaseData<Kind, Guid>;
        static constexpr Kind KIND = Kind::RadarStatus;
    private:
        Int64 rowVersion_ = 0;
        Guid radar_;
        DateTime timestamp_;
        Int32 azimuthCount_ = 0;
        Int32 triggerCount_ = 0;
        TimeSpan rotationTime_;
        Data::RadarPulse pulse_ = Data::RadarPulse::Short;
        bool tx_ = false;
        bool tracking_ = false;
    public:
        RadarStatusData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(rowVersion_);
            destination.Write(radar_);
            destination.Write(timestamp_);
            destination.Write(azimuthCount_);
            destination.Write(triggerCount_);
            destination.Write(rotationTime_);
            destination.Write(pulse_);
            destination.Write(tx_);
            destination.Write(tracking_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(rowVersion_);
            source.Read(radar_);
            source.Read(timestamp_);
            source.Read(azimuthCount_);
            source.Read(triggerCount_);
            source.Read(rotationTime_);
            source.Read(pulse_);
            source.Read(tx_);
            source.Read(tracking_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<RadarStatusData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<RadarStatusData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const RadarStatusData& >( other );
                if ( dataObject.rowVersion_ != rowVersion_ )
                {
                    return false;
                }
                if ( dataObject.radar_ != radar_ )
                {
                    return false;
                }
                if ( dataObject.timestamp_ != timestamp_ )
                {
                    return false;
                }
                if ( dataObject.azimuthCount_ != azimuthCount_ )
                {
                    return false;
                }
                if ( dataObject.triggerCount_ != triggerCount_ )
                {
                    return false;
                }
                if ( dataObject.rotationTime_ != rotationTime_ )
                {
                    return false;
                }
                if ( dataObject.pulse_ != pulse_ )
                {
                    return false;
                }
                if ( dataObject.tx_ != tx_ )
                {
                    return false;
                }
                if ( dataObject.tracking_ != tracking_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        Int64 RowVersion( ) const
        {
            return rowVersion_;
        }
        void SetRowVersion( const Int64& rowVersion )
        {
            rowVersion_ = rowVersion;
        }
        const Guid& Radar( ) const
        {
            return radar_;
        }
        void SetRadar( const Guid& radar )
        {
            radar_ = radar;
        }
        const DateTime& Timestamp( ) const
        {
            return timestamp_;
        }
        void SetTimestamp( const DateTime& timestamp )
        {
            timestamp_ = timestamp;
        }
        Int32 AzimuthCount( ) const
        {
            return azimuthCount_;
        }
        void SetAzimuthCount( Int32 azimuthCount )
        {
            azimuthCount_ = azimuthCount;
        }
        Int32 TriggerCount( ) const
        {
            return triggerCount_;
        }
        void SetTriggerCount( Int32 triggerCount )
        {
            triggerCount_ = triggerCount;
        }
        const TimeSpan& RotationTime( ) const
        {
            return rotationTime_;
        }
        void SetRotationTime( const TimeSpan& rotationTime )
        {
            rotationTime_ = rotationTime;
        }
        Data::RadarPulse Pulse( ) const
        {
            return pulse_;
        }
        void SetPulse( Data::RadarPulse pulse )
        {
            pulse_ = pulse;
        }
        bool Tx( ) const
        {
            return tx_;
        }
        void SetTx( bool tx )
        {
            tx_ = tx;
        }
        bool Tracking( ) const
        {
            return tracking_;
        }
        void SetTracking( bool tracking )
        {
            tracking_ = tracking;
        }
    };
    class RadioCommandData : public BaseData<Kind, Guid>
    {
    public:
        using Base = BaseData<Kind, Guid>;
        static constexpr Kind KIND = Kind::RadioCommand;
    private:
        Int64 rowVersion_ = 0;
        Guid radio_;
        DateTime timestamp_;
        Data::DeviceCommandSourceType deviceCommandSourceType_ = Data::DeviceCommandSourceType::Unknown;
        Guid deviceCommandSourceId_;
        Guid reply_;
    public:
        RadioCommandData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(rowVersion_);
            destination.Write(radio_);
            destination.Write(timestamp_);
            destination.Write(deviceCommandSourceType_);
            destination.Write(deviceCommandSourceId_);
            destination.Write(reply_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(rowVersion_);
            source.Read(radio_);
            source.Read(timestamp_);
            source.Read(deviceCommandSourceType_);
            source.Read(deviceCommandSourceId_);
            source.Read(reply_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<RadioCommandData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<RadioCommandData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const RadioCommandData& >( other );
                if ( dataObject.rowVersion_ != rowVersion_ )
                {
                    return false;
                }
                if ( dataObject.radio_ != radio_ )
                {
                    return false;
                }
                if ( dataObject.timestamp_ != timestamp_ )
                {
                    return false;
                }
                if ( dataObject.deviceCommandSourceType_ != deviceCommandSourceType_ )
                {
                    return false;
                }
                if ( dataObject.deviceCommandSourceId_ != deviceCommandSourceId_ )
                {
                    return false;
                }
                if ( dataObject.reply_ != reply_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        Int64 RowVersion( ) const
        {
            return rowVersion_;
        }
        void SetRowVersion( const Int64& rowVersion )
        {
            rowVersion_ = rowVersion;
        }
        const Guid& Radio( ) const
        {
            return radio_;
        }
        void SetRadio( const Guid& radio )
        {
            radio_ = radio;
        }
        const DateTime& Timestamp( ) const
        {
            return timestamp_;
        }
        void SetTimestamp( const DateTime& timestamp )
        {
            timestamp_ = timestamp;
        }
        Data::DeviceCommandSourceType DeviceCommandSourceType( ) const
        {
            return deviceCommandSourceType_;
        }
        void SetDeviceCommandSourceType( Data::DeviceCommandSourceType deviceCommandSourceType )
        {
            deviceCommandSourceType_ = deviceCommandSourceType;
        }
        const Guid& DeviceCommandSourceId( ) const
        {
            return deviceCommandSourceId_;
        }
        void SetDeviceCommandSourceId( const Guid& deviceCommandSourceId )
        {
            deviceCommandSourceId_ = deviceCommandSourceId;
        }
        const Guid& Reply( ) const
        {
            return reply_;
        }
        void SetReply( const Guid& reply )
        {
            reply_ = reply;
        }
    };
    class RadioCommandReplyData : public BaseData<Kind, Guid>
    {
    public:
        using Base = BaseData<Kind, Guid>;
        static constexpr Kind KIND = Kind::RadioCommandReply;
    private:
        Int64 rowVersion_ = 0;
        Guid radio_;
        DateTime timestamp_;
        Guid command_;
        Data::DeviceCommandReplyStatus status_ = Data::DeviceCommandReplyStatus::Unknown;
        WideString message_;
        SQLLEN messageLength_ = SQL_NULL_DATA;
    public:
        RadioCommandReplyData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(rowVersion_);
            destination.Write(radio_);
            destination.Write(timestamp_);
            destination.Write(command_);
            destination.Write(status_);
            destination.Write(message_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(rowVersion_);
            source.Read(radio_);
            source.Read(timestamp_);
            source.Read(command_);
            source.Read(status_);
            source.Read(message_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<RadioCommandReplyData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<RadioCommandReplyData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const RadioCommandReplyData& >( other );
                if ( dataObject.rowVersion_ != rowVersion_ )
                {
                    return false;
                }
                if ( dataObject.radio_ != radio_ )
                {
                    return false;
                }
                if ( dataObject.timestamp_ != timestamp_ )
                {
                    return false;
                }
                if ( dataObject.command_ != command_ )
                {
                    return false;
                }
                if ( dataObject.status_ != status_ )
                {
                    return false;
                }
                if ( dataObject.message_ != message_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        Int64 RowVersion( ) const
        {
            return rowVersion_;
        }
        void SetRowVersion( const Int64& rowVersion )
        {
            rowVersion_ = rowVersion;
        }
        const Guid& Radio( ) const
        {
            return radio_;
        }
        void SetRadio( const Guid& radio )
        {
            radio_ = radio;
        }
        const DateTime& Timestamp( ) const
        {
            return timestamp_;
        }
        void SetTimestamp( const DateTime& timestamp )
        {
            timestamp_ = timestamp;
        }
        const Guid& Command( ) const
        {
            return command_;
        }
        void SetCommand( const Guid& command )
        {
            command_ = command;
        }
        Data::DeviceCommandReplyStatus Status( ) const
        {
            return status_;
        }
        void SetStatus( Data::DeviceCommandReplyStatus status )
        {
            status_ = status;
        }
        const WideString& Message( ) const
        {
            return message_;
        }
        void SetMessage( const WideString& message )
        {
            message_ = message;
        }
    };
    class RadioConfigurationData : public BaseData<Kind, Guid>
    {
    public:
        using Base = BaseData<Kind, Guid>;
        static constexpr Kind KIND = Kind::RadioConfiguration;
    private:
        Int64 rowVersion_ = 0;
        Guid radio_;
        DateTime timestamp_;
        double longitude_ = 0.0;
        double latitude_ = 0.0;
        FixedDBWideString<100> playbackUrl_;
        FixedDBWideString<100> radioIPAddress_;
        Int32 radioPort_ = 0;
        FixedDBWideString<100> ed137IPAddress_;
        Int32 ed137Port_ = 0;
    public:
        RadioConfigurationData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(rowVersion_);
            destination.Write(radio_);
            destination.Write(timestamp_);
            destination.Write(longitude_);
            destination.Write(latitude_);
            playbackUrl_.WriteTo( destination );
            radioIPAddress_.WriteTo( destination );
            destination.Write(radioPort_);
            ed137IPAddress_.WriteTo( destination );
            destination.Write(ed137Port_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(rowVersion_);
            source.Read(radio_);
            source.Read(timestamp_);
            source.Read(longitude_);
            source.Read(latitude_);
            playbackUrl_.ReadFrom( source );
            radioIPAddress_.ReadFrom( source );
            source.Read(radioPort_);
            ed137IPAddress_.ReadFrom( source );
            source.Read(ed137Port_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<RadioConfigurationData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<RadioConfigurationData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const RadioConfigurationData& >( other );
                if ( dataObject.rowVersion_ != rowVersion_ )
                {
                    return false;
                }
                if ( dataObject.radio_ != radio_ )
                {
                    return false;
                }
                if ( dataObject.timestamp_ != timestamp_ )
                {
                    return false;
                }
                if ( dataObject.longitude_ != longitude_ )
                {
                    return false;
                }
                if ( dataObject.latitude_ != latitude_ )
                {
                    return false;
                }
                if ( dataObject.playbackUrl_ != playbackUrl_ )
                {
                    return false;
                }
                if ( dataObject.radioIPAddress_ != radioIPAddress_ )
                {
                    return false;
                }
                if ( dataObject.radioPort_ != radioPort_ )
                {
                    return false;
                }
                if ( dataObject.ed137IPAddress_ != ed137IPAddress_ )
                {
                    return false;
                }
                if ( dataObject.ed137Port_ != ed137Port_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        Int64 RowVersion( ) const
        {
            return rowVersion_;
        }
        void SetRowVersion( const Int64& rowVersion )
        {
            rowVersion_ = rowVersion;
        }
        const Guid& Radio( ) const
        {
            return radio_;
        }
        void SetRadio( const Guid& radio )
        {
            radio_ = radio;
        }
        const DateTime& Timestamp( ) const
        {
            return timestamp_;
        }
        void SetTimestamp( const DateTime& timestamp )
        {
            timestamp_ = timestamp;
        }
        double Longitude( ) const
        {
            return longitude_;
        }
        void SetLongitude( double longitude )
        {
            longitude_ = longitude;
        }
        double Latitude( ) const
        {
            return latitude_;
        }
        void SetLatitude( double latitude )
        {
            latitude_ = latitude;
        }
        const FixedDBWideString<100>& PlaybackUrl( ) const
        {
            return playbackUrl_;
        }
        void SetPlaybackUrl( const WideString& playbackUrl )
        {
            playbackUrl_ = playbackUrl;
        }
        const FixedDBWideString<100>& RadioIPAddress( ) const
        {
            return radioIPAddress_;
        }
        void SetRadioIPAddress( const WideString& radioIPAddress )
        {
            radioIPAddress_ = radioIPAddress;
        }
        Int32 RadioPort( ) const
        {
            return radioPort_;
        }
        void SetRadioPort( Int32 radioPort )
        {
            radioPort_ = radioPort;
        }
        const FixedDBWideString<100>& Ed137IPAddress( ) const
        {
            return ed137IPAddress_;
        }
        void SetEd137IPAddress( const WideString& ed137IPAddress )
        {
            ed137IPAddress_ = ed137IPAddress;
        }
        Int32 Ed137Port( ) const
        {
            return ed137Port_;
        }
        void SetEd137Port( Int32 ed137Port )
        {
            ed137Port_ = ed137Port;
        }
    };
    class RadomeCommandData : public BaseData<Kind, Guid>
    {
    public:
        using Base = BaseData<Kind, Guid>;
        static constexpr Kind KIND = Kind::RadomeCommand;
    private:
        Int64 rowVersion_ = 0;
        Guid radome_;
        DateTime timestamp_;
        Data::DeviceCommandSourceType deviceCommandSourceType_ = Data::DeviceCommandSourceType::Unknown;
        Guid deviceCommandSourceId_;
        Guid reply_;
    public:
        RadomeCommandData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(rowVersion_);
            destination.Write(radome_);
            destination.Write(timestamp_);
            destination.Write(deviceCommandSourceType_);
            destination.Write(deviceCommandSourceId_);
            destination.Write(reply_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(rowVersion_);
            source.Read(radome_);
            source.Read(timestamp_);
            source.Read(deviceCommandSourceType_);
            source.Read(deviceCommandSourceId_);
            source.Read(reply_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<RadomeCommandData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<RadomeCommandData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const RadomeCommandData& >( other );
                if ( dataObject.rowVersion_ != rowVersion_ )
                {
                    return false;
                }
                if ( dataObject.radome_ != radome_ )
                {
                    return false;
                }
                if ( dataObject.timestamp_ != timestamp_ )
                {
                    return false;
                }
                if ( dataObject.deviceCommandSourceType_ != deviceCommandSourceType_ )
                {
                    return false;
                }
                if ( dataObject.deviceCommandSourceId_ != deviceCommandSourceId_ )
                {
                    return false;
                }
                if ( dataObject.reply_ != reply_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        Int64 RowVersion( ) const
        {
            return rowVersion_;
        }
        void SetRowVersion( const Int64& rowVersion )
        {
            rowVersion_ = rowVersion;
        }
        const Guid& Radome( ) const
        {
            return radome_;
        }
        void SetRadome( const Guid& radome )
        {
            radome_ = radome;
        }
        const DateTime& Timestamp( ) const
        {
            return timestamp_;
        }
        void SetTimestamp( const DateTime& timestamp )
        {
            timestamp_ = timestamp;
        }
        Data::DeviceCommandSourceType DeviceCommandSourceType( ) const
        {
            return deviceCommandSourceType_;
        }
        void SetDeviceCommandSourceType( Data::DeviceCommandSourceType deviceCommandSourceType )
        {
            deviceCommandSourceType_ = deviceCommandSourceType;
        }
        const Guid& DeviceCommandSourceId( ) const
        {
            return deviceCommandSourceId_;
        }
        void SetDeviceCommandSourceId( const Guid& deviceCommandSourceId )
        {
            deviceCommandSourceId_ = deviceCommandSourceId;
        }
        const Guid& Reply( ) const
        {
            return reply_;
        }
        void SetReply( const Guid& reply )
        {
            reply_ = reply;
        }
    };
    class RadomeCommandReplyData : public BaseData<Kind, Guid>
    {
    public:
        using Base = BaseData<Kind, Guid>;
        static constexpr Kind KIND = Kind::RadomeCommandReply;
    private:
        Int64 rowVersion_ = 0;
        Guid radome_;
        DateTime timestamp_;
        Guid command_;
        Data::DeviceCommandReplyStatus status_ = Data::DeviceCommandReplyStatus::Unknown;
        WideString message_;
        SQLLEN messageLength_ = SQL_NULL_DATA;
    public:
        RadomeCommandReplyData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(rowVersion_);
            destination.Write(radome_);
            destination.Write(timestamp_);
            destination.Write(command_);
            destination.Write(status_);
            destination.Write(message_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(rowVersion_);
            source.Read(radome_);
            source.Read(timestamp_);
            source.Read(command_);
            source.Read(status_);
            source.Read(message_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<RadomeCommandReplyData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<RadomeCommandReplyData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const RadomeCommandReplyData& >( other );
                if ( dataObject.rowVersion_ != rowVersion_ )
                {
                    return false;
                }
                if ( dataObject.radome_ != radome_ )
                {
                    return false;
                }
                if ( dataObject.timestamp_ != timestamp_ )
                {
                    return false;
                }
                if ( dataObject.command_ != command_ )
                {
                    return false;
                }
                if ( dataObject.status_ != status_ )
                {
                    return false;
                }
                if ( dataObject.message_ != message_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        Int64 RowVersion( ) const
        {
            return rowVersion_;
        }
        void SetRowVersion( const Int64& rowVersion )
        {
            rowVersion_ = rowVersion;
        }
        const Guid& Radome( ) const
        {
            return radome_;
        }
        void SetRadome( const Guid& radome )
        {
            radome_ = radome;
        }
        const DateTime& Timestamp( ) const
        {
            return timestamp_;
        }
        void SetTimestamp( const DateTime& timestamp )
        {
            timestamp_ = timestamp;
        }
        const Guid& Command( ) const
        {
            return command_;
        }
        void SetCommand( const Guid& command )
        {
            command_ = command;
        }
        Data::DeviceCommandReplyStatus Status( ) const
        {
            return status_;
        }
        void SetStatus( Data::DeviceCommandReplyStatus status )
        {
            status_ = status;
        }
        const WideString& Message( ) const
        {
            return message_;
        }
        void SetMessage( const WideString& message )
        {
            message_ = message;
        }
    };
    class RadomeConfigurationData : public BaseData<Kind, Guid>
    {
    public:
        using Base = BaseData<Kind, Guid>;
        static constexpr Kind KIND = Kind::RadomeConfiguration;
    private:
        Int64 rowVersion_ = 0;
        Guid radome_;
        DateTime timestamp_;
        TimeSpan interval_;
        double lowPressureLimit_ = 0.0;
        double highPressureLimit_ = 0.0;
        double lowTemperatureLimit_ = 0.0;
        double highTemperatureLimit_ = 0.0;
    public:
        RadomeConfigurationData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(rowVersion_);
            destination.Write(radome_);
            destination.Write(timestamp_);
            destination.Write(interval_);
            destination.Write(lowPressureLimit_);
            destination.Write(highPressureLimit_);
            destination.Write(lowTemperatureLimit_);
            destination.Write(highTemperatureLimit_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(rowVersion_);
            source.Read(radome_);
            source.Read(timestamp_);
            source.Read(interval_);
            source.Read(lowPressureLimit_);
            source.Read(highPressureLimit_);
            source.Read(lowTemperatureLimit_);
            source.Read(highTemperatureLimit_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<RadomeConfigurationData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<RadomeConfigurationData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const RadomeConfigurationData& >( other );
                if ( dataObject.rowVersion_ != rowVersion_ )
                {
                    return false;
                }
                if ( dataObject.radome_ != radome_ )
                {
                    return false;
                }
                if ( dataObject.timestamp_ != timestamp_ )
                {
                    return false;
                }
                if ( dataObject.interval_ != interval_ )
                {
                    return false;
                }
                if ( dataObject.lowPressureLimit_ != lowPressureLimit_ )
                {
                    return false;
                }
                if ( dataObject.highPressureLimit_ != highPressureLimit_ )
                {
                    return false;
                }
                if ( dataObject.lowTemperatureLimit_ != lowTemperatureLimit_ )
                {
                    return false;
                }
                if ( dataObject.highTemperatureLimit_ != highTemperatureLimit_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        Int64 RowVersion( ) const
        {
            return rowVersion_;
        }
        void SetRowVersion( const Int64& rowVersion )
        {
            rowVersion_ = rowVersion;
        }
        const Guid& Radome( ) const
        {
            return radome_;
        }
        void SetRadome( const Guid& radome )
        {
            radome_ = radome;
        }
        const DateTime& Timestamp( ) const
        {
            return timestamp_;
        }
        void SetTimestamp( const DateTime& timestamp )
        {
            timestamp_ = timestamp;
        }
        const TimeSpan& Interval( ) const
        {
            return interval_;
        }
        void SetInterval( const TimeSpan& interval )
        {
            interval_ = interval;
        }
        double LowPressureLimit( ) const
        {
            return lowPressureLimit_;
        }
        void SetLowPressureLimit( double lowPressureLimit )
        {
            lowPressureLimit_ = lowPressureLimit;
        }
        double HighPressureLimit( ) const
        {
            return highPressureLimit_;
        }
        void SetHighPressureLimit( double highPressureLimit )
        {
            highPressureLimit_ = highPressureLimit;
        }
        double LowTemperatureLimit( ) const
        {
            return lowTemperatureLimit_;
        }
        void SetLowTemperatureLimit( double lowTemperatureLimit )
        {
            lowTemperatureLimit_ = lowTemperatureLimit;
        }
        double HighTemperatureLimit( ) const
        {
            return highTemperatureLimit_;
        }
        void SetHighTemperatureLimit( double highTemperatureLimit )
        {
            highTemperatureLimit_ = highTemperatureLimit;
        }
    };
    class ReferenceTimeseriesValueData : public BaseData<Kind, Guid>
    {
    public:
        using Base = BaseData<Kind, Guid>;
        static constexpr Kind KIND = Kind::ReferenceTimeseriesValue;
    private:
        Int64 rowVersion_ = 0;
        Guid timeseries_;
        DateTime timestamp_;
        Guid value_;
    public:
        ReferenceTimeseriesValueData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(rowVersion_);
            destination.Write(timeseries_);
            destination.Write(timestamp_);
            destination.Write(value_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(rowVersion_);
            source.Read(timeseries_);
            source.Read(timestamp_);
            source.Read(value_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<ReferenceTimeseriesValueData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<ReferenceTimeseriesValueData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const ReferenceTimeseriesValueData& >( other );
                if ( dataObject.rowVersion_ != rowVersion_ )
                {
                    return false;
                }
                if ( dataObject.timeseries_ != timeseries_ )
                {
                    return false;
                }
                if ( dataObject.timestamp_ != timestamp_ )
                {
                    return false;
                }
                if ( dataObject.value_ != value_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        Int64 RowVersion( ) const
        {
            return rowVersion_;
        }
        void SetRowVersion( const Int64& rowVersion )
        {
            rowVersion_ = rowVersion;
        }
        const Guid& Timeseries( ) const
        {
            return timeseries_;
        }
        void SetTimeseries( const Guid& timeseries )
        {
            timeseries_ = timeseries;
        }
        const DateTime& Timestamp( ) const
        {
            return timestamp_;
        }
        void SetTimestamp( const DateTime& timestamp )
        {
            timestamp_ = timestamp;
        }
        const Guid& Value( ) const
        {
            return value_;
        }
        void SetValue( const Guid& value )
        {
            value_ = value;
        }
    };
    class SByteTimeseriesValueData : public BaseData<Kind, Guid>
    {
    public:
        using Base = BaseData<Kind, Guid>;
        static constexpr Kind KIND = Kind::SByteTimeseriesValue;
    private:
        Int64 rowVersion_ = 0;
        Guid timeseries_;
        DateTime timestamp_;
        DBSByte value_;
    public:
        SByteTimeseriesValueData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(rowVersion_);
            destination.Write(timeseries_);
            destination.Write(timestamp_);
            value_.WriteTo( destination );
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(rowVersion_);
            source.Read(timeseries_);
            source.Read(timestamp_);
            value_.ReadFrom( source );
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<SByteTimeseriesValueData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<SByteTimeseriesValueData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const SByteTimeseriesValueData& >( other );
                if ( dataObject.rowVersion_ != rowVersion_ )
                {
                    return false;
                }
                if ( dataObject.timeseries_ != timeseries_ )
                {
                    return false;
                }
                if ( dataObject.timestamp_ != timestamp_ )
                {
                    return false;
                }
                if ( dataObject.value_ != value_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        Int64 RowVersion( ) const
        {
            return rowVersion_;
        }
        void SetRowVersion( const Int64& rowVersion )
        {
            rowVersion_ = rowVersion;
        }
        const Guid& Timeseries( ) const
        {
            return timeseries_;
        }
        void SetTimeseries( const Guid& timeseries )
        {
            timeseries_ = timeseries;
        }
        const DateTime& Timestamp( ) const
        {
            return timestamp_;
        }
        void SetTimestamp( const DateTime& timestamp )
        {
            timestamp_ = timestamp;
        }
        const DBSByte& Value( ) const
        {
            return value_;
        }
        void SetValue( const DBSByte& value )
        {
            value_ = value;
        }
    };
    class SecurityDomainData : public BaseData<Kind, Guid>
    {
    public:
        using Base = BaseData<Kind, Guid>;
        static constexpr Kind KIND = Kind::SecurityDomain;
    private:
        Int64 rowVersion_ = 0;
        FixedDBWideString<127> name_;
        WideString description_;
        SQLLEN descriptionLength_ = SQL_NULL_DATA;
    public:
        SecurityDomainData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(rowVersion_);
            name_.WriteTo( destination );
            destination.Write(description_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(rowVersion_);
            name_.ReadFrom( source );
            source.Read(description_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<SecurityDomainData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<SecurityDomainData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const SecurityDomainData& >( other );
                if ( dataObject.rowVersion_ != rowVersion_ )
                {
                    return false;
                }
                if ( dataObject.name_ != name_ )
                {
                    return false;
                }
                if ( dataObject.description_ != description_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        Int64 RowVersion( ) const
        {
            return rowVersion_;
        }
        void SetRowVersion( const Int64& rowVersion )
        {
            rowVersion_ = rowVersion;
        }
        const FixedDBWideString<127>& Name( ) const
        {
            return name_;
        }
        void SetName( const WideString& name )
        {
            name_ = name;
        }
        const WideString& Description( ) const
        {
            return description_;
        }
        void SetDescription( const WideString& description )
        {
            description_ = description;
        }
    };
    class SecurityIdentifierData : public BaseData<Kind, Guid>
    {
    public:
        using Base = BaseData<Kind, Guid>;
        static constexpr Kind KIND = Kind::SecurityIdentifier;
    private:
        Int64 rowVersion_ = 0;
        Guid domain_;
        FixedDBWideString<255> identity_;
        WideString description_;
        SQLLEN descriptionLength_ = SQL_NULL_DATA;
    public:
        SecurityIdentifierData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(rowVersion_);
            destination.Write(domain_);
            identity_.WriteTo( destination );
            destination.Write(description_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(rowVersion_);
            source.Read(domain_);
            identity_.ReadFrom( source );
            source.Read(description_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<SecurityIdentifierData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<SecurityIdentifierData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const SecurityIdentifierData& >( other );
                if ( dataObject.rowVersion_ != rowVersion_ )
                {
                    return false;
                }
                if ( dataObject.domain_ != domain_ )
                {
                    return false;
                }
                if ( dataObject.identity_ != identity_ )
                {
                    return false;
                }
                if ( dataObject.description_ != description_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        Int64 RowVersion( ) const
        {
            return rowVersion_;
        }
        void SetRowVersion( const Int64& rowVersion )
        {
            rowVersion_ = rowVersion;
        }
        const Guid& Domain( ) const
        {
            return domain_;
        }
        void SetDomain( const Guid& domain )
        {
            domain_ = domain;
        }
        const FixedDBWideString<255>& Identity( ) const
        {
            return identity_;
        }
        void SetIdentity( const WideString& identity )
        {
            identity_ = identity;
        }
        const WideString& Description( ) const
        {
            return description_;
        }
        void SetDescription( const WideString& description )
        {
            description_ = description;
        }
    };
    class SecurityLoginData : public SecurityIdentifierData
    {
    public:
        using Base = SecurityIdentifierData;
        static constexpr Kind KIND = Kind::SecurityLogin;
    private:
    public:
        SecurityLoginData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<SecurityLoginData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<SecurityLoginData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const SecurityLoginData& >( other );
                return true;
            }
            return false;
        }
    };
    class SecurityRoleData : public SecurityIdentifierData
    {
    public:
        using Base = SecurityIdentifierData;
        static constexpr Kind KIND = Kind::SecurityRole;
    private:
        FixedDBWideString<127> name_;
    public:
        SecurityRoleData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            name_.WriteTo( destination );
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            name_.ReadFrom( source );
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<SecurityRoleData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<SecurityRoleData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const SecurityRoleData& >( other );
                if ( dataObject.name_ != name_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        const FixedDBWideString<127>& Name( ) const
        {
            return name_;
        }
        void SetName( const WideString& name )
        {
            name_ = name;
        }
    };
    class SecurityIdentifierRoleLinkData : public BaseData<Kind, Guid>
    {
    public:
        using Base = BaseData<Kind, Guid>;
        static constexpr Kind KIND = Kind::SecurityIdentifierRoleLink;
    private:
        Int64 rowVersion_ = 0;
        Guid member_;
        Guid role_;
        DateTime start_;
        DBDateTime end_;
    public:
        SecurityIdentifierRoleLinkData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(rowVersion_);
            destination.Write(member_);
            destination.Write(role_);
            destination.Write(start_);
            end_.WriteTo( destination );
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(rowVersion_);
            source.Read(member_);
            source.Read(role_);
            source.Read(start_);
            end_.ReadFrom( source );
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<SecurityIdentifierRoleLinkData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<SecurityIdentifierRoleLinkData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const SecurityIdentifierRoleLinkData& >( other );
                if ( dataObject.rowVersion_ != rowVersion_ )
                {
                    return false;
                }
                if ( dataObject.member_ != member_ )
                {
                    return false;
                }
                if ( dataObject.role_ != role_ )
                {
                    return false;
                }
                if ( dataObject.start_ != start_ )
                {
                    return false;
                }
                if ( dataObject.end_ != end_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        Int64 RowVersion( ) const
        {
            return rowVersion_;
        }
        void SetRowVersion( const Int64& rowVersion )
        {
            rowVersion_ = rowVersion;
        }
        const Guid& Member( ) const
        {
            return member_;
        }
        void SetMember( const Guid& member )
        {
            member_ = member;
        }
        const Guid& Role( ) const
        {
            return role_;
        }
        void SetRole( const Guid& role )
        {
            role_ = role;
        }
        const DateTime& Start( ) const
        {
            return start_;
        }
        void SetStart( const DateTime& start )
        {
            start_ = start;
        }
        const DBDateTime& End( ) const
        {
            return end_;
        }
        void SetEnd( const DBDateTime& end )
        {
            end_ = end;
        }
    };
    class SecurityLoginSessionData : public BaseData<Kind, Guid>
    {
    public:
        using Base = BaseData<Kind, Guid>;
        static constexpr Kind KIND = Kind::SecurityLoginSession;
    private:
        Int64 rowVersion_ = 0;
        Guid login_;
        DateTime fromTime_;
        DBDateTime throughTime_;
        Guid clientSession_;
        FixedDBWideString<260> notificationQueueName_;
        FixedDBWideString<260> messageQueueName_;
    public:
        SecurityLoginSessionData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(rowVersion_);
            destination.Write(login_);
            destination.Write(fromTime_);
            throughTime_.WriteTo( destination );
            destination.Write(clientSession_);
            notificationQueueName_.WriteTo( destination );
            messageQueueName_.WriteTo( destination );
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(rowVersion_);
            source.Read(login_);
            source.Read(fromTime_);
            throughTime_.ReadFrom( source );
            source.Read(clientSession_);
            notificationQueueName_.ReadFrom( source );
            messageQueueName_.ReadFrom( source );
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<SecurityLoginSessionData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<SecurityLoginSessionData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const SecurityLoginSessionData& >( other );
                if ( dataObject.rowVersion_ != rowVersion_ )
                {
                    return false;
                }
                if ( dataObject.login_ != login_ )
                {
                    return false;
                }
                if ( dataObject.fromTime_ != fromTime_ )
                {
                    return false;
                }
                if ( dataObject.throughTime_ != throughTime_ )
                {
                    return false;
                }
                if ( dataObject.clientSession_ != clientSession_ )
                {
                    return false;
                }
                if ( dataObject.notificationQueueName_ != notificationQueueName_ )
                {
                    return false;
                }
                if ( dataObject.messageQueueName_ != messageQueueName_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        Int64 RowVersion( ) const
        {
            return rowVersion_;
        }
        void SetRowVersion( const Int64& rowVersion )
        {
            rowVersion_ = rowVersion;
        }
        const Guid& Login( ) const
        {
            return login_;
        }
        void SetLogin( const Guid& login )
        {
            login_ = login;
        }
        const DateTime& FromTime( ) const
        {
            return fromTime_;
        }
        void SetFromTime( const DateTime& fromTime )
        {
            fromTime_ = fromTime;
        }
        const DBDateTime& ThroughTime( ) const
        {
            return throughTime_;
        }
        void SetThroughTime( const DBDateTime& throughTime )
        {
            throughTime_ = throughTime;
        }
        const Guid& ClientSession( ) const
        {
            return clientSession_;
        }
        void SetClientSession( const Guid& clientSession )
        {
            clientSession_ = clientSession;
        }
        const FixedDBWideString<260>& NotificationQueueName( ) const
        {
            return notificationQueueName_;
        }
        void SetNotificationQueueName( const WideString& notificationQueueName )
        {
            notificationQueueName_ = notificationQueueName;
        }
        const FixedDBWideString<260>& MessageQueueName( ) const
        {
            return messageQueueName_;
        }
        void SetMessageQueueName( const WideString& messageQueueName )
        {
            messageQueueName_ = messageQueueName;
        }
    };
    class SecurityPermissionData : public BaseData<Kind, Guid>
    {
    public:
        using Base = BaseData<Kind, Guid>;
        static constexpr Kind KIND = Kind::SecurityPermission;
    private:
        Int64 rowVersion_ = 0;
        Guid identifier_;
        DateTime timestamp_;
        Int32 typeCode_ = 0;
        bool canCreate_ = false;
        bool canRead_ = false;
        bool canUpdate_ = false;
        bool canDelete_ = false;
    public:
        SecurityPermissionData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(rowVersion_);
            destination.Write(identifier_);
            destination.Write(timestamp_);
            destination.Write(typeCode_);
            destination.Write(canCreate_);
            destination.Write(canRead_);
            destination.Write(canUpdate_);
            destination.Write(canDelete_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(rowVersion_);
            source.Read(identifier_);
            source.Read(timestamp_);
            source.Read(typeCode_);
            source.Read(canCreate_);
            source.Read(canRead_);
            source.Read(canUpdate_);
            source.Read(canDelete_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<SecurityPermissionData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<SecurityPermissionData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const SecurityPermissionData& >( other );
                if ( dataObject.rowVersion_ != rowVersion_ )
                {
                    return false;
                }
                if ( dataObject.identifier_ != identifier_ )
                {
                    return false;
                }
                if ( dataObject.timestamp_ != timestamp_ )
                {
                    return false;
                }
                if ( dataObject.typeCode_ != typeCode_ )
                {
                    return false;
                }
                if ( dataObject.canCreate_ != canCreate_ )
                {
                    return false;
                }
                if ( dataObject.canRead_ != canRead_ )
                {
                    return false;
                }
                if ( dataObject.canUpdate_ != canUpdate_ )
                {
                    return false;
                }
                if ( dataObject.canDelete_ != canDelete_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        Int64 RowVersion( ) const
        {
            return rowVersion_;
        }
        void SetRowVersion( const Int64& rowVersion )
        {
            rowVersion_ = rowVersion;
        }
        const Guid& Identifier( ) const
        {
            return identifier_;
        }
        void SetIdentifier( const Guid& identifier )
        {
            identifier_ = identifier;
        }
        const DateTime& Timestamp( ) const
        {
            return timestamp_;
        }
        void SetTimestamp( const DateTime& timestamp )
        {
            timestamp_ = timestamp;
        }
        Int32 TypeCode( ) const
        {
            return typeCode_;
        }
        void SetTypeCode( Int32 typeCode )
        {
            typeCode_ = typeCode;
        }
        bool CanCreate( ) const
        {
            return canCreate_;
        }
        void SetCanCreate( bool canCreate )
        {
            canCreate_ = canCreate;
        }
        bool CanRead( ) const
        {
            return canRead_;
        }
        void SetCanRead( bool canRead )
        {
            canRead_ = canRead;
        }
        bool CanUpdate( ) const
        {
            return canUpdate_;
        }
        void SetCanUpdate( bool canUpdate )
        {
            canUpdate_ = canUpdate;
        }
        bool CanDelete( ) const
        {
            return canDelete_;
        }
        void SetCanDelete( bool canDelete )
        {
            canDelete_ = canDelete;
        }
    };
    class SingleTimeseriesValueData : public BaseData<Kind, Guid>
    {
    public:
        using Base = BaseData<Kind, Guid>;
        static constexpr Kind KIND = Kind::SingleTimeseriesValue;
    private:
        Int64 rowVersion_ = 0;
        Guid timeseries_;
        DateTime timestamp_;
        DBSingle value_;
    public:
        SingleTimeseriesValueData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(rowVersion_);
            destination.Write(timeseries_);
            destination.Write(timestamp_);
            value_.WriteTo( destination );
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(rowVersion_);
            source.Read(timeseries_);
            source.Read(timestamp_);
            value_.ReadFrom( source );
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<SingleTimeseriesValueData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<SingleTimeseriesValueData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const SingleTimeseriesValueData& >( other );
                if ( dataObject.rowVersion_ != rowVersion_ )
                {
                    return false;
                }
                if ( dataObject.timeseries_ != timeseries_ )
                {
                    return false;
                }
                if ( dataObject.timestamp_ != timestamp_ )
                {
                    return false;
                }
                if ( dataObject.value_ != value_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        Int64 RowVersion( ) const
        {
            return rowVersion_;
        }
        void SetRowVersion( const Int64& rowVersion )
        {
            rowVersion_ = rowVersion;
        }
        const Guid& Timeseries( ) const
        {
            return timeseries_;
        }
        void SetTimeseries( const Guid& timeseries )
        {
            timeseries_ = timeseries;
        }
        const DateTime& Timestamp( ) const
        {
            return timestamp_;
        }
        void SetTimestamp( const DateTime& timestamp )
        {
            timestamp_ = timestamp;
        }
        const DBSingle& Value( ) const
        {
            return value_;
        }
        void SetValue( const DBSingle& value )
        {
            value_ = value;
        }
    };
    class StringTimeseriesValueData : public BaseData<Kind, Guid>
    {
    public:
        using Base = BaseData<Kind, Guid>;
        static constexpr Kind KIND = Kind::StringTimeseriesValue;
    private:
        Int64 rowVersion_ = 0;
        Guid timeseries_;
        DateTime timestamp_;
        WideString value_;
        SQLLEN valueLength_ = SQL_NULL_DATA;
    public:
        StringTimeseriesValueData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(rowVersion_);
            destination.Write(timeseries_);
            destination.Write(timestamp_);
            destination.Write(value_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(rowVersion_);
            source.Read(timeseries_);
            source.Read(timestamp_);
            source.Read(value_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<StringTimeseriesValueData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<StringTimeseriesValueData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const StringTimeseriesValueData& >( other );
                if ( dataObject.rowVersion_ != rowVersion_ )
                {
                    return false;
                }
                if ( dataObject.timeseries_ != timeseries_ )
                {
                    return false;
                }
                if ( dataObject.timestamp_ != timestamp_ )
                {
                    return false;
                }
                if ( dataObject.value_ != value_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        Int64 RowVersion( ) const
        {
            return rowVersion_;
        }
        void SetRowVersion( const Int64& rowVersion )
        {
            rowVersion_ = rowVersion;
        }
        const Guid& Timeseries( ) const
        {
            return timeseries_;
        }
        void SetTimeseries( const Guid& timeseries )
        {
            timeseries_ = timeseries;
        }
        const DateTime& Timestamp( ) const
        {
            return timestamp_;
        }
        void SetTimestamp( const DateTime& timestamp )
        {
            timestamp_ = timestamp;
        }
        const WideString& Value( ) const
        {
            return value_;
        }
        void SetValue( const WideString& value )
        {
            value_ = value;
        }
    };
    class TimeseriesCatalogElementData : public BaseData<Kind, Guid>
    {
    public:
        using Base = BaseData<Kind, Guid>;
        static constexpr Kind KIND = Kind::TimeseriesCatalogElement;
    private:
        Int64 rowVersion_ = 0;
        Guid catalog_;
        FixedDBWideString<100> name_;
    public:
        TimeseriesCatalogElementData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(rowVersion_);
            destination.Write(catalog_);
            name_.WriteTo( destination );
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(rowVersion_);
            source.Read(catalog_);
            name_.ReadFrom( source );
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<TimeseriesCatalogElementData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<TimeseriesCatalogElementData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const TimeseriesCatalogElementData& >( other );
                if ( dataObject.rowVersion_ != rowVersion_ )
                {
                    return false;
                }
                if ( dataObject.catalog_ != catalog_ )
                {
                    return false;
                }
                if ( dataObject.name_ != name_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        Int64 RowVersion( ) const
        {
            return rowVersion_;
        }
        void SetRowVersion( const Int64& rowVersion )
        {
            rowVersion_ = rowVersion;
        }
        const Guid& Catalog( ) const
        {
            return catalog_;
        }
        void SetCatalog( const Guid& catalog )
        {
            catalog_ = catalog;
        }
        const FixedDBWideString<100>& Name( ) const
        {
            return name_;
        }
        void SetName( const WideString& name )
        {
            name_ = name;
        }
    };
    class TimeseriesData : public TimeseriesCatalogElementData
    {
    public:
        using Base = TimeseriesCatalogElementData;
        static constexpr Kind KIND = Kind::Timeseries;
    private:
        TimeSpan maxRetention_;
    public:
        TimeseriesData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(maxRetention_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(maxRetention_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<TimeseriesData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<TimeseriesData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const TimeseriesData& >( other );
                if ( dataObject.maxRetention_ != maxRetention_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        const TimeSpan& MaxRetention( ) const
        {
            return maxRetention_;
        }
        void SetMaxRetention( const TimeSpan& maxRetention )
        {
            maxRetention_ = maxRetention;
        }
    };
    class BinaryTimeseriesData : public TimeseriesData
    {
    public:
        using Base = TimeseriesData;
        static constexpr Kind KIND = Kind::BinaryTimeseries;
    private:
    public:
        BinaryTimeseriesData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<BinaryTimeseriesData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<BinaryTimeseriesData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const BinaryTimeseriesData& >( other );
                return true;
            }
            return false;
        }
    };
    class BooleanTimeseriesData : public TimeseriesData
    {
    public:
        using Base = TimeseriesData;
        static constexpr Kind KIND = Kind::BooleanTimeseries;
    private:
    public:
        BooleanTimeseriesData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<BooleanTimeseriesData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<BooleanTimeseriesData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const BooleanTimeseriesData& >( other );
                return true;
            }
            return false;
        }
    };
    class AisAidToNavigationOffPositionTimeseriesData : public BooleanTimeseriesData
    {
    public:
        using Base = BooleanTimeseriesData;
        static constexpr Kind KIND = Kind::AisAidToNavigationOffPositionTimeseries;
    private:
        Guid aidToNavigation_;
    public:
        AisAidToNavigationOffPositionTimeseriesData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(aidToNavigation_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(aidToNavigation_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<AisAidToNavigationOffPositionTimeseriesData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<AisAidToNavigationOffPositionTimeseriesData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const AisAidToNavigationOffPositionTimeseriesData& >( other );
                if ( dataObject.aidToNavigation_ != aidToNavigation_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        const Guid& AidToNavigation( ) const
        {
            return aidToNavigation_;
        }
        void SetAidToNavigation( const Guid& aidToNavigation )
        {
            aidToNavigation_ = aidToNavigation;
        }
    };
    class DeviceEnabledTimeseriesData : public BooleanTimeseriesData
    {
    public:
        using Base = BooleanTimeseriesData;
        static constexpr Kind KIND = Kind::DeviceEnabledTimeseries;
    private:
        Guid device_;
    public:
        DeviceEnabledTimeseriesData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(device_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(device_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<DeviceEnabledTimeseriesData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<DeviceEnabledTimeseriesData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const DeviceEnabledTimeseriesData& >( other );
                if ( dataObject.device_ != device_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        const Guid& Device( ) const
        {
            return device_;
        }
        void SetDevice( const Guid& device )
        {
            device_ = device;
        }
    };
    class RadarAutomaticSensitivityTimeControlTimeseriesData : public BooleanTimeseriesData
    {
    public:
        using Base = BooleanTimeseriesData;
        static constexpr Kind KIND = Kind::RadarAutomaticSensitivityTimeControlTimeseries;
    private:
        Guid radar_;
    public:
        RadarAutomaticSensitivityTimeControlTimeseriesData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(radar_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(radar_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<RadarAutomaticSensitivityTimeControlTimeseriesData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<RadarAutomaticSensitivityTimeControlTimeseriesData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const RadarAutomaticSensitivityTimeControlTimeseriesData& >( other );
                if ( dataObject.radar_ != radar_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        const Guid& Radar( ) const
        {
            return radar_;
        }
        void SetRadar( const Guid& radar )
        {
            radar_ = radar;
        }
    };
    class RadarBlankSector1TimeseriesData : public BooleanTimeseriesData
    {
    public:
        using Base = BooleanTimeseriesData;
        static constexpr Kind KIND = Kind::RadarBlankSector1Timeseries;
    private:
        Guid radar_;
    public:
        RadarBlankSector1TimeseriesData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(radar_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(radar_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<RadarBlankSector1TimeseriesData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<RadarBlankSector1TimeseriesData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const RadarBlankSector1TimeseriesData& >( other );
                if ( dataObject.radar_ != radar_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        const Guid& Radar( ) const
        {
            return radar_;
        }
        void SetRadar( const Guid& radar )
        {
            radar_ = radar;
        }
    };
    class RadarBlankSector2TimeseriesData : public BooleanTimeseriesData
    {
    public:
        using Base = BooleanTimeseriesData;
        static constexpr Kind KIND = Kind::RadarBlankSector2Timeseries;
    private:
        Guid radar_;
    public:
        RadarBlankSector2TimeseriesData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(radar_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(radar_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<RadarBlankSector2TimeseriesData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<RadarBlankSector2TimeseriesData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const RadarBlankSector2TimeseriesData& >( other );
                if ( dataObject.radar_ != radar_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        const Guid& Radar( ) const
        {
            return radar_;
        }
        void SetRadar( const Guid& radar )
        {
            radar_ = radar;
        }
    };
    class RadarEnableAutomaticFrequencyControlTimeseriesData : public BooleanTimeseriesData
    {
    public:
        using Base = BooleanTimeseriesData;
        static constexpr Kind KIND = Kind::RadarEnableAutomaticFrequencyControlTimeseries;
    private:
        Guid radar_;
    public:
        RadarEnableAutomaticFrequencyControlTimeseriesData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(radar_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(radar_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<RadarEnableAutomaticFrequencyControlTimeseriesData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<RadarEnableAutomaticFrequencyControlTimeseriesData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const RadarEnableAutomaticFrequencyControlTimeseriesData& >( other );
                if ( dataObject.radar_ != radar_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        const Guid& Radar( ) const
        {
            return radar_;
        }
        void SetRadar( const Guid& radar )
        {
            radar_ = radar;
        }
    };
    class RadarEnableFastTimeConstantTimeseriesData : public BooleanTimeseriesData
    {
    public:
        using Base = BooleanTimeseriesData;
        static constexpr Kind KIND = Kind::RadarEnableFastTimeConstantTimeseries;
    private:
        Guid radar_;
    public:
        RadarEnableFastTimeConstantTimeseriesData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(radar_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(radar_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<RadarEnableFastTimeConstantTimeseriesData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<RadarEnableFastTimeConstantTimeseriesData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const RadarEnableFastTimeConstantTimeseriesData& >( other );
                if ( dataObject.radar_ != radar_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        const Guid& Radar( ) const
        {
            return radar_;
        }
        void SetRadar( const Guid& radar )
        {
            radar_ = radar;
        }
    };
    class RadarEnableSensitivityTimeControlTimeseriesData : public BooleanTimeseriesData
    {
    public:
        using Base = BooleanTimeseriesData;
        static constexpr Kind KIND = Kind::RadarEnableSensitivityTimeControlTimeseries;
    private:
        Guid radar_;
    public:
        RadarEnableSensitivityTimeControlTimeseriesData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(radar_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(radar_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<RadarEnableSensitivityTimeControlTimeseriesData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<RadarEnableSensitivityTimeControlTimeseriesData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const RadarEnableSensitivityTimeControlTimeseriesData& >( other );
                if ( dataObject.radar_ != radar_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        const Guid& Radar( ) const
        {
            return radar_;
        }
        void SetRadar( const Guid& radar )
        {
            radar_ = radar;
        }
    };
    class RadarPowerOnTimeseriesData : public BooleanTimeseriesData
    {
    public:
        using Base = BooleanTimeseriesData;
        static constexpr Kind KIND = Kind::RadarPowerOnTimeseries;
    private:
        Guid radar_;
    public:
        RadarPowerOnTimeseriesData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(radar_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(radar_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<RadarPowerOnTimeseriesData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<RadarPowerOnTimeseriesData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const RadarPowerOnTimeseriesData& >( other );
                if ( dataObject.radar_ != radar_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        const Guid& Radar( ) const
        {
            return radar_;
        }
        void SetRadar( const Guid& radar )
        {
            radar_ = radar;
        }
    };
    class RadarSaveSettingsTimeseriesData : public BooleanTimeseriesData
    {
    public:
        using Base = BooleanTimeseriesData;
        static constexpr Kind KIND = Kind::RadarSaveSettingsTimeseries;
    private:
        Guid radar_;
    public:
        RadarSaveSettingsTimeseriesData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(radar_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(radar_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<RadarSaveSettingsTimeseriesData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<RadarSaveSettingsTimeseriesData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const RadarSaveSettingsTimeseriesData& >( other );
                if ( dataObject.radar_ != radar_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        const Guid& Radar( ) const
        {
            return radar_;
        }
        void SetRadar( const Guid& radar )
        {
            radar_ = radar;
        }
    };
    class RadarTrackingTimeseriesData : public BooleanTimeseriesData
    {
    public:
        using Base = BooleanTimeseriesData;
        static constexpr Kind KIND = Kind::RadarTrackingTimeseries;
    private:
        Guid radar_;
    public:
        RadarTrackingTimeseriesData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(radar_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(radar_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<RadarTrackingTimeseriesData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<RadarTrackingTimeseriesData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const RadarTrackingTimeseriesData& >( other );
                if ( dataObject.radar_ != radar_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        const Guid& Radar( ) const
        {
            return radar_;
        }
        void SetRadar( const Guid& radar )
        {
            radar_ = radar;
        }
    };
    class MediaProxySessionEnabledTimeseriesData : public BooleanTimeseriesData
    {
    public:
        using Base = BooleanTimeseriesData;
        static constexpr Kind KIND = Kind::MediaProxySessionEnabledTimeseries;
    private:
        Guid proxySession_;
    public:
        MediaProxySessionEnabledTimeseriesData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(proxySession_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(proxySession_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<MediaProxySessionEnabledTimeseriesData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<MediaProxySessionEnabledTimeseriesData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const MediaProxySessionEnabledTimeseriesData& >( other );
                if ( dataObject.proxySession_ != proxySession_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        const Guid& ProxySession( ) const
        {
            return proxySession_;
        }
        void SetProxySession( const Guid& proxySession )
        {
            proxySession_ = proxySession;
        }
    };
    class MediaServiceEnabledTimeseriesData : public BooleanTimeseriesData
    {
    public:
        using Base = BooleanTimeseriesData;
        static constexpr Kind KIND = Kind::MediaServiceEnabledTimeseries;
    private:
        Guid service_;
    public:
        MediaServiceEnabledTimeseriesData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(service_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(service_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<MediaServiceEnabledTimeseriesData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<MediaServiceEnabledTimeseriesData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const MediaServiceEnabledTimeseriesData& >( other );
                if ( dataObject.service_ != service_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        const Guid& Service( ) const
        {
            return service_;
        }
        void SetService( const Guid& service )
        {
            service_ = service;
        }
    };
    class ByteTimeseriesData : public TimeseriesData
    {
    public:
        using Base = TimeseriesData;
        static constexpr Kind KIND = Kind::ByteTimeseries;
    private:
    public:
        ByteTimeseriesData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<ByteTimeseriesData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<ByteTimeseriesData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const ByteTimeseriesData& >( other );
                return true;
            }
            return false;
        }
    };
    class DateTimeTimeseriesData : public TimeseriesData
    {
    public:
        using Base = TimeseriesData;
        static constexpr Kind KIND = Kind::DateTimeTimeseries;
    private:
    public:
        DateTimeTimeseriesData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<DateTimeTimeseriesData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<DateTimeTimeseriesData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const DateTimeTimeseriesData& >( other );
                return true;
            }
            return false;
        }
    };
    class DoubleTimeseriesData : public TimeseriesData
    {
    public:
        using Base = TimeseriesData;
        static constexpr Kind KIND = Kind::DoubleTimeseries;
    private:
    public:
        DoubleTimeseriesData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<DoubleTimeseriesData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<DoubleTimeseriesData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const DoubleTimeseriesData& >( other );
                return true;
            }
            return false;
        }
    };
    class GNSSAltitudeTimeseriesData : public DoubleTimeseriesData
    {
    public:
        using Base = DoubleTimeseriesData;
        static constexpr Kind KIND = Kind::GNSSAltitudeTimeseries;
    private:
        Guid gNSSDevice_;
    public:
        GNSSAltitudeTimeseriesData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(gNSSDevice_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(gNSSDevice_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<GNSSAltitudeTimeseriesData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<GNSSAltitudeTimeseriesData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const GNSSAltitudeTimeseriesData& >( other );
                if ( dataObject.gNSSDevice_ != gNSSDevice_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        const Guid& GNSSDevice( ) const
        {
            return gNSSDevice_;
        }
        void SetGNSSDevice( const Guid& gNSSDevice )
        {
            gNSSDevice_ = gNSSDevice;
        }
    };
    class GNSSLatitudeTimeseriesData : public DoubleTimeseriesData
    {
    public:
        using Base = DoubleTimeseriesData;
        static constexpr Kind KIND = Kind::GNSSLatitudeTimeseries;
    private:
        Guid gNSSDevice_;
    public:
        GNSSLatitudeTimeseriesData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(gNSSDevice_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(gNSSDevice_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<GNSSLatitudeTimeseriesData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<GNSSLatitudeTimeseriesData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const GNSSLatitudeTimeseriesData& >( other );
                if ( dataObject.gNSSDevice_ != gNSSDevice_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        const Guid& GNSSDevice( ) const
        {
            return gNSSDevice_;
        }
        void SetGNSSDevice( const Guid& gNSSDevice )
        {
            gNSSDevice_ = gNSSDevice;
        }
    };
    class GNSSLongitudeTimeseriesData : public DoubleTimeseriesData
    {
    public:
        using Base = DoubleTimeseriesData;
        static constexpr Kind KIND = Kind::GNSSLongitudeTimeseries;
    private:
        Guid gNSSDevice_;
    public:
        GNSSLongitudeTimeseriesData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(gNSSDevice_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(gNSSDevice_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<GNSSLongitudeTimeseriesData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<GNSSLongitudeTimeseriesData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const GNSSLongitudeTimeseriesData& >( other );
                if ( dataObject.gNSSDevice_ != gNSSDevice_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        const Guid& GNSSDevice( ) const
        {
            return gNSSDevice_;
        }
        void SetGNSSDevice( const Guid& gNSSDevice )
        {
            gNSSDevice_ = gNSSDevice;
        }
    };
    class GyroCourseTimeseriesData : public DoubleTimeseriesData
    {
    public:
        using Base = DoubleTimeseriesData;
        static constexpr Kind KIND = Kind::GyroCourseTimeseries;
    private:
        Guid gyroDevice_;
    public:
        GyroCourseTimeseriesData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(gyroDevice_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(gyroDevice_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<GyroCourseTimeseriesData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<GyroCourseTimeseriesData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const GyroCourseTimeseriesData& >( other );
                if ( dataObject.gyroDevice_ != gyroDevice_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        const Guid& GyroDevice( ) const
        {
            return gyroDevice_;
        }
        void SetGyroDevice( const Guid& gyroDevice )
        {
            gyroDevice_ = gyroDevice;
        }
    };
    class GyroHeadingMagneticNorthTimeseriesData : public DoubleTimeseriesData
    {
    public:
        using Base = DoubleTimeseriesData;
        static constexpr Kind KIND = Kind::GyroHeadingMagneticNorthTimeseries;
    private:
        Guid gyroDevice_;
    public:
        GyroHeadingMagneticNorthTimeseriesData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(gyroDevice_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(gyroDevice_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<GyroHeadingMagneticNorthTimeseriesData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<GyroHeadingMagneticNorthTimeseriesData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const GyroHeadingMagneticNorthTimeseriesData& >( other );
                if ( dataObject.gyroDevice_ != gyroDevice_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        const Guid& GyroDevice( ) const
        {
            return gyroDevice_;
        }
        void SetGyroDevice( const Guid& gyroDevice )
        {
            gyroDevice_ = gyroDevice;
        }
    };
    class GyroHeadingTrueNorthTimeseriesData : public DoubleTimeseriesData
    {
    public:
        using Base = DoubleTimeseriesData;
        static constexpr Kind KIND = Kind::GyroHeadingTrueNorthTimeseries;
    private:
        Guid gyroDevice_;
    public:
        GyroHeadingTrueNorthTimeseriesData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(gyroDevice_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(gyroDevice_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<GyroHeadingTrueNorthTimeseriesData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<GyroHeadingTrueNorthTimeseriesData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const GyroHeadingTrueNorthTimeseriesData& >( other );
                if ( dataObject.gyroDevice_ != gyroDevice_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        const Guid& GyroDevice( ) const
        {
            return gyroDevice_;
        }
        void SetGyroDevice( const Guid& gyroDevice )
        {
            gyroDevice_ = gyroDevice;
        }
    };
    class GyroPitchTimeseriesData : public DoubleTimeseriesData
    {
    public:
        using Base = DoubleTimeseriesData;
        static constexpr Kind KIND = Kind::GyroPitchTimeseries;
    private:
        Guid gyroDevice_;
    public:
        GyroPitchTimeseriesData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(gyroDevice_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(gyroDevice_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<GyroPitchTimeseriesData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<GyroPitchTimeseriesData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const GyroPitchTimeseriesData& >( other );
                if ( dataObject.gyroDevice_ != gyroDevice_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        const Guid& GyroDevice( ) const
        {
            return gyroDevice_;
        }
        void SetGyroDevice( const Guid& gyroDevice )
        {
            gyroDevice_ = gyroDevice;
        }
    };
    class GyroRateOfTurnTimeseriesData : public DoubleTimeseriesData
    {
    public:
        using Base = DoubleTimeseriesData;
        static constexpr Kind KIND = Kind::GyroRateOfTurnTimeseries;
    private:
        Guid gyroDevice_;
    public:
        GyroRateOfTurnTimeseriesData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(gyroDevice_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(gyroDevice_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<GyroRateOfTurnTimeseriesData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<GyroRateOfTurnTimeseriesData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const GyroRateOfTurnTimeseriesData& >( other );
                if ( dataObject.gyroDevice_ != gyroDevice_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        const Guid& GyroDevice( ) const
        {
            return gyroDevice_;
        }
        void SetGyroDevice( const Guid& gyroDevice )
        {
            gyroDevice_ = gyroDevice;
        }
    };
    class GyroRollTimeseriesData : public DoubleTimeseriesData
    {
    public:
        using Base = DoubleTimeseriesData;
        static constexpr Kind KIND = Kind::GyroRollTimeseries;
    private:
        Guid gyroDevice_;
    public:
        GyroRollTimeseriesData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(gyroDevice_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(gyroDevice_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<GyroRollTimeseriesData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<GyroRollTimeseriesData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const GyroRollTimeseriesData& >( other );
                if ( dataObject.gyroDevice_ != gyroDevice_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        const Guid& GyroDevice( ) const
        {
            return gyroDevice_;
        }
        void SetGyroDevice( const Guid& gyroDevice )
        {
            gyroDevice_ = gyroDevice;
        }
    };
    class GyroSpeedTimeseriesData : public DoubleTimeseriesData
    {
    public:
        using Base = DoubleTimeseriesData;
        static constexpr Kind KIND = Kind::GyroSpeedTimeseries;
    private:
        Guid gyroDevice_;
    public:
        GyroSpeedTimeseriesData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(gyroDevice_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(gyroDevice_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<GyroSpeedTimeseriesData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<GyroSpeedTimeseriesData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const GyroSpeedTimeseriesData& >( other );
                if ( dataObject.gyroDevice_ != gyroDevice_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        const Guid& GyroDevice( ) const
        {
            return gyroDevice_;
        }
        void SetGyroDevice( const Guid& gyroDevice )
        {
            gyroDevice_ = gyroDevice;
        }
    };
    class RadarLatitudeTimeseriesData : public DoubleTimeseriesData
    {
    public:
        using Base = DoubleTimeseriesData;
        static constexpr Kind KIND = Kind::RadarLatitudeTimeseries;
    private:
        Guid radar_;
    public:
        RadarLatitudeTimeseriesData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(radar_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(radar_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<RadarLatitudeTimeseriesData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<RadarLatitudeTimeseriesData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const RadarLatitudeTimeseriesData& >( other );
                if ( dataObject.radar_ != radar_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        const Guid& Radar( ) const
        {
            return radar_;
        }
        void SetRadar( const Guid& radar )
        {
            radar_ = radar;
        }
    };
    class RadarLongitudeTimeseriesData : public DoubleTimeseriesData
    {
    public:
        using Base = DoubleTimeseriesData;
        static constexpr Kind KIND = Kind::RadarLongitudeTimeseries;
    private:
        Guid radar_;
    public:
        RadarLongitudeTimeseriesData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(radar_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(radar_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<RadarLongitudeTimeseriesData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<RadarLongitudeTimeseriesData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const RadarLongitudeTimeseriesData& >( other );
                if ( dataObject.radar_ != radar_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        const Guid& Radar( ) const
        {
            return radar_;
        }
        void SetRadar( const Guid& radar )
        {
            radar_ = radar;
        }
    };
    class RadomeDewPointTimeseriesData : public DoubleTimeseriesData
    {
    public:
        using Base = DoubleTimeseriesData;
        static constexpr Kind KIND = Kind::RadomeDewPointTimeseries;
    private:
        Guid radome_;
    public:
        RadomeDewPointTimeseriesData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(radome_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(radome_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<RadomeDewPointTimeseriesData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<RadomeDewPointTimeseriesData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const RadomeDewPointTimeseriesData& >( other );
                if ( dataObject.radome_ != radome_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        const Guid& Radome( ) const
        {
            return radome_;
        }
        void SetRadome( const Guid& radome )
        {
            radome_ = radome;
        }
    };
    class RadomePressureTimeseriesData : public DoubleTimeseriesData
    {
    public:
        using Base = DoubleTimeseriesData;
        static constexpr Kind KIND = Kind::RadomePressureTimeseries;
    private:
        Guid radome_;
    public:
        RadomePressureTimeseriesData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(radome_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(radome_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<RadomePressureTimeseriesData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<RadomePressureTimeseriesData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const RadomePressureTimeseriesData& >( other );
                if ( dataObject.radome_ != radome_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        const Guid& Radome( ) const
        {
            return radome_;
        }
        void SetRadome( const Guid& radome )
        {
            radome_ = radome;
        }
    };
    class RadomeTemperatureTimeseriesData : public DoubleTimeseriesData
    {
    public:
        using Base = DoubleTimeseriesData;
        static constexpr Kind KIND = Kind::RadomeTemperatureTimeseries;
    private:
        Guid radome_;
    public:
        RadomeTemperatureTimeseriesData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(radome_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(radome_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<RadomeTemperatureTimeseriesData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<RadomeTemperatureTimeseriesData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const RadomeTemperatureTimeseriesData& >( other );
                if ( dataObject.radome_ != radome_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        const Guid& Radome( ) const
        {
            return radome_;
        }
        void SetRadome( const Guid& radome )
        {
            radome_ = radome;
        }
    };
    class VesselDraughtTimeseriesData : public DoubleTimeseriesData
    {
    public:
        using Base = DoubleTimeseriesData;
        static constexpr Kind KIND = Kind::VesselDraughtTimeseries;
    private:
        Guid vessel_;
    public:
        VesselDraughtTimeseriesData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(vessel_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(vessel_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<VesselDraughtTimeseriesData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<VesselDraughtTimeseriesData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const VesselDraughtTimeseriesData& >( other );
                if ( dataObject.vessel_ != vessel_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        const Guid& Vessel( ) const
        {
            return vessel_;
        }
        void SetVessel( const Guid& vessel )
        {
            vessel_ = vessel;
        }
    };
    class ViewLatitudeTimeseriesData : public DoubleTimeseriesData
    {
    public:
        using Base = DoubleTimeseriesData;
        static constexpr Kind KIND = Kind::ViewLatitudeTimeseries;
    private:
        Guid view_;
    public:
        ViewLatitudeTimeseriesData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(view_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(view_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<ViewLatitudeTimeseriesData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<ViewLatitudeTimeseriesData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const ViewLatitudeTimeseriesData& >( other );
                if ( dataObject.view_ != view_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        const Guid& View( ) const
        {
            return view_;
        }
        void SetView( const Guid& view )
        {
            view_ = view;
        }
    };
    class ViewLongitudeTimeseriesData : public DoubleTimeseriesData
    {
    public:
        using Base = DoubleTimeseriesData;
        static constexpr Kind KIND = Kind::ViewLongitudeTimeseries;
    private:
        Guid view_;
    public:
        ViewLongitudeTimeseriesData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(view_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(view_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<ViewLongitudeTimeseriesData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<ViewLongitudeTimeseriesData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const ViewLongitudeTimeseriesData& >( other );
                if ( dataObject.view_ != view_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        const Guid& View( ) const
        {
            return view_;
        }
        void SetView( const Guid& view )
        {
            view_ = view;
        }
    };
    class ViewZoomLevelTimeseriesData : public DoubleTimeseriesData
    {
    public:
        using Base = DoubleTimeseriesData;
        static constexpr Kind KIND = Kind::ViewZoomLevelTimeseries;
    private:
        Guid view_;
    public:
        ViewZoomLevelTimeseriesData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(view_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(view_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<ViewZoomLevelTimeseriesData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<ViewZoomLevelTimeseriesData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const ViewZoomLevelTimeseriesData& >( other );
                if ( dataObject.view_ != view_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        const Guid& View( ) const
        {
            return view_;
        }
        void SetView( const Guid& view )
        {
            view_ = view;
        }
    };
    class WeatherStationAbsoluteHumidityTimeseriesData : public DoubleTimeseriesData
    {
    public:
        using Base = DoubleTimeseriesData;
        static constexpr Kind KIND = Kind::WeatherStationAbsoluteHumidityTimeseries;
    private:
        Guid weatherStation_;
    public:
        WeatherStationAbsoluteHumidityTimeseriesData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(weatherStation_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(weatherStation_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<WeatherStationAbsoluteHumidityTimeseriesData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<WeatherStationAbsoluteHumidityTimeseriesData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const WeatherStationAbsoluteHumidityTimeseriesData& >( other );
                if ( dataObject.weatherStation_ != weatherStation_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        const Guid& WeatherStation( ) const
        {
            return weatherStation_;
        }
        void SetWeatherStation( const Guid& weatherStation )
        {
            weatherStation_ = weatherStation;
        }
    };
    class WeatherStationAirTemperatureTimeseriesData : public DoubleTimeseriesData
    {
    public:
        using Base = DoubleTimeseriesData;
        static constexpr Kind KIND = Kind::WeatherStationAirTemperatureTimeseries;
    private:
        Guid weatherStation_;
    public:
        WeatherStationAirTemperatureTimeseriesData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(weatherStation_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(weatherStation_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<WeatherStationAirTemperatureTimeseriesData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<WeatherStationAirTemperatureTimeseriesData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const WeatherStationAirTemperatureTimeseriesData& >( other );
                if ( dataObject.weatherStation_ != weatherStation_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        const Guid& WeatherStation( ) const
        {
            return weatherStation_;
        }
        void SetWeatherStation( const Guid& weatherStation )
        {
            weatherStation_ = weatherStation;
        }
    };
    class WeatherStationBarometricPressureTimeseriesData : public DoubleTimeseriesData
    {
    public:
        using Base = DoubleTimeseriesData;
        static constexpr Kind KIND = Kind::WeatherStationBarometricPressureTimeseries;
    private:
        Guid weatherStation_;
    public:
        WeatherStationBarometricPressureTimeseriesData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(weatherStation_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(weatherStation_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<WeatherStationBarometricPressureTimeseriesData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<WeatherStationBarometricPressureTimeseriesData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const WeatherStationBarometricPressureTimeseriesData& >( other );
                if ( dataObject.weatherStation_ != weatherStation_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        const Guid& WeatherStation( ) const
        {
            return weatherStation_;
        }
        void SetWeatherStation( const Guid& weatherStation )
        {
            weatherStation_ = weatherStation;
        }
    };
    class WeatherStationDewPointTimeseriesData : public DoubleTimeseriesData
    {
    public:
        using Base = DoubleTimeseriesData;
        static constexpr Kind KIND = Kind::WeatherStationDewPointTimeseries;
    private:
        Guid weatherStation_;
    public:
        WeatherStationDewPointTimeseriesData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(weatherStation_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(weatherStation_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<WeatherStationDewPointTimeseriesData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<WeatherStationDewPointTimeseriesData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const WeatherStationDewPointTimeseriesData& >( other );
                if ( dataObject.weatherStation_ != weatherStation_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        const Guid& WeatherStation( ) const
        {
            return weatherStation_;
        }
        void SetWeatherStation( const Guid& weatherStation )
        {
            weatherStation_ = weatherStation;
        }
    };
    class WeatherStationRelativeHumidityTimeseriesData : public DoubleTimeseriesData
    {
    public:
        using Base = DoubleTimeseriesData;
        static constexpr Kind KIND = Kind::WeatherStationRelativeHumidityTimeseries;
    private:
        Guid weatherStation_;
    public:
        WeatherStationRelativeHumidityTimeseriesData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(weatherStation_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(weatherStation_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<WeatherStationRelativeHumidityTimeseriesData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<WeatherStationRelativeHumidityTimeseriesData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const WeatherStationRelativeHumidityTimeseriesData& >( other );
                if ( dataObject.weatherStation_ != weatherStation_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        const Guid& WeatherStation( ) const
        {
            return weatherStation_;
        }
        void SetWeatherStation( const Guid& weatherStation )
        {
            weatherStation_ = weatherStation;
        }
    };
    class WeatherStationWaterTemperatureTimeseriesData : public DoubleTimeseriesData
    {
    public:
        using Base = DoubleTimeseriesData;
        static constexpr Kind KIND = Kind::WeatherStationWaterTemperatureTimeseries;
    private:
        Guid weatherStation_;
    public:
        WeatherStationWaterTemperatureTimeseriesData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(weatherStation_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(weatherStation_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<WeatherStationWaterTemperatureTimeseriesData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<WeatherStationWaterTemperatureTimeseriesData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const WeatherStationWaterTemperatureTimeseriesData& >( other );
                if ( dataObject.weatherStation_ != weatherStation_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        const Guid& WeatherStation( ) const
        {
            return weatherStation_;
        }
        void SetWeatherStation( const Guid& weatherStation )
        {
            weatherStation_ = weatherStation;
        }
    };
    class WeatherStationWindDirectionTimeseriesData : public DoubleTimeseriesData
    {
    public:
        using Base = DoubleTimeseriesData;
        static constexpr Kind KIND = Kind::WeatherStationWindDirectionTimeseries;
    private:
        Guid weatherStation_;
    public:
        WeatherStationWindDirectionTimeseriesData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(weatherStation_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(weatherStation_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<WeatherStationWindDirectionTimeseriesData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<WeatherStationWindDirectionTimeseriesData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const WeatherStationWindDirectionTimeseriesData& >( other );
                if ( dataObject.weatherStation_ != weatherStation_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        const Guid& WeatherStation( ) const
        {
            return weatherStation_;
        }
        void SetWeatherStation( const Guid& weatherStation )
        {
            weatherStation_ = weatherStation;
        }
    };
    class WeatherStationWindSpeedTimeseriesData : public DoubleTimeseriesData
    {
    public:
        using Base = DoubleTimeseriesData;
        static constexpr Kind KIND = Kind::WeatherStationWindSpeedTimeseries;
    private:
        Guid weatherStation_;
    public:
        WeatherStationWindSpeedTimeseriesData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(weatherStation_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(weatherStation_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<WeatherStationWindSpeedTimeseriesData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<WeatherStationWindSpeedTimeseriesData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const WeatherStationWindSpeedTimeseriesData& >( other );
                if ( dataObject.weatherStation_ != weatherStation_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        const Guid& WeatherStation( ) const
        {
            return weatherStation_;
        }
        void SetWeatherStation( const Guid& weatherStation )
        {
            weatherStation_ = weatherStation;
        }
    };
    class GeoPosition2DTimeseriesData : public TimeseriesData
    {
    public:
        using Base = TimeseriesData;
        static constexpr Kind KIND = Kind::GeoPosition2DTimeseries;
    private:
    public:
        GeoPosition2DTimeseriesData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<GeoPosition2DTimeseriesData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<GeoPosition2DTimeseriesData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const GeoPosition2DTimeseriesData& >( other );
                return true;
            }
            return false;
        }
    };
    class AisAidToNavigationPositionTimeseriesData : public GeoPosition2DTimeseriesData
    {
    public:
        using Base = GeoPosition2DTimeseriesData;
        static constexpr Kind KIND = Kind::AisAidToNavigationPositionTimeseries;
    private:
        Guid aidToNavigation_;
    public:
        AisAidToNavigationPositionTimeseriesData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(aidToNavigation_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(aidToNavigation_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<AisAidToNavigationPositionTimeseriesData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<AisAidToNavigationPositionTimeseriesData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const AisAidToNavigationPositionTimeseriesData& >( other );
                if ( dataObject.aidToNavigation_ != aidToNavigation_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        const Guid& AidToNavigation( ) const
        {
            return aidToNavigation_;
        }
        void SetAidToNavigation( const Guid& aidToNavigation )
        {
            aidToNavigation_ = aidToNavigation;
        }
    };
    class GeoPosition3DTimeseriesData : public TimeseriesData
    {
    public:
        using Base = TimeseriesData;
        static constexpr Kind KIND = Kind::GeoPosition3DTimeseries;
    private:
    public:
        GeoPosition3DTimeseriesData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<GeoPosition3DTimeseriesData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<GeoPosition3DTimeseriesData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const GeoPosition3DTimeseriesData& >( other );
                return true;
            }
            return false;
        }
    };
    class GuidTimeseriesData : public TimeseriesData
    {
    public:
        using Base = TimeseriesData;
        static constexpr Kind KIND = Kind::GuidTimeseries;
    private:
    public:
        GuidTimeseriesData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<GuidTimeseriesData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<GuidTimeseriesData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const GuidTimeseriesData& >( other );
                return true;
            }
            return false;
        }
    };
    class Int16TimeseriesData : public TimeseriesData
    {
    public:
        using Base = TimeseriesData;
        static constexpr Kind KIND = Kind::Int16Timeseries;
    private:
    public:
        Int16TimeseriesData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<Int16TimeseriesData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<Int16TimeseriesData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const Int16TimeseriesData& >( other );
                return true;
            }
            return false;
        }
    };
    class Int32TimeseriesData : public TimeseriesData
    {
    public:
        using Base = TimeseriesData;
        static constexpr Kind KIND = Kind::Int32Timeseries;
    private:
    public:
        Int32TimeseriesData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<Int32TimeseriesData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<Int32TimeseriesData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const Int32TimeseriesData& >( other );
                return true;
            }
            return false;
        }
    };
    class RadarAzimuthOffsetTimeseriesData : public Int32TimeseriesData
    {
    public:
        using Base = Int32TimeseriesData;
        static constexpr Kind KIND = Kind::RadarAzimuthOffsetTimeseries;
    private:
        Guid radar_;
    public:
        RadarAzimuthOffsetTimeseriesData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(radar_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(radar_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<RadarAzimuthOffsetTimeseriesData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<RadarAzimuthOffsetTimeseriesData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const RadarAzimuthOffsetTimeseriesData& >( other );
                if ( dataObject.radar_ != radar_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        const Guid& Radar( ) const
        {
            return radar_;
        }
        void SetRadar( const Guid& radar )
        {
            radar_ = radar;
        }
    };
    class RadarFastTimeConstantLevelTimeseriesData : public Int32TimeseriesData
    {
    public:
        using Base = Int32TimeseriesData;
        static constexpr Kind KIND = Kind::RadarFastTimeConstantLevelTimeseries;
    private:
        Guid radar_;
    public:
        RadarFastTimeConstantLevelTimeseriesData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(radar_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(radar_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<RadarFastTimeConstantLevelTimeseriesData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<RadarFastTimeConstantLevelTimeseriesData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const RadarFastTimeConstantLevelTimeseriesData& >( other );
                if ( dataObject.radar_ != radar_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        const Guid& Radar( ) const
        {
            return radar_;
        }
        void SetRadar( const Guid& radar )
        {
            radar_ = radar;
        }
    };
    class RadarFastTimeConstantModeTimeseriesData : public Int32TimeseriesData
    {
    public:
        using Base = Int32TimeseriesData;
        static constexpr Kind KIND = Kind::RadarFastTimeConstantModeTimeseries;
    private:
        Guid radar_;
    public:
        RadarFastTimeConstantModeTimeseriesData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(radar_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(radar_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<RadarFastTimeConstantModeTimeseriesData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<RadarFastTimeConstantModeTimeseriesData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const RadarFastTimeConstantModeTimeseriesData& >( other );
                if ( dataObject.radar_ != radar_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        const Guid& Radar( ) const
        {
            return radar_;
        }
        void SetRadar( const Guid& radar )
        {
            radar_ = radar;
        }
    };
    class RadarPulseTimeseriesData : public Int32TimeseriesData
    {
    public:
        using Base = Int32TimeseriesData;
        static constexpr Kind KIND = Kind::RadarPulseTimeseries;
    private:
        Guid radar_;
    public:
        RadarPulseTimeseriesData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(radar_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(radar_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<RadarPulseTimeseriesData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<RadarPulseTimeseriesData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const RadarPulseTimeseriesData& >( other );
                if ( dataObject.radar_ != radar_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        const Guid& Radar( ) const
        {
            return radar_;
        }
        void SetRadar( const Guid& radar )
        {
            radar_ = radar;
        }
    };
    class RadarSector1EndTimeseriesData : public Int32TimeseriesData
    {
    public:
        using Base = Int32TimeseriesData;
        static constexpr Kind KIND = Kind::RadarSector1EndTimeseries;
    private:
        Guid radar_;
    public:
        RadarSector1EndTimeseriesData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(radar_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(radar_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<RadarSector1EndTimeseriesData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<RadarSector1EndTimeseriesData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const RadarSector1EndTimeseriesData& >( other );
                if ( dataObject.radar_ != radar_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        const Guid& Radar( ) const
        {
            return radar_;
        }
        void SetRadar( const Guid& radar )
        {
            radar_ = radar;
        }
    };
    class RadarSector1StartTimeseriesData : public Int32TimeseriesData
    {
    public:
        using Base = Int32TimeseriesData;
        static constexpr Kind KIND = Kind::RadarSector1StartTimeseries;
    private:
        Guid radar_;
    public:
        RadarSector1StartTimeseriesData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(radar_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(radar_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<RadarSector1StartTimeseriesData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<RadarSector1StartTimeseriesData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const RadarSector1StartTimeseriesData& >( other );
                if ( dataObject.radar_ != radar_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        const Guid& Radar( ) const
        {
            return radar_;
        }
        void SetRadar( const Guid& radar )
        {
            radar_ = radar;
        }
    };
    class RadarSector2EndTimeseriesData : public Int32TimeseriesData
    {
    public:
        using Base = Int32TimeseriesData;
        static constexpr Kind KIND = Kind::RadarSector2EndTimeseries;
    private:
        Guid radar_;
    public:
        RadarSector2EndTimeseriesData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(radar_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(radar_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<RadarSector2EndTimeseriesData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<RadarSector2EndTimeseriesData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const RadarSector2EndTimeseriesData& >( other );
                if ( dataObject.radar_ != radar_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        const Guid& Radar( ) const
        {
            return radar_;
        }
        void SetRadar( const Guid& radar )
        {
            radar_ = radar;
        }
    };
    class RadarSector2StartTimeseriesData : public Int32TimeseriesData
    {
    public:
        using Base = Int32TimeseriesData;
        static constexpr Kind KIND = Kind::RadarSector2StartTimeseries;
    private:
        Guid radar_;
    public:
        RadarSector2StartTimeseriesData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(radar_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(radar_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<RadarSector2StartTimeseriesData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<RadarSector2StartTimeseriesData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const RadarSector2StartTimeseriesData& >( other );
                if ( dataObject.radar_ != radar_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        const Guid& Radar( ) const
        {
            return radar_;
        }
        void SetRadar( const Guid& radar )
        {
            radar_ = radar;
        }
    };
    class RadarSensitivityTimeControlLevelTimeseriesData : public Int32TimeseriesData
    {
    public:
        using Base = Int32TimeseriesData;
        static constexpr Kind KIND = Kind::RadarSensitivityTimeControlLevelTimeseries;
    private:
        Guid radar_;
    public:
        RadarSensitivityTimeControlLevelTimeseriesData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(radar_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(radar_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<RadarSensitivityTimeControlLevelTimeseriesData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<RadarSensitivityTimeControlLevelTimeseriesData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const RadarSensitivityTimeControlLevelTimeseriesData& >( other );
                if ( dataObject.radar_ != radar_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        const Guid& Radar( ) const
        {
            return radar_;
        }
        void SetRadar( const Guid& radar )
        {
            radar_ = radar;
        }
    };
    class RadarTuningTimeseriesData : public Int32TimeseriesData
    {
    public:
        using Base = Int32TimeseriesData;
        static constexpr Kind KIND = Kind::RadarTuningTimeseries;
    private:
        Guid radar_;
    public:
        RadarTuningTimeseriesData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(radar_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(radar_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<RadarTuningTimeseriesData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<RadarTuningTimeseriesData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const RadarTuningTimeseriesData& >( other );
                if ( dataObject.radar_ != radar_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        const Guid& Radar( ) const
        {
            return radar_;
        }
        void SetRadar( const Guid& radar )
        {
            radar_ = radar;
        }
    };
    class VesselPersonsOnBoardTimeseriesData : public Int32TimeseriesData
    {
    public:
        using Base = Int32TimeseriesData;
        static constexpr Kind KIND = Kind::VesselPersonsOnBoardTimeseries;
    private:
        Guid vessel_;
    public:
        VesselPersonsOnBoardTimeseriesData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(vessel_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(vessel_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<VesselPersonsOnBoardTimeseriesData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<VesselPersonsOnBoardTimeseriesData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const VesselPersonsOnBoardTimeseriesData& >( other );
                if ( dataObject.vessel_ != vessel_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        const Guid& Vessel( ) const
        {
            return vessel_;
        }
        void SetVessel( const Guid& vessel )
        {
            vessel_ = vessel;
        }
    };
    class Int64TimeseriesData : public TimeseriesData
    {
    public:
        using Base = TimeseriesData;
        static constexpr Kind KIND = Kind::Int64Timeseries;
    private:
    public:
        Int64TimeseriesData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<Int64TimeseriesData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<Int64TimeseriesData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const Int64TimeseriesData& >( other );
                return true;
            }
            return false;
        }
    };
    class Position2DTimeseriesData : public TimeseriesData
    {
    public:
        using Base = TimeseriesData;
        static constexpr Kind KIND = Kind::Position2DTimeseries;
    private:
    public:
        Position2DTimeseriesData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<Position2DTimeseriesData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<Position2DTimeseriesData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const Position2DTimeseriesData& >( other );
                return true;
            }
            return false;
        }
    };
    class Position3DTimeseriesData : public TimeseriesData
    {
    public:
        using Base = TimeseriesData;
        static constexpr Kind KIND = Kind::Position3DTimeseries;
    private:
    public:
        Position3DTimeseriesData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<Position3DTimeseriesData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<Position3DTimeseriesData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const Position3DTimeseriesData& >( other );
                return true;
            }
            return false;
        }
    };
    class ReferenceTimeseriesData : public TimeseriesData
    {
    public:
        using Base = TimeseriesData;
        static constexpr Kind KIND = Kind::ReferenceTimeseries;
    private:
    public:
        ReferenceTimeseriesData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<ReferenceTimeseriesData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<ReferenceTimeseriesData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const ReferenceTimeseriesData& >( other );
                return true;
            }
            return false;
        }
    };
    class SByteTimeseriesData : public TimeseriesData
    {
    public:
        using Base = TimeseriesData;
        static constexpr Kind KIND = Kind::SByteTimeseries;
    private:
    public:
        SByteTimeseriesData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<SByteTimeseriesData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<SByteTimeseriesData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const SByteTimeseriesData& >( other );
                return true;
            }
            return false;
        }
    };
    class SingleTimeseriesData : public TimeseriesData
    {
    public:
        using Base = TimeseriesData;
        static constexpr Kind KIND = Kind::SingleTimeseries;
    private:
    public:
        SingleTimeseriesData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<SingleTimeseriesData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<SingleTimeseriesData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const SingleTimeseriesData& >( other );
                return true;
            }
            return false;
        }
    };
    class StringTimeseriesData : public TimeseriesData
    {
    public:
        using Base = TimeseriesData;
        static constexpr Kind KIND = Kind::StringTimeseries;
    private:
    public:
        StringTimeseriesData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<StringTimeseriesData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<StringTimeseriesData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const StringTimeseriesData& >( other );
                return true;
            }
            return false;
        }
    };
    class TimeSpanTimeseriesData : public TimeseriesData
    {
    public:
        using Base = TimeseriesData;
        static constexpr Kind KIND = Kind::TimeSpanTimeseries;
    private:
    public:
        TimeSpanTimeseriesData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<TimeSpanTimeseriesData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<TimeSpanTimeseriesData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const TimeSpanTimeseriesData& >( other );
                return true;
            }
            return false;
        }
    };
    class UInt16TimeseriesData : public TimeseriesData
    {
    public:
        using Base = TimeseriesData;
        static constexpr Kind KIND = Kind::UInt16Timeseries;
    private:
    public:
        UInt16TimeseriesData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<UInt16TimeseriesData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<UInt16TimeseriesData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const UInt16TimeseriesData& >( other );
                return true;
            }
            return false;
        }
    };
    class UInt32TimeseriesData : public TimeseriesData
    {
    public:
        using Base = TimeseriesData;
        static constexpr Kind KIND = Kind::UInt32Timeseries;
    private:
    public:
        UInt32TimeseriesData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<UInt32TimeseriesData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<UInt32TimeseriesData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const UInt32TimeseriesData& >( other );
                return true;
            }
            return false;
        }
    };
    class RadomeStatusTimeseriesData : public UInt32TimeseriesData
    {
    public:
        using Base = UInt32TimeseriesData;
        static constexpr Kind KIND = Kind::RadomeStatusTimeseries;
    private:
        Guid radome_;
    public:
        RadomeStatusTimeseriesData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(radome_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(radome_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<RadomeStatusTimeseriesData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<RadomeStatusTimeseriesData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const RadomeStatusTimeseriesData& >( other );
                if ( dataObject.radome_ != radome_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        const Guid& Radome( ) const
        {
            return radome_;
        }
        void SetRadome( const Guid& radome )
        {
            radome_ = radome;
        }
    };
    class UInt64TimeseriesData : public TimeseriesData
    {
    public:
        using Base = TimeseriesData;
        static constexpr Kind KIND = Kind::UInt64Timeseries;
    private:
    public:
        UInt64TimeseriesData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<UInt64TimeseriesData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<UInt64TimeseriesData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const UInt64TimeseriesData& >( other );
                return true;
            }
            return false;
        }
    };
    class TimeseriesCatalogData : public TimeseriesCatalogElementData
    {
    public:
        using Base = TimeseriesCatalogElementData;
        static constexpr Kind KIND = Kind::TimeseriesCatalog;
    private:
    public:
        TimeseriesCatalogData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<TimeseriesCatalogData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<TimeseriesCatalogData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const TimeseriesCatalogData& >( other );
                return true;
            }
            return false;
        }
    };
    class TimeseriesInfoData : public BaseData<Kind, Guid>
    {
    public:
        using Base = BaseData<Kind, Guid>;
        static constexpr Kind KIND = Kind::TimeseriesInfo;
    private:
        Int64 rowVersion_ = 0;
        DBDateTime firstTimestamp_;
        DBDateTime lastTimestamp_;
        Int64 count_ = 0;
    public:
        TimeseriesInfoData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(rowVersion_);
            firstTimestamp_.WriteTo( destination );
            lastTimestamp_.WriteTo( destination );
            destination.Write(count_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(rowVersion_);
            firstTimestamp_.ReadFrom( source );
            lastTimestamp_.ReadFrom( source );
            source.Read(count_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<TimeseriesInfoData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<TimeseriesInfoData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const TimeseriesInfoData& >( other );
                if ( dataObject.rowVersion_ != rowVersion_ )
                {
                    return false;
                }
                if ( dataObject.firstTimestamp_ != firstTimestamp_ )
                {
                    return false;
                }
                if ( dataObject.lastTimestamp_ != lastTimestamp_ )
                {
                    return false;
                }
                if ( dataObject.count_ != count_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        Int64 RowVersion( ) const
        {
            return rowVersion_;
        }
        void SetRowVersion( const Int64& rowVersion )
        {
            rowVersion_ = rowVersion;
        }
        const DBDateTime& FirstTimestamp( ) const
        {
            return firstTimestamp_;
        }
        void SetFirstTimestamp( const DBDateTime& firstTimestamp )
        {
            firstTimestamp_ = firstTimestamp;
        }
        const DBDateTime& LastTimestamp( ) const
        {
            return lastTimestamp_;
        }
        void SetLastTimestamp( const DBDateTime& lastTimestamp )
        {
            lastTimestamp_ = lastTimestamp;
        }
        Int64 Count( ) const
        {
            return count_;
        }
        void SetCount( Int64 count )
        {
            count_ = count;
        }
    };
    class TimeSpanTimeseriesValueData : public BaseData<Kind, Guid>
    {
    public:
        using Base = BaseData<Kind, Guid>;
        static constexpr Kind KIND = Kind::TimeSpanTimeseriesValue;
    private:
        Int64 rowVersion_ = 0;
        Guid timeseries_;
        DateTime timestamp_;
        DBTimeSpan value_;
    public:
        TimeSpanTimeseriesValueData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(rowVersion_);
            destination.Write(timeseries_);
            destination.Write(timestamp_);
            value_.WriteTo( destination );
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(rowVersion_);
            source.Read(timeseries_);
            source.Read(timestamp_);
            value_.ReadFrom( source );
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<TimeSpanTimeseriesValueData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<TimeSpanTimeseriesValueData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const TimeSpanTimeseriesValueData& >( other );
                if ( dataObject.rowVersion_ != rowVersion_ )
                {
                    return false;
                }
                if ( dataObject.timeseries_ != timeseries_ )
                {
                    return false;
                }
                if ( dataObject.timestamp_ != timestamp_ )
                {
                    return false;
                }
                if ( dataObject.value_ != value_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        Int64 RowVersion( ) const
        {
            return rowVersion_;
        }
        void SetRowVersion( const Int64& rowVersion )
        {
            rowVersion_ = rowVersion;
        }
        const Guid& Timeseries( ) const
        {
            return timeseries_;
        }
        void SetTimeseries( const Guid& timeseries )
        {
            timeseries_ = timeseries;
        }
        const DateTime& Timestamp( ) const
        {
            return timestamp_;
        }
        void SetTimestamp( const DateTime& timestamp )
        {
            timestamp_ = timestamp;
        }
        const DBTimeSpan& Value( ) const
        {
            return value_;
        }
        void SetValue( const DBTimeSpan& value )
        {
            value_ = value;
        }
    };
    class TrackableItemTrackLinkData : public BaseData<Kind, Guid>
    {
    public:
        using Base = BaseData<Kind, Guid>;
        static constexpr Kind KIND = Kind::TrackableItemTrackLink;
    private:
        Int64 rowVersion_ = 0;
        Guid item_;
        Guid track_;
        DateTime start_;
        DBDateTime end_;
    public:
        TrackableItemTrackLinkData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(rowVersion_);
            destination.Write(item_);
            destination.Write(track_);
            destination.Write(start_);
            end_.WriteTo( destination );
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(rowVersion_);
            source.Read(item_);
            source.Read(track_);
            source.Read(start_);
            end_.ReadFrom( source );
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<TrackableItemTrackLinkData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<TrackableItemTrackLinkData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const TrackableItemTrackLinkData& >( other );
                if ( dataObject.rowVersion_ != rowVersion_ )
                {
                    return false;
                }
                if ( dataObject.item_ != item_ )
                {
                    return false;
                }
                if ( dataObject.track_ != track_ )
                {
                    return false;
                }
                if ( dataObject.start_ != start_ )
                {
                    return false;
                }
                if ( dataObject.end_ != end_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        Int64 RowVersion( ) const
        {
            return rowVersion_;
        }
        void SetRowVersion( const Int64& rowVersion )
        {
            rowVersion_ = rowVersion;
        }
        const Guid& Item( ) const
        {
            return item_;
        }
        void SetItem( const Guid& item )
        {
            item_ = item;
        }
        const Guid& Track( ) const
        {
            return track_;
        }
        void SetTrack( const Guid& track )
        {
            track_ = track;
        }
        const DateTime& Start( ) const
        {
            return start_;
        }
        void SetStart( const DateTime& start )
        {
            start_ = start;
        }
        const DBDateTime& End( ) const
        {
            return end_;
        }
        void SetEnd( const DBDateTime& end )
        {
            end_ = end;
        }
    };
    class TrackBaseData : public BaseData<Kind, Guid>
    {
    public:
        using Base = BaseData<Kind, Guid>;
        static constexpr Kind KIND = Kind::TrackBase;
    private:
        Int64 rowVersion_ = 0;
        Guid tracker_;
        Int64 trackNumber_ = 0;
        DateTime timestamp_;
    public:
        TrackBaseData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(rowVersion_);
            destination.Write(tracker_);
            destination.Write(trackNumber_);
            destination.Write(timestamp_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(rowVersion_);
            source.Read(tracker_);
            source.Read(trackNumber_);
            source.Read(timestamp_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<TrackBaseData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<TrackBaseData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const TrackBaseData& >( other );
                if ( dataObject.rowVersion_ != rowVersion_ )
                {
                    return false;
                }
                if ( dataObject.tracker_ != tracker_ )
                {
                    return false;
                }
                if ( dataObject.trackNumber_ != trackNumber_ )
                {
                    return false;
                }
                if ( dataObject.timestamp_ != timestamp_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        Int64 RowVersion( ) const
        {
            return rowVersion_;
        }
        void SetRowVersion( const Int64& rowVersion )
        {
            rowVersion_ = rowVersion;
        }
        const Guid& Tracker( ) const
        {
            return tracker_;
        }
        void SetTracker( const Guid& tracker )
        {
            tracker_ = tracker;
        }
        Int64 TrackNumber( ) const
        {
            return trackNumber_;
        }
        void SetTrackNumber( Int64 trackNumber )
        {
            trackNumber_ = trackNumber;
        }
        const DateTime& Timestamp( ) const
        {
            return timestamp_;
        }
        void SetTimestamp( const DateTime& timestamp )
        {
            timestamp_ = timestamp;
        }
    };
    class TrackData : public TrackBaseData
    {
    public:
        using Base = TrackBaseData;
        static constexpr Kind KIND = Kind::Track;
    private:
    public:
        TrackData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<TrackData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<TrackData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const TrackData& >( other );
                return true;
            }
            return false;
        }
    };
    class Track3DData : public TrackBaseData
    {
    public:
        using Base = TrackBaseData;
        static constexpr Kind KIND = Kind::Track3D;
    private:
    public:
        Track3DData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<Track3DData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<Track3DData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const Track3DData& >( other );
                return true;
            }
            return false;
        }
    };
    class TrackerFilterParametersData : public BaseData<Kind, Guid>
    {
    public:
        using Base = BaseData<Kind, Guid>;
        static constexpr Kind KIND = Kind::TrackerFilterParameters;
    private:
        Int64 rowVersion_ = 0;
        Guid tracker_;
        FixedDBWideString<100> name_;
    public:
        TrackerFilterParametersData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(rowVersion_);
            destination.Write(tracker_);
            name_.WriteTo( destination );
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(rowVersion_);
            source.Read(tracker_);
            name_.ReadFrom( source );
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<TrackerFilterParametersData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<TrackerFilterParametersData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const TrackerFilterParametersData& >( other );
                if ( dataObject.rowVersion_ != rowVersion_ )
                {
                    return false;
                }
                if ( dataObject.tracker_ != tracker_ )
                {
                    return false;
                }
                if ( dataObject.name_ != name_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        Int64 RowVersion( ) const
        {
            return rowVersion_;
        }
        void SetRowVersion( const Int64& rowVersion )
        {
            rowVersion_ = rowVersion;
        }
        const Guid& Tracker( ) const
        {
            return tracker_;
        }
        void SetTracker( const Guid& tracker )
        {
            tracker_ = tracker;
        }
        const FixedDBWideString<100>& Name( ) const
        {
            return name_;
        }
        void SetName( const WideString& name )
        {
            name_ = name;
        }
    };
    class TrackerFilterParametersConfigurationData : public BaseData<Kind, Guid>
    {
    public:
        using Base = BaseData<Kind, Guid>;
        static constexpr Kind KIND = Kind::TrackerFilterParametersConfiguration;
    private:
        Int64 rowVersion_ = 0;
        Guid parameters_;
        DateTime timestamp_;
        bool useNaivePredictor_ = false;
        Int32 numberOfPoints_ = 0;
        Int32 windowSize_ = 0;
        Int32 stabilizeCount_ = 0;
        Int32 maxBadPoints_ = 0;
        Data::TrackerFilterModelType modelType_ = Data::TrackerFilterModelType::Unknown;
        double sigmaR_ = 0.0;
        double sigmaAcc_ = 0.0;
        double tauVel_ = 0.0;
        double tauAcc_ = 0.0;
        double deltaRMin_ = 0.0;
        double deltaVMax_ = 0.0;
        double deltaAMax_ = 0.0;
    public:
        TrackerFilterParametersConfigurationData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(rowVersion_);
            destination.Write(parameters_);
            destination.Write(timestamp_);
            destination.Write(useNaivePredictor_);
            destination.Write(numberOfPoints_);
            destination.Write(windowSize_);
            destination.Write(stabilizeCount_);
            destination.Write(maxBadPoints_);
            destination.Write(modelType_);
            destination.Write(sigmaR_);
            destination.Write(sigmaAcc_);
            destination.Write(tauVel_);
            destination.Write(tauAcc_);
            destination.Write(deltaRMin_);
            destination.Write(deltaVMax_);
            destination.Write(deltaAMax_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(rowVersion_);
            source.Read(parameters_);
            source.Read(timestamp_);
            source.Read(useNaivePredictor_);
            source.Read(numberOfPoints_);
            source.Read(windowSize_);
            source.Read(stabilizeCount_);
            source.Read(maxBadPoints_);
            source.Read(modelType_);
            source.Read(sigmaR_);
            source.Read(sigmaAcc_);
            source.Read(tauVel_);
            source.Read(tauAcc_);
            source.Read(deltaRMin_);
            source.Read(deltaVMax_);
            source.Read(deltaAMax_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<TrackerFilterParametersConfigurationData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<TrackerFilterParametersConfigurationData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const TrackerFilterParametersConfigurationData& >( other );
                if ( dataObject.rowVersion_ != rowVersion_ )
                {
                    return false;
                }
                if ( dataObject.parameters_ != parameters_ )
                {
                    return false;
                }
                if ( dataObject.timestamp_ != timestamp_ )
                {
                    return false;
                }
                if ( dataObject.useNaivePredictor_ != useNaivePredictor_ )
                {
                    return false;
                }
                if ( dataObject.numberOfPoints_ != numberOfPoints_ )
                {
                    return false;
                }
                if ( dataObject.windowSize_ != windowSize_ )
                {
                    return false;
                }
                if ( dataObject.stabilizeCount_ != stabilizeCount_ )
                {
                    return false;
                }
                if ( dataObject.maxBadPoints_ != maxBadPoints_ )
                {
                    return false;
                }
                if ( dataObject.modelType_ != modelType_ )
                {
                    return false;
                }
                if ( dataObject.sigmaR_ != sigmaR_ )
                {
                    return false;
                }
                if ( dataObject.sigmaAcc_ != sigmaAcc_ )
                {
                    return false;
                }
                if ( dataObject.tauVel_ != tauVel_ )
                {
                    return false;
                }
                if ( dataObject.tauAcc_ != tauAcc_ )
                {
                    return false;
                }
                if ( dataObject.deltaRMin_ != deltaRMin_ )
                {
                    return false;
                }
                if ( dataObject.deltaVMax_ != deltaVMax_ )
                {
                    return false;
                }
                if ( dataObject.deltaAMax_ != deltaAMax_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        Int64 RowVersion( ) const
        {
            return rowVersion_;
        }
        void SetRowVersion( const Int64& rowVersion )
        {
            rowVersion_ = rowVersion;
        }
        const Guid& Parameters( ) const
        {
            return parameters_;
        }
        void SetParameters( const Guid& parameters )
        {
            parameters_ = parameters;
        }
        const DateTime& Timestamp( ) const
        {
            return timestamp_;
        }
        void SetTimestamp( const DateTime& timestamp )
        {
            timestamp_ = timestamp;
        }
        bool UseNaivePredictor( ) const
        {
            return useNaivePredictor_;
        }
        void SetUseNaivePredictor( bool useNaivePredictor )
        {
            useNaivePredictor_ = useNaivePredictor;
        }
        Int32 NumberOfPoints( ) const
        {
            return numberOfPoints_;
        }
        void SetNumberOfPoints( Int32 numberOfPoints )
        {
            numberOfPoints_ = numberOfPoints;
        }
        Int32 WindowSize( ) const
        {
            return windowSize_;
        }
        void SetWindowSize( Int32 windowSize )
        {
            windowSize_ = windowSize;
        }
        Int32 StabilizeCount( ) const
        {
            return stabilizeCount_;
        }
        void SetStabilizeCount( Int32 stabilizeCount )
        {
            stabilizeCount_ = stabilizeCount;
        }
        Int32 MaxBadPoints( ) const
        {
            return maxBadPoints_;
        }
        void SetMaxBadPoints( Int32 maxBadPoints )
        {
            maxBadPoints_ = maxBadPoints;
        }
        Data::TrackerFilterModelType ModelType( ) const
        {
            return modelType_;
        }
        void SetModelType( Data::TrackerFilterModelType modelType )
        {
            modelType_ = modelType;
        }
        double SigmaR( ) const
        {
            return sigmaR_;
        }
        void SetSigmaR( double sigmaR )
        {
            sigmaR_ = sigmaR;
        }
        double SigmaAcc( ) const
        {
            return sigmaAcc_;
        }
        void SetSigmaAcc( double sigmaAcc )
        {
            sigmaAcc_ = sigmaAcc;
        }
        double TauVel( ) const
        {
            return tauVel_;
        }
        void SetTauVel( double tauVel )
        {
            tauVel_ = tauVel;
        }
        double TauAcc( ) const
        {
            return tauAcc_;
        }
        void SetTauAcc( double tauAcc )
        {
            tauAcc_ = tauAcc;
        }
        double DeltaRMin( ) const
        {
            return deltaRMin_;
        }
        void SetDeltaRMin( double deltaRMin )
        {
            deltaRMin_ = deltaRMin;
        }
        double DeltaVMax( ) const
        {
            return deltaVMax_;
        }
        void SetDeltaVMax( double deltaVMax )
        {
            deltaVMax_ = deltaVMax;
        }
        double DeltaAMax( ) const
        {
            return deltaAMax_;
        }
        void SetDeltaAMax( double deltaAMax )
        {
            deltaAMax_ = deltaAMax;
        }
    };
    class TrackInfoData : public BaseData<Kind, Guid>
    {
    public:
        using Base = BaseData<Kind, Guid>;
        static constexpr Kind KIND = Kind::TrackInfo;
    private:
        Int64 rowVersion_ = 0;
        DBDateTime firstTimestamp_;
        DBDateTime lastTimestamp_;
        Int64 count_ = 0;
        DBDouble northWestLatitude_;
        DBDouble northWestLongitude_;
        DBDouble southEastLatitude_;
        DBDouble southEastLongitude_;
    public:
        TrackInfoData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(rowVersion_);
            firstTimestamp_.WriteTo( destination );
            lastTimestamp_.WriteTo( destination );
            destination.Write(count_);
            northWestLatitude_.WriteTo( destination );
            northWestLongitude_.WriteTo( destination );
            southEastLatitude_.WriteTo( destination );
            southEastLongitude_.WriteTo( destination );
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(rowVersion_);
            firstTimestamp_.ReadFrom( source );
            lastTimestamp_.ReadFrom( source );
            source.Read(count_);
            northWestLatitude_.ReadFrom( source );
            northWestLongitude_.ReadFrom( source );
            southEastLatitude_.ReadFrom( source );
            southEastLongitude_.ReadFrom( source );
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<TrackInfoData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<TrackInfoData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const TrackInfoData& >( other );
                if ( dataObject.rowVersion_ != rowVersion_ )
                {
                    return false;
                }
                if ( dataObject.firstTimestamp_ != firstTimestamp_ )
                {
                    return false;
                }
                if ( dataObject.lastTimestamp_ != lastTimestamp_ )
                {
                    return false;
                }
                if ( dataObject.count_ != count_ )
                {
                    return false;
                }
                if ( dataObject.northWestLatitude_ != northWestLatitude_ )
                {
                    return false;
                }
                if ( dataObject.northWestLongitude_ != northWestLongitude_ )
                {
                    return false;
                }
                if ( dataObject.southEastLatitude_ != southEastLatitude_ )
                {
                    return false;
                }
                if ( dataObject.southEastLongitude_ != southEastLongitude_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        Int64 RowVersion( ) const
        {
            return rowVersion_;
        }
        void SetRowVersion( const Int64& rowVersion )
        {
            rowVersion_ = rowVersion;
        }
        const DBDateTime& FirstTimestamp( ) const
        {
            return firstTimestamp_;
        }
        void SetFirstTimestamp( const DBDateTime& firstTimestamp )
        {
            firstTimestamp_ = firstTimestamp;
        }
        const DBDateTime& LastTimestamp( ) const
        {
            return lastTimestamp_;
        }
        void SetLastTimestamp( const DBDateTime& lastTimestamp )
        {
            lastTimestamp_ = lastTimestamp;
        }
        Int64 Count( ) const
        {
            return count_;
        }
        void SetCount( Int64 count )
        {
            count_ = count;
        }
        const DBDouble& NorthWestLatitude( ) const
        {
            return northWestLatitude_;
        }
        void SetNorthWestLatitude( const DBDouble& northWestLatitude )
        {
            northWestLatitude_ = northWestLatitude;
        }
        const DBDouble& NorthWestLongitude( ) const
        {
            return northWestLongitude_;
        }
        void SetNorthWestLongitude( const DBDouble& northWestLongitude )
        {
            northWestLongitude_ = northWestLongitude;
        }
        const DBDouble& SouthEastLatitude( ) const
        {
            return southEastLatitude_;
        }
        void SetSouthEastLatitude( const DBDouble& southEastLatitude )
        {
            southEastLatitude_ = southEastLatitude;
        }
        const DBDouble& SouthEastLongitude( ) const
        {
            return southEastLongitude_;
        }
        void SetSouthEastLongitude( const DBDouble& southEastLongitude )
        {
            southEastLongitude_ = southEastLongitude;
        }
    };
    class TrackingServiceOptionsData : public BaseData<Kind, Guid>
    {
    public:
        using Base = BaseData<Kind, Guid>;
        static constexpr Kind KIND = Kind::TrackingServiceOptions;
    private:
        Int64 rowVersion_ = 0;
        DateTime timestamp_;
        TimeSpan timerInterval_;
        TimeSpan maxAgeOfCurrentTrackValue_;
        double falseThreshold_ = 0.0;
        double distanceThreshold_ = 0.0;
        double distanceUnmergeThreshold_ = 0.0;
        Int64 unmergeLatency_ = 0;
        bool kalmanFiltering_ = false;
        double maxCourseDeviation_ = 0.0;
        double maxSpeedDeviation_ = 0.0;
        double minimumSpeedThreshold_ = 0.0;
    public:
        TrackingServiceOptionsData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(rowVersion_);
            destination.Write(timestamp_);
            destination.Write(timerInterval_);
            destination.Write(maxAgeOfCurrentTrackValue_);
            destination.Write(falseThreshold_);
            destination.Write(distanceThreshold_);
            destination.Write(distanceUnmergeThreshold_);
            destination.Write(unmergeLatency_);
            destination.Write(kalmanFiltering_);
            destination.Write(maxCourseDeviation_);
            destination.Write(maxSpeedDeviation_);
            destination.Write(minimumSpeedThreshold_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(rowVersion_);
            source.Read(timestamp_);
            source.Read(timerInterval_);
            source.Read(maxAgeOfCurrentTrackValue_);
            source.Read(falseThreshold_);
            source.Read(distanceThreshold_);
            source.Read(distanceUnmergeThreshold_);
            source.Read(unmergeLatency_);
            source.Read(kalmanFiltering_);
            source.Read(maxCourseDeviation_);
            source.Read(maxSpeedDeviation_);
            source.Read(minimumSpeedThreshold_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<TrackingServiceOptionsData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<TrackingServiceOptionsData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const TrackingServiceOptionsData& >( other );
                if ( dataObject.rowVersion_ != rowVersion_ )
                {
                    return false;
                }
                if ( dataObject.timestamp_ != timestamp_ )
                {
                    return false;
                }
                if ( dataObject.timerInterval_ != timerInterval_ )
                {
                    return false;
                }
                if ( dataObject.maxAgeOfCurrentTrackValue_ != maxAgeOfCurrentTrackValue_ )
                {
                    return false;
                }
                if ( dataObject.falseThreshold_ != falseThreshold_ )
                {
                    return false;
                }
                if ( dataObject.distanceThreshold_ != distanceThreshold_ )
                {
                    return false;
                }
                if ( dataObject.distanceUnmergeThreshold_ != distanceUnmergeThreshold_ )
                {
                    return false;
                }
                if ( dataObject.unmergeLatency_ != unmergeLatency_ )
                {
                    return false;
                }
                if ( dataObject.kalmanFiltering_ != kalmanFiltering_ )
                {
                    return false;
                }
                if ( dataObject.maxCourseDeviation_ != maxCourseDeviation_ )
                {
                    return false;
                }
                if ( dataObject.maxSpeedDeviation_ != maxSpeedDeviation_ )
                {
                    return false;
                }
                if ( dataObject.minimumSpeedThreshold_ != minimumSpeedThreshold_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        Int64 RowVersion( ) const
        {
            return rowVersion_;
        }
        void SetRowVersion( const Int64& rowVersion )
        {
            rowVersion_ = rowVersion;
        }
        const DateTime& Timestamp( ) const
        {
            return timestamp_;
        }
        void SetTimestamp( const DateTime& timestamp )
        {
            timestamp_ = timestamp;
        }
        const TimeSpan& TimerInterval( ) const
        {
            return timerInterval_;
        }
        void SetTimerInterval( const TimeSpan& timerInterval )
        {
            timerInterval_ = timerInterval;
        }
        const TimeSpan& MaxAgeOfCurrentTrackValue( ) const
        {
            return maxAgeOfCurrentTrackValue_;
        }
        void SetMaxAgeOfCurrentTrackValue( const TimeSpan& maxAgeOfCurrentTrackValue )
        {
            maxAgeOfCurrentTrackValue_ = maxAgeOfCurrentTrackValue;
        }
        double FalseThreshold( ) const
        {
            return falseThreshold_;
        }
        void SetFalseThreshold( double falseThreshold )
        {
            falseThreshold_ = falseThreshold;
        }
        double DistanceThreshold( ) const
        {
            return distanceThreshold_;
        }
        void SetDistanceThreshold( double distanceThreshold )
        {
            distanceThreshold_ = distanceThreshold;
        }
        double DistanceUnmergeThreshold( ) const
        {
            return distanceUnmergeThreshold_;
        }
        void SetDistanceUnmergeThreshold( double distanceUnmergeThreshold )
        {
            distanceUnmergeThreshold_ = distanceUnmergeThreshold;
        }
        Int64 UnmergeLatency( ) const
        {
            return unmergeLatency_;
        }
        void SetUnmergeLatency( Int64 unmergeLatency )
        {
            unmergeLatency_ = unmergeLatency;
        }
        bool KalmanFiltering( ) const
        {
            return kalmanFiltering_;
        }
        void SetKalmanFiltering( bool kalmanFiltering )
        {
            kalmanFiltering_ = kalmanFiltering;
        }
        double MaxCourseDeviation( ) const
        {
            return maxCourseDeviation_;
        }
        void SetMaxCourseDeviation( double maxCourseDeviation )
        {
            maxCourseDeviation_ = maxCourseDeviation;
        }
        double MaxSpeedDeviation( ) const
        {
            return maxSpeedDeviation_;
        }
        void SetMaxSpeedDeviation( double maxSpeedDeviation )
        {
            maxSpeedDeviation_ = maxSpeedDeviation;
        }
        double MinimumSpeedThreshold( ) const
        {
            return minimumSpeedThreshold_;
        }
        void SetMinimumSpeedThreshold( double minimumSpeedThreshold )
        {
            minimumSpeedThreshold_ = minimumSpeedThreshold;
        }
    };
    class TrackLinkData : public BaseData<Kind, Guid>
    {
    public:
        using Base = BaseData<Kind, Guid>;
        static constexpr Kind KIND = Kind::TrackLink;
    private:
        Int64 rowVersion_ = 0;
        Guid primary_;
        Guid secondary_;
        DateTime start_;
        DBDateTime end_;
    public:
        TrackLinkData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(rowVersion_);
            destination.Write(primary_);
            destination.Write(secondary_);
            destination.Write(start_);
            end_.WriteTo( destination );
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(rowVersion_);
            source.Read(primary_);
            source.Read(secondary_);
            source.Read(start_);
            end_.ReadFrom( source );
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<TrackLinkData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<TrackLinkData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const TrackLinkData& >( other );
                if ( dataObject.rowVersion_ != rowVersion_ )
                {
                    return false;
                }
                if ( dataObject.primary_ != primary_ )
                {
                    return false;
                }
                if ( dataObject.secondary_ != secondary_ )
                {
                    return false;
                }
                if ( dataObject.start_ != start_ )
                {
                    return false;
                }
                if ( dataObject.end_ != end_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        Int64 RowVersion( ) const
        {
            return rowVersion_;
        }
        void SetRowVersion( const Int64& rowVersion )
        {
            rowVersion_ = rowVersion;
        }
        const Guid& Primary( ) const
        {
            return primary_;
        }
        void SetPrimary( const Guid& primary )
        {
            primary_ = primary;
        }
        const Guid& Secondary( ) const
        {
            return secondary_;
        }
        void SetSecondary( const Guid& secondary )
        {
            secondary_ = secondary;
        }
        const DateTime& Start( ) const
        {
            return start_;
        }
        void SetStart( const DateTime& start )
        {
            start_ = start;
        }
        const DBDateTime& End( ) const
        {
            return end_;
        }
        void SetEnd( const DBDateTime& end )
        {
            end_ = end;
        }
    };
    class TrackValueData : public BaseData<Kind, Guid>
    {
    public:
        using Base = BaseData<Kind, Guid>;
        static constexpr Kind KIND = Kind::TrackValue;
    private:
        Int64 rowVersion_ = 0;
        Guid track_;
        DateTime timestamp_;
        Data::TrackFlags flags_ = Data::TrackFlags::None;
        Data::TrackStatus status_ = Data::TrackStatus::Unknown;
        double latitude_ = 0.0;
        double longitude_ = 0.0;
        double speed_ = 0.0;
        double course_ = 0.0;
        double heading_ = 0.0;
    public:
        TrackValueData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(rowVersion_);
            destination.Write(track_);
            destination.Write(timestamp_);
            destination.Write(flags_);
            destination.Write(status_);
            destination.Write(latitude_);
            destination.Write(longitude_);
            destination.Write(speed_);
            destination.Write(course_);
            destination.Write(heading_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(rowVersion_);
            source.Read(track_);
            source.Read(timestamp_);
            source.Read(flags_);
            source.Read(status_);
            source.Read(latitude_);
            source.Read(longitude_);
            source.Read(speed_);
            source.Read(course_);
            source.Read(heading_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<TrackValueData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<TrackValueData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const TrackValueData& >( other );
                if ( dataObject.rowVersion_ != rowVersion_ )
                {
                    return false;
                }
                if ( dataObject.track_ != track_ )
                {
                    return false;
                }
                if ( dataObject.timestamp_ != timestamp_ )
                {
                    return false;
                }
                if ( dataObject.flags_ != flags_ )
                {
                    return false;
                }
                if ( dataObject.status_ != status_ )
                {
                    return false;
                }
                if ( dataObject.latitude_ != latitude_ )
                {
                    return false;
                }
                if ( dataObject.longitude_ != longitude_ )
                {
                    return false;
                }
                if ( dataObject.speed_ != speed_ )
                {
                    return false;
                }
                if ( dataObject.course_ != course_ )
                {
                    return false;
                }
                if ( dataObject.heading_ != heading_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        Int64 RowVersion( ) const
        {
            return rowVersion_;
        }
        void SetRowVersion( const Int64& rowVersion )
        {
            rowVersion_ = rowVersion;
        }
        const Guid& Track( ) const
        {
            return track_;
        }
        void SetTrack( const Guid& track )
        {
            track_ = track;
        }
        const DateTime& Timestamp( ) const
        {
            return timestamp_;
        }
        void SetTimestamp( const DateTime& timestamp )
        {
            timestamp_ = timestamp;
        }
        Data::TrackFlags Flags( ) const
        {
            return flags_;
        }
        void SetFlags( Data::TrackFlags flags )
        {
            flags_ = flags;
        }
        Data::TrackStatus Status( ) const
        {
            return status_;
        }
        void SetStatus( Data::TrackStatus status )
        {
            status_ = status;
        }
        double Latitude( ) const
        {
            return latitude_;
        }
        void SetLatitude( double latitude )
        {
            latitude_ = latitude;
        }
        double Longitude( ) const
        {
            return longitude_;
        }
        void SetLongitude( double longitude )
        {
            longitude_ = longitude;
        }
        double Speed( ) const
        {
            return speed_;
        }
        void SetSpeed( double speed )
        {
            speed_ = speed;
        }
        double Course( ) const
        {
            return course_;
        }
        void SetCourse( double course )
        {
            course_ = course;
        }
        double Heading( ) const
        {
            return heading_;
        }
        void SetHeading( double heading )
        {
            heading_ = heading;
        }
    };
    class TrackValue3DData : public BaseData<Kind, Guid>
    {
    public:
        using Base = BaseData<Kind, Guid>;
        static constexpr Kind KIND = Kind::TrackValue3D;
    private:
        Int64 rowVersion_ = 0;
        Guid track_;
        DateTime timestamp_;
        Data::TrackFlags3D flags_ = Data::TrackFlags3D::None;
        UInt32 status_ = 0;
        double latitude_ = 0.0;
        double longitude_ = 0.0;
        double altitude_ = 0.0;
        double speed_ = 0.0;
        double course_ = 0.0;
        double rateOfClimb_ = 0.0;
    public:
        TrackValue3DData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(rowVersion_);
            destination.Write(track_);
            destination.Write(timestamp_);
            destination.Write(flags_);
            destination.Write(status_);
            destination.Write(latitude_);
            destination.Write(longitude_);
            destination.Write(altitude_);
            destination.Write(speed_);
            destination.Write(course_);
            destination.Write(rateOfClimb_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(rowVersion_);
            source.Read(track_);
            source.Read(timestamp_);
            source.Read(flags_);
            source.Read(status_);
            source.Read(latitude_);
            source.Read(longitude_);
            source.Read(altitude_);
            source.Read(speed_);
            source.Read(course_);
            source.Read(rateOfClimb_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<TrackValue3DData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<TrackValue3DData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const TrackValue3DData& >( other );
                if ( dataObject.rowVersion_ != rowVersion_ )
                {
                    return false;
                }
                if ( dataObject.track_ != track_ )
                {
                    return false;
                }
                if ( dataObject.timestamp_ != timestamp_ )
                {
                    return false;
                }
                if ( dataObject.flags_ != flags_ )
                {
                    return false;
                }
                if ( dataObject.status_ != status_ )
                {
                    return false;
                }
                if ( dataObject.latitude_ != latitude_ )
                {
                    return false;
                }
                if ( dataObject.longitude_ != longitude_ )
                {
                    return false;
                }
                if ( dataObject.altitude_ != altitude_ )
                {
                    return false;
                }
                if ( dataObject.speed_ != speed_ )
                {
                    return false;
                }
                if ( dataObject.course_ != course_ )
                {
                    return false;
                }
                if ( dataObject.rateOfClimb_ != rateOfClimb_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        Int64 RowVersion( ) const
        {
            return rowVersion_;
        }
        void SetRowVersion( const Int64& rowVersion )
        {
            rowVersion_ = rowVersion;
        }
        const Guid& Track( ) const
        {
            return track_;
        }
        void SetTrack( const Guid& track )
        {
            track_ = track;
        }
        const DateTime& Timestamp( ) const
        {
            return timestamp_;
        }
        void SetTimestamp( const DateTime& timestamp )
        {
            timestamp_ = timestamp;
        }
        Data::TrackFlags3D Flags( ) const
        {
            return flags_;
        }
        void SetFlags( Data::TrackFlags3D flags )
        {
            flags_ = flags;
        }
        UInt32 Status( ) const
        {
            return status_;
        }
        void SetStatus( UInt32 status )
        {
            status_ = status;
        }
        double Latitude( ) const
        {
            return latitude_;
        }
        void SetLatitude( double latitude )
        {
            latitude_ = latitude;
        }
        double Longitude( ) const
        {
            return longitude_;
        }
        void SetLongitude( double longitude )
        {
            longitude_ = longitude;
        }
        double Altitude( ) const
        {
            return altitude_;
        }
        void SetAltitude( double altitude )
        {
            altitude_ = altitude;
        }
        double Speed( ) const
        {
            return speed_;
        }
        void SetSpeed( double speed )
        {
            speed_ = speed;
        }
        double Course( ) const
        {
            return course_;
        }
        void SetCourse( double course )
        {
            course_ = course;
        }
        double RateOfClimb( ) const
        {
            return rateOfClimb_;
        }
        void SetRateOfClimb( double rateOfClimb )
        {
            rateOfClimb_ = rateOfClimb;
        }
    };
    class UInt16TimeseriesValueData : public BaseData<Kind, Guid>
    {
    public:
        using Base = BaseData<Kind, Guid>;
        static constexpr Kind KIND = Kind::UInt16TimeseriesValue;
    private:
        Int64 rowVersion_ = 0;
        Guid timeseries_;
        DateTime timestamp_;
        DBUInt16 value_;
    public:
        UInt16TimeseriesValueData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(rowVersion_);
            destination.Write(timeseries_);
            destination.Write(timestamp_);
            value_.WriteTo( destination );
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(rowVersion_);
            source.Read(timeseries_);
            source.Read(timestamp_);
            value_.ReadFrom( source );
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<UInt16TimeseriesValueData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<UInt16TimeseriesValueData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const UInt16TimeseriesValueData& >( other );
                if ( dataObject.rowVersion_ != rowVersion_ )
                {
                    return false;
                }
                if ( dataObject.timeseries_ != timeseries_ )
                {
                    return false;
                }
                if ( dataObject.timestamp_ != timestamp_ )
                {
                    return false;
                }
                if ( dataObject.value_ != value_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        Int64 RowVersion( ) const
        {
            return rowVersion_;
        }
        void SetRowVersion( const Int64& rowVersion )
        {
            rowVersion_ = rowVersion;
        }
        const Guid& Timeseries( ) const
        {
            return timeseries_;
        }
        void SetTimeseries( const Guid& timeseries )
        {
            timeseries_ = timeseries;
        }
        const DateTime& Timestamp( ) const
        {
            return timestamp_;
        }
        void SetTimestamp( const DateTime& timestamp )
        {
            timestamp_ = timestamp;
        }
        const DBUInt16& Value( ) const
        {
            return value_;
        }
        void SetValue( const DBUInt16& value )
        {
            value_ = value;
        }
    };
    class UInt32TimeseriesValueData : public BaseData<Kind, Guid>
    {
    public:
        using Base = BaseData<Kind, Guid>;
        static constexpr Kind KIND = Kind::UInt32TimeseriesValue;
    private:
        Int64 rowVersion_ = 0;
        Guid timeseries_;
        DateTime timestamp_;
        DBUInt32 value_;
    public:
        UInt32TimeseriesValueData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(rowVersion_);
            destination.Write(timeseries_);
            destination.Write(timestamp_);
            value_.WriteTo( destination );
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(rowVersion_);
            source.Read(timeseries_);
            source.Read(timestamp_);
            value_.ReadFrom( source );
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<UInt32TimeseriesValueData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<UInt32TimeseriesValueData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const UInt32TimeseriesValueData& >( other );
                if ( dataObject.rowVersion_ != rowVersion_ )
                {
                    return false;
                }
                if ( dataObject.timeseries_ != timeseries_ )
                {
                    return false;
                }
                if ( dataObject.timestamp_ != timestamp_ )
                {
                    return false;
                }
                if ( dataObject.value_ != value_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        Int64 RowVersion( ) const
        {
            return rowVersion_;
        }
        void SetRowVersion( const Int64& rowVersion )
        {
            rowVersion_ = rowVersion;
        }
        const Guid& Timeseries( ) const
        {
            return timeseries_;
        }
        void SetTimeseries( const Guid& timeseries )
        {
            timeseries_ = timeseries;
        }
        const DateTime& Timestamp( ) const
        {
            return timestamp_;
        }
        void SetTimestamp( const DateTime& timestamp )
        {
            timestamp_ = timestamp;
        }
        const DBUInt32& Value( ) const
        {
            return value_;
        }
        void SetValue( const DBUInt32& value )
        {
            value_ = value;
        }
    };
    class UInt64TimeseriesValueData : public BaseData<Kind, Guid>
    {
    public:
        using Base = BaseData<Kind, Guid>;
        static constexpr Kind KIND = Kind::UInt64TimeseriesValue;
    private:
        Int64 rowVersion_ = 0;
        Guid timeseries_;
        DateTime timestamp_;
        DBInt64 value_;
    public:
        UInt64TimeseriesValueData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(rowVersion_);
            destination.Write(timeseries_);
            destination.Write(timestamp_);
            value_.WriteTo( destination );
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(rowVersion_);
            source.Read(timeseries_);
            source.Read(timestamp_);
            value_.ReadFrom( source );
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<UInt64TimeseriesValueData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<UInt64TimeseriesValueData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const UInt64TimeseriesValueData& >( other );
                if ( dataObject.rowVersion_ != rowVersion_ )
                {
                    return false;
                }
                if ( dataObject.timeseries_ != timeseries_ )
                {
                    return false;
                }
                if ( dataObject.timestamp_ != timestamp_ )
                {
                    return false;
                }
                if ( dataObject.value_ != value_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        Int64 RowVersion( ) const
        {
            return rowVersion_;
        }
        void SetRowVersion( const Int64& rowVersion )
        {
            rowVersion_ = rowVersion;
        }
        const Guid& Timeseries( ) const
        {
            return timeseries_;
        }
        void SetTimeseries( const Guid& timeseries )
        {
            timeseries_ = timeseries;
        }
        const DateTime& Timestamp( ) const
        {
            return timestamp_;
        }
        void SetTimestamp( const DateTime& timestamp )
        {
            timestamp_ = timestamp;
        }
        const DBInt64& Value( ) const
        {
            return value_;
        }
        void SetValue( const DBInt64& value )
        {
            value_ = value;
        }
    };
    class VehicleTypeData : public BaseData<Kind, Guid>
    {
    public:
        using Base = BaseData<Kind, Guid>;
        static constexpr Kind KIND = Kind::VehicleType;
    private:
        Int64 rowVersion_ = 0;
        FixedDBWideString<127> name_;
    public:
        VehicleTypeData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(rowVersion_);
            name_.WriteTo( destination );
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(rowVersion_);
            name_.ReadFrom( source );
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<VehicleTypeData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<VehicleTypeData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const VehicleTypeData& >( other );
                if ( dataObject.rowVersion_ != rowVersion_ )
                {
                    return false;
                }
                if ( dataObject.name_ != name_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        Int64 RowVersion( ) const
        {
            return rowVersion_;
        }
        void SetRowVersion( const Int64& rowVersion )
        {
            rowVersion_ = rowVersion;
        }
        const FixedDBWideString<127>& Name( ) const
        {
            return name_;
        }
        void SetName( const WideString& name )
        {
            name_ = name;
        }
    };
    class VesselTypeData : public BaseData<Kind, Guid>
    {
    public:
        using Base = BaseData<Kind, Guid>;
        static constexpr Kind KIND = Kind::VesselType;
    private:
        Int64 rowVersion_ = 0;
        FixedDBWideString<127> name_;
        Int32 code_ = 0;
    public:
        VesselTypeData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(rowVersion_);
            name_.WriteTo( destination );
            destination.Write(code_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(rowVersion_);
            name_.ReadFrom( source );
            source.Read(code_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<VesselTypeData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<VesselTypeData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const VesselTypeData& >( other );
                if ( dataObject.rowVersion_ != rowVersion_ )
                {
                    return false;
                }
                if ( dataObject.name_ != name_ )
                {
                    return false;
                }
                if ( dataObject.code_ != code_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        Int64 RowVersion( ) const
        {
            return rowVersion_;
        }
        void SetRowVersion( const Int64& rowVersion )
        {
            rowVersion_ = rowVersion;
        }
        const FixedDBWideString<127>& Name( ) const
        {
            return name_;
        }
        void SetName( const WideString& name )
        {
            name_ = name;
        }
        Int32 Code( ) const
        {
            return code_;
        }
        void SetCode( Int32 code )
        {
            code_ = code;
        }
    };
    class ViewData : public BaseData<Kind, Guid>
    {
    public:
        using Base = BaseData<Kind, Guid>;
        static constexpr Kind KIND = Kind::View;
    private:
        Int64 rowVersion_ = 0;
        FixedDBWideString<127> name_;
        Guid latitudeTimeseries_;
        Guid longitudeTimeseries_;
        Guid zoomLevelTimeseries_;
    public:
        ViewData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(rowVersion_);
            name_.WriteTo( destination );
            destination.Write(latitudeTimeseries_);
            destination.Write(longitudeTimeseries_);
            destination.Write(zoomLevelTimeseries_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(rowVersion_);
            name_.ReadFrom( source );
            source.Read(latitudeTimeseries_);
            source.Read(longitudeTimeseries_);
            source.Read(zoomLevelTimeseries_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<ViewData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<ViewData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const ViewData& >( other );
                if ( dataObject.rowVersion_ != rowVersion_ )
                {
                    return false;
                }
                if ( dataObject.name_ != name_ )
                {
                    return false;
                }
                if ( dataObject.latitudeTimeseries_ != latitudeTimeseries_ )
                {
                    return false;
                }
                if ( dataObject.longitudeTimeseries_ != longitudeTimeseries_ )
                {
                    return false;
                }
                if ( dataObject.zoomLevelTimeseries_ != zoomLevelTimeseries_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        Int64 RowVersion( ) const
        {
            return rowVersion_;
        }
        void SetRowVersion( const Int64& rowVersion )
        {
            rowVersion_ = rowVersion;
        }
        const FixedDBWideString<127>& Name( ) const
        {
            return name_;
        }
        void SetName( const WideString& name )
        {
            name_ = name;
        }
        const Guid& LatitudeTimeseries( ) const
        {
            return latitudeTimeseries_;
        }
        void SetLatitudeTimeseries( const Guid& latitudeTimeseries )
        {
            latitudeTimeseries_ = latitudeTimeseries;
        }
        const Guid& LongitudeTimeseries( ) const
        {
            return longitudeTimeseries_;
        }
        void SetLongitudeTimeseries( const Guid& longitudeTimeseries )
        {
            longitudeTimeseries_ = longitudeTimeseries;
        }
        const Guid& ZoomLevelTimeseries( ) const
        {
            return zoomLevelTimeseries_;
        }
        void SetZoomLevelTimeseries( const Guid& zoomLevelTimeseries )
        {
            zoomLevelTimeseries_ = zoomLevelTimeseries;
        }
    };
    class ViewCameraLinkData : public BaseData<Kind, Guid>
    {
    public:
        using Base = BaseData<Kind, Guid>;
        static constexpr Kind KIND = Kind::ViewCameraLink;
    private:
        Int64 rowVersion_ = 0;
        Guid view_;
        Guid camera_;
        DateTime start_;
        DBDateTime end_;
    public:
        ViewCameraLinkData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(rowVersion_);
            destination.Write(view_);
            destination.Write(camera_);
            destination.Write(start_);
            end_.WriteTo( destination );
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(rowVersion_);
            source.Read(view_);
            source.Read(camera_);
            source.Read(start_);
            end_.ReadFrom( source );
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<ViewCameraLinkData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<ViewCameraLinkData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const ViewCameraLinkData& >( other );
                if ( dataObject.rowVersion_ != rowVersion_ )
                {
                    return false;
                }
                if ( dataObject.view_ != view_ )
                {
                    return false;
                }
                if ( dataObject.camera_ != camera_ )
                {
                    return false;
                }
                if ( dataObject.start_ != start_ )
                {
                    return false;
                }
                if ( dataObject.end_ != end_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        Int64 RowVersion( ) const
        {
            return rowVersion_;
        }
        void SetRowVersion( const Int64& rowVersion )
        {
            rowVersion_ = rowVersion;
        }
        const Guid& View( ) const
        {
            return view_;
        }
        void SetView( const Guid& view )
        {
            view_ = view;
        }
        const Guid& Camera( ) const
        {
            return camera_;
        }
        void SetCamera( const Guid& camera )
        {
            camera_ = camera;
        }
        const DateTime& Start( ) const
        {
            return start_;
        }
        void SetStart( const DateTime& start )
        {
            start_ = start;
        }
        const DBDateTime& End( ) const
        {
            return end_;
        }
        void SetEnd( const DBDateTime& end )
        {
            end_ = end;
        }
    };
    class ViewTrackerLinkData : public BaseData<Kind, Guid>
    {
    public:
        using Base = BaseData<Kind, Guid>;
        static constexpr Kind KIND = Kind::ViewTrackerLink;
    private:
        Int64 rowVersion_ = 0;
        Guid view_;
        Guid tracker_;
        DateTime start_;
        DBDateTime end_;
    public:
        ViewTrackerLinkData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(rowVersion_);
            destination.Write(view_);
            destination.Write(tracker_);
            destination.Write(start_);
            end_.WriteTo( destination );
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(rowVersion_);
            source.Read(view_);
            source.Read(tracker_);
            source.Read(start_);
            end_.ReadFrom( source );
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<ViewTrackerLinkData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<ViewTrackerLinkData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const ViewTrackerLinkData& >( other );
                if ( dataObject.rowVersion_ != rowVersion_ )
                {
                    return false;
                }
                if ( dataObject.view_ != view_ )
                {
                    return false;
                }
                if ( dataObject.tracker_ != tracker_ )
                {
                    return false;
                }
                if ( dataObject.start_ != start_ )
                {
                    return false;
                }
                if ( dataObject.end_ != end_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        Int64 RowVersion( ) const
        {
            return rowVersion_;
        }
        void SetRowVersion( const Int64& rowVersion )
        {
            rowVersion_ = rowVersion;
        }
        const Guid& View( ) const
        {
            return view_;
        }
        void SetView( const Guid& view )
        {
            view_ = view;
        }
        const Guid& Tracker( ) const
        {
            return tracker_;
        }
        void SetTracker( const Guid& tracker )
        {
            tracker_ = tracker;
        }
        const DateTime& Start( ) const
        {
            return start_;
        }
        void SetStart( const DateTime& start )
        {
            start_ = start;
        }
        const DBDateTime& End( ) const
        {
            return end_;
        }
        void SetEnd( const DBDateTime& end )
        {
            end_ = end;
        }
    };
    class WeatherStationCommandData : public BaseData<Kind, Guid>
    {
    public:
        using Base = BaseData<Kind, Guid>;
        static constexpr Kind KIND = Kind::WeatherStationCommand;
    private:
        Int64 rowVersion_ = 0;
        Guid weatherStation_;
        DateTime timestamp_;
        Data::DeviceCommandSourceType deviceCommandSourceType_ = Data::DeviceCommandSourceType::Unknown;
        Guid deviceCommandSourceId_;
        Guid reply_;
    public:
        WeatherStationCommandData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(rowVersion_);
            destination.Write(weatherStation_);
            destination.Write(timestamp_);
            destination.Write(deviceCommandSourceType_);
            destination.Write(deviceCommandSourceId_);
            destination.Write(reply_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(rowVersion_);
            source.Read(weatherStation_);
            source.Read(timestamp_);
            source.Read(deviceCommandSourceType_);
            source.Read(deviceCommandSourceId_);
            source.Read(reply_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<WeatherStationCommandData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<WeatherStationCommandData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const WeatherStationCommandData& >( other );
                if ( dataObject.rowVersion_ != rowVersion_ )
                {
                    return false;
                }
                if ( dataObject.weatherStation_ != weatherStation_ )
                {
                    return false;
                }
                if ( dataObject.timestamp_ != timestamp_ )
                {
                    return false;
                }
                if ( dataObject.deviceCommandSourceType_ != deviceCommandSourceType_ )
                {
                    return false;
                }
                if ( dataObject.deviceCommandSourceId_ != deviceCommandSourceId_ )
                {
                    return false;
                }
                if ( dataObject.reply_ != reply_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        Int64 RowVersion( ) const
        {
            return rowVersion_;
        }
        void SetRowVersion( const Int64& rowVersion )
        {
            rowVersion_ = rowVersion;
        }
        const Guid& WeatherStation( ) const
        {
            return weatherStation_;
        }
        void SetWeatherStation( const Guid& weatherStation )
        {
            weatherStation_ = weatherStation;
        }
        const DateTime& Timestamp( ) const
        {
            return timestamp_;
        }
        void SetTimestamp( const DateTime& timestamp )
        {
            timestamp_ = timestamp;
        }
        Data::DeviceCommandSourceType DeviceCommandSourceType( ) const
        {
            return deviceCommandSourceType_;
        }
        void SetDeviceCommandSourceType( Data::DeviceCommandSourceType deviceCommandSourceType )
        {
            deviceCommandSourceType_ = deviceCommandSourceType;
        }
        const Guid& DeviceCommandSourceId( ) const
        {
            return deviceCommandSourceId_;
        }
        void SetDeviceCommandSourceId( const Guid& deviceCommandSourceId )
        {
            deviceCommandSourceId_ = deviceCommandSourceId;
        }
        const Guid& Reply( ) const
        {
            return reply_;
        }
        void SetReply( const Guid& reply )
        {
            reply_ = reply;
        }
    };
    class WeatherStationCommandReplyData : public BaseData<Kind, Guid>
    {
    public:
        using Base = BaseData<Kind, Guid>;
        static constexpr Kind KIND = Kind::WeatherStationCommandReply;
    private:
        Int64 rowVersion_ = 0;
        Guid weatherStation_;
        DateTime timestamp_;
        Guid command_;
        Data::DeviceCommandReplyStatus status_ = Data::DeviceCommandReplyStatus::Unknown;
        WideString message_;
        SQLLEN messageLength_ = SQL_NULL_DATA;
    public:
        WeatherStationCommandReplyData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(rowVersion_);
            destination.Write(weatherStation_);
            destination.Write(timestamp_);
            destination.Write(command_);
            destination.Write(status_);
            destination.Write(message_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(rowVersion_);
            source.Read(weatherStation_);
            source.Read(timestamp_);
            source.Read(command_);
            source.Read(status_);
            source.Read(message_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<WeatherStationCommandReplyData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<WeatherStationCommandReplyData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const WeatherStationCommandReplyData& >( other );
                if ( dataObject.rowVersion_ != rowVersion_ )
                {
                    return false;
                }
                if ( dataObject.weatherStation_ != weatherStation_ )
                {
                    return false;
                }
                if ( dataObject.timestamp_ != timestamp_ )
                {
                    return false;
                }
                if ( dataObject.command_ != command_ )
                {
                    return false;
                }
                if ( dataObject.status_ != status_ )
                {
                    return false;
                }
                if ( dataObject.message_ != message_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        Int64 RowVersion( ) const
        {
            return rowVersion_;
        }
        void SetRowVersion( const Int64& rowVersion )
        {
            rowVersion_ = rowVersion;
        }
        const Guid& WeatherStation( ) const
        {
            return weatherStation_;
        }
        void SetWeatherStation( const Guid& weatherStation )
        {
            weatherStation_ = weatherStation;
        }
        const DateTime& Timestamp( ) const
        {
            return timestamp_;
        }
        void SetTimestamp( const DateTime& timestamp )
        {
            timestamp_ = timestamp;
        }
        const Guid& Command( ) const
        {
            return command_;
        }
        void SetCommand( const Guid& command )
        {
            command_ = command;
        }
        Data::DeviceCommandReplyStatus Status( ) const
        {
            return status_;
        }
        void SetStatus( Data::DeviceCommandReplyStatus status )
        {
            status_ = status;
        }
        const WideString& Message( ) const
        {
            return message_;
        }
        void SetMessage( const WideString& message )
        {
            message_ = message;
        }
    };
    class WeatherStationConfigurationData : public BaseData<Kind, Guid>
    {
    public:
        using Base = BaseData<Kind, Guid>;
        static constexpr Kind KIND = Kind::WeatherStationConfiguration;
    private:
        Int64 rowVersion_ = 0;
        Guid weatherStation_;
        DateTime timestamp_;
        TimeSpan noDataTimeOut_;
        TimeSpan sendInterval_;
        double latitude_ = 0.0;
        double longitude_ = 0.0;
        double gyroOffset_ = 0.0;
        bool enableAveraging_ = false;
        TimeSpan averagingInterval_;
    public:
        WeatherStationConfigurationData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(rowVersion_);
            destination.Write(weatherStation_);
            destination.Write(timestamp_);
            destination.Write(noDataTimeOut_);
            destination.Write(sendInterval_);
            destination.Write(latitude_);
            destination.Write(longitude_);
            destination.Write(gyroOffset_);
            destination.Write(enableAveraging_);
            destination.Write(averagingInterval_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(rowVersion_);
            source.Read(weatherStation_);
            source.Read(timestamp_);
            source.Read(noDataTimeOut_);
            source.Read(sendInterval_);
            source.Read(latitude_);
            source.Read(longitude_);
            source.Read(gyroOffset_);
            source.Read(enableAveraging_);
            source.Read(averagingInterval_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<WeatherStationConfigurationData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<WeatherStationConfigurationData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const WeatherStationConfigurationData& >( other );
                if ( dataObject.rowVersion_ != rowVersion_ )
                {
                    return false;
                }
                if ( dataObject.weatherStation_ != weatherStation_ )
                {
                    return false;
                }
                if ( dataObject.timestamp_ != timestamp_ )
                {
                    return false;
                }
                if ( dataObject.noDataTimeOut_ != noDataTimeOut_ )
                {
                    return false;
                }
                if ( dataObject.sendInterval_ != sendInterval_ )
                {
                    return false;
                }
                if ( dataObject.latitude_ != latitude_ )
                {
                    return false;
                }
                if ( dataObject.longitude_ != longitude_ )
                {
                    return false;
                }
                if ( dataObject.gyroOffset_ != gyroOffset_ )
                {
                    return false;
                }
                if ( dataObject.enableAveraging_ != enableAveraging_ )
                {
                    return false;
                }
                if ( dataObject.averagingInterval_ != averagingInterval_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        Int64 RowVersion( ) const
        {
            return rowVersion_;
        }
        void SetRowVersion( const Int64& rowVersion )
        {
            rowVersion_ = rowVersion;
        }
        const Guid& WeatherStation( ) const
        {
            return weatherStation_;
        }
        void SetWeatherStation( const Guid& weatherStation )
        {
            weatherStation_ = weatherStation;
        }
        const DateTime& Timestamp( ) const
        {
            return timestamp_;
        }
        void SetTimestamp( const DateTime& timestamp )
        {
            timestamp_ = timestamp;
        }
        const TimeSpan& NoDataTimeOut( ) const
        {
            return noDataTimeOut_;
        }
        void SetNoDataTimeOut( const TimeSpan& noDataTimeOut )
        {
            noDataTimeOut_ = noDataTimeOut;
        }
        const TimeSpan& SendInterval( ) const
        {
            return sendInterval_;
        }
        void SetSendInterval( const TimeSpan& sendInterval )
        {
            sendInterval_ = sendInterval;
        }
        double Latitude( ) const
        {
            return latitude_;
        }
        void SetLatitude( double latitude )
        {
            latitude_ = latitude;
        }
        double Longitude( ) const
        {
            return longitude_;
        }
        void SetLongitude( double longitude )
        {
            longitude_ = longitude;
        }
        double GyroOffset( ) const
        {
            return gyroOffset_;
        }
        void SetGyroOffset( double gyroOffset )
        {
            gyroOffset_ = gyroOffset;
        }
        bool EnableAveraging( ) const
        {
            return enableAveraging_;
        }
        void SetEnableAveraging( bool enableAveraging )
        {
            enableAveraging_ = enableAveraging;
        }
        const TimeSpan& AveragingInterval( ) const
        {
            return averagingInterval_;
        }
        void SetAveragingInterval( const TimeSpan& averagingInterval )
        {
            averagingInterval_ = averagingInterval;
        }
    };
    class ZoneData : public BaseData<Kind, Guid>
    {
    public:
        using Base = BaseData<Kind, Guid>;
        static constexpr Kind KIND = Kind::Zone;
    private:
        Int64 rowVersion_ = 0;
        FixedDBWideString<127> name_;
        double longitude_ = 0.0;
        double latitude_ = 0.0;
        Data::ZoneAlarmType alarmType_ = Data::ZoneAlarmType::None;
        TimeSpan alarmTime_;
        TimeSpan radarTrackMinimumLifetime_;
        double speed_ = 0.0;
        UInt32 strokeColor_ = 0;
        UInt32 fillColor_ = 0;
    public:
        ZoneData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(rowVersion_);
            name_.WriteTo( destination );
            destination.Write(longitude_);
            destination.Write(latitude_);
            destination.Write(alarmType_);
            destination.Write(alarmTime_);
            destination.Write(radarTrackMinimumLifetime_);
            destination.Write(speed_);
            destination.Write(strokeColor_);
            destination.Write(fillColor_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(rowVersion_);
            name_.ReadFrom( source );
            source.Read(longitude_);
            source.Read(latitude_);
            source.Read(alarmType_);
            source.Read(alarmTime_);
            source.Read(radarTrackMinimumLifetime_);
            source.Read(speed_);
            source.Read(strokeColor_);
            source.Read(fillColor_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<ZoneData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<ZoneData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const ZoneData& >( other );
                if ( dataObject.rowVersion_ != rowVersion_ )
                {
                    return false;
                }
                if ( dataObject.name_ != name_ )
                {
                    return false;
                }
                if ( dataObject.longitude_ != longitude_ )
                {
                    return false;
                }
                if ( dataObject.latitude_ != latitude_ )
                {
                    return false;
                }
                if ( dataObject.alarmType_ != alarmType_ )
                {
                    return false;
                }
                if ( dataObject.alarmTime_ != alarmTime_ )
                {
                    return false;
                }
                if ( dataObject.radarTrackMinimumLifetime_ != radarTrackMinimumLifetime_ )
                {
                    return false;
                }
                if ( dataObject.speed_ != speed_ )
                {
                    return false;
                }
                if ( dataObject.strokeColor_ != strokeColor_ )
                {
                    return false;
                }
                if ( dataObject.fillColor_ != fillColor_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        Int64 RowVersion( ) const
        {
            return rowVersion_;
        }
        void SetRowVersion( const Int64& rowVersion )
        {
            rowVersion_ = rowVersion;
        }
        const FixedDBWideString<127>& Name( ) const
        {
            return name_;
        }
        void SetName( const WideString& name )
        {
            name_ = name;
        }
        double Longitude( ) const
        {
            return longitude_;
        }
        void SetLongitude( double longitude )
        {
            longitude_ = longitude;
        }
        double Latitude( ) const
        {
            return latitude_;
        }
        void SetLatitude( double latitude )
        {
            latitude_ = latitude;
        }
        Data::ZoneAlarmType AlarmType( ) const
        {
            return alarmType_;
        }
        void SetAlarmType( Data::ZoneAlarmType alarmType )
        {
            alarmType_ = alarmType;
        }
        const TimeSpan& AlarmTime( ) const
        {
            return alarmTime_;
        }
        void SetAlarmTime( const TimeSpan& alarmTime )
        {
            alarmTime_ = alarmTime;
        }
        const TimeSpan& RadarTrackMinimumLifetime( ) const
        {
            return radarTrackMinimumLifetime_;
        }
        void SetRadarTrackMinimumLifetime( const TimeSpan& radarTrackMinimumLifetime )
        {
            radarTrackMinimumLifetime_ = radarTrackMinimumLifetime;
        }
        double Speed( ) const
        {
            return speed_;
        }
        void SetSpeed( double speed )
        {
            speed_ = speed;
        }
        UInt32 StrokeColor( ) const
        {
            return strokeColor_;
        }
        void SetStrokeColor( UInt32 strokeColor )
        {
            strokeColor_ = strokeColor;
        }
        UInt32 FillColor( ) const
        {
            return fillColor_;
        }
        void SetFillColor( UInt32 fillColor )
        {
            fillColor_ = fillColor;
        }
    };
    class CircularZoneData : public ZoneData
    {
    public:
        using Base = ZoneData;
        static constexpr Kind KIND = Kind::CircularZone;
    private:
        double radius_ = 0.0;
    public:
        CircularZoneData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(radius_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(radius_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<CircularZoneData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<CircularZoneData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const CircularZoneData& >( other );
                if ( dataObject.radius_ != radius_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        double Radius( ) const
        {
            return radius_;
        }
        void SetRadius( double radius )
        {
            radius_ = radius;
        }
    };
    class PolygonZoneData : public ZoneData
    {
    public:
        using Base = ZoneData;
        static constexpr Kind KIND = Kind::PolygonZone;
    private:
        Binary polygon_;
        SQLLEN polygonLength_ = SQL_NULL_DATA;
    public:
        PolygonZoneData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(polygon_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(polygon_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<PolygonZoneData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<PolygonZoneData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const PolygonZoneData& >( other );
                if ( dataObject.polygon_ != polygon_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        const Binary& Polygon( ) const
        {
            return polygon_;
        }
        void SetPolygon( const Binary& polygon )
        {
            polygon_ = polygon;
        }
    };
    class ZoneExceptionsData : public BaseData<Kind, Guid>
    {
    public:
        using Base = BaseData<Kind, Guid>;
        static constexpr Kind KIND = Kind::ZoneExceptions;
    private:
        Int64 rowVersion_ = 0;
        Guid zone_;
        DateTime timestamp_;
    public:
        ZoneExceptionsData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(rowVersion_);
            destination.Write(zone_);
            destination.Write(timestamp_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(rowVersion_);
            source.Read(zone_);
            source.Read(timestamp_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<ZoneExceptionsData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<ZoneExceptionsData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const ZoneExceptionsData& >( other );
                if ( dataObject.rowVersion_ != rowVersion_ )
                {
                    return false;
                }
                if ( dataObject.zone_ != zone_ )
                {
                    return false;
                }
                if ( dataObject.timestamp_ != timestamp_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        Int64 RowVersion( ) const
        {
            return rowVersion_;
        }
        void SetRowVersion( const Int64& rowVersion )
        {
            rowVersion_ = rowVersion;
        }
        const Guid& Zone( ) const
        {
            return zone_;
        }
        void SetZone( const Guid& zone )
        {
            zone_ = zone;
        }
        const DateTime& Timestamp( ) const
        {
            return timestamp_;
        }
        void SetTimestamp( const DateTime& timestamp )
        {
            timestamp_ = timestamp;
        }
    };
    class ZoneExceptionsVesselLinkData : public BaseData<Kind, Guid>
    {
    public:
        using Base = BaseData<Kind, Guid>;
        static constexpr Kind KIND = Kind::ZoneExceptionsVesselLink;
    private:
        Int64 rowVersion_ = 0;
        Guid zoneExceptions_;
        Guid vessel_;
    public:
        ZoneExceptionsVesselLinkData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(rowVersion_);
            destination.Write(zoneExceptions_);
            destination.Write(vessel_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(rowVersion_);
            source.Read(zoneExceptions_);
            source.Read(vessel_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<ZoneExceptionsVesselLinkData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<ZoneExceptionsVesselLinkData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const ZoneExceptionsVesselLinkData& >( other );
                if ( dataObject.rowVersion_ != rowVersion_ )
                {
                    return false;
                }
                if ( dataObject.zoneExceptions_ != zoneExceptions_ )
                {
                    return false;
                }
                if ( dataObject.vessel_ != vessel_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        Int64 RowVersion( ) const
        {
            return rowVersion_;
        }
        void SetRowVersion( const Int64& rowVersion )
        {
            rowVersion_ = rowVersion;
        }
        const Guid& ZoneExceptions( ) const
        {
            return zoneExceptions_;
        }
        void SetZoneExceptions( const Guid& zoneExceptions )
        {
            zoneExceptions_ = zoneExceptions;
        }
        const Guid& Vessel( ) const
        {
            return vessel_;
        }
        void SetVessel( const Guid& vessel )
        {
            vessel_ = vessel;
        }
    };
    class ZoneTrackAlarmData : public BaseData<Kind, Guid>
    {
    public:
        using Base = BaseData<Kind, Guid>;
        static constexpr Kind KIND = Kind::ZoneTrackAlarm;
    private:
        Int64 rowVersion_ = 0;
        Guid track_;
        Guid zone_;
        Guid radarTrack_;
        DateTime timestamp_;
        double latitude_ = 0.0;
        double longitude_ = 0.0;
        double speed_ = 0.0;
        DBDouble course_;
        DBDouble heading_;
        double enterLatitude_ = 0.0;
        double enterLongitude_ = 0.0;
        DBDouble leaveLatitude_;
        DBDouble leaveLongitude_;
    public:
        ZoneTrackAlarmData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(rowVersion_);
            destination.Write(track_);
            destination.Write(zone_);
            destination.Write(radarTrack_);
            destination.Write(timestamp_);
            destination.Write(latitude_);
            destination.Write(longitude_);
            destination.Write(speed_);
            course_.WriteTo( destination );
            heading_.WriteTo( destination );
            destination.Write(enterLatitude_);
            destination.Write(enterLongitude_);
            leaveLatitude_.WriteTo( destination );
            leaveLongitude_.WriteTo( destination );
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(rowVersion_);
            source.Read(track_);
            source.Read(zone_);
            source.Read(radarTrack_);
            source.Read(timestamp_);
            source.Read(latitude_);
            source.Read(longitude_);
            source.Read(speed_);
            course_.ReadFrom( source );
            heading_.ReadFrom( source );
            source.Read(enterLatitude_);
            source.Read(enterLongitude_);
            leaveLatitude_.ReadFrom( source );
            leaveLongitude_.ReadFrom( source );
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<ZoneTrackAlarmData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<ZoneTrackAlarmData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const ZoneTrackAlarmData& >( other );
                if ( dataObject.rowVersion_ != rowVersion_ )
                {
                    return false;
                }
                if ( dataObject.track_ != track_ )
                {
                    return false;
                }
                if ( dataObject.zone_ != zone_ )
                {
                    return false;
                }
                if ( dataObject.radarTrack_ != radarTrack_ )
                {
                    return false;
                }
                if ( dataObject.timestamp_ != timestamp_ )
                {
                    return false;
                }
                if ( dataObject.latitude_ != latitude_ )
                {
                    return false;
                }
                if ( dataObject.longitude_ != longitude_ )
                {
                    return false;
                }
                if ( dataObject.speed_ != speed_ )
                {
                    return false;
                }
                if ( dataObject.course_ != course_ )
                {
                    return false;
                }
                if ( dataObject.heading_ != heading_ )
                {
                    return false;
                }
                if ( dataObject.enterLatitude_ != enterLatitude_ )
                {
                    return false;
                }
                if ( dataObject.enterLongitude_ != enterLongitude_ )
                {
                    return false;
                }
                if ( dataObject.leaveLatitude_ != leaveLatitude_ )
                {
                    return false;
                }
                if ( dataObject.leaveLongitude_ != leaveLongitude_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        Int64 RowVersion( ) const
        {
            return rowVersion_;
        }
        void SetRowVersion( const Int64& rowVersion )
        {
            rowVersion_ = rowVersion;
        }
        const Guid& Track( ) const
        {
            return track_;
        }
        void SetTrack( const Guid& track )
        {
            track_ = track;
        }
        const Guid& Zone( ) const
        {
            return zone_;
        }
        void SetZone( const Guid& zone )
        {
            zone_ = zone;
        }
        const Guid& RadarTrack( ) const
        {
            return radarTrack_;
        }
        void SetRadarTrack( const Guid& radarTrack )
        {
            radarTrack_ = radarTrack;
        }
        const DateTime& Timestamp( ) const
        {
            return timestamp_;
        }
        void SetTimestamp( const DateTime& timestamp )
        {
            timestamp_ = timestamp;
        }
        double Latitude( ) const
        {
            return latitude_;
        }
        void SetLatitude( double latitude )
        {
            latitude_ = latitude;
        }
        double Longitude( ) const
        {
            return longitude_;
        }
        void SetLongitude( double longitude )
        {
            longitude_ = longitude;
        }
        double Speed( ) const
        {
            return speed_;
        }
        void SetSpeed( double speed )
        {
            speed_ = speed;
        }
        const DBDouble& Course( ) const
        {
            return course_;
        }
        void SetCourse( const DBDouble& course )
        {
            course_ = course;
        }
        const DBDouble& Heading( ) const
        {
            return heading_;
        }
        void SetHeading( const DBDouble& heading )
        {
            heading_ = heading;
        }
        double EnterLatitude( ) const
        {
            return enterLatitude_;
        }
        void SetEnterLatitude( double enterLatitude )
        {
            enterLatitude_ = enterLatitude;
        }
        double EnterLongitude( ) const
        {
            return enterLongitude_;
        }
        void SetEnterLongitude( double enterLongitude )
        {
            enterLongitude_ = enterLongitude;
        }
        const DBDouble& LeaveLatitude( ) const
        {
            return leaveLatitude_;
        }
        void SetLeaveLatitude( const DBDouble& leaveLatitude )
        {
            leaveLatitude_ = leaveLatitude;
        }
        const DBDouble& LeaveLongitude( ) const
        {
            return leaveLongitude_;
        }
        void SetLeaveLongitude( const DBDouble& leaveLongitude )
        {
            leaveLongitude_ = leaveLongitude;
        }
    };
    template<IO::StreamReader StreamT>
    std::shared_ptr<BaseData<Kind, Guid>> ReadDataFrom( IO::BinaryReader<StreamT>& source )
    {
        auto kind = source.Read<Kind>( );
        auto newObject = DataFactory( kind );
        switch ( kind )
        {
            case Kind::AircraftType:
                static_cast<AircraftTypeData&>(*newObject).ReadFrom( source );
                break;
            case Kind::AidToNavigationReportMessage:
                static_cast<AidToNavigationReportMessageData&>(*newObject).ReadFrom( source );
                break;
            case Kind::AisAddressedSafetyRelatedMessage:
                static_cast<AisAddressedSafetyRelatedMessageData&>(*newObject).ReadFrom( source );
                break;
            case Kind::AisBaseStationReportMessage:
                static_cast<AisBaseStationReportMessageData&>(*newObject).ReadFrom( source );
                break;
            case Kind::AisBinaryAcknowledgeMessage:
                static_cast<AisBinaryAcknowledgeMessageData&>(*newObject).ReadFrom( source );
                break;
            case Kind::AisBinaryAddressedMessage:
                static_cast<AisBinaryAddressedMessageData&>(*newObject).ReadFrom( source );
                break;
            case Kind::AisBinaryBroadcastMessage:
                static_cast<AisBinaryBroadcastMessageData&>(*newObject).ReadFrom( source );
                break;
            case Kind::AisDataLinkManagementMessage:
                static_cast<AisDataLinkManagementMessageData&>(*newObject).ReadFrom( source );
                break;
            case Kind::AisExtendedClassBCsPositionReportMessage:
                static_cast<AisExtendedClassBCsPositionReportMessageData&>(*newObject).ReadFrom( source );
                break;
            case Kind::AisInterrogationMessage:
                static_cast<AisInterrogationMessageData&>(*newObject).ReadFrom( source );
                break;
            case Kind::AisPositionReportClassAAssignedScheduleMessage:
                static_cast<AisPositionReportClassAAssignedScheduleMessageData&>(*newObject).ReadFrom( source );
                break;
            case Kind::AisPositionReportClassAMessage:
                static_cast<AisPositionReportClassAMessageData&>(*newObject).ReadFrom( source );
                break;
            case Kind::AisPositionReportClassAResponseToInterrogationMessage:
                static_cast<AisPositionReportClassAResponseToInterrogationMessageData&>(*newObject).ReadFrom( source );
                break;
            case Kind::AisPositionReportForLongRangeApplicationsMessage:
                static_cast<AisPositionReportForLongRangeApplicationsMessageData&>(*newObject).ReadFrom( source );
                break;
            case Kind::AisSafetyRelatedAcknowledgmentMessage:
                static_cast<AisSafetyRelatedAcknowledgmentMessageData&>(*newObject).ReadFrom( source );
                break;
            case Kind::AisStandardClassBCsPositionReportMessage:
                static_cast<AisStandardClassBCsPositionReportMessageData&>(*newObject).ReadFrom( source );
                break;
            case Kind::AisStandardSarAircraftPositionReportMessage:
                static_cast<AisStandardSarAircraftPositionReportMessageData&>(*newObject).ReadFrom( source );
                break;
            case Kind::AisStaticAndVoyageRelatedDataMessage:
                static_cast<AisStaticAndVoyageRelatedDataMessageData&>(*newObject).ReadFrom( source );
                break;
            case Kind::AisStaticDataReportMessage:
                static_cast<AisStaticDataReportMessageData&>(*newObject).ReadFrom( source );
                break;
            case Kind::AisStaticDataReportPartAMessage:
                static_cast<AisStaticDataReportPartAMessageData&>(*newObject).ReadFrom( source );
                break;
            case Kind::AisStaticDataReportPartBMessage:
                static_cast<AisStaticDataReportPartBMessageData&>(*newObject).ReadFrom( source );
                break;
            case Kind::AisUtcAndDateInquiryMessage:
                static_cast<AisUtcAndDateInquiryMessageData&>(*newObject).ReadFrom( source );
                break;
            case Kind::AisUtcAndDateResponseMessage:
                static_cast<AisUtcAndDateResponseMessageData&>(*newObject).ReadFrom( source );
                break;
            case Kind::AisTransceiverCommand:
                static_cast<AisTransceiverCommandData&>(*newObject).ReadFrom( source );
                break;
            case Kind::AisTransceiverCommandReply:
                static_cast<AisTransceiverCommandReplyData&>(*newObject).ReadFrom( source );
                break;
            case Kind::AisTransceiverConfiguration:
                static_cast<AisTransceiverConfigurationData&>(*newObject).ReadFrom( source );
                break;
            case Kind::AisTransceiverRawMessage:
                static_cast<AisTransceiverRawMessageData&>(*newObject).ReadFrom( source );
                break;
            case Kind::AisTransceiverRawSentence:
                static_cast<AisTransceiverRawSentenceData&>(*newObject).ReadFrom( source );
                break;
            case Kind::AlarmStateChange:
                static_cast<AlarmStateChangeData&>(*newObject).ReadFrom( source );
                break;
            case Kind::BaseStationType:
                static_cast<BaseStationTypeData&>(*newObject).ReadFrom( source );
                break;
            case Kind::BinaryTimeseriesValue:
                static_cast<BinaryTimeseriesValueData&>(*newObject).ReadFrom( source );
                break;
            case Kind::Bookmark:
                static_cast<BookmarkData&>(*newObject).ReadFrom( source );
                break;
            case Kind::BooleanTimeseriesValue:
                static_cast<BooleanTimeseriesValueData&>(*newObject).ReadFrom( source );
                break;
            case Kind::ByteTimeseriesValue:
                static_cast<ByteTimeseriesValueData&>(*newObject).ReadFrom( source );
                break;
            case Kind::CameraCommand:
                static_cast<CameraCommandData&>(*newObject).ReadFrom( source );
                break;
            case Kind::CameraCommandAbsoluteMove:
                static_cast<CameraCommandAbsoluteMoveData&>(*newObject).ReadFrom( source );
                break;
            case Kind::CameraCommandAdjustPanTiltZoom:
                static_cast<CameraCommandAdjustPanTiltZoomData&>(*newObject).ReadFrom( source );
                break;
            case Kind::CameraCommandContinuousMove:
                static_cast<CameraCommandContinuousMoveData&>(*newObject).ReadFrom( source );
                break;
            case Kind::CameraCommandGeoMove:
                static_cast<CameraCommandGeoMoveData&>(*newObject).ReadFrom( source );
                break;
            case Kind::CameraCommandRelativeMove:
                static_cast<CameraCommandRelativeMoveData&>(*newObject).ReadFrom( source );
                break;
            case Kind::CameraCommandReleasePTZOwnership:
                static_cast<CameraCommandReleasePTZOwnershipData&>(*newObject).ReadFrom( source );
                break;
            case Kind::CameraCommandRequestPTZOwnership:
                static_cast<CameraCommandRequestPTZOwnershipData&>(*newObject).ReadFrom( source );
                break;
            case Kind::CameraCommandSetAutoFocus:
                static_cast<CameraCommandSetAutoFocusData&>(*newObject).ReadFrom( source );
                break;
            case Kind::CameraCommandSetBlackAndWhite:
                static_cast<CameraCommandSetBlackAndWhiteData&>(*newObject).ReadFrom( source );
                break;
            case Kind::CameraCommandSetFollowed:
                static_cast<CameraCommandSetFollowedData&>(*newObject).ReadFrom( source );
                break;
            case Kind::CameraCommandSetInfraRedLamp:
                static_cast<CameraCommandSetInfraRedLampData&>(*newObject).ReadFrom( source );
                break;
            case Kind::CameraCommandSetWasher:
                static_cast<CameraCommandSetWasherData&>(*newObject).ReadFrom( source );
                break;
            case Kind::CameraCommandSetWiper:
                static_cast<CameraCommandSetWiperData&>(*newObject).ReadFrom( source );
                break;
            case Kind::CameraCommandStop:
                static_cast<CameraCommandStopData&>(*newObject).ReadFrom( source );
                break;
            case Kind::CameraCommandReply:
                static_cast<CameraCommandReplyData&>(*newObject).ReadFrom( source );
                break;
            case Kind::CameraConfiguration:
                static_cast<CameraConfigurationData&>(*newObject).ReadFrom( source );
                break;
            case Kind::CameraPanCalibration:
                static_cast<CameraPanCalibrationData&>(*newObject).ReadFrom( source );
                break;
            case Kind::CameraPanCalibrationValue:
                static_cast<CameraPanCalibrationValueData&>(*newObject).ReadFrom( source );
                break;
            case Kind::CameraStatus:
                static_cast<CameraStatusData&>(*newObject).ReadFrom( source );
                break;
            case Kind::CameraTiltCalibration:
                static_cast<CameraTiltCalibrationData&>(*newObject).ReadFrom( source );
                break;
            case Kind::CameraTiltCalibrationValue:
                static_cast<CameraTiltCalibrationValueData&>(*newObject).ReadFrom( source );
                break;
            case Kind::CameraZoomCalibration:
                static_cast<CameraZoomCalibrationData&>(*newObject).ReadFrom( source );
                break;
            case Kind::CameraZoomCalibrationValue:
                static_cast<CameraZoomCalibrationValueData&>(*newObject).ReadFrom( source );
                break;
            case Kind::Catalog:
                static_cast<CatalogData&>(*newObject).ReadFrom( source );
                break;
            case Kind::Element:
                static_cast<ElementData&>(*newObject).ReadFrom( source );
                break;
            case Kind::CollectionInfo:
                static_cast<CollectionInfoData&>(*newObject).ReadFrom( source );
                break;
            case Kind::Country:
                static_cast<CountryData&>(*newObject).ReadFrom( source );
                break;
            case Kind::CursorInfo:
                static_cast<CursorInfoData&>(*newObject).ReadFrom( source );
                break;
            case Kind::DateTimeTimeseriesValue:
                static_cast<DateTimeTimeseriesValueData&>(*newObject).ReadFrom( source );
                break;
            case Kind::DeviceHost:
                static_cast<DeviceHostData&>(*newObject).ReadFrom( source );
                break;
            case Kind::DeviceHostConfiguration:
                static_cast<DeviceHostConfigurationData&>(*newObject).ReadFrom( source );
                break;
            case Kind::DoubleTimeseriesValue:
                static_cast<DoubleTimeseriesValueData&>(*newObject).ReadFrom( source );
                break;
            case Kind::FacilityType:
                static_cast<FacilityTypeData&>(*newObject).ReadFrom( source );
                break;
            case Kind::GeoPosition2DTimeseriesValue:
                static_cast<GeoPosition2DTimeseriesValueData&>(*newObject).ReadFrom( source );
                break;
            case Kind::GeoPosition3DTimeseriesValue:
                static_cast<GeoPosition3DTimeseriesValueData&>(*newObject).ReadFrom( source );
                break;
            case Kind::GNSSDeviceCommand:
                static_cast<GNSSDeviceCommandData&>(*newObject).ReadFrom( source );
                break;
            case Kind::GNSSDeviceCommandReply:
                static_cast<GNSSDeviceCommandReplyData&>(*newObject).ReadFrom( source );
                break;
            case Kind::GNSSDeviceConfiguration:
                static_cast<GNSSDeviceConfigurationData&>(*newObject).ReadFrom( source );
                break;
            case Kind::GuidTimeseriesValue:
                static_cast<GuidTimeseriesValueData&>(*newObject).ReadFrom( source );
                break;
            case Kind::GyroDeviceCommand:
                static_cast<GyroDeviceCommandData&>(*newObject).ReadFrom( source );
                break;
            case Kind::GyroDeviceCommandReply:
                static_cast<GyroDeviceCommandReplyData&>(*newObject).ReadFrom( source );
                break;
            case Kind::GyroDeviceConfiguration:
                static_cast<GyroDeviceConfigurationData&>(*newObject).ReadFrom( source );
                break;
            case Kind::Callsign:
                static_cast<CallsignData&>(*newObject).ReadFrom( source );
                break;
            case Kind::InternationalMaritimeOrganizationNumber:
                static_cast<InternationalMaritimeOrganizationNumberData&>(*newObject).ReadFrom( source );
                break;
            case Kind::MaritimeMobileServiceIdentity:
                static_cast<MaritimeMobileServiceIdentityData&>(*newObject).ReadFrom( source );
                break;
            case Kind::Name:
                static_cast<NameData&>(*newObject).ReadFrom( source );
                break;
            case Kind::Int16TimeseriesValue:
                static_cast<Int16TimeseriesValueData&>(*newObject).ReadFrom( source );
                break;
            case Kind::Int32TimeseriesValue:
                static_cast<Int32TimeseriesValueData&>(*newObject).ReadFrom( source );
                break;
            case Kind::Int64TimeseriesValue:
                static_cast<Int64TimeseriesValueData&>(*newObject).ReadFrom( source );
                break;
            case Kind::BaseStation:
                static_cast<BaseStationData&>(*newObject).ReadFrom( source );
                break;
            case Kind::Camera:
                static_cast<CameraData&>(*newObject).ReadFrom( source );
                break;
            case Kind::GNSSDevice:
                static_cast<GNSSDeviceData&>(*newObject).ReadFrom( source );
                break;
            case Kind::GyroDevice:
                static_cast<GyroDeviceData&>(*newObject).ReadFrom( source );
                break;
            case Kind::LineInputDevice:
                static_cast<LineInputDeviceData&>(*newObject).ReadFrom( source );
                break;
            case Kind::OilspillDetector:
                static_cast<OilspillDetectorData&>(*newObject).ReadFrom( source );
                break;
            case Kind::Radio:
                static_cast<RadioData&>(*newObject).ReadFrom( source );
                break;
            case Kind::Radome:
                static_cast<RadomeData&>(*newObject).ReadFrom( source );
                break;
            case Kind::AisTransceiver:
                static_cast<AisTransceiverData&>(*newObject).ReadFrom( source );
                break;
            case Kind::Radar:
                static_cast<RadarData&>(*newObject).ReadFrom( source );
                break;
            case Kind::WeatherStation:
                static_cast<WeatherStationData&>(*newObject).ReadFrom( source );
                break;
            case Kind::Facility:
                static_cast<FacilityData&>(*newObject).ReadFrom( source );
                break;
            case Kind::Aircraft:
                static_cast<AircraftData&>(*newObject).ReadFrom( source );
                break;
            case Kind::AisAidToNavigation:
                static_cast<AisAidToNavigationData&>(*newObject).ReadFrom( source );
                break;
            case Kind::Vehicle:
                static_cast<VehicleData&>(*newObject).ReadFrom( source );
                break;
            case Kind::Vessel:
                static_cast<VesselData&>(*newObject).ReadFrom( source );
                break;
            case Kind::ItemIdentityLink:
                static_cast<ItemIdentityLinkData&>(*newObject).ReadFrom( source );
                break;
            case Kind::ItemParentChildLink:
                static_cast<ItemParentChildLinkData&>(*newObject).ReadFrom( source );
                break;
            case Kind::LineInputDeviceCommand:
                static_cast<LineInputDeviceCommandData&>(*newObject).ReadFrom( source );
                break;
            case Kind::LineInputDeviceCommandReply:
                static_cast<LineInputDeviceCommandReplyData&>(*newObject).ReadFrom( source );
                break;
            case Kind::LineInputDeviceConfiguration:
                static_cast<LineInputDeviceConfigurationData&>(*newObject).ReadFrom( source );
                break;
            case Kind::LineInputMessageRouting:
                static_cast<LineInputMessageRoutingData&>(*newObject).ReadFrom( source );
                break;
            case Kind::LineInputMessageRoutingDestination:
                static_cast<LineInputMessageRoutingDestinationData&>(*newObject).ReadFrom( source );
                break;
            case Kind::LineInputWhiteListEntry:
                static_cast<LineInputWhiteListEntryData&>(*newObject).ReadFrom( source );
                break;
            case Kind::LogApplication:
                static_cast<LogApplicationData&>(*newObject).ReadFrom( source );
                break;
            case Kind::LogApplicationConfiguration:
                static_cast<LogApplicationConfigurationData&>(*newObject).ReadFrom( source );
                break;
            case Kind::LogHost:
                static_cast<LogHostData&>(*newObject).ReadFrom( source );
                break;
            case Kind::LogHostConfiguration:
                static_cast<LogHostConfigurationData&>(*newObject).ReadFrom( source );
                break;
            case Kind::LogLocation:
                static_cast<LogLocationData&>(*newObject).ReadFrom( source );
                break;
            case Kind::LogProcess:
                static_cast<LogProcessData&>(*newObject).ReadFrom( source );
                break;
            case Kind::LogRecord:
                static_cast<LogRecordData&>(*newObject).ReadFrom( source );
                break;
            case Kind::LogThread:
                static_cast<LogThreadData&>(*newObject).ReadFrom( source );
                break;
            case Kind::LogTraceEntry:
                static_cast<LogTraceEntryData&>(*newObject).ReadFrom( source );
                break;
            case Kind::MapElement:
                static_cast<MapElementData&>(*newObject).ReadFrom( source );
                break;
            case Kind::MapInfo:
                static_cast<MapInfoData&>(*newObject).ReadFrom( source );
                break;
            case Kind::MapServiceOptions:
                static_cast<MapServiceOptionsData&>(*newObject).ReadFrom( source );
                break;
            case Kind::MaritimeIdentificationDigits:
                static_cast<MaritimeIdentificationDigitsData&>(*newObject).ReadFrom( source );
                break;
            case Kind::MediaProxySession:
                static_cast<MediaProxySessionData&>(*newObject).ReadFrom( source );
                break;
            case Kind::MediaProxySessionFile:
                static_cast<MediaProxySessionFileData&>(*newObject).ReadFrom( source );
                break;
            case Kind::MediaProxySessionOptions:
                static_cast<MediaProxySessionOptionsData&>(*newObject).ReadFrom( source );
                break;
            case Kind::MediaService:
                static_cast<MediaServiceData&>(*newObject).ReadFrom( source );
                break;
            case Kind::MediaServiceOptions:
                static_cast<MediaServiceOptionsData&>(*newObject).ReadFrom( source );
                break;
            case Kind::ElementType:
                static_cast<ElementTypeData&>(*newObject).ReadFrom( source );
                break;
            case Kind::Namespace:
                static_cast<NamespaceData&>(*newObject).ReadFrom( source );
                break;
            case Kind::Oilspill:
                static_cast<OilspillData&>(*newObject).ReadFrom( source );
                break;
            case Kind::OilspillDetectorCommand:
                static_cast<OilspillDetectorCommandData&>(*newObject).ReadFrom( source );
                break;
            case Kind::OilspillDetectorCommandReply:
                static_cast<OilspillDetectorCommandReplyData&>(*newObject).ReadFrom( source );
                break;
            case Kind::OilspillDetectorConfiguration:
                static_cast<OilspillDetectorConfigurationData&>(*newObject).ReadFrom( source );
                break;
            case Kind::Position2DTimeseriesValue:
                static_cast<Position2DTimeseriesValueData&>(*newObject).ReadFrom( source );
                break;
            case Kind::Position3DTimeseriesValue:
                static_cast<Position3DTimeseriesValueData&>(*newObject).ReadFrom( source );
                break;
            case Kind::ProcessTrackValueResult:
                static_cast<ProcessTrackValueResultData&>(*newObject).ReadFrom( source );
                break;
            case Kind::BinaryProperty:
                static_cast<BinaryPropertyData&>(*newObject).ReadFrom( source );
                break;
            case Kind::BooleanProperty:
                static_cast<BooleanPropertyData&>(*newObject).ReadFrom( source );
                break;
            case Kind::ByteProperty:
                static_cast<BytePropertyData&>(*newObject).ReadFrom( source );
                break;
            case Kind::DateTimeProperty:
                static_cast<DateTimePropertyData&>(*newObject).ReadFrom( source );
                break;
            case Kind::DoubleProperty:
                static_cast<DoublePropertyData&>(*newObject).ReadFrom( source );
                break;
            case Kind::GuidProperty:
                static_cast<GuidPropertyData&>(*newObject).ReadFrom( source );
                break;
            case Kind::Int16Property:
                static_cast<Int16PropertyData&>(*newObject).ReadFrom( source );
                break;
            case Kind::Int32Property:
                static_cast<Int32PropertyData&>(*newObject).ReadFrom( source );
                break;
            case Kind::Int64Property:
                static_cast<Int64PropertyData&>(*newObject).ReadFrom( source );
                break;
            case Kind::ReferenceProperty:
                static_cast<ReferencePropertyData&>(*newObject).ReadFrom( source );
                break;
            case Kind::SByteProperty:
                static_cast<SBytePropertyData&>(*newObject).ReadFrom( source );
                break;
            case Kind::SingleProperty:
                static_cast<SinglePropertyData&>(*newObject).ReadFrom( source );
                break;
            case Kind::StringProperty:
                static_cast<StringPropertyData&>(*newObject).ReadFrom( source );
                break;
            case Kind::BinaryTimeseriesProperty:
                static_cast<BinaryTimeseriesPropertyData&>(*newObject).ReadFrom( source );
                break;
            case Kind::BooleanTimeseriesProperty:
                static_cast<BooleanTimeseriesPropertyData&>(*newObject).ReadFrom( source );
                break;
            case Kind::ByteTimeseriesProperty:
                static_cast<ByteTimeseriesPropertyData&>(*newObject).ReadFrom( source );
                break;
            case Kind::DateTimeTimeseriesProperty:
                static_cast<DateTimeTimeseriesPropertyData&>(*newObject).ReadFrom( source );
                break;
            case Kind::DoubleTimeseriesProperty:
                static_cast<DoubleTimeseriesPropertyData&>(*newObject).ReadFrom( source );
                break;
            case Kind::GuidTimeseriesProperty:
                static_cast<GuidTimeseriesPropertyData&>(*newObject).ReadFrom( source );
                break;
            case Kind::Int16TimeseriesProperty:
                static_cast<Int16TimeseriesPropertyData&>(*newObject).ReadFrom( source );
                break;
            case Kind::Int32TimeseriesProperty:
                static_cast<Int32TimeseriesPropertyData&>(*newObject).ReadFrom( source );
                break;
            case Kind::Int64TimeseriesProperty:
                static_cast<Int64TimeseriesPropertyData&>(*newObject).ReadFrom( source );
                break;
            case Kind::ReferenceTimeseriesProperty:
                static_cast<ReferenceTimeseriesPropertyData&>(*newObject).ReadFrom( source );
                break;
            case Kind::SByteTimeseriesProperty:
                static_cast<SByteTimeseriesPropertyData&>(*newObject).ReadFrom( source );
                break;
            case Kind::SingleTimeseriesProperty:
                static_cast<SingleTimeseriesPropertyData&>(*newObject).ReadFrom( source );
                break;
            case Kind::StringTimeseriesProperty:
                static_cast<StringTimeseriesPropertyData&>(*newObject).ReadFrom( source );
                break;
            case Kind::TimeSpanTimeseriesProperty:
                static_cast<TimeSpanTimeseriesPropertyData&>(*newObject).ReadFrom( source );
                break;
            case Kind::UInt16TimeseriesProperty:
                static_cast<UInt16TimeseriesPropertyData&>(*newObject).ReadFrom( source );
                break;
            case Kind::UInt32TimeseriesProperty:
                static_cast<UInt32TimeseriesPropertyData&>(*newObject).ReadFrom( source );
                break;
            case Kind::UInt64TimeseriesProperty:
                static_cast<UInt64TimeseriesPropertyData&>(*newObject).ReadFrom( source );
                break;
            case Kind::TimeSpanProperty:
                static_cast<TimeSpanPropertyData&>(*newObject).ReadFrom( source );
                break;
            case Kind::UInt16Property:
                static_cast<UInt16PropertyData&>(*newObject).ReadFrom( source );
                break;
            case Kind::UInt32Property:
                static_cast<UInt32PropertyData&>(*newObject).ReadFrom( source );
                break;
            case Kind::UInt64Property:
                static_cast<UInt64PropertyData&>(*newObject).ReadFrom( source );
                break;
            case Kind::BinaryPropertyDefinition:
                static_cast<BinaryPropertyDefinitionData&>(*newObject).ReadFrom( source );
                break;
            case Kind::BooleanPropertyDefinition:
                static_cast<BooleanPropertyDefinitionData&>(*newObject).ReadFrom( source );
                break;
            case Kind::BytePropertyDefinition:
                static_cast<BytePropertyDefinitionData&>(*newObject).ReadFrom( source );
                break;
            case Kind::DateTimePropertyDefinition:
                static_cast<DateTimePropertyDefinitionData&>(*newObject).ReadFrom( source );
                break;
            case Kind::DoublePropertyDefinition:
                static_cast<DoublePropertyDefinitionData&>(*newObject).ReadFrom( source );
                break;
            case Kind::GuidPropertyDefinition:
                static_cast<GuidPropertyDefinitionData&>(*newObject).ReadFrom( source );
                break;
            case Kind::Int16PropertyDefinition:
                static_cast<Int16PropertyDefinitionData&>(*newObject).ReadFrom( source );
                break;
            case Kind::Int32PropertyDefinition:
                static_cast<Int32PropertyDefinitionData&>(*newObject).ReadFrom( source );
                break;
            case Kind::Int64PropertyDefinition:
                static_cast<Int64PropertyDefinitionData&>(*newObject).ReadFrom( source );
                break;
            case Kind::ReferencePropertyDefinition:
                static_cast<ReferencePropertyDefinitionData&>(*newObject).ReadFrom( source );
                break;
            case Kind::SBytePropertyDefinition:
                static_cast<SBytePropertyDefinitionData&>(*newObject).ReadFrom( source );
                break;
            case Kind::SinglePropertyDefinition:
                static_cast<SinglePropertyDefinitionData&>(*newObject).ReadFrom( source );
                break;
            case Kind::StringPropertyDefinition:
                static_cast<StringPropertyDefinitionData&>(*newObject).ReadFrom( source );
                break;
            case Kind::BinaryTimeseriesPropertyDefinition:
                static_cast<BinaryTimeseriesPropertyDefinitionData&>(*newObject).ReadFrom( source );
                break;
            case Kind::BooleanTimeseriesPropertyDefinition:
                static_cast<BooleanTimeseriesPropertyDefinitionData&>(*newObject).ReadFrom( source );
                break;
            case Kind::ByteTimeseriesPropertyDefinition:
                static_cast<ByteTimeseriesPropertyDefinitionData&>(*newObject).ReadFrom( source );
                break;
            case Kind::DateTimeTimeseriesPropertyDefinition:
                static_cast<DateTimeTimeseriesPropertyDefinitionData&>(*newObject).ReadFrom( source );
                break;
            case Kind::DoubleTimeseriesPropertyDefinition:
                static_cast<DoubleTimeseriesPropertyDefinitionData&>(*newObject).ReadFrom( source );
                break;
            case Kind::GuidTimeseriesPropertyDefinition:
                static_cast<GuidTimeseriesPropertyDefinitionData&>(*newObject).ReadFrom( source );
                break;
            case Kind::Int16TimeseriesPropertyDefinition:
                static_cast<Int16TimeseriesPropertyDefinitionData&>(*newObject).ReadFrom( source );
                break;
            case Kind::Int32TimeseriesPropertyDefinition:
                static_cast<Int32TimeseriesPropertyDefinitionData&>(*newObject).ReadFrom( source );
                break;
            case Kind::Int64TimeseriesPropertyDefinition:
                static_cast<Int64TimeseriesPropertyDefinitionData&>(*newObject).ReadFrom( source );
                break;
            case Kind::ReferenceTimeseriesPropertyDefinition:
                static_cast<ReferenceTimeseriesPropertyDefinitionData&>(*newObject).ReadFrom( source );
                break;
            case Kind::SByteTimeseriesPropertyDefinition:
                static_cast<SByteTimeseriesPropertyDefinitionData&>(*newObject).ReadFrom( source );
                break;
            case Kind::SingleTimeseriesPropertyDefinition:
                static_cast<SingleTimeseriesPropertyDefinitionData&>(*newObject).ReadFrom( source );
                break;
            case Kind::StringTimeseriesPropertyDefinition:
                static_cast<StringTimeseriesPropertyDefinitionData&>(*newObject).ReadFrom( source );
                break;
            case Kind::TimeSpanTimeseriesPropertyDefinition:
                static_cast<TimeSpanTimeseriesPropertyDefinitionData&>(*newObject).ReadFrom( source );
                break;
            case Kind::UInt16TimeseriesPropertyDefinition:
                static_cast<UInt16TimeseriesPropertyDefinitionData&>(*newObject).ReadFrom( source );
                break;
            case Kind::UInt32TimeseriesPropertyDefinition:
                static_cast<UInt32TimeseriesPropertyDefinitionData&>(*newObject).ReadFrom( source );
                break;
            case Kind::UInt64TimeseriesPropertyDefinition:
                static_cast<UInt64TimeseriesPropertyDefinitionData&>(*newObject).ReadFrom( source );
                break;
            case Kind::TimeSpanPropertyDefinition:
                static_cast<TimeSpanPropertyDefinitionData&>(*newObject).ReadFrom( source );
                break;
            case Kind::UInt16PropertyDefinition:
                static_cast<UInt16PropertyDefinitionData&>(*newObject).ReadFrom( source );
                break;
            case Kind::UInt32PropertyDefinition:
                static_cast<UInt32PropertyDefinitionData&>(*newObject).ReadFrom( source );
                break;
            case Kind::UInt64PropertyDefinition:
                static_cast<UInt64PropertyDefinitionData&>(*newObject).ReadFrom( source );
                break;
            case Kind::RadarAlarmStatus:
                static_cast<RadarAlarmStatusData&>(*newObject).ReadFrom( source );
                break;
            case Kind::RadarCommand:
                static_cast<RadarCommandData&>(*newObject).ReadFrom( source );
                break;
            case Kind::RadarCommandGetStatus:
                static_cast<RadarCommandGetStatusData&>(*newObject).ReadFrom( source );
                break;
            case Kind::RadarCommandReply:
                static_cast<RadarCommandReplyData&>(*newObject).ReadFrom( source );
                break;
            case Kind::RadarCommandReplyGetStatus:
                static_cast<RadarCommandReplyGetStatusData&>(*newObject).ReadFrom( source );
                break;
            case Kind::RadarConfiguration:
                static_cast<RadarConfigurationData&>(*newObject).ReadFrom( source );
                break;
            case Kind::RadarImage:
                static_cast<RadarImageData&>(*newObject).ReadFrom( source );
                break;
            case Kind::RadarRawTrackTable:
                static_cast<RadarRawTrackTableData&>(*newObject).ReadFrom( source );
                break;
            case Kind::RadarStatus:
                static_cast<RadarStatusData&>(*newObject).ReadFrom( source );
                break;
            case Kind::RadioCommand:
                static_cast<RadioCommandData&>(*newObject).ReadFrom( source );
                break;
            case Kind::RadioCommandReply:
                static_cast<RadioCommandReplyData&>(*newObject).ReadFrom( source );
                break;
            case Kind::RadioConfiguration:
                static_cast<RadioConfigurationData&>(*newObject).ReadFrom( source );
                break;
            case Kind::RadomeCommand:
                static_cast<RadomeCommandData&>(*newObject).ReadFrom( source );
                break;
            case Kind::RadomeCommandReply:
                static_cast<RadomeCommandReplyData&>(*newObject).ReadFrom( source );
                break;
            case Kind::RadomeConfiguration:
                static_cast<RadomeConfigurationData&>(*newObject).ReadFrom( source );
                break;
            case Kind::ReferenceTimeseriesValue:
                static_cast<ReferenceTimeseriesValueData&>(*newObject).ReadFrom( source );
                break;
            case Kind::SByteTimeseriesValue:
                static_cast<SByteTimeseriesValueData&>(*newObject).ReadFrom( source );
                break;
            case Kind::SecurityDomain:
                static_cast<SecurityDomainData&>(*newObject).ReadFrom( source );
                break;
            case Kind::SecurityLogin:
                static_cast<SecurityLoginData&>(*newObject).ReadFrom( source );
                break;
            case Kind::SecurityRole:
                static_cast<SecurityRoleData&>(*newObject).ReadFrom( source );
                break;
            case Kind::SecurityIdentifierRoleLink:
                static_cast<SecurityIdentifierRoleLinkData&>(*newObject).ReadFrom( source );
                break;
            case Kind::SecurityLoginSession:
                static_cast<SecurityLoginSessionData&>(*newObject).ReadFrom( source );
                break;
            case Kind::SecurityPermission:
                static_cast<SecurityPermissionData&>(*newObject).ReadFrom( source );
                break;
            case Kind::SingleTimeseriesValue:
                static_cast<SingleTimeseriesValueData&>(*newObject).ReadFrom( source );
                break;
            case Kind::StringTimeseriesValue:
                static_cast<StringTimeseriesValueData&>(*newObject).ReadFrom( source );
                break;
            case Kind::BinaryTimeseries:
                static_cast<BinaryTimeseriesData&>(*newObject).ReadFrom( source );
                break;
            case Kind::BooleanTimeseries:
                static_cast<BooleanTimeseriesData&>(*newObject).ReadFrom( source );
                break;
            case Kind::AisAidToNavigationOffPositionTimeseries:
                static_cast<AisAidToNavigationOffPositionTimeseriesData&>(*newObject).ReadFrom( source );
                break;
            case Kind::DeviceEnabledTimeseries:
                static_cast<DeviceEnabledTimeseriesData&>(*newObject).ReadFrom( source );
                break;
            case Kind::RadarAutomaticSensitivityTimeControlTimeseries:
                static_cast<RadarAutomaticSensitivityTimeControlTimeseriesData&>(*newObject).ReadFrom( source );
                break;
            case Kind::RadarBlankSector1Timeseries:
                static_cast<RadarBlankSector1TimeseriesData&>(*newObject).ReadFrom( source );
                break;
            case Kind::RadarBlankSector2Timeseries:
                static_cast<RadarBlankSector2TimeseriesData&>(*newObject).ReadFrom( source );
                break;
            case Kind::RadarEnableAutomaticFrequencyControlTimeseries:
                static_cast<RadarEnableAutomaticFrequencyControlTimeseriesData&>(*newObject).ReadFrom( source );
                break;
            case Kind::RadarEnableFastTimeConstantTimeseries:
                static_cast<RadarEnableFastTimeConstantTimeseriesData&>(*newObject).ReadFrom( source );
                break;
            case Kind::RadarEnableSensitivityTimeControlTimeseries:
                static_cast<RadarEnableSensitivityTimeControlTimeseriesData&>(*newObject).ReadFrom( source );
                break;
            case Kind::RadarPowerOnTimeseries:
                static_cast<RadarPowerOnTimeseriesData&>(*newObject).ReadFrom( source );
                break;
            case Kind::RadarSaveSettingsTimeseries:
                static_cast<RadarSaveSettingsTimeseriesData&>(*newObject).ReadFrom( source );
                break;
            case Kind::RadarTrackingTimeseries:
                static_cast<RadarTrackingTimeseriesData&>(*newObject).ReadFrom( source );
                break;
            case Kind::MediaProxySessionEnabledTimeseries:
                static_cast<MediaProxySessionEnabledTimeseriesData&>(*newObject).ReadFrom( source );
                break;
            case Kind::MediaServiceEnabledTimeseries:
                static_cast<MediaServiceEnabledTimeseriesData&>(*newObject).ReadFrom( source );
                break;
            case Kind::ByteTimeseries:
                static_cast<ByteTimeseriesData&>(*newObject).ReadFrom( source );
                break;
            case Kind::DateTimeTimeseries:
                static_cast<DateTimeTimeseriesData&>(*newObject).ReadFrom( source );
                break;
            case Kind::DoubleTimeseries:
                static_cast<DoubleTimeseriesData&>(*newObject).ReadFrom( source );
                break;
            case Kind::GNSSAltitudeTimeseries:
                static_cast<GNSSAltitudeTimeseriesData&>(*newObject).ReadFrom( source );
                break;
            case Kind::GNSSLatitudeTimeseries:
                static_cast<GNSSLatitudeTimeseriesData&>(*newObject).ReadFrom( source );
                break;
            case Kind::GNSSLongitudeTimeseries:
                static_cast<GNSSLongitudeTimeseriesData&>(*newObject).ReadFrom( source );
                break;
            case Kind::GyroCourseTimeseries:
                static_cast<GyroCourseTimeseriesData&>(*newObject).ReadFrom( source );
                break;
            case Kind::GyroHeadingMagneticNorthTimeseries:
                static_cast<GyroHeadingMagneticNorthTimeseriesData&>(*newObject).ReadFrom( source );
                break;
            case Kind::GyroHeadingTrueNorthTimeseries:
                static_cast<GyroHeadingTrueNorthTimeseriesData&>(*newObject).ReadFrom( source );
                break;
            case Kind::GyroPitchTimeseries:
                static_cast<GyroPitchTimeseriesData&>(*newObject).ReadFrom( source );
                break;
            case Kind::GyroRateOfTurnTimeseries:
                static_cast<GyroRateOfTurnTimeseriesData&>(*newObject).ReadFrom( source );
                break;
            case Kind::GyroRollTimeseries:
                static_cast<GyroRollTimeseriesData&>(*newObject).ReadFrom( source );
                break;
            case Kind::GyroSpeedTimeseries:
                static_cast<GyroSpeedTimeseriesData&>(*newObject).ReadFrom( source );
                break;
            case Kind::RadarLatitudeTimeseries:
                static_cast<RadarLatitudeTimeseriesData&>(*newObject).ReadFrom( source );
                break;
            case Kind::RadarLongitudeTimeseries:
                static_cast<RadarLongitudeTimeseriesData&>(*newObject).ReadFrom( source );
                break;
            case Kind::RadomeDewPointTimeseries:
                static_cast<RadomeDewPointTimeseriesData&>(*newObject).ReadFrom( source );
                break;
            case Kind::RadomePressureTimeseries:
                static_cast<RadomePressureTimeseriesData&>(*newObject).ReadFrom( source );
                break;
            case Kind::RadomeTemperatureTimeseries:
                static_cast<RadomeTemperatureTimeseriesData&>(*newObject).ReadFrom( source );
                break;
            case Kind::VesselDraughtTimeseries:
                static_cast<VesselDraughtTimeseriesData&>(*newObject).ReadFrom( source );
                break;
            case Kind::ViewLatitudeTimeseries:
                static_cast<ViewLatitudeTimeseriesData&>(*newObject).ReadFrom( source );
                break;
            case Kind::ViewLongitudeTimeseries:
                static_cast<ViewLongitudeTimeseriesData&>(*newObject).ReadFrom( source );
                break;
            case Kind::ViewZoomLevelTimeseries:
                static_cast<ViewZoomLevelTimeseriesData&>(*newObject).ReadFrom( source );
                break;
            case Kind::WeatherStationAbsoluteHumidityTimeseries:
                static_cast<WeatherStationAbsoluteHumidityTimeseriesData&>(*newObject).ReadFrom( source );
                break;
            case Kind::WeatherStationAirTemperatureTimeseries:
                static_cast<WeatherStationAirTemperatureTimeseriesData&>(*newObject).ReadFrom( source );
                break;
            case Kind::WeatherStationBarometricPressureTimeseries:
                static_cast<WeatherStationBarometricPressureTimeseriesData&>(*newObject).ReadFrom( source );
                break;
            case Kind::WeatherStationDewPointTimeseries:
                static_cast<WeatherStationDewPointTimeseriesData&>(*newObject).ReadFrom( source );
                break;
            case Kind::WeatherStationRelativeHumidityTimeseries:
                static_cast<WeatherStationRelativeHumidityTimeseriesData&>(*newObject).ReadFrom( source );
                break;
            case Kind::WeatherStationWaterTemperatureTimeseries:
                static_cast<WeatherStationWaterTemperatureTimeseriesData&>(*newObject).ReadFrom( source );
                break;
            case Kind::WeatherStationWindDirectionTimeseries:
                static_cast<WeatherStationWindDirectionTimeseriesData&>(*newObject).ReadFrom( source );
                break;
            case Kind::WeatherStationWindSpeedTimeseries:
                static_cast<WeatherStationWindSpeedTimeseriesData&>(*newObject).ReadFrom( source );
                break;
            case Kind::GeoPosition2DTimeseries:
                static_cast<GeoPosition2DTimeseriesData&>(*newObject).ReadFrom( source );
                break;
            case Kind::AisAidToNavigationPositionTimeseries:
                static_cast<AisAidToNavigationPositionTimeseriesData&>(*newObject).ReadFrom( source );
                break;
            case Kind::GeoPosition3DTimeseries:
                static_cast<GeoPosition3DTimeseriesData&>(*newObject).ReadFrom( source );
                break;
            case Kind::GuidTimeseries:
                static_cast<GuidTimeseriesData&>(*newObject).ReadFrom( source );
                break;
            case Kind::Int16Timeseries:
                static_cast<Int16TimeseriesData&>(*newObject).ReadFrom( source );
                break;
            case Kind::Int32Timeseries:
                static_cast<Int32TimeseriesData&>(*newObject).ReadFrom( source );
                break;
            case Kind::RadarAzimuthOffsetTimeseries:
                static_cast<RadarAzimuthOffsetTimeseriesData&>(*newObject).ReadFrom( source );
                break;
            case Kind::RadarFastTimeConstantLevelTimeseries:
                static_cast<RadarFastTimeConstantLevelTimeseriesData&>(*newObject).ReadFrom( source );
                break;
            case Kind::RadarFastTimeConstantModeTimeseries:
                static_cast<RadarFastTimeConstantModeTimeseriesData&>(*newObject).ReadFrom( source );
                break;
            case Kind::RadarPulseTimeseries:
                static_cast<RadarPulseTimeseriesData&>(*newObject).ReadFrom( source );
                break;
            case Kind::RadarSector1EndTimeseries:
                static_cast<RadarSector1EndTimeseriesData&>(*newObject).ReadFrom( source );
                break;
            case Kind::RadarSector1StartTimeseries:
                static_cast<RadarSector1StartTimeseriesData&>(*newObject).ReadFrom( source );
                break;
            case Kind::RadarSector2EndTimeseries:
                static_cast<RadarSector2EndTimeseriesData&>(*newObject).ReadFrom( source );
                break;
            case Kind::RadarSector2StartTimeseries:
                static_cast<RadarSector2StartTimeseriesData&>(*newObject).ReadFrom( source );
                break;
            case Kind::RadarSensitivityTimeControlLevelTimeseries:
                static_cast<RadarSensitivityTimeControlLevelTimeseriesData&>(*newObject).ReadFrom( source );
                break;
            case Kind::RadarTuningTimeseries:
                static_cast<RadarTuningTimeseriesData&>(*newObject).ReadFrom( source );
                break;
            case Kind::VesselPersonsOnBoardTimeseries:
                static_cast<VesselPersonsOnBoardTimeseriesData&>(*newObject).ReadFrom( source );
                break;
            case Kind::Int64Timeseries:
                static_cast<Int64TimeseriesData&>(*newObject).ReadFrom( source );
                break;
            case Kind::Position2DTimeseries:
                static_cast<Position2DTimeseriesData&>(*newObject).ReadFrom( source );
                break;
            case Kind::Position3DTimeseries:
                static_cast<Position3DTimeseriesData&>(*newObject).ReadFrom( source );
                break;
            case Kind::ReferenceTimeseries:
                static_cast<ReferenceTimeseriesData&>(*newObject).ReadFrom( source );
                break;
            case Kind::SByteTimeseries:
                static_cast<SByteTimeseriesData&>(*newObject).ReadFrom( source );
                break;
            case Kind::SingleTimeseries:
                static_cast<SingleTimeseriesData&>(*newObject).ReadFrom( source );
                break;
            case Kind::StringTimeseries:
                static_cast<StringTimeseriesData&>(*newObject).ReadFrom( source );
                break;
            case Kind::TimeSpanTimeseries:
                static_cast<TimeSpanTimeseriesData&>(*newObject).ReadFrom( source );
                break;
            case Kind::UInt16Timeseries:
                static_cast<UInt16TimeseriesData&>(*newObject).ReadFrom( source );
                break;
            case Kind::UInt32Timeseries:
                static_cast<UInt32TimeseriesData&>(*newObject).ReadFrom( source );
                break;
            case Kind::RadomeStatusTimeseries:
                static_cast<RadomeStatusTimeseriesData&>(*newObject).ReadFrom( source );
                break;
            case Kind::UInt64Timeseries:
                static_cast<UInt64TimeseriesData&>(*newObject).ReadFrom( source );
                break;
            case Kind::TimeseriesCatalog:
                static_cast<TimeseriesCatalogData&>(*newObject).ReadFrom( source );
                break;
            case Kind::TimeseriesInfo:
                static_cast<TimeseriesInfoData&>(*newObject).ReadFrom( source );
                break;
            case Kind::TimeSpanTimeseriesValue:
                static_cast<TimeSpanTimeseriesValueData&>(*newObject).ReadFrom( source );
                break;
            case Kind::TrackableItemTrackLink:
                static_cast<TrackableItemTrackLinkData&>(*newObject).ReadFrom( source );
                break;
            case Kind::Track:
                static_cast<TrackData&>(*newObject).ReadFrom( source );
                break;
            case Kind::Track3D:
                static_cast<Track3DData&>(*newObject).ReadFrom( source );
                break;
            case Kind::TrackerFilterParameters:
                static_cast<TrackerFilterParametersData&>(*newObject).ReadFrom( source );
                break;
            case Kind::TrackerFilterParametersConfiguration:
                static_cast<TrackerFilterParametersConfigurationData&>(*newObject).ReadFrom( source );
                break;
            case Kind::TrackInfo:
                static_cast<TrackInfoData&>(*newObject).ReadFrom( source );
                break;
            case Kind::TrackingServiceOptions:
                static_cast<TrackingServiceOptionsData&>(*newObject).ReadFrom( source );
                break;
            case Kind::TrackLink:
                static_cast<TrackLinkData&>(*newObject).ReadFrom( source );
                break;
            case Kind::TrackValue:
                static_cast<TrackValueData&>(*newObject).ReadFrom( source );
                break;
            case Kind::TrackValue3D:
                static_cast<TrackValue3DData&>(*newObject).ReadFrom( source );
                break;
            case Kind::UInt16TimeseriesValue:
                static_cast<UInt16TimeseriesValueData&>(*newObject).ReadFrom( source );
                break;
            case Kind::UInt32TimeseriesValue:
                static_cast<UInt32TimeseriesValueData&>(*newObject).ReadFrom( source );
                break;
            case Kind::UInt64TimeseriesValue:
                static_cast<UInt64TimeseriesValueData&>(*newObject).ReadFrom( source );
                break;
            case Kind::VehicleType:
                static_cast<VehicleTypeData&>(*newObject).ReadFrom( source );
                break;
            case Kind::VesselType:
                static_cast<VesselTypeData&>(*newObject).ReadFrom( source );
                break;
            case Kind::View:
                static_cast<ViewData&>(*newObject).ReadFrom( source );
                break;
            case Kind::ViewCameraLink:
                static_cast<ViewCameraLinkData&>(*newObject).ReadFrom( source );
                break;
            case Kind::ViewTrackerLink:
                static_cast<ViewTrackerLinkData&>(*newObject).ReadFrom( source );
                break;
            case Kind::WeatherStationCommand:
                static_cast<WeatherStationCommandData&>(*newObject).ReadFrom( source );
                break;
            case Kind::WeatherStationCommandReply:
                static_cast<WeatherStationCommandReplyData&>(*newObject).ReadFrom( source );
                break;
            case Kind::WeatherStationConfiguration:
                static_cast<WeatherStationConfigurationData&>(*newObject).ReadFrom( source );
                break;
            case Kind::CircularZone:
                static_cast<CircularZoneData&>(*newObject).ReadFrom( source );
                break;
            case Kind::PolygonZone:
                static_cast<PolygonZoneData&>(*newObject).ReadFrom( source );
                break;
            case Kind::ZoneExceptions:
                static_cast<ZoneExceptionsData&>(*newObject).ReadFrom( source );
                break;
            case Kind::ZoneExceptionsVesselLink:
                static_cast<ZoneExceptionsVesselLinkData&>(*newObject).ReadFrom( source );
                break;
            case Kind::ZoneTrackAlarm:
                static_cast<ZoneTrackAlarmData&>(*newObject).ReadFrom( source );
                break;
        }
        return newObject;
    }

    template<IO::StreamWriter StreamT>
    void WriteDataTo( const BaseData<Kind, Guid>& data, IO::BinaryWriter<StreamT>& destination )
    {
        auto kind = data.GetObjectType( );
        switch ( kind )
        {
            case Kind::AircraftType:
                static_cast<const AircraftTypeData&>(data).WriteTo( destination );
                break;
            case Kind::AidToNavigationReportMessage:
                static_cast<const AidToNavigationReportMessageData&>(data).WriteTo( destination );
                break;
            case Kind::AisAddressedSafetyRelatedMessage:
                static_cast<const AisAddressedSafetyRelatedMessageData&>(data).WriteTo( destination );
                break;
            case Kind::AisBaseStationReportMessage:
                static_cast<const AisBaseStationReportMessageData&>(data).WriteTo( destination );
                break;
            case Kind::AisBinaryAcknowledgeMessage:
                static_cast<const AisBinaryAcknowledgeMessageData&>(data).WriteTo( destination );
                break;
            case Kind::AisBinaryAddressedMessage:
                static_cast<const AisBinaryAddressedMessageData&>(data).WriteTo( destination );
                break;
            case Kind::AisBinaryBroadcastMessage:
                static_cast<const AisBinaryBroadcastMessageData&>(data).WriteTo( destination );
                break;
            case Kind::AisDataLinkManagementMessage:
                static_cast<const AisDataLinkManagementMessageData&>(data).WriteTo( destination );
                break;
            case Kind::AisExtendedClassBCsPositionReportMessage:
                static_cast<const AisExtendedClassBCsPositionReportMessageData&>(data).WriteTo( destination );
                break;
            case Kind::AisInterrogationMessage:
                static_cast<const AisInterrogationMessageData&>(data).WriteTo( destination );
                break;
            case Kind::AisPositionReportClassAAssignedScheduleMessage:
                static_cast<const AisPositionReportClassAAssignedScheduleMessageData&>(data).WriteTo( destination );
                break;
            case Kind::AisPositionReportClassAMessage:
                static_cast<const AisPositionReportClassAMessageData&>(data).WriteTo( destination );
                break;
            case Kind::AisPositionReportClassAResponseToInterrogationMessage:
                static_cast<const AisPositionReportClassAResponseToInterrogationMessageData&>(data).WriteTo( destination );
                break;
            case Kind::AisPositionReportForLongRangeApplicationsMessage:
                static_cast<const AisPositionReportForLongRangeApplicationsMessageData&>(data).WriteTo( destination );
                break;
            case Kind::AisSafetyRelatedAcknowledgmentMessage:
                static_cast<const AisSafetyRelatedAcknowledgmentMessageData&>(data).WriteTo( destination );
                break;
            case Kind::AisStandardClassBCsPositionReportMessage:
                static_cast<const AisStandardClassBCsPositionReportMessageData&>(data).WriteTo( destination );
                break;
            case Kind::AisStandardSarAircraftPositionReportMessage:
                static_cast<const AisStandardSarAircraftPositionReportMessageData&>(data).WriteTo( destination );
                break;
            case Kind::AisStaticAndVoyageRelatedDataMessage:
                static_cast<const AisStaticAndVoyageRelatedDataMessageData&>(data).WriteTo( destination );
                break;
            case Kind::AisStaticDataReportMessage:
                static_cast<const AisStaticDataReportMessageData&>(data).WriteTo( destination );
                break;
            case Kind::AisStaticDataReportPartAMessage:
                static_cast<const AisStaticDataReportPartAMessageData&>(data).WriteTo( destination );
                break;
            case Kind::AisStaticDataReportPartBMessage:
                static_cast<const AisStaticDataReportPartBMessageData&>(data).WriteTo( destination );
                break;
            case Kind::AisUtcAndDateInquiryMessage:
                static_cast<const AisUtcAndDateInquiryMessageData&>(data).WriteTo( destination );
                break;
            case Kind::AisUtcAndDateResponseMessage:
                static_cast<const AisUtcAndDateResponseMessageData&>(data).WriteTo( destination );
                break;
            case Kind::AisTransceiverCommand:
                static_cast<const AisTransceiverCommandData&>(data).WriteTo( destination );
                break;
            case Kind::AisTransceiverCommandReply:
                static_cast<const AisTransceiverCommandReplyData&>(data).WriteTo( destination );
                break;
            case Kind::AisTransceiverConfiguration:
                static_cast<const AisTransceiverConfigurationData&>(data).WriteTo( destination );
                break;
            case Kind::AisTransceiverRawMessage:
                static_cast<const AisTransceiverRawMessageData&>(data).WriteTo( destination );
                break;
            case Kind::AisTransceiverRawSentence:
                static_cast<const AisTransceiverRawSentenceData&>(data).WriteTo( destination );
                break;
            case Kind::AlarmStateChange:
                static_cast<const AlarmStateChangeData&>(data).WriteTo( destination );
                break;
            case Kind::BaseStationType:
                static_cast<const BaseStationTypeData&>(data).WriteTo( destination );
                break;
            case Kind::BinaryTimeseriesValue:
                static_cast<const BinaryTimeseriesValueData&>(data).WriteTo( destination );
                break;
            case Kind::Bookmark:
                static_cast<const BookmarkData&>(data).WriteTo( destination );
                break;
            case Kind::BooleanTimeseriesValue:
                static_cast<const BooleanTimeseriesValueData&>(data).WriteTo( destination );
                break;
            case Kind::ByteTimeseriesValue:
                static_cast<const ByteTimeseriesValueData&>(data).WriteTo( destination );
                break;
            case Kind::CameraCommand:
                static_cast<const CameraCommandData&>(data).WriteTo( destination );
                break;
            case Kind::CameraCommandAbsoluteMove:
                static_cast<const CameraCommandAbsoluteMoveData&>(data).WriteTo( destination );
                break;
            case Kind::CameraCommandAdjustPanTiltZoom:
                static_cast<const CameraCommandAdjustPanTiltZoomData&>(data).WriteTo( destination );
                break;
            case Kind::CameraCommandContinuousMove:
                static_cast<const CameraCommandContinuousMoveData&>(data).WriteTo( destination );
                break;
            case Kind::CameraCommandGeoMove:
                static_cast<const CameraCommandGeoMoveData&>(data).WriteTo( destination );
                break;
            case Kind::CameraCommandRelativeMove:
                static_cast<const CameraCommandRelativeMoveData&>(data).WriteTo( destination );
                break;
            case Kind::CameraCommandReleasePTZOwnership:
                static_cast<const CameraCommandReleasePTZOwnershipData&>(data).WriteTo( destination );
                break;
            case Kind::CameraCommandRequestPTZOwnership:
                static_cast<const CameraCommandRequestPTZOwnershipData&>(data).WriteTo( destination );
                break;
            case Kind::CameraCommandSetAutoFocus:
                static_cast<const CameraCommandSetAutoFocusData&>(data).WriteTo( destination );
                break;
            case Kind::CameraCommandSetBlackAndWhite:
                static_cast<const CameraCommandSetBlackAndWhiteData&>(data).WriteTo( destination );
                break;
            case Kind::CameraCommandSetFollowed:
                static_cast<const CameraCommandSetFollowedData&>(data).WriteTo( destination );
                break;
            case Kind::CameraCommandSetInfraRedLamp:
                static_cast<const CameraCommandSetInfraRedLampData&>(data).WriteTo( destination );
                break;
            case Kind::CameraCommandSetWasher:
                static_cast<const CameraCommandSetWasherData&>(data).WriteTo( destination );
                break;
            case Kind::CameraCommandSetWiper:
                static_cast<const CameraCommandSetWiperData&>(data).WriteTo( destination );
                break;
            case Kind::CameraCommandStop:
                static_cast<const CameraCommandStopData&>(data).WriteTo( destination );
                break;
            case Kind::CameraCommandReply:
                static_cast<const CameraCommandReplyData&>(data).WriteTo( destination );
                break;
            case Kind::CameraConfiguration:
                static_cast<const CameraConfigurationData&>(data).WriteTo( destination );
                break;
            case Kind::CameraPanCalibration:
                static_cast<const CameraPanCalibrationData&>(data).WriteTo( destination );
                break;
            case Kind::CameraPanCalibrationValue:
                static_cast<const CameraPanCalibrationValueData&>(data).WriteTo( destination );
                break;
            case Kind::CameraStatus:
                static_cast<const CameraStatusData&>(data).WriteTo( destination );
                break;
            case Kind::CameraTiltCalibration:
                static_cast<const CameraTiltCalibrationData&>(data).WriteTo( destination );
                break;
            case Kind::CameraTiltCalibrationValue:
                static_cast<const CameraTiltCalibrationValueData&>(data).WriteTo( destination );
                break;
            case Kind::CameraZoomCalibration:
                static_cast<const CameraZoomCalibrationData&>(data).WriteTo( destination );
                break;
            case Kind::CameraZoomCalibrationValue:
                static_cast<const CameraZoomCalibrationValueData&>(data).WriteTo( destination );
                break;
            case Kind::Catalog:
                static_cast<const CatalogData&>(data).WriteTo( destination );
                break;
            case Kind::Element:
                static_cast<const ElementData&>(data).WriteTo( destination );
                break;
            case Kind::CollectionInfo:
                static_cast<const CollectionInfoData&>(data).WriteTo( destination );
                break;
            case Kind::Country:
                static_cast<const CountryData&>(data).WriteTo( destination );
                break;
            case Kind::CursorInfo:
                static_cast<const CursorInfoData&>(data).WriteTo( destination );
                break;
            case Kind::DateTimeTimeseriesValue:
                static_cast<const DateTimeTimeseriesValueData&>(data).WriteTo( destination );
                break;
            case Kind::DeviceHost:
                static_cast<const DeviceHostData&>(data).WriteTo( destination );
                break;
            case Kind::DeviceHostConfiguration:
                static_cast<const DeviceHostConfigurationData&>(data).WriteTo( destination );
                break;
            case Kind::DoubleTimeseriesValue:
                static_cast<const DoubleTimeseriesValueData&>(data).WriteTo( destination );
                break;
            case Kind::FacilityType:
                static_cast<const FacilityTypeData&>(data).WriteTo( destination );
                break;
            case Kind::GeoPosition2DTimeseriesValue:
                static_cast<const GeoPosition2DTimeseriesValueData&>(data).WriteTo( destination );
                break;
            case Kind::GeoPosition3DTimeseriesValue:
                static_cast<const GeoPosition3DTimeseriesValueData&>(data).WriteTo( destination );
                break;
            case Kind::GNSSDeviceCommand:
                static_cast<const GNSSDeviceCommandData&>(data).WriteTo( destination );
                break;
            case Kind::GNSSDeviceCommandReply:
                static_cast<const GNSSDeviceCommandReplyData&>(data).WriteTo( destination );
                break;
            case Kind::GNSSDeviceConfiguration:
                static_cast<const GNSSDeviceConfigurationData&>(data).WriteTo( destination );
                break;
            case Kind::GuidTimeseriesValue:
                static_cast<const GuidTimeseriesValueData&>(data).WriteTo( destination );
                break;
            case Kind::GyroDeviceCommand:
                static_cast<const GyroDeviceCommandData&>(data).WriteTo( destination );
                break;
            case Kind::GyroDeviceCommandReply:
                static_cast<const GyroDeviceCommandReplyData&>(data).WriteTo( destination );
                break;
            case Kind::GyroDeviceConfiguration:
                static_cast<const GyroDeviceConfigurationData&>(data).WriteTo( destination );
                break;
            case Kind::Callsign:
                static_cast<const CallsignData&>(data).WriteTo( destination );
                break;
            case Kind::InternationalMaritimeOrganizationNumber:
                static_cast<const InternationalMaritimeOrganizationNumberData&>(data).WriteTo( destination );
                break;
            case Kind::MaritimeMobileServiceIdentity:
                static_cast<const MaritimeMobileServiceIdentityData&>(data).WriteTo( destination );
                break;
            case Kind::Name:
                static_cast<const NameData&>(data).WriteTo( destination );
                break;
            case Kind::Int16TimeseriesValue:
                static_cast<const Int16TimeseriesValueData&>(data).WriteTo( destination );
                break;
            case Kind::Int32TimeseriesValue:
                static_cast<const Int32TimeseriesValueData&>(data).WriteTo( destination );
                break;
            case Kind::Int64TimeseriesValue:
                static_cast<const Int64TimeseriesValueData&>(data).WriteTo( destination );
                break;
            case Kind::BaseStation:
                static_cast<const BaseStationData&>(data).WriteTo( destination );
                break;
            case Kind::Camera:
                static_cast<const CameraData&>(data).WriteTo( destination );
                break;
            case Kind::GNSSDevice:
                static_cast<const GNSSDeviceData&>(data).WriteTo( destination );
                break;
            case Kind::GyroDevice:
                static_cast<const GyroDeviceData&>(data).WriteTo( destination );
                break;
            case Kind::LineInputDevice:
                static_cast<const LineInputDeviceData&>(data).WriteTo( destination );
                break;
            case Kind::OilspillDetector:
                static_cast<const OilspillDetectorData&>(data).WriteTo( destination );
                break;
            case Kind::Radio:
                static_cast<const RadioData&>(data).WriteTo( destination );
                break;
            case Kind::Radome:
                static_cast<const RadomeData&>(data).WriteTo( destination );
                break;
            case Kind::AisTransceiver:
                static_cast<const AisTransceiverData&>(data).WriteTo( destination );
                break;
            case Kind::Radar:
                static_cast<const RadarData&>(data).WriteTo( destination );
                break;
            case Kind::WeatherStation:
                static_cast<const WeatherStationData&>(data).WriteTo( destination );
                break;
            case Kind::Facility:
                static_cast<const FacilityData&>(data).WriteTo( destination );
                break;
            case Kind::Aircraft:
                static_cast<const AircraftData&>(data).WriteTo( destination );
                break;
            case Kind::AisAidToNavigation:
                static_cast<const AisAidToNavigationData&>(data).WriteTo( destination );
                break;
            case Kind::Vehicle:
                static_cast<const VehicleData&>(data).WriteTo( destination );
                break;
            case Kind::Vessel:
                static_cast<const VesselData&>(data).WriteTo( destination );
                break;
            case Kind::ItemIdentityLink:
                static_cast<const ItemIdentityLinkData&>(data).WriteTo( destination );
                break;
            case Kind::ItemParentChildLink:
                static_cast<const ItemParentChildLinkData&>(data).WriteTo( destination );
                break;
            case Kind::LineInputDeviceCommand:
                static_cast<const LineInputDeviceCommandData&>(data).WriteTo( destination );
                break;
            case Kind::LineInputDeviceCommandReply:
                static_cast<const LineInputDeviceCommandReplyData&>(data).WriteTo( destination );
                break;
            case Kind::LineInputDeviceConfiguration:
                static_cast<const LineInputDeviceConfigurationData&>(data).WriteTo( destination );
                break;
            case Kind::LineInputMessageRouting:
                static_cast<const LineInputMessageRoutingData&>(data).WriteTo( destination );
                break;
            case Kind::LineInputMessageRoutingDestination:
                static_cast<const LineInputMessageRoutingDestinationData&>(data).WriteTo( destination );
                break;
            case Kind::LineInputWhiteListEntry:
                static_cast<const LineInputWhiteListEntryData&>(data).WriteTo( destination );
                break;
            case Kind::LogApplication:
                static_cast<const LogApplicationData&>(data).WriteTo( destination );
                break;
            case Kind::LogApplicationConfiguration:
                static_cast<const LogApplicationConfigurationData&>(data).WriteTo( destination );
                break;
            case Kind::LogHost:
                static_cast<const LogHostData&>(data).WriteTo( destination );
                break;
            case Kind::LogHostConfiguration:
                static_cast<const LogHostConfigurationData&>(data).WriteTo( destination );
                break;
            case Kind::LogLocation:
                static_cast<const LogLocationData&>(data).WriteTo( destination );
                break;
            case Kind::LogProcess:
                static_cast<const LogProcessData&>(data).WriteTo( destination );
                break;
            case Kind::LogRecord:
                static_cast<const LogRecordData&>(data).WriteTo( destination );
                break;
            case Kind::LogThread:
                static_cast<const LogThreadData&>(data).WriteTo( destination );
                break;
            case Kind::LogTraceEntry:
                static_cast<const LogTraceEntryData&>(data).WriteTo( destination );
                break;
            case Kind::MapElement:
                static_cast<const MapElementData&>(data).WriteTo( destination );
                break;
            case Kind::MapInfo:
                static_cast<const MapInfoData&>(data).WriteTo( destination );
                break;
            case Kind::MapServiceOptions:
                static_cast<const MapServiceOptionsData&>(data).WriteTo( destination );
                break;
            case Kind::MaritimeIdentificationDigits:
                static_cast<const MaritimeIdentificationDigitsData&>(data).WriteTo( destination );
                break;
            case Kind::MediaProxySession:
                static_cast<const MediaProxySessionData&>(data).WriteTo( destination );
                break;
            case Kind::MediaProxySessionFile:
                static_cast<const MediaProxySessionFileData&>(data).WriteTo( destination );
                break;
            case Kind::MediaProxySessionOptions:
                static_cast<const MediaProxySessionOptionsData&>(data).WriteTo( destination );
                break;
            case Kind::MediaService:
                static_cast<const MediaServiceData&>(data).WriteTo( destination );
                break;
            case Kind::MediaServiceOptions:
                static_cast<const MediaServiceOptionsData&>(data).WriteTo( destination );
                break;
            case Kind::ElementType:
                static_cast<const ElementTypeData&>(data).WriteTo( destination );
                break;
            case Kind::Namespace:
                static_cast<const NamespaceData&>(data).WriteTo( destination );
                break;
            case Kind::Oilspill:
                static_cast<const OilspillData&>(data).WriteTo( destination );
                break;
            case Kind::OilspillDetectorCommand:
                static_cast<const OilspillDetectorCommandData&>(data).WriteTo( destination );
                break;
            case Kind::OilspillDetectorCommandReply:
                static_cast<const OilspillDetectorCommandReplyData&>(data).WriteTo( destination );
                break;
            case Kind::OilspillDetectorConfiguration:
                static_cast<const OilspillDetectorConfigurationData&>(data).WriteTo( destination );
                break;
            case Kind::Position2DTimeseriesValue:
                static_cast<const Position2DTimeseriesValueData&>(data).WriteTo( destination );
                break;
            case Kind::Position3DTimeseriesValue:
                static_cast<const Position3DTimeseriesValueData&>(data).WriteTo( destination );
                break;
            case Kind::ProcessTrackValueResult:
                static_cast<const ProcessTrackValueResultData&>(data).WriteTo( destination );
                break;
            case Kind::BinaryProperty:
                static_cast<const BinaryPropertyData&>(data).WriteTo( destination );
                break;
            case Kind::BooleanProperty:
                static_cast<const BooleanPropertyData&>(data).WriteTo( destination );
                break;
            case Kind::ByteProperty:
                static_cast<const BytePropertyData&>(data).WriteTo( destination );
                break;
            case Kind::DateTimeProperty:
                static_cast<const DateTimePropertyData&>(data).WriteTo( destination );
                break;
            case Kind::DoubleProperty:
                static_cast<const DoublePropertyData&>(data).WriteTo( destination );
                break;
            case Kind::GuidProperty:
                static_cast<const GuidPropertyData&>(data).WriteTo( destination );
                break;
            case Kind::Int16Property:
                static_cast<const Int16PropertyData&>(data).WriteTo( destination );
                break;
            case Kind::Int32Property:
                static_cast<const Int32PropertyData&>(data).WriteTo( destination );
                break;
            case Kind::Int64Property:
                static_cast<const Int64PropertyData&>(data).WriteTo( destination );
                break;
            case Kind::ReferenceProperty:
                static_cast<const ReferencePropertyData&>(data).WriteTo( destination );
                break;
            case Kind::SByteProperty:
                static_cast<const SBytePropertyData&>(data).WriteTo( destination );
                break;
            case Kind::SingleProperty:
                static_cast<const SinglePropertyData&>(data).WriteTo( destination );
                break;
            case Kind::StringProperty:
                static_cast<const StringPropertyData&>(data).WriteTo( destination );
                break;
            case Kind::BinaryTimeseriesProperty:
                static_cast<const BinaryTimeseriesPropertyData&>(data).WriteTo( destination );
                break;
            case Kind::BooleanTimeseriesProperty:
                static_cast<const BooleanTimeseriesPropertyData&>(data).WriteTo( destination );
                break;
            case Kind::ByteTimeseriesProperty:
                static_cast<const ByteTimeseriesPropertyData&>(data).WriteTo( destination );
                break;
            case Kind::DateTimeTimeseriesProperty:
                static_cast<const DateTimeTimeseriesPropertyData&>(data).WriteTo( destination );
                break;
            case Kind::DoubleTimeseriesProperty:
                static_cast<const DoubleTimeseriesPropertyData&>(data).WriteTo( destination );
                break;
            case Kind::GuidTimeseriesProperty:
                static_cast<const GuidTimeseriesPropertyData&>(data).WriteTo( destination );
                break;
            case Kind::Int16TimeseriesProperty:
                static_cast<const Int16TimeseriesPropertyData&>(data).WriteTo( destination );
                break;
            case Kind::Int32TimeseriesProperty:
                static_cast<const Int32TimeseriesPropertyData&>(data).WriteTo( destination );
                break;
            case Kind::Int64TimeseriesProperty:
                static_cast<const Int64TimeseriesPropertyData&>(data).WriteTo( destination );
                break;
            case Kind::ReferenceTimeseriesProperty:
                static_cast<const ReferenceTimeseriesPropertyData&>(data).WriteTo( destination );
                break;
            case Kind::SByteTimeseriesProperty:
                static_cast<const SByteTimeseriesPropertyData&>(data).WriteTo( destination );
                break;
            case Kind::SingleTimeseriesProperty:
                static_cast<const SingleTimeseriesPropertyData&>(data).WriteTo( destination );
                break;
            case Kind::StringTimeseriesProperty:
                static_cast<const StringTimeseriesPropertyData&>(data).WriteTo( destination );
                break;
            case Kind::TimeSpanTimeseriesProperty:
                static_cast<const TimeSpanTimeseriesPropertyData&>(data).WriteTo( destination );
                break;
            case Kind::UInt16TimeseriesProperty:
                static_cast<const UInt16TimeseriesPropertyData&>(data).WriteTo( destination );
                break;
            case Kind::UInt32TimeseriesProperty:
                static_cast<const UInt32TimeseriesPropertyData&>(data).WriteTo( destination );
                break;
            case Kind::UInt64TimeseriesProperty:
                static_cast<const UInt64TimeseriesPropertyData&>(data).WriteTo( destination );
                break;
            case Kind::TimeSpanProperty:
                static_cast<const TimeSpanPropertyData&>(data).WriteTo( destination );
                break;
            case Kind::UInt16Property:
                static_cast<const UInt16PropertyData&>(data).WriteTo( destination );
                break;
            case Kind::UInt32Property:
                static_cast<const UInt32PropertyData&>(data).WriteTo( destination );
                break;
            case Kind::UInt64Property:
                static_cast<const UInt64PropertyData&>(data).WriteTo( destination );
                break;
            case Kind::BinaryPropertyDefinition:
                static_cast<const BinaryPropertyDefinitionData&>(data).WriteTo( destination );
                break;
            case Kind::BooleanPropertyDefinition:
                static_cast<const BooleanPropertyDefinitionData&>(data).WriteTo( destination );
                break;
            case Kind::BytePropertyDefinition:
                static_cast<const BytePropertyDefinitionData&>(data).WriteTo( destination );
                break;
            case Kind::DateTimePropertyDefinition:
                static_cast<const DateTimePropertyDefinitionData&>(data).WriteTo( destination );
                break;
            case Kind::DoublePropertyDefinition:
                static_cast<const DoublePropertyDefinitionData&>(data).WriteTo( destination );
                break;
            case Kind::GuidPropertyDefinition:
                static_cast<const GuidPropertyDefinitionData&>(data).WriteTo( destination );
                break;
            case Kind::Int16PropertyDefinition:
                static_cast<const Int16PropertyDefinitionData&>(data).WriteTo( destination );
                break;
            case Kind::Int32PropertyDefinition:
                static_cast<const Int32PropertyDefinitionData&>(data).WriteTo( destination );
                break;
            case Kind::Int64PropertyDefinition:
                static_cast<const Int64PropertyDefinitionData&>(data).WriteTo( destination );
                break;
            case Kind::ReferencePropertyDefinition:
                static_cast<const ReferencePropertyDefinitionData&>(data).WriteTo( destination );
                break;
            case Kind::SBytePropertyDefinition:
                static_cast<const SBytePropertyDefinitionData&>(data).WriteTo( destination );
                break;
            case Kind::SinglePropertyDefinition:
                static_cast<const SinglePropertyDefinitionData&>(data).WriteTo( destination );
                break;
            case Kind::StringPropertyDefinition:
                static_cast<const StringPropertyDefinitionData&>(data).WriteTo( destination );
                break;
            case Kind::BinaryTimeseriesPropertyDefinition:
                static_cast<const BinaryTimeseriesPropertyDefinitionData&>(data).WriteTo( destination );
                break;
            case Kind::BooleanTimeseriesPropertyDefinition:
                static_cast<const BooleanTimeseriesPropertyDefinitionData&>(data).WriteTo( destination );
                break;
            case Kind::ByteTimeseriesPropertyDefinition:
                static_cast<const ByteTimeseriesPropertyDefinitionData&>(data).WriteTo( destination );
                break;
            case Kind::DateTimeTimeseriesPropertyDefinition:
                static_cast<const DateTimeTimeseriesPropertyDefinitionData&>(data).WriteTo( destination );
                break;
            case Kind::DoubleTimeseriesPropertyDefinition:
                static_cast<const DoubleTimeseriesPropertyDefinitionData&>(data).WriteTo( destination );
                break;
            case Kind::GuidTimeseriesPropertyDefinition:
                static_cast<const GuidTimeseriesPropertyDefinitionData&>(data).WriteTo( destination );
                break;
            case Kind::Int16TimeseriesPropertyDefinition:
                static_cast<const Int16TimeseriesPropertyDefinitionData&>(data).WriteTo( destination );
                break;
            case Kind::Int32TimeseriesPropertyDefinition:
                static_cast<const Int32TimeseriesPropertyDefinitionData&>(data).WriteTo( destination );
                break;
            case Kind::Int64TimeseriesPropertyDefinition:
                static_cast<const Int64TimeseriesPropertyDefinitionData&>(data).WriteTo( destination );
                break;
            case Kind::ReferenceTimeseriesPropertyDefinition:
                static_cast<const ReferenceTimeseriesPropertyDefinitionData&>(data).WriteTo( destination );
                break;
            case Kind::SByteTimeseriesPropertyDefinition:
                static_cast<const SByteTimeseriesPropertyDefinitionData&>(data).WriteTo( destination );
                break;
            case Kind::SingleTimeseriesPropertyDefinition:
                static_cast<const SingleTimeseriesPropertyDefinitionData&>(data).WriteTo( destination );
                break;
            case Kind::StringTimeseriesPropertyDefinition:
                static_cast<const StringTimeseriesPropertyDefinitionData&>(data).WriteTo( destination );
                break;
            case Kind::TimeSpanTimeseriesPropertyDefinition:
                static_cast<const TimeSpanTimeseriesPropertyDefinitionData&>(data).WriteTo( destination );
                break;
            case Kind::UInt16TimeseriesPropertyDefinition:
                static_cast<const UInt16TimeseriesPropertyDefinitionData&>(data).WriteTo( destination );
                break;
            case Kind::UInt32TimeseriesPropertyDefinition:
                static_cast<const UInt32TimeseriesPropertyDefinitionData&>(data).WriteTo( destination );
                break;
            case Kind::UInt64TimeseriesPropertyDefinition:
                static_cast<const UInt64TimeseriesPropertyDefinitionData&>(data).WriteTo( destination );
                break;
            case Kind::TimeSpanPropertyDefinition:
                static_cast<const TimeSpanPropertyDefinitionData&>(data).WriteTo( destination );
                break;
            case Kind::UInt16PropertyDefinition:
                static_cast<const UInt16PropertyDefinitionData&>(data).WriteTo( destination );
                break;
            case Kind::UInt32PropertyDefinition:
                static_cast<const UInt32PropertyDefinitionData&>(data).WriteTo( destination );
                break;
            case Kind::UInt64PropertyDefinition:
                static_cast<const UInt64PropertyDefinitionData&>(data).WriteTo( destination );
                break;
            case Kind::RadarAlarmStatus:
                static_cast<const RadarAlarmStatusData&>(data).WriteTo( destination );
                break;
            case Kind::RadarCommand:
                static_cast<const RadarCommandData&>(data).WriteTo( destination );
                break;
            case Kind::RadarCommandGetStatus:
                static_cast<const RadarCommandGetStatusData&>(data).WriteTo( destination );
                break;
            case Kind::RadarCommandReply:
                static_cast<const RadarCommandReplyData&>(data).WriteTo( destination );
                break;
            case Kind::RadarCommandReplyGetStatus:
                static_cast<const RadarCommandReplyGetStatusData&>(data).WriteTo( destination );
                break;
            case Kind::RadarConfiguration:
                static_cast<const RadarConfigurationData&>(data).WriteTo( destination );
                break;
            case Kind::RadarImage:
                static_cast<const RadarImageData&>(data).WriteTo( destination );
                break;
            case Kind::RadarRawTrackTable:
                static_cast<const RadarRawTrackTableData&>(data).WriteTo( destination );
                break;
            case Kind::RadarStatus:
                static_cast<const RadarStatusData&>(data).WriteTo( destination );
                break;
            case Kind::RadioCommand:
                static_cast<const RadioCommandData&>(data).WriteTo( destination );
                break;
            case Kind::RadioCommandReply:
                static_cast<const RadioCommandReplyData&>(data).WriteTo( destination );
                break;
            case Kind::RadioConfiguration:
                static_cast<const RadioConfigurationData&>(data).WriteTo( destination );
                break;
            case Kind::RadomeCommand:
                static_cast<const RadomeCommandData&>(data).WriteTo( destination );
                break;
            case Kind::RadomeCommandReply:
                static_cast<const RadomeCommandReplyData&>(data).WriteTo( destination );
                break;
            case Kind::RadomeConfiguration:
                static_cast<const RadomeConfigurationData&>(data).WriteTo( destination );
                break;
            case Kind::ReferenceTimeseriesValue:
                static_cast<const ReferenceTimeseriesValueData&>(data).WriteTo( destination );
                break;
            case Kind::SByteTimeseriesValue:
                static_cast<const SByteTimeseriesValueData&>(data).WriteTo( destination );
                break;
            case Kind::SecurityDomain:
                static_cast<const SecurityDomainData&>(data).WriteTo( destination );
                break;
            case Kind::SecurityLogin:
                static_cast<const SecurityLoginData&>(data).WriteTo( destination );
                break;
            case Kind::SecurityRole:
                static_cast<const SecurityRoleData&>(data).WriteTo( destination );
                break;
            case Kind::SecurityIdentifierRoleLink:
                static_cast<const SecurityIdentifierRoleLinkData&>(data).WriteTo( destination );
                break;
            case Kind::SecurityLoginSession:
                static_cast<const SecurityLoginSessionData&>(data).WriteTo( destination );
                break;
            case Kind::SecurityPermission:
                static_cast<const SecurityPermissionData&>(data).WriteTo( destination );
                break;
            case Kind::SingleTimeseriesValue:
                static_cast<const SingleTimeseriesValueData&>(data).WriteTo( destination );
                break;
            case Kind::StringTimeseriesValue:
                static_cast<const StringTimeseriesValueData&>(data).WriteTo( destination );
                break;
            case Kind::BinaryTimeseries:
                static_cast<const BinaryTimeseriesData&>(data).WriteTo( destination );
                break;
            case Kind::BooleanTimeseries:
                static_cast<const BooleanTimeseriesData&>(data).WriteTo( destination );
                break;
            case Kind::AisAidToNavigationOffPositionTimeseries:
                static_cast<const AisAidToNavigationOffPositionTimeseriesData&>(data).WriteTo( destination );
                break;
            case Kind::DeviceEnabledTimeseries:
                static_cast<const DeviceEnabledTimeseriesData&>(data).WriteTo( destination );
                break;
            case Kind::RadarAutomaticSensitivityTimeControlTimeseries:
                static_cast<const RadarAutomaticSensitivityTimeControlTimeseriesData&>(data).WriteTo( destination );
                break;
            case Kind::RadarBlankSector1Timeseries:
                static_cast<const RadarBlankSector1TimeseriesData&>(data).WriteTo( destination );
                break;
            case Kind::RadarBlankSector2Timeseries:
                static_cast<const RadarBlankSector2TimeseriesData&>(data).WriteTo( destination );
                break;
            case Kind::RadarEnableAutomaticFrequencyControlTimeseries:
                static_cast<const RadarEnableAutomaticFrequencyControlTimeseriesData&>(data).WriteTo( destination );
                break;
            case Kind::RadarEnableFastTimeConstantTimeseries:
                static_cast<const RadarEnableFastTimeConstantTimeseriesData&>(data).WriteTo( destination );
                break;
            case Kind::RadarEnableSensitivityTimeControlTimeseries:
                static_cast<const RadarEnableSensitivityTimeControlTimeseriesData&>(data).WriteTo( destination );
                break;
            case Kind::RadarPowerOnTimeseries:
                static_cast<const RadarPowerOnTimeseriesData&>(data).WriteTo( destination );
                break;
            case Kind::RadarSaveSettingsTimeseries:
                static_cast<const RadarSaveSettingsTimeseriesData&>(data).WriteTo( destination );
                break;
            case Kind::RadarTrackingTimeseries:
                static_cast<const RadarTrackingTimeseriesData&>(data).WriteTo( destination );
                break;
            case Kind::MediaProxySessionEnabledTimeseries:
                static_cast<const MediaProxySessionEnabledTimeseriesData&>(data).WriteTo( destination );
                break;
            case Kind::MediaServiceEnabledTimeseries:
                static_cast<const MediaServiceEnabledTimeseriesData&>(data).WriteTo( destination );
                break;
            case Kind::ByteTimeseries:
                static_cast<const ByteTimeseriesData&>(data).WriteTo( destination );
                break;
            case Kind::DateTimeTimeseries:
                static_cast<const DateTimeTimeseriesData&>(data).WriteTo( destination );
                break;
            case Kind::DoubleTimeseries:
                static_cast<const DoubleTimeseriesData&>(data).WriteTo( destination );
                break;
            case Kind::GNSSAltitudeTimeseries:
                static_cast<const GNSSAltitudeTimeseriesData&>(data).WriteTo( destination );
                break;
            case Kind::GNSSLatitudeTimeseries:
                static_cast<const GNSSLatitudeTimeseriesData&>(data).WriteTo( destination );
                break;
            case Kind::GNSSLongitudeTimeseries:
                static_cast<const GNSSLongitudeTimeseriesData&>(data).WriteTo( destination );
                break;
            case Kind::GyroCourseTimeseries:
                static_cast<const GyroCourseTimeseriesData&>(data).WriteTo( destination );
                break;
            case Kind::GyroHeadingMagneticNorthTimeseries:
                static_cast<const GyroHeadingMagneticNorthTimeseriesData&>(data).WriteTo( destination );
                break;
            case Kind::GyroHeadingTrueNorthTimeseries:
                static_cast<const GyroHeadingTrueNorthTimeseriesData&>(data).WriteTo( destination );
                break;
            case Kind::GyroPitchTimeseries:
                static_cast<const GyroPitchTimeseriesData&>(data).WriteTo( destination );
                break;
            case Kind::GyroRateOfTurnTimeseries:
                static_cast<const GyroRateOfTurnTimeseriesData&>(data).WriteTo( destination );
                break;
            case Kind::GyroRollTimeseries:
                static_cast<const GyroRollTimeseriesData&>(data).WriteTo( destination );
                break;
            case Kind::GyroSpeedTimeseries:
                static_cast<const GyroSpeedTimeseriesData&>(data).WriteTo( destination );
                break;
            case Kind::RadarLatitudeTimeseries:
                static_cast<const RadarLatitudeTimeseriesData&>(data).WriteTo( destination );
                break;
            case Kind::RadarLongitudeTimeseries:
                static_cast<const RadarLongitudeTimeseriesData&>(data).WriteTo( destination );
                break;
            case Kind::RadomeDewPointTimeseries:
                static_cast<const RadomeDewPointTimeseriesData&>(data).WriteTo( destination );
                break;
            case Kind::RadomePressureTimeseries:
                static_cast<const RadomePressureTimeseriesData&>(data).WriteTo( destination );
                break;
            case Kind::RadomeTemperatureTimeseries:
                static_cast<const RadomeTemperatureTimeseriesData&>(data).WriteTo( destination );
                break;
            case Kind::VesselDraughtTimeseries:
                static_cast<const VesselDraughtTimeseriesData&>(data).WriteTo( destination );
                break;
            case Kind::ViewLatitudeTimeseries:
                static_cast<const ViewLatitudeTimeseriesData&>(data).WriteTo( destination );
                break;
            case Kind::ViewLongitudeTimeseries:
                static_cast<const ViewLongitudeTimeseriesData&>(data).WriteTo( destination );
                break;
            case Kind::ViewZoomLevelTimeseries:
                static_cast<const ViewZoomLevelTimeseriesData&>(data).WriteTo( destination );
                break;
            case Kind::WeatherStationAbsoluteHumidityTimeseries:
                static_cast<const WeatherStationAbsoluteHumidityTimeseriesData&>(data).WriteTo( destination );
                break;
            case Kind::WeatherStationAirTemperatureTimeseries:
                static_cast<const WeatherStationAirTemperatureTimeseriesData&>(data).WriteTo( destination );
                break;
            case Kind::WeatherStationBarometricPressureTimeseries:
                static_cast<const WeatherStationBarometricPressureTimeseriesData&>(data).WriteTo( destination );
                break;
            case Kind::WeatherStationDewPointTimeseries:
                static_cast<const WeatherStationDewPointTimeseriesData&>(data).WriteTo( destination );
                break;
            case Kind::WeatherStationRelativeHumidityTimeseries:
                static_cast<const WeatherStationRelativeHumidityTimeseriesData&>(data).WriteTo( destination );
                break;
            case Kind::WeatherStationWaterTemperatureTimeseries:
                static_cast<const WeatherStationWaterTemperatureTimeseriesData&>(data).WriteTo( destination );
                break;
            case Kind::WeatherStationWindDirectionTimeseries:
                static_cast<const WeatherStationWindDirectionTimeseriesData&>(data).WriteTo( destination );
                break;
            case Kind::WeatherStationWindSpeedTimeseries:
                static_cast<const WeatherStationWindSpeedTimeseriesData&>(data).WriteTo( destination );
                break;
            case Kind::GeoPosition2DTimeseries:
                static_cast<const GeoPosition2DTimeseriesData&>(data).WriteTo( destination );
                break;
            case Kind::AisAidToNavigationPositionTimeseries:
                static_cast<const AisAidToNavigationPositionTimeseriesData&>(data).WriteTo( destination );
                break;
            case Kind::GeoPosition3DTimeseries:
                static_cast<const GeoPosition3DTimeseriesData&>(data).WriteTo( destination );
                break;
            case Kind::GuidTimeseries:
                static_cast<const GuidTimeseriesData&>(data).WriteTo( destination );
                break;
            case Kind::Int16Timeseries:
                static_cast<const Int16TimeseriesData&>(data).WriteTo( destination );
                break;
            case Kind::Int32Timeseries:
                static_cast<const Int32TimeseriesData&>(data).WriteTo( destination );
                break;
            case Kind::RadarAzimuthOffsetTimeseries:
                static_cast<const RadarAzimuthOffsetTimeseriesData&>(data).WriteTo( destination );
                break;
            case Kind::RadarFastTimeConstantLevelTimeseries:
                static_cast<const RadarFastTimeConstantLevelTimeseriesData&>(data).WriteTo( destination );
                break;
            case Kind::RadarFastTimeConstantModeTimeseries:
                static_cast<const RadarFastTimeConstantModeTimeseriesData&>(data).WriteTo( destination );
                break;
            case Kind::RadarPulseTimeseries:
                static_cast<const RadarPulseTimeseriesData&>(data).WriteTo( destination );
                break;
            case Kind::RadarSector1EndTimeseries:
                static_cast<const RadarSector1EndTimeseriesData&>(data).WriteTo( destination );
                break;
            case Kind::RadarSector1StartTimeseries:
                static_cast<const RadarSector1StartTimeseriesData&>(data).WriteTo( destination );
                break;
            case Kind::RadarSector2EndTimeseries:
                static_cast<const RadarSector2EndTimeseriesData&>(data).WriteTo( destination );
                break;
            case Kind::RadarSector2StartTimeseries:
                static_cast<const RadarSector2StartTimeseriesData&>(data).WriteTo( destination );
                break;
            case Kind::RadarSensitivityTimeControlLevelTimeseries:
                static_cast<const RadarSensitivityTimeControlLevelTimeseriesData&>(data).WriteTo( destination );
                break;
            case Kind::RadarTuningTimeseries:
                static_cast<const RadarTuningTimeseriesData&>(data).WriteTo( destination );
                break;
            case Kind::VesselPersonsOnBoardTimeseries:
                static_cast<const VesselPersonsOnBoardTimeseriesData&>(data).WriteTo( destination );
                break;
            case Kind::Int64Timeseries:
                static_cast<const Int64TimeseriesData&>(data).WriteTo( destination );
                break;
            case Kind::Position2DTimeseries:
                static_cast<const Position2DTimeseriesData&>(data).WriteTo( destination );
                break;
            case Kind::Position3DTimeseries:
                static_cast<const Position3DTimeseriesData&>(data).WriteTo( destination );
                break;
            case Kind::ReferenceTimeseries:
                static_cast<const ReferenceTimeseriesData&>(data).WriteTo( destination );
                break;
            case Kind::SByteTimeseries:
                static_cast<const SByteTimeseriesData&>(data).WriteTo( destination );
                break;
            case Kind::SingleTimeseries:
                static_cast<const SingleTimeseriesData&>(data).WriteTo( destination );
                break;
            case Kind::StringTimeseries:
                static_cast<const StringTimeseriesData&>(data).WriteTo( destination );
                break;
            case Kind::TimeSpanTimeseries:
                static_cast<const TimeSpanTimeseriesData&>(data).WriteTo( destination );
                break;
            case Kind::UInt16Timeseries:
                static_cast<const UInt16TimeseriesData&>(data).WriteTo( destination );
                break;
            case Kind::UInt32Timeseries:
                static_cast<const UInt32TimeseriesData&>(data).WriteTo( destination );
                break;
            case Kind::RadomeStatusTimeseries:
                static_cast<const RadomeStatusTimeseriesData&>(data).WriteTo( destination );
                break;
            case Kind::UInt64Timeseries:
                static_cast<const UInt64TimeseriesData&>(data).WriteTo( destination );
                break;
            case Kind::TimeseriesCatalog:
                static_cast<const TimeseriesCatalogData&>(data).WriteTo( destination );
                break;
            case Kind::TimeseriesInfo:
                static_cast<const TimeseriesInfoData&>(data).WriteTo( destination );
                break;
            case Kind::TimeSpanTimeseriesValue:
                static_cast<const TimeSpanTimeseriesValueData&>(data).WriteTo( destination );
                break;
            case Kind::TrackableItemTrackLink:
                static_cast<const TrackableItemTrackLinkData&>(data).WriteTo( destination );
                break;
            case Kind::Track:
                static_cast<const TrackData&>(data).WriteTo( destination );
                break;
            case Kind::Track3D:
                static_cast<const Track3DData&>(data).WriteTo( destination );
                break;
            case Kind::TrackerFilterParameters:
                static_cast<const TrackerFilterParametersData&>(data).WriteTo( destination );
                break;
            case Kind::TrackerFilterParametersConfiguration:
                static_cast<const TrackerFilterParametersConfigurationData&>(data).WriteTo( destination );
                break;
            case Kind::TrackInfo:
                static_cast<const TrackInfoData&>(data).WriteTo( destination );
                break;
            case Kind::TrackingServiceOptions:
                static_cast<const TrackingServiceOptionsData&>(data).WriteTo( destination );
                break;
            case Kind::TrackLink:
                static_cast<const TrackLinkData&>(data).WriteTo( destination );
                break;
            case Kind::TrackValue:
                static_cast<const TrackValueData&>(data).WriteTo( destination );
                break;
            case Kind::TrackValue3D:
                static_cast<const TrackValue3DData&>(data).WriteTo( destination );
                break;
            case Kind::UInt16TimeseriesValue:
                static_cast<const UInt16TimeseriesValueData&>(data).WriteTo( destination );
                break;
            case Kind::UInt32TimeseriesValue:
                static_cast<const UInt32TimeseriesValueData&>(data).WriteTo( destination );
                break;
            case Kind::UInt64TimeseriesValue:
                static_cast<const UInt64TimeseriesValueData&>(data).WriteTo( destination );
                break;
            case Kind::VehicleType:
                static_cast<const VehicleTypeData&>(data).WriteTo( destination );
                break;
            case Kind::VesselType:
                static_cast<const VesselTypeData&>(data).WriteTo( destination );
                break;
            case Kind::View:
                static_cast<const ViewData&>(data).WriteTo( destination );
                break;
            case Kind::ViewCameraLink:
                static_cast<const ViewCameraLinkData&>(data).WriteTo( destination );
                break;
            case Kind::ViewTrackerLink:
                static_cast<const ViewTrackerLinkData&>(data).WriteTo( destination );
                break;
            case Kind::WeatherStationCommand:
                static_cast<const WeatherStationCommandData&>(data).WriteTo( destination );
                break;
            case Kind::WeatherStationCommandReply:
                static_cast<const WeatherStationCommandReplyData&>(data).WriteTo( destination );
                break;
            case Kind::WeatherStationConfiguration:
                static_cast<const WeatherStationConfigurationData&>(data).WriteTo( destination );
                break;
            case Kind::CircularZone:
                static_cast<const CircularZoneData&>(data).WriteTo( destination );
                break;
            case Kind::PolygonZone:
                static_cast<const PolygonZoneData&>(data).WriteTo( destination );
                break;
            case Kind::ZoneExceptions:
                static_cast<const ZoneExceptionsData&>(data).WriteTo( destination );
                break;
            case Kind::ZoneExceptionsVesselLink:
                static_cast<const ZoneExceptionsVesselLinkData&>(data).WriteTo( destination );
                break;
            case Kind::ZoneTrackAlarm:
                static_cast<const ZoneTrackAlarmData&>(data).WriteTo( destination );
                break;
        }
    }


}
#endif
