#pragma once
#ifndef DATA_DATATYPES_H_
#define DATA_DATATYPES_H_

#include "Data/Enums.h"
#include <HODBC.h>
#include <HCCData.h>


namespace Barrelman::Data
{
    using namespace Harlinn;
    using namespace Harlinn::ODBC;
    using namespace Harlinn::Common::Core;

    template<typename ObjectT, typename KeyT>
        requires std::is_enum_v<ObjectT>
    using BaseData = Harlinn::Common::Core::Data::BaseData<ObjectT, KeyT>;

    class AircraftTypeData : public BaseData<Kind, Guid>
    {
    public:
        using Base = BaseData<Kind, Guid>;
        static constexpr Kind KIND = Kind::AircraftType;
    private:
        Int64 rowVersion_ = 0;
        FixedDBWideString<127> name_;
    public:
        AircraftTypeData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(rowVersion_);
            name_.WriteTo( destination );
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(rowVersion_);
            name_.ReadFrom( source );
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<AircraftTypeData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<AircraftTypeData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const AircraftTypeData& >( other );
                if ( dataObject.rowVersion_ != rowVersion_ )
                {
                    return false;
                }
                if ( dataObject.name_ != name_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
    };
    class AisMessageData : public BaseData<Kind, Guid>
    {
    public:
        using Base = BaseData<Kind, Guid>;
        static constexpr Kind KIND = Kind::AisMessage;
    private:
        Int64 rowVersion_ = 0;
        Guid aisTransceiver_;
        DateTime receivedTimestamp_;
        Int64 messageSequenceNumber_ = 0;
        Int32 repeat_ = 0;
        Guid mmsi_;
    public:
        AisMessageData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(rowVersion_);
            destination.Write(aisTransceiver_);
            destination.Write(receivedTimestamp_);
            destination.Write(messageSequenceNumber_);
            destination.Write(repeat_);
            destination.Write(mmsi_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(rowVersion_);
            source.Read(aisTransceiver_);
            source.Read(receivedTimestamp_);
            source.Read(messageSequenceNumber_);
            source.Read(repeat_);
            source.Read(mmsi_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<AisMessageData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<AisMessageData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const AisMessageData& >( other );
                if ( dataObject.rowVersion_ != rowVersion_ )
                {
                    return false;
                }
                if ( dataObject.aisTransceiver_ != aisTransceiver_ )
                {
                    return false;
                }
                if ( dataObject.receivedTimestamp_ != receivedTimestamp_ )
                {
                    return false;
                }
                if ( dataObject.messageSequenceNumber_ != messageSequenceNumber_ )
                {
                    return false;
                }
                if ( dataObject.repeat_ != repeat_ )
                {
                    return false;
                }
                if ( dataObject.mmsi_ != mmsi_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
    };
    class AidToNavigationReportMessageData : public AisMessageData
    {
    public:
        using Base = AisMessageData;
        static constexpr Kind KIND = Kind::AidToNavigationReportMessage;
    private:
        Data::NavigationalAidType navigationalAidType_ = Data::NavigationalAidType::NotSpecified;
        FixedDBWideString<100> name_;
        Data::PositionAccuracy positionAccuracy_ = Data::PositionAccuracy::Low;
        double longitude_ = 0.0;
        double latitude_ = 0.0;
        Int32 dimensionToBow_ = 0;
        Int32 dimensionToStern_ = 0;
        Int32 dimensionToPort_ = 0;
        Int32 dimensionToStarboard_ = 0;
        Data::PositionFixType positionFixType_ = Data::PositionFixType::Undefined1;
        Int32 timestamp_ = 0;
        bool offPosition_ = false;
        Int32 regionalReserved_ = 0;
        Data::Raim raim_ = Data::Raim::NotInUse;
        bool virtualAid_ = false;
        bool assigned_ = false;
        Int32 spare_ = 0;
        FixedDBWideString<100> nameExtension_;
    public:
        AidToNavigationReportMessageData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(navigationalAidType_);
            name_.WriteTo( destination );
            destination.Write(positionAccuracy_);
            destination.Write(longitude_);
            destination.Write(latitude_);
            destination.Write(dimensionToBow_);
            destination.Write(dimensionToStern_);
            destination.Write(dimensionToPort_);
            destination.Write(dimensionToStarboard_);
            destination.Write(positionFixType_);
            destination.Write(timestamp_);
            destination.Write(offPosition_);
            destination.Write(regionalReserved_);
            destination.Write(raim_);
            destination.Write(virtualAid_);
            destination.Write(assigned_);
            destination.Write(spare_);
            nameExtension_.WriteTo( destination );
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(navigationalAidType_);
            name_.ReadFrom( source );
            source.Read(positionAccuracy_);
            source.Read(longitude_);
            source.Read(latitude_);
            source.Read(dimensionToBow_);
            source.Read(dimensionToStern_);
            source.Read(dimensionToPort_);
            source.Read(dimensionToStarboard_);
            source.Read(positionFixType_);
            source.Read(timestamp_);
            source.Read(offPosition_);
            source.Read(regionalReserved_);
            source.Read(raim_);
            source.Read(virtualAid_);
            source.Read(assigned_);
            source.Read(spare_);
            nameExtension_.ReadFrom( source );
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<AidToNavigationReportMessageData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<AidToNavigationReportMessageData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const AidToNavigationReportMessageData& >( other );
                if ( dataObject.navigationalAidType_ != navigationalAidType_ )
                {
                    return false;
                }
                if ( dataObject.name_ != name_ )
                {
                    return false;
                }
                if ( dataObject.positionAccuracy_ != positionAccuracy_ )
                {
                    return false;
                }
                if ( dataObject.longitude_ != longitude_ )
                {
                    return false;
                }
                if ( dataObject.latitude_ != latitude_ )
                {
                    return false;
                }
                if ( dataObject.dimensionToBow_ != dimensionToBow_ )
                {
                    return false;
                }
                if ( dataObject.dimensionToStern_ != dimensionToStern_ )
                {
                    return false;
                }
                if ( dataObject.dimensionToPort_ != dimensionToPort_ )
                {
                    return false;
                }
                if ( dataObject.dimensionToStarboard_ != dimensionToStarboard_ )
                {
                    return false;
                }
                if ( dataObject.positionFixType_ != positionFixType_ )
                {
                    return false;
                }
                if ( dataObject.timestamp_ != timestamp_ )
                {
                    return false;
                }
                if ( dataObject.offPosition_ != offPosition_ )
                {
                    return false;
                }
                if ( dataObject.regionalReserved_ != regionalReserved_ )
                {
                    return false;
                }
                if ( dataObject.raim_ != raim_ )
                {
                    return false;
                }
                if ( dataObject.virtualAid_ != virtualAid_ )
                {
                    return false;
                }
                if ( dataObject.assigned_ != assigned_ )
                {
                    return false;
                }
                if ( dataObject.spare_ != spare_ )
                {
                    return false;
                }
                if ( dataObject.nameExtension_ != nameExtension_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
    };
    class AisAddressedSafetyRelatedMessageData : public AisMessageData
    {
    public:
        using Base = AisMessageData;
        static constexpr Kind KIND = Kind::AisAddressedSafetyRelatedMessage;
    private:
        Int32 sequenceNumber_ = 0;
        Guid destinationMmsi_;
        bool retransmitFlag_ = false;
        Int32 spare_ = 0;
        FixedDBWideString<100> text_;
    public:
        AisAddressedSafetyRelatedMessageData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(sequenceNumber_);
            destination.Write(destinationMmsi_);
            destination.Write(retransmitFlag_);
            destination.Write(spare_);
            text_.WriteTo( destination );
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(sequenceNumber_);
            source.Read(destinationMmsi_);
            source.Read(retransmitFlag_);
            source.Read(spare_);
            text_.ReadFrom( source );
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<AisAddressedSafetyRelatedMessageData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<AisAddressedSafetyRelatedMessageData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const AisAddressedSafetyRelatedMessageData& >( other );
                if ( dataObject.sequenceNumber_ != sequenceNumber_ )
                {
                    return false;
                }
                if ( dataObject.destinationMmsi_ != destinationMmsi_ )
                {
                    return false;
                }
                if ( dataObject.retransmitFlag_ != retransmitFlag_ )
                {
                    return false;
                }
                if ( dataObject.spare_ != spare_ )
                {
                    return false;
                }
                if ( dataObject.text_ != text_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
    };
    class AisBaseStationReportMessageData : public AisMessageData
    {
    public:
        using Base = AisMessageData;
        static constexpr Kind KIND = Kind::AisBaseStationReportMessage;
    private:
        DateTime timestamp_;
        Data::PositionAccuracy positionAccuracy_ = Data::PositionAccuracy::Low;
        double longitude_ = 0.0;
        double latitude_ = 0.0;
        Data::PositionFixType positionFixType_ = Data::PositionFixType::Undefined1;
        Int32 spare_ = 0;
        Data::Raim raim_ = Data::Raim::NotInUse;
        Int32 radioStatus_ = 0;
    public:
        AisBaseStationReportMessageData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(timestamp_);
            destination.Write(positionAccuracy_);
            destination.Write(longitude_);
            destination.Write(latitude_);
            destination.Write(positionFixType_);
            destination.Write(spare_);
            destination.Write(raim_);
            destination.Write(radioStatus_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(timestamp_);
            source.Read(positionAccuracy_);
            source.Read(longitude_);
            source.Read(latitude_);
            source.Read(positionFixType_);
            source.Read(spare_);
            source.Read(raim_);
            source.Read(radioStatus_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<AisBaseStationReportMessageData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<AisBaseStationReportMessageData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const AisBaseStationReportMessageData& >( other );
                if ( dataObject.timestamp_ != timestamp_ )
                {
                    return false;
                }
                if ( dataObject.positionAccuracy_ != positionAccuracy_ )
                {
                    return false;
                }
                if ( dataObject.longitude_ != longitude_ )
                {
                    return false;
                }
                if ( dataObject.latitude_ != latitude_ )
                {
                    return false;
                }
                if ( dataObject.positionFixType_ != positionFixType_ )
                {
                    return false;
                }
                if ( dataObject.spare_ != spare_ )
                {
                    return false;
                }
                if ( dataObject.raim_ != raim_ )
                {
                    return false;
                }
                if ( dataObject.radioStatus_ != radioStatus_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
    };
    class AisBinaryAcknowledgeMessageData : public AisMessageData
    {
    public:
        using Base = AisMessageData;
        static constexpr Kind KIND = Kind::AisBinaryAcknowledgeMessage;
    private:
        Int32 spare_ = 0;
        Int32 sequenceNumber1_ = 0;
        Guid mmsi1_;
        Int32 sequenceNumber2_ = 0;
        Guid mmsi2_;
        Int32 sequenceNumber3_ = 0;
        Guid mmsi3_;
        Int32 sequenceNumber4_ = 0;
        Guid mmsi4_;
    public:
        AisBinaryAcknowledgeMessageData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(spare_);
            destination.Write(sequenceNumber1_);
            destination.Write(mmsi1_);
            destination.Write(sequenceNumber2_);
            destination.Write(mmsi2_);
            destination.Write(sequenceNumber3_);
            destination.Write(mmsi3_);
            destination.Write(sequenceNumber4_);
            destination.Write(mmsi4_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(spare_);
            source.Read(sequenceNumber1_);
            source.Read(mmsi1_);
            source.Read(sequenceNumber2_);
            source.Read(mmsi2_);
            source.Read(sequenceNumber3_);
            source.Read(mmsi3_);
            source.Read(sequenceNumber4_);
            source.Read(mmsi4_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<AisBinaryAcknowledgeMessageData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<AisBinaryAcknowledgeMessageData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const AisBinaryAcknowledgeMessageData& >( other );
                if ( dataObject.spare_ != spare_ )
                {
                    return false;
                }
                if ( dataObject.sequenceNumber1_ != sequenceNumber1_ )
                {
                    return false;
                }
                if ( dataObject.mmsi1_ != mmsi1_ )
                {
                    return false;
                }
                if ( dataObject.sequenceNumber2_ != sequenceNumber2_ )
                {
                    return false;
                }
                if ( dataObject.mmsi2_ != mmsi2_ )
                {
                    return false;
                }
                if ( dataObject.sequenceNumber3_ != sequenceNumber3_ )
                {
                    return false;
                }
                if ( dataObject.mmsi3_ != mmsi3_ )
                {
                    return false;
                }
                if ( dataObject.sequenceNumber4_ != sequenceNumber4_ )
                {
                    return false;
                }
                if ( dataObject.mmsi4_ != mmsi4_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
    };
    class AisBinaryAddressedMessageData : public AisMessageData
    {
    public:
        using Base = AisMessageData;
        static constexpr Kind KIND = Kind::AisBinaryAddressedMessage;
    private:
        Int32 sequenceNumber_ = 0;
        Guid destinationMmsi_;
        bool retransmitFlag_ = false;
        Int32 spare_ = 0;
        Int32 designatedAreaCode_ = 0;
        Int32 functionalId_ = 0;
        WideString data_;
        SQLLEN dataLength_ = SQL_NULL_DATA;
    public:
        AisBinaryAddressedMessageData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(sequenceNumber_);
            destination.Write(destinationMmsi_);
            destination.Write(retransmitFlag_);
            destination.Write(spare_);
            destination.Write(designatedAreaCode_);
            destination.Write(functionalId_);
            destination.Write(data_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(sequenceNumber_);
            source.Read(destinationMmsi_);
            source.Read(retransmitFlag_);
            source.Read(spare_);
            source.Read(designatedAreaCode_);
            source.Read(functionalId_);
            source.Read(data_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<AisBinaryAddressedMessageData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<AisBinaryAddressedMessageData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const AisBinaryAddressedMessageData& >( other );
                if ( dataObject.sequenceNumber_ != sequenceNumber_ )
                {
                    return false;
                }
                if ( dataObject.destinationMmsi_ != destinationMmsi_ )
                {
                    return false;
                }
                if ( dataObject.retransmitFlag_ != retransmitFlag_ )
                {
                    return false;
                }
                if ( dataObject.spare_ != spare_ )
                {
                    return false;
                }
                if ( dataObject.designatedAreaCode_ != designatedAreaCode_ )
                {
                    return false;
                }
                if ( dataObject.functionalId_ != functionalId_ )
                {
                    return false;
                }
                if ( dataObject.data_ != data_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
    };
    class AisBinaryBroadcastMessageData : public AisMessageData
    {
    public:
        using Base = AisMessageData;
        static constexpr Kind KIND = Kind::AisBinaryBroadcastMessage;
    private:
        Int32 spare_ = 0;
        Int32 designatedAreaCode_ = 0;
        Int32 functionalId_ = 0;
        WideString data_;
        SQLLEN dataLength_ = SQL_NULL_DATA;
    public:
        AisBinaryBroadcastMessageData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(spare_);
            destination.Write(designatedAreaCode_);
            destination.Write(functionalId_);
            destination.Write(data_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(spare_);
            source.Read(designatedAreaCode_);
            source.Read(functionalId_);
            source.Read(data_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<AisBinaryBroadcastMessageData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<AisBinaryBroadcastMessageData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const AisBinaryBroadcastMessageData& >( other );
                if ( dataObject.spare_ != spare_ )
                {
                    return false;
                }
                if ( dataObject.designatedAreaCode_ != designatedAreaCode_ )
                {
                    return false;
                }
                if ( dataObject.functionalId_ != functionalId_ )
                {
                    return false;
                }
                if ( dataObject.data_ != data_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
    };
    class AisDataLinkManagementMessageData : public AisMessageData
    {
    public:
        using Base = AisMessageData;
        static constexpr Kind KIND = Kind::AisDataLinkManagementMessage;
    private:
        Int32 spare_ = 0;
        Int32 offset1_ = 0;
        Int32 reservedSlots1_ = 0;
        Int32 timeout1_ = 0;
        Int32 increment1_ = 0;
        Int32 offset2_ = 0;
        Int32 reservedSlots2_ = 0;
        Int32 timeout2_ = 0;
        Int32 increment2_ = 0;
        Int32 offset3_ = 0;
        Int32 reservedSlots3_ = 0;
        Int32 timeout3_ = 0;
        Int32 increment3_ = 0;
        Int32 offset4_ = 0;
        Int32 reservedSlots4_ = 0;
        Int32 timeout4_ = 0;
        Int32 increment4_ = 0;
    public:
        AisDataLinkManagementMessageData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(spare_);
            destination.Write(offset1_);
            destination.Write(reservedSlots1_);
            destination.Write(timeout1_);
            destination.Write(increment1_);
            destination.Write(offset2_);
            destination.Write(reservedSlots2_);
            destination.Write(timeout2_);
            destination.Write(increment2_);
            destination.Write(offset3_);
            destination.Write(reservedSlots3_);
            destination.Write(timeout3_);
            destination.Write(increment3_);
            destination.Write(offset4_);
            destination.Write(reservedSlots4_);
            destination.Write(timeout4_);
            destination.Write(increment4_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(spare_);
            source.Read(offset1_);
            source.Read(reservedSlots1_);
            source.Read(timeout1_);
            source.Read(increment1_);
            source.Read(offset2_);
            source.Read(reservedSlots2_);
            source.Read(timeout2_);
            source.Read(increment2_);
            source.Read(offset3_);
            source.Read(reservedSlots3_);
            source.Read(timeout3_);
            source.Read(increment3_);
            source.Read(offset4_);
            source.Read(reservedSlots4_);
            source.Read(timeout4_);
            source.Read(increment4_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<AisDataLinkManagementMessageData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<AisDataLinkManagementMessageData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const AisDataLinkManagementMessageData& >( other );
                if ( dataObject.spare_ != spare_ )
                {
                    return false;
                }
                if ( dataObject.offset1_ != offset1_ )
                {
                    return false;
                }
                if ( dataObject.reservedSlots1_ != reservedSlots1_ )
                {
                    return false;
                }
                if ( dataObject.timeout1_ != timeout1_ )
                {
                    return false;
                }
                if ( dataObject.increment1_ != increment1_ )
                {
                    return false;
                }
                if ( dataObject.offset2_ != offset2_ )
                {
                    return false;
                }
                if ( dataObject.reservedSlots2_ != reservedSlots2_ )
                {
                    return false;
                }
                if ( dataObject.timeout2_ != timeout2_ )
                {
                    return false;
                }
                if ( dataObject.increment2_ != increment2_ )
                {
                    return false;
                }
                if ( dataObject.offset3_ != offset3_ )
                {
                    return false;
                }
                if ( dataObject.reservedSlots3_ != reservedSlots3_ )
                {
                    return false;
                }
                if ( dataObject.timeout3_ != timeout3_ )
                {
                    return false;
                }
                if ( dataObject.increment3_ != increment3_ )
                {
                    return false;
                }
                if ( dataObject.offset4_ != offset4_ )
                {
                    return false;
                }
                if ( dataObject.reservedSlots4_ != reservedSlots4_ )
                {
                    return false;
                }
                if ( dataObject.timeout4_ != timeout4_ )
                {
                    return false;
                }
                if ( dataObject.increment4_ != increment4_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
    };
    class AisExtendedClassBCsPositionReportMessageData : public AisMessageData
    {
    public:
        using Base = AisMessageData;
        static constexpr Kind KIND = Kind::AisExtendedClassBCsPositionReportMessage;
    private:
        Int32 reserved_ = 0;
        double speedOverGround_ = 0.0;
        Data::PositionAccuracy positionAccuracy_ = Data::PositionAccuracy::Low;
        double longitude_ = 0.0;
        double latitude_ = 0.0;
        double courseOverGround_ = 0.0;
        DBInt32 trueHeading_;
        Int32 timestamp_ = 0;
        Int32 regionalReserved_ = 0;
        Guid name_;
        Data::ShipType shipType_ = Data::ShipType::NotAvailable;
        Int32 dimensionToBow_ = 0;
        Int32 dimensionToStern_ = 0;
        Int32 dimensionToPort_ = 0;
        Int32 dimensionToStarboard_ = 0;
        Data::PositionFixType positionFixType_ = Data::PositionFixType::Undefined1;
        Data::Raim raim_ = Data::Raim::NotInUse;
        bool dataTerminalReady_ = false;
        bool assigned_ = false;
        Int32 spare_ = 0;
    public:
        AisExtendedClassBCsPositionReportMessageData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(reserved_);
            destination.Write(speedOverGround_);
            destination.Write(positionAccuracy_);
            destination.Write(longitude_);
            destination.Write(latitude_);
            destination.Write(courseOverGround_);
            trueHeading_.WriteTo( destination );
            destination.Write(timestamp_);
            destination.Write(regionalReserved_);
            destination.Write(name_);
            destination.Write(shipType_);
            destination.Write(dimensionToBow_);
            destination.Write(dimensionToStern_);
            destination.Write(dimensionToPort_);
            destination.Write(dimensionToStarboard_);
            destination.Write(positionFixType_);
            destination.Write(raim_);
            destination.Write(dataTerminalReady_);
            destination.Write(assigned_);
            destination.Write(spare_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(reserved_);
            source.Read(speedOverGround_);
            source.Read(positionAccuracy_);
            source.Read(longitude_);
            source.Read(latitude_);
            source.Read(courseOverGround_);
            trueHeading_.ReadFrom( source );
            source.Read(timestamp_);
            source.Read(regionalReserved_);
            source.Read(name_);
            source.Read(shipType_);
            source.Read(dimensionToBow_);
            source.Read(dimensionToStern_);
            source.Read(dimensionToPort_);
            source.Read(dimensionToStarboard_);
            source.Read(positionFixType_);
            source.Read(raim_);
            source.Read(dataTerminalReady_);
            source.Read(assigned_);
            source.Read(spare_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<AisExtendedClassBCsPositionReportMessageData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<AisExtendedClassBCsPositionReportMessageData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const AisExtendedClassBCsPositionReportMessageData& >( other );
                if ( dataObject.reserved_ != reserved_ )
                {
                    return false;
                }
                if ( dataObject.speedOverGround_ != speedOverGround_ )
                {
                    return false;
                }
                if ( dataObject.positionAccuracy_ != positionAccuracy_ )
                {
                    return false;
                }
                if ( dataObject.longitude_ != longitude_ )
                {
                    return false;
                }
                if ( dataObject.latitude_ != latitude_ )
                {
                    return false;
                }
                if ( dataObject.courseOverGround_ != courseOverGround_ )
                {
                    return false;
                }
                if ( dataObject.trueHeading_ != trueHeading_ )
                {
                    return false;
                }
                if ( dataObject.timestamp_ != timestamp_ )
                {
                    return false;
                }
                if ( dataObject.regionalReserved_ != regionalReserved_ )
                {
                    return false;
                }
                if ( dataObject.name_ != name_ )
                {
                    return false;
                }
                if ( dataObject.shipType_ != shipType_ )
                {
                    return false;
                }
                if ( dataObject.dimensionToBow_ != dimensionToBow_ )
                {
                    return false;
                }
                if ( dataObject.dimensionToStern_ != dimensionToStern_ )
                {
                    return false;
                }
                if ( dataObject.dimensionToPort_ != dimensionToPort_ )
                {
                    return false;
                }
                if ( dataObject.dimensionToStarboard_ != dimensionToStarboard_ )
                {
                    return false;
                }
                if ( dataObject.positionFixType_ != positionFixType_ )
                {
                    return false;
                }
                if ( dataObject.raim_ != raim_ )
                {
                    return false;
                }
                if ( dataObject.dataTerminalReady_ != dataTerminalReady_ )
                {
                    return false;
                }
                if ( dataObject.assigned_ != assigned_ )
                {
                    return false;
                }
                if ( dataObject.spare_ != spare_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
    };
    class AisInterrogationMessageData : public AisMessageData
    {
    public:
        using Base = AisMessageData;
        static constexpr Kind KIND = Kind::AisInterrogationMessage;
    private:
        Guid interrogatedMmsi_;
        Data::AisMessageType firstMessageType_ = Data::AisMessageType::PositionReportClassA;
        Int32 firstSlotOffset_ = 0;
        DBEnum<Data::AisMessageType> secondMessageType_;
        DBInt32 secondSlotOffset_;
        Guid secondStationInterrogationMmsi_;
        DBEnum<Data::AisMessageType> secondStationFirstMessageType_;
        DBInt32 secondStationFirstSlotOffset_;
    public:
        AisInterrogationMessageData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(interrogatedMmsi_);
            destination.Write(firstMessageType_);
            destination.Write(firstSlotOffset_);
            secondMessageType_.WriteTo( destination );
            secondSlotOffset_.WriteTo( destination );
            destination.Write(secondStationInterrogationMmsi_);
            secondStationFirstMessageType_.WriteTo( destination );
            secondStationFirstSlotOffset_.WriteTo( destination );
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(interrogatedMmsi_);
            source.Read(firstMessageType_);
            source.Read(firstSlotOffset_);
            secondMessageType_.ReadFrom( source );
            secondSlotOffset_.ReadFrom( source );
            source.Read(secondStationInterrogationMmsi_);
            secondStationFirstMessageType_.ReadFrom( source );
            secondStationFirstSlotOffset_.ReadFrom( source );
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<AisInterrogationMessageData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<AisInterrogationMessageData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const AisInterrogationMessageData& >( other );
                if ( dataObject.interrogatedMmsi_ != interrogatedMmsi_ )
                {
                    return false;
                }
                if ( dataObject.firstMessageType_ != firstMessageType_ )
                {
                    return false;
                }
                if ( dataObject.firstSlotOffset_ != firstSlotOffset_ )
                {
                    return false;
                }
                if ( dataObject.secondMessageType_ != secondMessageType_ )
                {
                    return false;
                }
                if ( dataObject.secondSlotOffset_ != secondSlotOffset_ )
                {
                    return false;
                }
                if ( dataObject.secondStationInterrogationMmsi_ != secondStationInterrogationMmsi_ )
                {
                    return false;
                }
                if ( dataObject.secondStationFirstMessageType_ != secondStationFirstMessageType_ )
                {
                    return false;
                }
                if ( dataObject.secondStationFirstSlotOffset_ != secondStationFirstSlotOffset_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
    };
    class AisPositionReportClassAMessageBaseData : public AisMessageData
    {
    public:
        using Base = AisMessageData;
        static constexpr Kind KIND = Kind::AisPositionReportClassAMessageBase;
    private:
        Data::NavigationStatus navigationStatus_ = Data::NavigationStatus::UnderWayUsingEngine;
        DBInt32 rateOfTurn_;
        double speedOverGround_ = 0.0;
        Data::PositionAccuracy positionAccuracy_ = Data::PositionAccuracy::Low;
        double longitude_ = 0.0;
        double latitude_ = 0.0;
        double courseOverGround_ = 0.0;
        DBInt32 trueHeading_;
        Int32 timestamp_ = 0;
        Data::ManeuverIndicator maneuverIndicator_ = Data::ManeuverIndicator::NotAvailable;
        Int32 spare_ = 0;
        Data::Raim raim_ = Data::Raim::NotInUse;
        Int32 radioStatus_ = 0;
    public:
        AisPositionReportClassAMessageBaseData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(navigationStatus_);
            rateOfTurn_.WriteTo( destination );
            destination.Write(speedOverGround_);
            destination.Write(positionAccuracy_);
            destination.Write(longitude_);
            destination.Write(latitude_);
            destination.Write(courseOverGround_);
            trueHeading_.WriteTo( destination );
            destination.Write(timestamp_);
            destination.Write(maneuverIndicator_);
            destination.Write(spare_);
            destination.Write(raim_);
            destination.Write(radioStatus_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(navigationStatus_);
            rateOfTurn_.ReadFrom( source );
            source.Read(speedOverGround_);
            source.Read(positionAccuracy_);
            source.Read(longitude_);
            source.Read(latitude_);
            source.Read(courseOverGround_);
            trueHeading_.ReadFrom( source );
            source.Read(timestamp_);
            source.Read(maneuverIndicator_);
            source.Read(spare_);
            source.Read(raim_);
            source.Read(radioStatus_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<AisPositionReportClassAMessageBaseData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<AisPositionReportClassAMessageBaseData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const AisPositionReportClassAMessageBaseData& >( other );
                if ( dataObject.navigationStatus_ != navigationStatus_ )
                {
                    return false;
                }
                if ( dataObject.rateOfTurn_ != rateOfTurn_ )
                {
                    return false;
                }
                if ( dataObject.speedOverGround_ != speedOverGround_ )
                {
                    return false;
                }
                if ( dataObject.positionAccuracy_ != positionAccuracy_ )
                {
                    return false;
                }
                if ( dataObject.longitude_ != longitude_ )
                {
                    return false;
                }
                if ( dataObject.latitude_ != latitude_ )
                {
                    return false;
                }
                if ( dataObject.courseOverGround_ != courseOverGround_ )
                {
                    return false;
                }
                if ( dataObject.trueHeading_ != trueHeading_ )
                {
                    return false;
                }
                if ( dataObject.timestamp_ != timestamp_ )
                {
                    return false;
                }
                if ( dataObject.maneuverIndicator_ != maneuverIndicator_ )
                {
                    return false;
                }
                if ( dataObject.spare_ != spare_ )
                {
                    return false;
                }
                if ( dataObject.raim_ != raim_ )
                {
                    return false;
                }
                if ( dataObject.radioStatus_ != radioStatus_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
    };
    class AisPositionReportClassAAssignedScheduleMessageData : public AisPositionReportClassAMessageBaseData
    {
    public:
        using Base = AisPositionReportClassAMessageBaseData;
        static constexpr Kind KIND = Kind::AisPositionReportClassAAssignedScheduleMessage;
    private:
    public:
        AisPositionReportClassAAssignedScheduleMessageData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<AisPositionReportClassAAssignedScheduleMessageData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<AisPositionReportClassAAssignedScheduleMessageData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const AisPositionReportClassAAssignedScheduleMessageData& >( other );
                return true;
            }
            return false;
        }
    };
    class AisPositionReportClassAMessageData : public AisPositionReportClassAMessageBaseData
    {
    public:
        using Base = AisPositionReportClassAMessageBaseData;
        static constexpr Kind KIND = Kind::AisPositionReportClassAMessage;
    private:
    public:
        AisPositionReportClassAMessageData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<AisPositionReportClassAMessageData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<AisPositionReportClassAMessageData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const AisPositionReportClassAMessageData& >( other );
                return true;
            }
            return false;
        }
    };
    class AisPositionReportClassAResponseToInterrogationMessageData : public AisPositionReportClassAMessageBaseData
    {
    public:
        using Base = AisPositionReportClassAMessageBaseData;
        static constexpr Kind KIND = Kind::AisPositionReportClassAResponseToInterrogationMessage;
    private:
    public:
        AisPositionReportClassAResponseToInterrogationMessageData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<AisPositionReportClassAResponseToInterrogationMessageData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<AisPositionReportClassAResponseToInterrogationMessageData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const AisPositionReportClassAResponseToInterrogationMessageData& >( other );
                return true;
            }
            return false;
        }
    };
    class AisPositionReportForLongRangeApplicationsMessageData : public AisMessageData
    {
    public:
        using Base = AisMessageData;
        static constexpr Kind KIND = Kind::AisPositionReportForLongRangeApplicationsMessage;
    private:
        Data::PositionAccuracy positionAccuracy_ = Data::PositionAccuracy::Low;
        Data::Raim raim_ = Data::Raim::NotInUse;
        Data::NavigationStatus navigationStatus_ = Data::NavigationStatus::UnderWayUsingEngine;
        double longitude_ = 0.0;
        double latitude_ = 0.0;
        double speedOverGround_ = 0.0;
        double courseOverGround_ = 0.0;
        Data::GnssPositionStatus gnssPositionStatus_ = Data::GnssPositionStatus::CurrentGnssPosition;
        Int32 spare_ = 0;
    public:
        AisPositionReportForLongRangeApplicationsMessageData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(positionAccuracy_);
            destination.Write(raim_);
            destination.Write(navigationStatus_);
            destination.Write(longitude_);
            destination.Write(latitude_);
            destination.Write(speedOverGround_);
            destination.Write(courseOverGround_);
            destination.Write(gnssPositionStatus_);
            destination.Write(spare_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(positionAccuracy_);
            source.Read(raim_);
            source.Read(navigationStatus_);
            source.Read(longitude_);
            source.Read(latitude_);
            source.Read(speedOverGround_);
            source.Read(courseOverGround_);
            source.Read(gnssPositionStatus_);
            source.Read(spare_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<AisPositionReportForLongRangeApplicationsMessageData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<AisPositionReportForLongRangeApplicationsMessageData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const AisPositionReportForLongRangeApplicationsMessageData& >( other );
                if ( dataObject.positionAccuracy_ != positionAccuracy_ )
                {
                    return false;
                }
                if ( dataObject.raim_ != raim_ )
                {
                    return false;
                }
                if ( dataObject.navigationStatus_ != navigationStatus_ )
                {
                    return false;
                }
                if ( dataObject.longitude_ != longitude_ )
                {
                    return false;
                }
                if ( dataObject.latitude_ != latitude_ )
                {
                    return false;
                }
                if ( dataObject.speedOverGround_ != speedOverGround_ )
                {
                    return false;
                }
                if ( dataObject.courseOverGround_ != courseOverGround_ )
                {
                    return false;
                }
                if ( dataObject.gnssPositionStatus_ != gnssPositionStatus_ )
                {
                    return false;
                }
                if ( dataObject.spare_ != spare_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
    };
    class AisSafetyRelatedAcknowledgmentMessageData : public AisMessageData
    {
    public:
        using Base = AisMessageData;
        static constexpr Kind KIND = Kind::AisSafetyRelatedAcknowledgmentMessage;
    private:
        Int32 spare_ = 0;
        Int32 sequenceNumber1_ = 0;
        Guid mmsi1_;
        Int32 sequenceNumber2_ = 0;
        Guid mmsi2_;
        Int32 sequenceNumber3_ = 0;
        Guid mmsi3_;
        Int32 sequenceNumber4_ = 0;
        Guid mmsi4_;
    public:
        AisSafetyRelatedAcknowledgmentMessageData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(spare_);
            destination.Write(sequenceNumber1_);
            destination.Write(mmsi1_);
            destination.Write(sequenceNumber2_);
            destination.Write(mmsi2_);
            destination.Write(sequenceNumber3_);
            destination.Write(mmsi3_);
            destination.Write(sequenceNumber4_);
            destination.Write(mmsi4_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(spare_);
            source.Read(sequenceNumber1_);
            source.Read(mmsi1_);
            source.Read(sequenceNumber2_);
            source.Read(mmsi2_);
            source.Read(sequenceNumber3_);
            source.Read(mmsi3_);
            source.Read(sequenceNumber4_);
            source.Read(mmsi4_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<AisSafetyRelatedAcknowledgmentMessageData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<AisSafetyRelatedAcknowledgmentMessageData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const AisSafetyRelatedAcknowledgmentMessageData& >( other );
                if ( dataObject.spare_ != spare_ )
                {
                    return false;
                }
                if ( dataObject.sequenceNumber1_ != sequenceNumber1_ )
                {
                    return false;
                }
                if ( dataObject.mmsi1_ != mmsi1_ )
                {
                    return false;
                }
                if ( dataObject.sequenceNumber2_ != sequenceNumber2_ )
                {
                    return false;
                }
                if ( dataObject.mmsi2_ != mmsi2_ )
                {
                    return false;
                }
                if ( dataObject.sequenceNumber3_ != sequenceNumber3_ )
                {
                    return false;
                }
                if ( dataObject.mmsi3_ != mmsi3_ )
                {
                    return false;
                }
                if ( dataObject.sequenceNumber4_ != sequenceNumber4_ )
                {
                    return false;
                }
                if ( dataObject.mmsi4_ != mmsi4_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
    };
    class AisStandardClassBCsPositionReportMessageData : public AisMessageData
    {
    public:
        using Base = AisMessageData;
        static constexpr Kind KIND = Kind::AisStandardClassBCsPositionReportMessage;
    private:
        Int32 reserved_ = 0;
        double speedOverGround_ = 0.0;
        Data::PositionAccuracy positionAccuracy_ = Data::PositionAccuracy::Low;
        double longitude_ = 0.0;
        double latitude_ = 0.0;
        double courseOverGround_ = 0.0;
        DBInt32 trueHeading_;
        Int32 timestamp_ = 0;
        Int32 regionalReserved_ = 0;
        bool isCsUnit_ = false;
        bool hasDisplay_ = false;
        bool hasDscCapability_ = false;
        bool band_ = false;
        bool canAcceptMessage22_ = false;
        bool assigned_ = false;
        Data::Raim raim_ = Data::Raim::NotInUse;
        Int32 radioStatus_ = 0;
    public:
        AisStandardClassBCsPositionReportMessageData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(reserved_);
            destination.Write(speedOverGround_);
            destination.Write(positionAccuracy_);
            destination.Write(longitude_);
            destination.Write(latitude_);
            destination.Write(courseOverGround_);
            trueHeading_.WriteTo( destination );
            destination.Write(timestamp_);
            destination.Write(regionalReserved_);
            destination.Write(isCsUnit_);
            destination.Write(hasDisplay_);
            destination.Write(hasDscCapability_);
            destination.Write(band_);
            destination.Write(canAcceptMessage22_);
            destination.Write(assigned_);
            destination.Write(raim_);
            destination.Write(radioStatus_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(reserved_);
            source.Read(speedOverGround_);
            source.Read(positionAccuracy_);
            source.Read(longitude_);
            source.Read(latitude_);
            source.Read(courseOverGround_);
            trueHeading_.ReadFrom( source );
            source.Read(timestamp_);
            source.Read(regionalReserved_);
            source.Read(isCsUnit_);
            source.Read(hasDisplay_);
            source.Read(hasDscCapability_);
            source.Read(band_);
            source.Read(canAcceptMessage22_);
            source.Read(assigned_);
            source.Read(raim_);
            source.Read(radioStatus_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<AisStandardClassBCsPositionReportMessageData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<AisStandardClassBCsPositionReportMessageData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const AisStandardClassBCsPositionReportMessageData& >( other );
                if ( dataObject.reserved_ != reserved_ )
                {
                    return false;
                }
                if ( dataObject.speedOverGround_ != speedOverGround_ )
                {
                    return false;
                }
                if ( dataObject.positionAccuracy_ != positionAccuracy_ )
                {
                    return false;
                }
                if ( dataObject.longitude_ != longitude_ )
                {
                    return false;
                }
                if ( dataObject.latitude_ != latitude_ )
                {
                    return false;
                }
                if ( dataObject.courseOverGround_ != courseOverGround_ )
                {
                    return false;
                }
                if ( dataObject.trueHeading_ != trueHeading_ )
                {
                    return false;
                }
                if ( dataObject.timestamp_ != timestamp_ )
                {
                    return false;
                }
                if ( dataObject.regionalReserved_ != regionalReserved_ )
                {
                    return false;
                }
                if ( dataObject.isCsUnit_ != isCsUnit_ )
                {
                    return false;
                }
                if ( dataObject.hasDisplay_ != hasDisplay_ )
                {
                    return false;
                }
                if ( dataObject.hasDscCapability_ != hasDscCapability_ )
                {
                    return false;
                }
                if ( dataObject.band_ != band_ )
                {
                    return false;
                }
                if ( dataObject.canAcceptMessage22_ != canAcceptMessage22_ )
                {
                    return false;
                }
                if ( dataObject.assigned_ != assigned_ )
                {
                    return false;
                }
                if ( dataObject.raim_ != raim_ )
                {
                    return false;
                }
                if ( dataObject.radioStatus_ != radioStatus_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
    };
    class AisStandardSarAircraftPositionReportMessageData : public AisMessageData
    {
    public:
        using Base = AisMessageData;
        static constexpr Kind KIND = Kind::AisStandardSarAircraftPositionReportMessage;
    private:
        Int32 altitude_ = 0;
        Int32 speedOverGround_ = 0;
        Data::PositionAccuracy positionAccuracy_ = Data::PositionAccuracy::Low;
        double longitude_ = 0.0;
        double latitude_ = 0.0;
        double courseOverGround_ = 0.0;
        Int32 timestamp_ = 0;
        Int32 reserved_ = 0;
        bool dataTerminalReady_ = false;
        Int32 spare_ = 0;
        bool assigned_ = false;
        Data::Raim raim_ = Data::Raim::NotInUse;
        Int32 radioStatus_ = 0;
    public:
        AisStandardSarAircraftPositionReportMessageData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(altitude_);
            destination.Write(speedOverGround_);
            destination.Write(positionAccuracy_);
            destination.Write(longitude_);
            destination.Write(latitude_);
            destination.Write(courseOverGround_);
            destination.Write(timestamp_);
            destination.Write(reserved_);
            destination.Write(dataTerminalReady_);
            destination.Write(spare_);
            destination.Write(assigned_);
            destination.Write(raim_);
            destination.Write(radioStatus_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(altitude_);
            source.Read(speedOverGround_);
            source.Read(positionAccuracy_);
            source.Read(longitude_);
            source.Read(latitude_);
            source.Read(courseOverGround_);
            source.Read(timestamp_);
            source.Read(reserved_);
            source.Read(dataTerminalReady_);
            source.Read(spare_);
            source.Read(assigned_);
            source.Read(raim_);
            source.Read(radioStatus_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<AisStandardSarAircraftPositionReportMessageData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<AisStandardSarAircraftPositionReportMessageData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const AisStandardSarAircraftPositionReportMessageData& >( other );
                if ( dataObject.altitude_ != altitude_ )
                {
                    return false;
                }
                if ( dataObject.speedOverGround_ != speedOverGround_ )
                {
                    return false;
                }
                if ( dataObject.positionAccuracy_ != positionAccuracy_ )
                {
                    return false;
                }
                if ( dataObject.longitude_ != longitude_ )
                {
                    return false;
                }
                if ( dataObject.latitude_ != latitude_ )
                {
                    return false;
                }
                if ( dataObject.courseOverGround_ != courseOverGround_ )
                {
                    return false;
                }
                if ( dataObject.timestamp_ != timestamp_ )
                {
                    return false;
                }
                if ( dataObject.reserved_ != reserved_ )
                {
                    return false;
                }
                if ( dataObject.dataTerminalReady_ != dataTerminalReady_ )
                {
                    return false;
                }
                if ( dataObject.spare_ != spare_ )
                {
                    return false;
                }
                if ( dataObject.assigned_ != assigned_ )
                {
                    return false;
                }
                if ( dataObject.raim_ != raim_ )
                {
                    return false;
                }
                if ( dataObject.radioStatus_ != radioStatus_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
    };
    class AisStaticAndVoyageRelatedDataMessageData : public AisMessageData
    {
    public:
        using Base = AisMessageData;
        static constexpr Kind KIND = Kind::AisStaticAndVoyageRelatedDataMessage;
    private:
        Int32 aisVersion_ = 0;
        Guid imoNumber_;
        Guid callsign_;
        Guid shipName_;
        Data::ShipType shipType_ = Data::ShipType::NotAvailable;
        Int32 dimensionToBow_ = 0;
        Int32 dimensionToStern_ = 0;
        Int32 dimensionToPort_ = 0;
        Int32 dimensionToStarboard_ = 0;
        Data::PositionFixType positionFixType_ = Data::PositionFixType::Undefined1;
        DBDateTime estimatedTimeOfArrival_;
        double draught_ = 0.0;
        FixedDBWideString<100> destination_;
        bool dataTerminalReady_ = false;
        Int32 spare_ = 0;
    public:
        AisStaticAndVoyageRelatedDataMessageData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(aisVersion_);
            destination.Write(imoNumber_);
            destination.Write(callsign_);
            destination.Write(shipName_);
            destination.Write(shipType_);
            destination.Write(dimensionToBow_);
            destination.Write(dimensionToStern_);
            destination.Write(dimensionToPort_);
            destination.Write(dimensionToStarboard_);
            destination.Write(positionFixType_);
            estimatedTimeOfArrival_.WriteTo( destination );
            destination.Write(draught_);
            destination_.WriteTo( destination );
            destination.Write(dataTerminalReady_);
            destination.Write(spare_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(aisVersion_);
            source.Read(imoNumber_);
            source.Read(callsign_);
            source.Read(shipName_);
            source.Read(shipType_);
            source.Read(dimensionToBow_);
            source.Read(dimensionToStern_);
            source.Read(dimensionToPort_);
            source.Read(dimensionToStarboard_);
            source.Read(positionFixType_);
            estimatedTimeOfArrival_.ReadFrom( source );
            source.Read(draught_);
            destination_.ReadFrom( source );
            source.Read(dataTerminalReady_);
            source.Read(spare_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<AisStaticAndVoyageRelatedDataMessageData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<AisStaticAndVoyageRelatedDataMessageData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const AisStaticAndVoyageRelatedDataMessageData& >( other );
                if ( dataObject.aisVersion_ != aisVersion_ )
                {
                    return false;
                }
                if ( dataObject.imoNumber_ != imoNumber_ )
                {
                    return false;
                }
                if ( dataObject.callsign_ != callsign_ )
                {
                    return false;
                }
                if ( dataObject.shipName_ != shipName_ )
                {
                    return false;
                }
                if ( dataObject.shipType_ != shipType_ )
                {
                    return false;
                }
                if ( dataObject.dimensionToBow_ != dimensionToBow_ )
                {
                    return false;
                }
                if ( dataObject.dimensionToStern_ != dimensionToStern_ )
                {
                    return false;
                }
                if ( dataObject.dimensionToPort_ != dimensionToPort_ )
                {
                    return false;
                }
                if ( dataObject.dimensionToStarboard_ != dimensionToStarboard_ )
                {
                    return false;
                }
                if ( dataObject.positionFixType_ != positionFixType_ )
                {
                    return false;
                }
                if ( dataObject.estimatedTimeOfArrival_ != estimatedTimeOfArrival_ )
                {
                    return false;
                }
                if ( dataObject.draught_ != draught_ )
                {
                    return false;
                }
                if ( dataObject.destination_ != destination_ )
                {
                    return false;
                }
                if ( dataObject.dataTerminalReady_ != dataTerminalReady_ )
                {
                    return false;
                }
                if ( dataObject.spare_ != spare_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
    };
    class AisStaticDataReportMessageData : public AisMessageData
    {
    public:
        using Base = AisMessageData;
        static constexpr Kind KIND = Kind::AisStaticDataReportMessage;
    private:
        Int32 partNumber_ = 0;
    public:
        AisStaticDataReportMessageData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(partNumber_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(partNumber_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<AisStaticDataReportMessageData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<AisStaticDataReportMessageData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const AisStaticDataReportMessageData& >( other );
                if ( dataObject.partNumber_ != partNumber_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
    };
    class AisStaticDataReportPartAMessageData : public AisStaticDataReportMessageData
    {
    public:
        using Base = AisStaticDataReportMessageData;
        static constexpr Kind KIND = Kind::AisStaticDataReportPartAMessage;
    private:
        Guid shipName_;
        Int32 spare_ = 0;
    public:
        AisStaticDataReportPartAMessageData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(shipName_);
            destination.Write(spare_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(shipName_);
            source.Read(spare_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<AisStaticDataReportPartAMessageData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<AisStaticDataReportPartAMessageData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const AisStaticDataReportPartAMessageData& >( other );
                if ( dataObject.shipName_ != shipName_ )
                {
                    return false;
                }
                if ( dataObject.spare_ != spare_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
    };
    class AisStaticDataReportPartBMessageData : public AisStaticDataReportMessageData
    {
    public:
        using Base = AisStaticDataReportMessageData;
        static constexpr Kind KIND = Kind::AisStaticDataReportPartBMessage;
    private:
        Data::ShipType shipType_ = Data::ShipType::NotAvailable;
        FixedDBWideString<100> vendorId_;
        Int32 unitModelCode_ = 0;
        Int32 serialNumber_ = 0;
        Guid callsign_;
        Int32 dimensionToBow_ = 0;
        Int32 dimensionToStern_ = 0;
        Int32 dimensionToPort_ = 0;
        Int32 dimensionToStarboard_ = 0;
        Guid mothershipMmsi_;
        Data::PositionFixType positionFixType_ = Data::PositionFixType::Undefined1;
        Int32 spare_ = 0;
    public:
        AisStaticDataReportPartBMessageData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(shipType_);
            vendorId_.WriteTo( destination );
            destination.Write(unitModelCode_);
            destination.Write(serialNumber_);
            destination.Write(callsign_);
            destination.Write(dimensionToBow_);
            destination.Write(dimensionToStern_);
            destination.Write(dimensionToPort_);
            destination.Write(dimensionToStarboard_);
            destination.Write(mothershipMmsi_);
            destination.Write(positionFixType_);
            destination.Write(spare_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(shipType_);
            vendorId_.ReadFrom( source );
            source.Read(unitModelCode_);
            source.Read(serialNumber_);
            source.Read(callsign_);
            source.Read(dimensionToBow_);
            source.Read(dimensionToStern_);
            source.Read(dimensionToPort_);
            source.Read(dimensionToStarboard_);
            source.Read(mothershipMmsi_);
            source.Read(positionFixType_);
            source.Read(spare_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<AisStaticDataReportPartBMessageData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<AisStaticDataReportPartBMessageData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const AisStaticDataReportPartBMessageData& >( other );
                if ( dataObject.shipType_ != shipType_ )
                {
                    return false;
                }
                if ( dataObject.vendorId_ != vendorId_ )
                {
                    return false;
                }
                if ( dataObject.unitModelCode_ != unitModelCode_ )
                {
                    return false;
                }
                if ( dataObject.serialNumber_ != serialNumber_ )
                {
                    return false;
                }
                if ( dataObject.callsign_ != callsign_ )
                {
                    return false;
                }
                if ( dataObject.dimensionToBow_ != dimensionToBow_ )
                {
                    return false;
                }
                if ( dataObject.dimensionToStern_ != dimensionToStern_ )
                {
                    return false;
                }
                if ( dataObject.dimensionToPort_ != dimensionToPort_ )
                {
                    return false;
                }
                if ( dataObject.dimensionToStarboard_ != dimensionToStarboard_ )
                {
                    return false;
                }
                if ( dataObject.mothershipMmsi_ != mothershipMmsi_ )
                {
                    return false;
                }
                if ( dataObject.positionFixType_ != positionFixType_ )
                {
                    return false;
                }
                if ( dataObject.spare_ != spare_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
    };
    class AisUtcAndDateInquiryMessageData : public AisMessageData
    {
    public:
        using Base = AisMessageData;
        static constexpr Kind KIND = Kind::AisUtcAndDateInquiryMessage;
    private:
        Int32 spare1_ = 0;
        Int32 destinationMmsi_ = 0;
        Int32 spare2_ = 0;
    public:
        AisUtcAndDateInquiryMessageData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(spare1_);
            destination.Write(destinationMmsi_);
            destination.Write(spare2_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(spare1_);
            source.Read(destinationMmsi_);
            source.Read(spare2_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<AisUtcAndDateInquiryMessageData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<AisUtcAndDateInquiryMessageData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const AisUtcAndDateInquiryMessageData& >( other );
                if ( dataObject.spare1_ != spare1_ )
                {
                    return false;
                }
                if ( dataObject.destinationMmsi_ != destinationMmsi_ )
                {
                    return false;
                }
                if ( dataObject.spare2_ != spare2_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
    };
    class AisUtcAndDateResponseMessageData : public AisMessageData
    {
    public:
        using Base = AisMessageData;
        static constexpr Kind KIND = Kind::AisUtcAndDateResponseMessage;
    private:
        DateTime datetime_;
        Data::PositionAccuracy positionAccuracy_ = Data::PositionAccuracy::Low;
        double longitude_ = 0.0;
        double latitude_ = 0.0;
        Data::PositionFixType positionFixType_ = Data::PositionFixType::Undefined1;
        Int32 spare_ = 0;
        Data::Raim raim_ = Data::Raim::NotInUse;
        Int32 radioStatus_ = 0;
    public:
        AisUtcAndDateResponseMessageData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(datetime_);
            destination.Write(positionAccuracy_);
            destination.Write(longitude_);
            destination.Write(latitude_);
            destination.Write(positionFixType_);
            destination.Write(spare_);
            destination.Write(raim_);
            destination.Write(radioStatus_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(datetime_);
            source.Read(positionAccuracy_);
            source.Read(longitude_);
            source.Read(latitude_);
            source.Read(positionFixType_);
            source.Read(spare_);
            source.Read(raim_);
            source.Read(radioStatus_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<AisUtcAndDateResponseMessageData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<AisUtcAndDateResponseMessageData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const AisUtcAndDateResponseMessageData& >( other );
                if ( dataObject.datetime_ != datetime_ )
                {
                    return false;
                }
                if ( dataObject.positionAccuracy_ != positionAccuracy_ )
                {
                    return false;
                }
                if ( dataObject.longitude_ != longitude_ )
                {
                    return false;
                }
                if ( dataObject.latitude_ != latitude_ )
                {
                    return false;
                }
                if ( dataObject.positionFixType_ != positionFixType_ )
                {
                    return false;
                }
                if ( dataObject.spare_ != spare_ )
                {
                    return false;
                }
                if ( dataObject.raim_ != raim_ )
                {
                    return false;
                }
                if ( dataObject.radioStatus_ != radioStatus_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
    };
    class AisTransceiverCommandData : public BaseData<Kind, Guid>
    {
    public:
        using Base = BaseData<Kind, Guid>;
        static constexpr Kind KIND = Kind::AisTransceiverCommand;
    private:
        Int64 rowVersion_ = 0;
        Guid aisTransceiver_;
        DateTime timestamp_;
        Data::DeviceCommandSourceType deviceCommandSourceType_ = Data::DeviceCommandSourceType::Unknown;
        Guid deviceCommandSourceId_;
        Guid reply_;
    public:
        AisTransceiverCommandData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(rowVersion_);
            destination.Write(aisTransceiver_);
            destination.Write(timestamp_);
            destination.Write(deviceCommandSourceType_);
            destination.Write(deviceCommandSourceId_);
            destination.Write(reply_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(rowVersion_);
            source.Read(aisTransceiver_);
            source.Read(timestamp_);
            source.Read(deviceCommandSourceType_);
            source.Read(deviceCommandSourceId_);
            source.Read(reply_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<AisTransceiverCommandData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<AisTransceiverCommandData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const AisTransceiverCommandData& >( other );
                if ( dataObject.rowVersion_ != rowVersion_ )
                {
                    return false;
                }
                if ( dataObject.aisTransceiver_ != aisTransceiver_ )
                {
                    return false;
                }
                if ( dataObject.timestamp_ != timestamp_ )
                {
                    return false;
                }
                if ( dataObject.deviceCommandSourceType_ != deviceCommandSourceType_ )
                {
                    return false;
                }
                if ( dataObject.deviceCommandSourceId_ != deviceCommandSourceId_ )
                {
                    return false;
                }
                if ( dataObject.reply_ != reply_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
    };
    class AisTransceiverCommandReplyData : public BaseData<Kind, Guid>
    {
    public:
        using Base = BaseData<Kind, Guid>;
        static constexpr Kind KIND = Kind::AisTransceiverCommandReply;
    private:
        Int64 rowVersion_ = 0;
        Guid aisTransceiver_;
        DateTime timestamp_;
        Guid command_;
        Data::DeviceCommandReplyStatus status_ = Data::DeviceCommandReplyStatus::Unknown;
        WideString message_;
        SQLLEN messageLength_ = SQL_NULL_DATA;
    public:
        AisTransceiverCommandReplyData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(rowVersion_);
            destination.Write(aisTransceiver_);
            destination.Write(timestamp_);
            destination.Write(command_);
            destination.Write(status_);
            destination.Write(message_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(rowVersion_);
            source.Read(aisTransceiver_);
            source.Read(timestamp_);
            source.Read(command_);
            source.Read(status_);
            source.Read(message_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<AisTransceiverCommandReplyData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<AisTransceiverCommandReplyData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const AisTransceiverCommandReplyData& >( other );
                if ( dataObject.rowVersion_ != rowVersion_ )
                {
                    return false;
                }
                if ( dataObject.aisTransceiver_ != aisTransceiver_ )
                {
                    return false;
                }
                if ( dataObject.timestamp_ != timestamp_ )
                {
                    return false;
                }
                if ( dataObject.command_ != command_ )
                {
                    return false;
                }
                if ( dataObject.status_ != status_ )
                {
                    return false;
                }
                if ( dataObject.message_ != message_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
    };
    class AisTransceiverConfigurationData : public BaseData<Kind, Guid>
    {
    public:
        using Base = BaseData<Kind, Guid>;
        static constexpr Kind KIND = Kind::AisTransceiverConfiguration;
    private:
        Int64 rowVersion_ = 0;
        Guid aisTransceiver_;
        DateTime timestamp_;
        FixedDBWideString<127> userName_;
        FixedDBWideString<127> password_;
        double latitude_ = 0.0;
        double longitude_ = 0.0;
        FixedDBWideString<127> aisProviderLoginURL_;
        FixedDBWideString<32> comPort_;
        Int32 baudRate_ = 0;
        bool filterByArea_ = false;
        double upperLeftCornerLatitude_ = 0.0;
        double upperLeftCornerLongitude_ = 0.0;
        double bottomRightCornerLatitude_ = 0.0;
        double bottomRightCornerLongitude_ = 0.0;
        FixedDBWideString<127> aisProviderIPAddress_;
        Int32 aisProviderPort_ = 0;
        bool useLogin_ = false;
        Int32 aisProviderLoginPort_ = 0;
        bool canSendAISMessage_ = false;
        WideString textMessageHeader_;
        SQLLEN textMessageHeaderLength_ = SQL_NULL_DATA;
        WideString urls_;
        SQLLEN urlsLength_ = SQL_NULL_DATA;
        Int32 udpPort_ = 0;
        Data::AisTransceiverConnectionType connectionType_ = Data::AisTransceiverConnectionType::Unknown;
        bool enableRefreshAidToNavigationIn30sec_ = false;
        bool enableAidToNavigationFromFile_ = false;
        WideString aidToNavigationHeader_;
        SQLLEN aidToNavigationHeaderLength_ = SQL_NULL_DATA;
        bool sendingMMSI_ = false;
        Int32 sourceUpdateRate_ = 0;
        bool enableRefreshStayingStillTargetIn30sec_ = false;
        WideString excludeSendAisBaseStation_;
        SQLLEN excludeSendAisBaseStationLength_ = SQL_NULL_DATA;
        WideString excludeSendAisA_;
        SQLLEN excludeSendAisALength_ = SQL_NULL_DATA;
        bool enableSendBaseStationAlarms_ = false;
        FixedDBWideString<127> aisWebConfig_;
        bool storeReceivedSentences_ = false;
        bool storeSentMessages_ = false;
        bool storeUnsentMessages_ = false;
    public:
        AisTransceiverConfigurationData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(rowVersion_);
            destination.Write(aisTransceiver_);
            destination.Write(timestamp_);
            userName_.WriteTo( destination );
            password_.WriteTo( destination );
            destination.Write(latitude_);
            destination.Write(longitude_);
            aisProviderLoginURL_.WriteTo( destination );
            comPort_.WriteTo( destination );
            destination.Write(baudRate_);
            destination.Write(filterByArea_);
            destination.Write(upperLeftCornerLatitude_);
            destination.Write(upperLeftCornerLongitude_);
            destination.Write(bottomRightCornerLatitude_);
            destination.Write(bottomRightCornerLongitude_);
            aisProviderIPAddress_.WriteTo( destination );
            destination.Write(aisProviderPort_);
            destination.Write(useLogin_);
            destination.Write(aisProviderLoginPort_);
            destination.Write(canSendAISMessage_);
            destination.Write(textMessageHeader_);
            destination.Write(urls_);
            destination.Write(udpPort_);
            destination.Write(connectionType_);
            destination.Write(enableRefreshAidToNavigationIn30sec_);
            destination.Write(enableAidToNavigationFromFile_);
            destination.Write(aidToNavigationHeader_);
            destination.Write(sendingMMSI_);
            destination.Write(sourceUpdateRate_);
            destination.Write(enableRefreshStayingStillTargetIn30sec_);
            destination.Write(excludeSendAisBaseStation_);
            destination.Write(excludeSendAisA_);
            destination.Write(enableSendBaseStationAlarms_);
            aisWebConfig_.WriteTo( destination );
            destination.Write(storeReceivedSentences_);
            destination.Write(storeSentMessages_);
            destination.Write(storeUnsentMessages_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(rowVersion_);
            source.Read(aisTransceiver_);
            source.Read(timestamp_);
            userName_.ReadFrom( source );
            password_.ReadFrom( source );
            source.Read(latitude_);
            source.Read(longitude_);
            aisProviderLoginURL_.ReadFrom( source );
            comPort_.ReadFrom( source );
            source.Read(baudRate_);
            source.Read(filterByArea_);
            source.Read(upperLeftCornerLatitude_);
            source.Read(upperLeftCornerLongitude_);
            source.Read(bottomRightCornerLatitude_);
            source.Read(bottomRightCornerLongitude_);
            aisProviderIPAddress_.ReadFrom( source );
            source.Read(aisProviderPort_);
            source.Read(useLogin_);
            source.Read(aisProviderLoginPort_);
            source.Read(canSendAISMessage_);
            source.Read(textMessageHeader_);
            source.Read(urls_);
            source.Read(udpPort_);
            source.Read(connectionType_);
            source.Read(enableRefreshAidToNavigationIn30sec_);
            source.Read(enableAidToNavigationFromFile_);
            source.Read(aidToNavigationHeader_);
            source.Read(sendingMMSI_);
            source.Read(sourceUpdateRate_);
            source.Read(enableRefreshStayingStillTargetIn30sec_);
            source.Read(excludeSendAisBaseStation_);
            source.Read(excludeSendAisA_);
            source.Read(enableSendBaseStationAlarms_);
            aisWebConfig_.ReadFrom( source );
            source.Read(storeReceivedSentences_);
            source.Read(storeSentMessages_);
            source.Read(storeUnsentMessages_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<AisTransceiverConfigurationData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<AisTransceiverConfigurationData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const AisTransceiverConfigurationData& >( other );
                if ( dataObject.rowVersion_ != rowVersion_ )
                {
                    return false;
                }
                if ( dataObject.aisTransceiver_ != aisTransceiver_ )
                {
                    return false;
                }
                if ( dataObject.timestamp_ != timestamp_ )
                {
                    return false;
                }
                if ( dataObject.userName_ != userName_ )
                {
                    return false;
                }
                if ( dataObject.password_ != password_ )
                {
                    return false;
                }
                if ( dataObject.latitude_ != latitude_ )
                {
                    return false;
                }
                if ( dataObject.longitude_ != longitude_ )
                {
                    return false;
                }
                if ( dataObject.aisProviderLoginURL_ != aisProviderLoginURL_ )
                {
                    return false;
                }
                if ( dataObject.comPort_ != comPort_ )
                {
                    return false;
                }
                if ( dataObject.baudRate_ != baudRate_ )
                {
                    return false;
                }
                if ( dataObject.filterByArea_ != filterByArea_ )
                {
                    return false;
                }
                if ( dataObject.upperLeftCornerLatitude_ != upperLeftCornerLatitude_ )
                {
                    return false;
                }
                if ( dataObject.upperLeftCornerLongitude_ != upperLeftCornerLongitude_ )
                {
                    return false;
                }
                if ( dataObject.bottomRightCornerLatitude_ != bottomRightCornerLatitude_ )
                {
                    return false;
                }
                if ( dataObject.bottomRightCornerLongitude_ != bottomRightCornerLongitude_ )
                {
                    return false;
                }
                if ( dataObject.aisProviderIPAddress_ != aisProviderIPAddress_ )
                {
                    return false;
                }
                if ( dataObject.aisProviderPort_ != aisProviderPort_ )
                {
                    return false;
                }
                if ( dataObject.useLogin_ != useLogin_ )
                {
                    return false;
                }
                if ( dataObject.aisProviderLoginPort_ != aisProviderLoginPort_ )
                {
                    return false;
                }
                if ( dataObject.canSendAISMessage_ != canSendAISMessage_ )
                {
                    return false;
                }
                if ( dataObject.textMessageHeader_ != textMessageHeader_ )
                {
                    return false;
                }
                if ( dataObject.urls_ != urls_ )
                {
                    return false;
                }
                if ( dataObject.udpPort_ != udpPort_ )
                {
                    return false;
                }
                if ( dataObject.connectionType_ != connectionType_ )
                {
                    return false;
                }
                if ( dataObject.enableRefreshAidToNavigationIn30sec_ != enableRefreshAidToNavigationIn30sec_ )
                {
                    return false;
                }
                if ( dataObject.enableAidToNavigationFromFile_ != enableAidToNavigationFromFile_ )
                {
                    return false;
                }
                if ( dataObject.aidToNavigationHeader_ != aidToNavigationHeader_ )
                {
                    return false;
                }
                if ( dataObject.sendingMMSI_ != sendingMMSI_ )
                {
                    return false;
                }
                if ( dataObject.sourceUpdateRate_ != sourceUpdateRate_ )
                {
                    return false;
                }
                if ( dataObject.enableRefreshStayingStillTargetIn30sec_ != enableRefreshStayingStillTargetIn30sec_ )
                {
                    return false;
                }
                if ( dataObject.excludeSendAisBaseStation_ != excludeSendAisBaseStation_ )
                {
                    return false;
                }
                if ( dataObject.excludeSendAisA_ != excludeSendAisA_ )
                {
                    return false;
                }
                if ( dataObject.enableSendBaseStationAlarms_ != enableSendBaseStationAlarms_ )
                {
                    return false;
                }
                if ( dataObject.aisWebConfig_ != aisWebConfig_ )
                {
                    return false;
                }
                if ( dataObject.storeReceivedSentences_ != storeReceivedSentences_ )
                {
                    return false;
                }
                if ( dataObject.storeSentMessages_ != storeSentMessages_ )
                {
                    return false;
                }
                if ( dataObject.storeUnsentMessages_ != storeUnsentMessages_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
    };
    class AisTransceiverRawMessageData : public BaseData<Kind, Guid>
    {
    public:
        using Base = BaseData<Kind, Guid>;
        static constexpr Kind KIND = Kind::AisTransceiverRawMessage;
    private:
        Int64 rowVersion_ = 0;
        Guid aisTransceiver_;
        DateTime timestamp_;
        bool isSent_ = false;
        FixedDBWideString<100> message_;
    public:
        AisTransceiverRawMessageData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(rowVersion_);
            destination.Write(aisTransceiver_);
            destination.Write(timestamp_);
            destination.Write(isSent_);
            message_.WriteTo( destination );
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(rowVersion_);
            source.Read(aisTransceiver_);
            source.Read(timestamp_);
            source.Read(isSent_);
            message_.ReadFrom( source );
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<AisTransceiverRawMessageData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<AisTransceiverRawMessageData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const AisTransceiverRawMessageData& >( other );
                if ( dataObject.rowVersion_ != rowVersion_ )
                {
                    return false;
                }
                if ( dataObject.aisTransceiver_ != aisTransceiver_ )
                {
                    return false;
                }
                if ( dataObject.timestamp_ != timestamp_ )
                {
                    return false;
                }
                if ( dataObject.isSent_ != isSent_ )
                {
                    return false;
                }
                if ( dataObject.message_ != message_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
    };
    class AisTransceiverRawSentenceData : public BaseData<Kind, Guid>
    {
    public:
        using Base = BaseData<Kind, Guid>;
        static constexpr Kind KIND = Kind::AisTransceiverRawSentence;
    private:
        Int64 rowVersion_ = 0;
        Guid aisTransceiver_;
        DateTime timestamp_;
        WideString sentence_;
        SQLLEN sentenceLength_ = SQL_NULL_DATA;
    public:
        AisTransceiverRawSentenceData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(rowVersion_);
            destination.Write(aisTransceiver_);
            destination.Write(timestamp_);
            destination.Write(sentence_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(rowVersion_);
            source.Read(aisTransceiver_);
            source.Read(timestamp_);
            source.Read(sentence_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<AisTransceiverRawSentenceData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<AisTransceiverRawSentenceData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const AisTransceiverRawSentenceData& >( other );
                if ( dataObject.rowVersion_ != rowVersion_ )
                {
                    return false;
                }
                if ( dataObject.aisTransceiver_ != aisTransceiver_ )
                {
                    return false;
                }
                if ( dataObject.timestamp_ != timestamp_ )
                {
                    return false;
                }
                if ( dataObject.sentence_ != sentence_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
    };
    class AlarmStateChangeData : public BaseData<Kind, Guid>
    {
    public:
        using Base = BaseData<Kind, Guid>;
        static constexpr Kind KIND = Kind::AlarmStateChange;
    private:
        Int64 rowVersion_ = 0;
        Guid alarm_;
        DateTime timestamp_;
        Data::AlarmState state_ = Data::AlarmState::Unknown;
    public:
        AlarmStateChangeData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(rowVersion_);
            destination.Write(alarm_);
            destination.Write(timestamp_);
            destination.Write(state_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(rowVersion_);
            source.Read(alarm_);
            source.Read(timestamp_);
            source.Read(state_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<AlarmStateChangeData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<AlarmStateChangeData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const AlarmStateChangeData& >( other );
                if ( dataObject.rowVersion_ != rowVersion_ )
                {
                    return false;
                }
                if ( dataObject.alarm_ != alarm_ )
                {
                    return false;
                }
                if ( dataObject.timestamp_ != timestamp_ )
                {
                    return false;
                }
                if ( dataObject.state_ != state_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
    };
    class BaseStationTypeData : public BaseData<Kind, Guid>
    {
    public:
        using Base = BaseData<Kind, Guid>;
        static constexpr Kind KIND = Kind::BaseStationType;
    private:
        Int64 rowVersion_ = 0;
        FixedDBWideString<127> name_;
    public:
        BaseStationTypeData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(rowVersion_);
            name_.WriteTo( destination );
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(rowVersion_);
            name_.ReadFrom( source );
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<BaseStationTypeData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<BaseStationTypeData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const BaseStationTypeData& >( other );
                if ( dataObject.rowVersion_ != rowVersion_ )
                {
                    return false;
                }
                if ( dataObject.name_ != name_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
    };
    class BinaryTimeseriesValueData : public BaseData<Kind, Guid>
    {
    public:
        using Base = BaseData<Kind, Guid>;
        static constexpr Kind KIND = Kind::BinaryTimeseriesValue;
    private:
        Int64 rowVersion_ = 0;
        Guid timeseries_;
        DateTime timestamp_;
        Binary value_;
        SQLLEN valueLength_ = SQL_NULL_DATA;
    public:
        BinaryTimeseriesValueData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(rowVersion_);
            destination.Write(timeseries_);
            destination.Write(timestamp_);
            destination.Write(value_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(rowVersion_);
            source.Read(timeseries_);
            source.Read(timestamp_);
            source.Read(value_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<BinaryTimeseriesValueData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<BinaryTimeseriesValueData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const BinaryTimeseriesValueData& >( other );
                if ( dataObject.rowVersion_ != rowVersion_ )
                {
                    return false;
                }
                if ( dataObject.timeseries_ != timeseries_ )
                {
                    return false;
                }
                if ( dataObject.timestamp_ != timestamp_ )
                {
                    return false;
                }
                if ( dataObject.value_ != value_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
    };
    class BookmarkData : public BaseData<Kind, Guid>
    {
    public:
        using Base = BaseData<Kind, Guid>;
        static constexpr Kind KIND = Kind::Bookmark;
    private:
        Int64 rowVersion_ = 0;
        Guid view_;
        FixedDBWideString<100> name_;
        DBDateTime timestamp_;
        double latitude_ = 0.0;
        double longitude_ = 0.0;
        double zoomLevel_ = 0.0;
    public:
        BookmarkData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(rowVersion_);
            destination.Write(view_);
            name_.WriteTo( destination );
            timestamp_.WriteTo( destination );
            destination.Write(latitude_);
            destination.Write(longitude_);
            destination.Write(zoomLevel_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(rowVersion_);
            source.Read(view_);
            name_.ReadFrom( source );
            timestamp_.ReadFrom( source );
            source.Read(latitude_);
            source.Read(longitude_);
            source.Read(zoomLevel_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<BookmarkData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<BookmarkData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const BookmarkData& >( other );
                if ( dataObject.rowVersion_ != rowVersion_ )
                {
                    return false;
                }
                if ( dataObject.view_ != view_ )
                {
                    return false;
                }
                if ( dataObject.name_ != name_ )
                {
                    return false;
                }
                if ( dataObject.timestamp_ != timestamp_ )
                {
                    return false;
                }
                if ( dataObject.latitude_ != latitude_ )
                {
                    return false;
                }
                if ( dataObject.longitude_ != longitude_ )
                {
                    return false;
                }
                if ( dataObject.zoomLevel_ != zoomLevel_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
    };
    class BooleanTimeseriesValueData : public BaseData<Kind, Guid>
    {
    public:
        using Base = BaseData<Kind, Guid>;
        static constexpr Kind KIND = Kind::BooleanTimeseriesValue;
    private:
        Int64 rowVersion_ = 0;
        Guid timeseries_;
        DateTime timestamp_;
        DBBoolean  value_;
    public:
        BooleanTimeseriesValueData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(rowVersion_);
            destination.Write(timeseries_);
            destination.Write(timestamp_);
            value_.WriteTo( destination );
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(rowVersion_);
            source.Read(timeseries_);
            source.Read(timestamp_);
            value_.ReadFrom( source );
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<BooleanTimeseriesValueData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<BooleanTimeseriesValueData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const BooleanTimeseriesValueData& >( other );
                if ( dataObject.rowVersion_ != rowVersion_ )
                {
                    return false;
                }
                if ( dataObject.timeseries_ != timeseries_ )
                {
                    return false;
                }
                if ( dataObject.timestamp_ != timestamp_ )
                {
                    return false;
                }
                if ( dataObject.value_ != value_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
    };
    class ByteTimeseriesValueData : public BaseData<Kind, Guid>
    {
    public:
        using Base = BaseData<Kind, Guid>;
        static constexpr Kind KIND = Kind::ByteTimeseriesValue;
    private:
        Int64 rowVersion_ = 0;
        Guid timeseries_;
        DateTime timestamp_;
        DBByte value_;
    public:
        ByteTimeseriesValueData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(rowVersion_);
            destination.Write(timeseries_);
            destination.Write(timestamp_);
            value_.WriteTo( destination );
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(rowVersion_);
            source.Read(timeseries_);
            source.Read(timestamp_);
            value_.ReadFrom( source );
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<ByteTimeseriesValueData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<ByteTimeseriesValueData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const ByteTimeseriesValueData& >( other );
                if ( dataObject.rowVersion_ != rowVersion_ )
                {
                    return false;
                }
                if ( dataObject.timeseries_ != timeseries_ )
                {
                    return false;
                }
                if ( dataObject.timestamp_ != timestamp_ )
                {
                    return false;
                }
                if ( dataObject.value_ != value_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
    };
    class CameraCommandData : public BaseData<Kind, Guid>
    {
    public:
        using Base = BaseData<Kind, Guid>;
        static constexpr Kind KIND = Kind::CameraCommand;
    private:
        Int64 rowVersion_ = 0;
        Guid camera_;
        DateTime timestamp_;
        Data::DeviceCommandSourceType deviceCommandSourceType_ = Data::DeviceCommandSourceType::Unknown;
        Guid deviceCommandSourceId_;
        Guid reply_;
    public:
        CameraCommandData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(rowVersion_);
            destination.Write(camera_);
            destination.Write(timestamp_);
            destination.Write(deviceCommandSourceType_);
            destination.Write(deviceCommandSourceId_);
            destination.Write(reply_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(rowVersion_);
            source.Read(camera_);
            source.Read(timestamp_);
            source.Read(deviceCommandSourceType_);
            source.Read(deviceCommandSourceId_);
            source.Read(reply_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<CameraCommandData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<CameraCommandData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const CameraCommandData& >( other );
                if ( dataObject.rowVersion_ != rowVersion_ )
                {
                    return false;
                }
                if ( dataObject.camera_ != camera_ )
                {
                    return false;
                }
                if ( dataObject.timestamp_ != timestamp_ )
                {
                    return false;
                }
                if ( dataObject.deviceCommandSourceType_ != deviceCommandSourceType_ )
                {
                    return false;
                }
                if ( dataObject.deviceCommandSourceId_ != deviceCommandSourceId_ )
                {
                    return false;
                }
                if ( dataObject.reply_ != reply_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
    };
    class CameraCommandAbsoluteMoveData : public CameraCommandData
    {
    public:
        using Base = CameraCommandData;
        static constexpr Kind KIND = Kind::CameraCommandAbsoluteMove;
    private:
        Data::CameraPanTiltMode positionPanTiltMode_ = Data::CameraPanTiltMode::Unknown;
        DBDouble panAngle_;
        DBDouble tiltAngle_;
        Data::CameraFocalLengthMode positionFocalLengthMode_ = Data::CameraFocalLengthMode::Unknown;
        DBDouble focalLength_;
        Data::CameraPanTiltMode speedPanTiltMode_ = Data::CameraPanTiltMode::Unknown;
        DBDouble panSpeed_;
        DBDouble tiltSpeed_;
        Data::CameraFocalLengthMode speedFocalLengthMode_ = Data::CameraFocalLengthMode::Unknown;
        DBDouble zoomSpeed_;
    public:
        CameraCommandAbsoluteMoveData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(positionPanTiltMode_);
            panAngle_.WriteTo( destination );
            tiltAngle_.WriteTo( destination );
            destination.Write(positionFocalLengthMode_);
            focalLength_.WriteTo( destination );
            destination.Write(speedPanTiltMode_);
            panSpeed_.WriteTo( destination );
            tiltSpeed_.WriteTo( destination );
            destination.Write(speedFocalLengthMode_);
            zoomSpeed_.WriteTo( destination );
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(positionPanTiltMode_);
            panAngle_.ReadFrom( source );
            tiltAngle_.ReadFrom( source );
            source.Read(positionFocalLengthMode_);
            focalLength_.ReadFrom( source );
            source.Read(speedPanTiltMode_);
            panSpeed_.ReadFrom( source );
            tiltSpeed_.ReadFrom( source );
            source.Read(speedFocalLengthMode_);
            zoomSpeed_.ReadFrom( source );
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<CameraCommandAbsoluteMoveData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<CameraCommandAbsoluteMoveData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const CameraCommandAbsoluteMoveData& >( other );
                if ( dataObject.positionPanTiltMode_ != positionPanTiltMode_ )
                {
                    return false;
                }
                if ( dataObject.panAngle_ != panAngle_ )
                {
                    return false;
                }
                if ( dataObject.tiltAngle_ != tiltAngle_ )
                {
                    return false;
                }
                if ( dataObject.positionFocalLengthMode_ != positionFocalLengthMode_ )
                {
                    return false;
                }
                if ( dataObject.focalLength_ != focalLength_ )
                {
                    return false;
                }
                if ( dataObject.speedPanTiltMode_ != speedPanTiltMode_ )
                {
                    return false;
                }
                if ( dataObject.panSpeed_ != panSpeed_ )
                {
                    return false;
                }
                if ( dataObject.tiltSpeed_ != tiltSpeed_ )
                {
                    return false;
                }
                if ( dataObject.speedFocalLengthMode_ != speedFocalLengthMode_ )
                {
                    return false;
                }
                if ( dataObject.zoomSpeed_ != zoomSpeed_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
    };
    class CameraCommandAdjustPanTiltZoomData : public CameraCommandData
    {
    public:
        using Base = CameraCommandData;
        static constexpr Kind KIND = Kind::CameraCommandAdjustPanTiltZoom;
    private:
        DBDouble x_;
        DBDouble y_;
        DBDouble z_;
    public:
        CameraCommandAdjustPanTiltZoomData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            x_.WriteTo( destination );
            y_.WriteTo( destination );
            z_.WriteTo( destination );
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            x_.ReadFrom( source );
            y_.ReadFrom( source );
            z_.ReadFrom( source );
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<CameraCommandAdjustPanTiltZoomData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<CameraCommandAdjustPanTiltZoomData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const CameraCommandAdjustPanTiltZoomData& >( other );
                if ( dataObject.x_ != x_ )
                {
                    return false;
                }
                if ( dataObject.y_ != y_ )
                {
                    return false;
                }
                if ( dataObject.z_ != z_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
    };
    class CameraCommandContinuousMoveData : public CameraCommandData
    {
    public:
        using Base = CameraCommandData;
        static constexpr Kind KIND = Kind::CameraCommandContinuousMove;
    private:
        bool normalized_ = false;
        DBDouble panVelocity_;
        DBDouble tiltVelocity_;
        DBDouble zoomVelocity_;
        DBTimeSpan duration_;
    public:
        CameraCommandContinuousMoveData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(normalized_);
            panVelocity_.WriteTo( destination );
            tiltVelocity_.WriteTo( destination );
            zoomVelocity_.WriteTo( destination );
            duration_.WriteTo( destination );
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(normalized_);
            panVelocity_.ReadFrom( source );
            tiltVelocity_.ReadFrom( source );
            zoomVelocity_.ReadFrom( source );
            duration_.ReadFrom( source );
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<CameraCommandContinuousMoveData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<CameraCommandContinuousMoveData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const CameraCommandContinuousMoveData& >( other );
                if ( dataObject.normalized_ != normalized_ )
                {
                    return false;
                }
                if ( dataObject.panVelocity_ != panVelocity_ )
                {
                    return false;
                }
                if ( dataObject.tiltVelocity_ != tiltVelocity_ )
                {
                    return false;
                }
                if ( dataObject.zoomVelocity_ != zoomVelocity_ )
                {
                    return false;
                }
                if ( dataObject.duration_ != duration_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
    };
    class CameraCommandGeoMoveData : public CameraCommandData
    {
    public:
        using Base = CameraCommandData;
        static constexpr Kind KIND = Kind::CameraCommandGeoMove;
    private:
        double latitude_ = 0.0;
        double longitude_ = 0.0;
        DBDouble altitude_;
        DBDouble viewportWidth_;
        DBDouble viewportHeight_;
    public:
        CameraCommandGeoMoveData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(latitude_);
            destination.Write(longitude_);
            altitude_.WriteTo( destination );
            viewportWidth_.WriteTo( destination );
            viewportHeight_.WriteTo( destination );
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(latitude_);
            source.Read(longitude_);
            altitude_.ReadFrom( source );
            viewportWidth_.ReadFrom( source );
            viewportHeight_.ReadFrom( source );
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<CameraCommandGeoMoveData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<CameraCommandGeoMoveData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const CameraCommandGeoMoveData& >( other );
                if ( dataObject.latitude_ != latitude_ )
                {
                    return false;
                }
                if ( dataObject.longitude_ != longitude_ )
                {
                    return false;
                }
                if ( dataObject.altitude_ != altitude_ )
                {
                    return false;
                }
                if ( dataObject.viewportWidth_ != viewportWidth_ )
                {
                    return false;
                }
                if ( dataObject.viewportHeight_ != viewportHeight_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
    };
    class CameraCommandRelativeMoveData : public CameraCommandData
    {
    public:
        using Base = CameraCommandData;
        static constexpr Kind KIND = Kind::CameraCommandRelativeMove;
    private:
        bool normalized_ = false;
        DBDouble panAngle_;
        DBDouble tiltAngle_;
        DBDouble focalLength_;
        DBDouble panSpeed_;
        DBDouble tiltSpeed_;
        DBDouble zoomSpeed_;
    public:
        CameraCommandRelativeMoveData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(normalized_);
            panAngle_.WriteTo( destination );
            tiltAngle_.WriteTo( destination );
            focalLength_.WriteTo( destination );
            panSpeed_.WriteTo( destination );
            tiltSpeed_.WriteTo( destination );
            zoomSpeed_.WriteTo( destination );
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(normalized_);
            panAngle_.ReadFrom( source );
            tiltAngle_.ReadFrom( source );
            focalLength_.ReadFrom( source );
            panSpeed_.ReadFrom( source );
            tiltSpeed_.ReadFrom( source );
            zoomSpeed_.ReadFrom( source );
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<CameraCommandRelativeMoveData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<CameraCommandRelativeMoveData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const CameraCommandRelativeMoveData& >( other );
                if ( dataObject.normalized_ != normalized_ )
                {
                    return false;
                }
                if ( dataObject.panAngle_ != panAngle_ )
                {
                    return false;
                }
                if ( dataObject.tiltAngle_ != tiltAngle_ )
                {
                    return false;
                }
                if ( dataObject.focalLength_ != focalLength_ )
                {
                    return false;
                }
                if ( dataObject.panSpeed_ != panSpeed_ )
                {
                    return false;
                }
                if ( dataObject.tiltSpeed_ != tiltSpeed_ )
                {
                    return false;
                }
                if ( dataObject.zoomSpeed_ != zoomSpeed_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
    };
    class CameraCommandReleasePTZOwnershipData : public CameraCommandData
    {
    public:
        using Base = CameraCommandData;
        static constexpr Kind KIND = Kind::CameraCommandReleasePTZOwnership;
    private:
    public:
        CameraCommandReleasePTZOwnershipData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<CameraCommandReleasePTZOwnershipData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<CameraCommandReleasePTZOwnershipData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const CameraCommandReleasePTZOwnershipData& >( other );
                return true;
            }
            return false;
        }
    };
    class CameraCommandRequestPTZOwnershipData : public CameraCommandData
    {
    public:
        using Base = CameraCommandData;
        static constexpr Kind KIND = Kind::CameraCommandRequestPTZOwnership;
    private:
    public:
        CameraCommandRequestPTZOwnershipData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<CameraCommandRequestPTZOwnershipData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<CameraCommandRequestPTZOwnershipData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const CameraCommandRequestPTZOwnershipData& >( other );
                return true;
            }
            return false;
        }
    };
    class CameraCommandSetAutoFocusData : public CameraCommandData
    {
    public:
        using Base = CameraCommandData;
        static constexpr Kind KIND = Kind::CameraCommandSetAutoFocus;
    private:
        bool enabled_ = false;
    public:
        CameraCommandSetAutoFocusData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(enabled_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(enabled_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<CameraCommandSetAutoFocusData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<CameraCommandSetAutoFocusData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const CameraCommandSetAutoFocusData& >( other );
                if ( dataObject.enabled_ != enabled_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
    };
    class CameraCommandSetBlackAndWhiteData : public CameraCommandData
    {
    public:
        using Base = CameraCommandData;
        static constexpr Kind KIND = Kind::CameraCommandSetBlackAndWhite;
    private:
        bool enabled_ = false;
    public:
        CameraCommandSetBlackAndWhiteData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(enabled_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(enabled_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<CameraCommandSetBlackAndWhiteData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<CameraCommandSetBlackAndWhiteData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const CameraCommandSetBlackAndWhiteData& >( other );
                if ( dataObject.enabled_ != enabled_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
    };
    class CameraCommandSetFollowedData : public CameraCommandData
    {
    public:
        using Base = CameraCommandData;
        static constexpr Kind KIND = Kind::CameraCommandSetFollowed;
    private:
        Guid trackId_;
        Data::CameraFollowReason reason_ = Data::CameraFollowReason::Alarm;
    public:
        CameraCommandSetFollowedData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(trackId_);
            destination.Write(reason_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(trackId_);
            source.Read(reason_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<CameraCommandSetFollowedData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<CameraCommandSetFollowedData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const CameraCommandSetFollowedData& >( other );
                if ( dataObject.trackId_ != trackId_ )
                {
                    return false;
                }
                if ( dataObject.reason_ != reason_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
    };
    class CameraCommandSetInfraRedLampData : public CameraCommandData
    {
    public:
        using Base = CameraCommandData;
        static constexpr Kind KIND = Kind::CameraCommandSetInfraRedLamp;
    private:
        bool enabled_ = false;
    public:
        CameraCommandSetInfraRedLampData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(enabled_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(enabled_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<CameraCommandSetInfraRedLampData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<CameraCommandSetInfraRedLampData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const CameraCommandSetInfraRedLampData& >( other );
                if ( dataObject.enabled_ != enabled_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
    };
    class CameraCommandSetWasherData : public CameraCommandData
    {
    public:
        using Base = CameraCommandData;
        static constexpr Kind KIND = Kind::CameraCommandSetWasher;
    private:
        bool enabled_ = false;
    public:
        CameraCommandSetWasherData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(enabled_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(enabled_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<CameraCommandSetWasherData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<CameraCommandSetWasherData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const CameraCommandSetWasherData& >( other );
                if ( dataObject.enabled_ != enabled_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
    };
    class CameraCommandSetWiperData : public CameraCommandData
    {
    public:
        using Base = CameraCommandData;
        static constexpr Kind KIND = Kind::CameraCommandSetWiper;
    private:
        bool enabled_ = false;
    public:
        CameraCommandSetWiperData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(enabled_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(enabled_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<CameraCommandSetWiperData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<CameraCommandSetWiperData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const CameraCommandSetWiperData& >( other );
                if ( dataObject.enabled_ != enabled_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
    };
    class CameraCommandStopData : public CameraCommandData
    {
    public:
        using Base = CameraCommandData;
        static constexpr Kind KIND = Kind::CameraCommandStop;
    private:
        bool panTilt_ = false;
        bool zoom_ = false;
    public:
        CameraCommandStopData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(panTilt_);
            destination.Write(zoom_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(panTilt_);
            source.Read(zoom_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<CameraCommandStopData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<CameraCommandStopData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const CameraCommandStopData& >( other );
                if ( dataObject.panTilt_ != panTilt_ )
                {
                    return false;
                }
                if ( dataObject.zoom_ != zoom_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
    };
    class CameraCommandReplyData : public BaseData<Kind, Guid>
    {
    public:
        using Base = BaseData<Kind, Guid>;
        static constexpr Kind KIND = Kind::CameraCommandReply;
    private:
        Int64 rowVersion_ = 0;
        Guid camera_;
        DateTime timestamp_;
        Guid command_;
        Data::DeviceCommandReplyStatus status_ = Data::DeviceCommandReplyStatus::Unknown;
        WideString message_;
        SQLLEN messageLength_ = SQL_NULL_DATA;
        double panAngle_ = 0.0;
        double tiltAngle_ = 0.0;
        double focalLength_ = 0.0;
    public:
        CameraCommandReplyData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(rowVersion_);
            destination.Write(camera_);
            destination.Write(timestamp_);
            destination.Write(command_);
            destination.Write(status_);
            destination.Write(message_);
            destination.Write(panAngle_);
            destination.Write(tiltAngle_);
            destination.Write(focalLength_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(rowVersion_);
            source.Read(camera_);
            source.Read(timestamp_);
            source.Read(command_);
            source.Read(status_);
            source.Read(message_);
            source.Read(panAngle_);
            source.Read(tiltAngle_);
            source.Read(focalLength_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<CameraCommandReplyData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<CameraCommandReplyData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const CameraCommandReplyData& >( other );
                if ( dataObject.rowVersion_ != rowVersion_ )
                {
                    return false;
                }
                if ( dataObject.camera_ != camera_ )
                {
                    return false;
                }
                if ( dataObject.timestamp_ != timestamp_ )
                {
                    return false;
                }
                if ( dataObject.command_ != command_ )
                {
                    return false;
                }
                if ( dataObject.status_ != status_ )
                {
                    return false;
                }
                if ( dataObject.message_ != message_ )
                {
                    return false;
                }
                if ( dataObject.panAngle_ != panAngle_ )
                {
                    return false;
                }
                if ( dataObject.tiltAngle_ != tiltAngle_ )
                {
                    return false;
                }
                if ( dataObject.focalLength_ != focalLength_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
    };
    class CameraConfigurationData : public BaseData<Kind, Guid>
    {
    public:
        using Base = BaseData<Kind, Guid>;
        static constexpr Kind KIND = Kind::CameraConfiguration;
    private:
        Int64 rowVersion_ = 0;
        Guid camera_;
        DateTime timestamp_;
        Data::CameraControlProtocol cameraControlProtocol_ = Data::CameraControlProtocol::Unknown;
        FixedDBWideString<127> cameraAddress_;
        Int32 cameraPort_ = 0;
        FixedDBWideString<127> cameraControlAddress_;
        Int32 cameraControlPort_ = 0;
        FixedDBWideString<127> cameraUserName_;
        FixedDBWideString<127> cameraPassword_;
        bool useRtspUriOverride_ = false;
        FixedDBWideString<127> rtspUriOverride_;
        double latitude_ = 0.0;
        double longitude_ = 0.0;
        double altitude_ = 0.0;
        bool useRelativePosition_ = false;
        double azimuthFromGPS_ = 0.0;
        double distanceFromGPS_ = 0.0;
        Data::CameraPanTiltMode panTiltMode_ = Data::CameraPanTiltMode::Unknown;
        double minTiltAngle_ = 0.0;
        double maxTiltAngle_ = 0.0;
        double minTiltScaleAngle_ = 0.0;
        double maxTiltScaleAngle_ = 0.0;
        bool useReverseTiltAngle_ = false;
        bool useReverseNormalizedTiltAngle_ = false;
        double minTiltVelocity_ = 0.0;
        double maxTiltVelocity_ = 0.0;
        double minTiltSpeed_ = 0.0;
        double maxTiltSpeed_ = 0.0;
        double minPanAngle_ = 0.0;
        double maxPanAngle_ = 0.0;
        double minPanScaleAngle_ = 0.0;
        double maxPanScaleAngle_ = 0.0;
        bool useReversePanAngle_ = false;
        bool useReverseNormalizedPanAngle_ = false;
        double minPanVelocity_ = 0.0;
        double maxPanVelocity_ = 0.0;
        double minPanSpeed_ = 0.0;
        double maxPanSpeed_ = 0.0;
        Data::CameraFocalLengthMode focalLengthMode_ = Data::CameraFocalLengthMode::Unknown;
        double minFocalLength_ = 0.0;
        double maxFocalLength_ = 0.0;
        double minFocalLengthScale_ = 0.0;
        double maxFocalLengthScale_ = 0.0;
        double minZoomVelocity_ = 0.0;
        double maxZoomVelocity_ = 0.0;
        double minZoomSpeed_ = 0.0;
        double maxZoomSpeed_ = 0.0;
        double imageSensorWidth_ = 0.0;
        double imageSensorHeight_ = 0.0;
        double homePanAngle_ = 0.0;
        double homeTiltAngle_ = 0.0;
        double homeFocalLength_ = 0.0;
        double panOffset_ = 0.0;
        double tiltOffset_ = 0.0;
        double aimAltitude_ = 0.0;
        double minimumTargetWidth_ = 0.0;
        TimeSpan targetLockTimeout_;
        TimeSpan updateStatusInterval_;
        TimeSpan readTimeout_;
        TimeSpan moveCommandStatusDelay_;
        FixedDBWideString<127> ptzProfileName_;
        FixedDBWideString<127> ptzConfigurationToken_;
        FixedDBWideString<127> videoSourceToken_;
    public:
        CameraConfigurationData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(rowVersion_);
            destination.Write(camera_);
            destination.Write(timestamp_);
            destination.Write(cameraControlProtocol_);
            cameraAddress_.WriteTo( destination );
            destination.Write(cameraPort_);
            cameraControlAddress_.WriteTo( destination );
            destination.Write(cameraControlPort_);
            cameraUserName_.WriteTo( destination );
            cameraPassword_.WriteTo( destination );
            destination.Write(useRtspUriOverride_);
            rtspUriOverride_.WriteTo( destination );
            destination.Write(latitude_);
            destination.Write(longitude_);
            destination.Write(altitude_);
            destination.Write(useRelativePosition_);
            destination.Write(azimuthFromGPS_);
            destination.Write(distanceFromGPS_);
            destination.Write(panTiltMode_);
            destination.Write(minTiltAngle_);
            destination.Write(maxTiltAngle_);
            destination.Write(minTiltScaleAngle_);
            destination.Write(maxTiltScaleAngle_);
            destination.Write(useReverseTiltAngle_);
            destination.Write(useReverseNormalizedTiltAngle_);
            destination.Write(minTiltVelocity_);
            destination.Write(maxTiltVelocity_);
            destination.Write(minTiltSpeed_);
            destination.Write(maxTiltSpeed_);
            destination.Write(minPanAngle_);
            destination.Write(maxPanAngle_);
            destination.Write(minPanScaleAngle_);
            destination.Write(maxPanScaleAngle_);
            destination.Write(useReversePanAngle_);
            destination.Write(useReverseNormalizedPanAngle_);
            destination.Write(minPanVelocity_);
            destination.Write(maxPanVelocity_);
            destination.Write(minPanSpeed_);
            destination.Write(maxPanSpeed_);
            destination.Write(focalLengthMode_);
            destination.Write(minFocalLength_);
            destination.Write(maxFocalLength_);
            destination.Write(minFocalLengthScale_);
            destination.Write(maxFocalLengthScale_);
            destination.Write(minZoomVelocity_);
            destination.Write(maxZoomVelocity_);
            destination.Write(minZoomSpeed_);
            destination.Write(maxZoomSpeed_);
            destination.Write(imageSensorWidth_);
            destination.Write(imageSensorHeight_);
            destination.Write(homePanAngle_);
            destination.Write(homeTiltAngle_);
            destination.Write(homeFocalLength_);
            destination.Write(panOffset_);
            destination.Write(tiltOffset_);
            destination.Write(aimAltitude_);
            destination.Write(minimumTargetWidth_);
            destination.Write(targetLockTimeout_);
            destination.Write(updateStatusInterval_);
            destination.Write(readTimeout_);
            destination.Write(moveCommandStatusDelay_);
            ptzProfileName_.WriteTo( destination );
            ptzConfigurationToken_.WriteTo( destination );
            videoSourceToken_.WriteTo( destination );
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(rowVersion_);
            source.Read(camera_);
            source.Read(timestamp_);
            source.Read(cameraControlProtocol_);
            cameraAddress_.ReadFrom( source );
            source.Read(cameraPort_);
            cameraControlAddress_.ReadFrom( source );
            source.Read(cameraControlPort_);
            cameraUserName_.ReadFrom( source );
            cameraPassword_.ReadFrom( source );
            source.Read(useRtspUriOverride_);
            rtspUriOverride_.ReadFrom( source );
            source.Read(latitude_);
            source.Read(longitude_);
            source.Read(altitude_);
            source.Read(useRelativePosition_);
            source.Read(azimuthFromGPS_);
            source.Read(distanceFromGPS_);
            source.Read(panTiltMode_);
            source.Read(minTiltAngle_);
            source.Read(maxTiltAngle_);
            source.Read(minTiltScaleAngle_);
            source.Read(maxTiltScaleAngle_);
            source.Read(useReverseTiltAngle_);
            source.Read(useReverseNormalizedTiltAngle_);
            source.Read(minTiltVelocity_);
            source.Read(maxTiltVelocity_);
            source.Read(minTiltSpeed_);
            source.Read(maxTiltSpeed_);
            source.Read(minPanAngle_);
            source.Read(maxPanAngle_);
            source.Read(minPanScaleAngle_);
            source.Read(maxPanScaleAngle_);
            source.Read(useReversePanAngle_);
            source.Read(useReverseNormalizedPanAngle_);
            source.Read(minPanVelocity_);
            source.Read(maxPanVelocity_);
            source.Read(minPanSpeed_);
            source.Read(maxPanSpeed_);
            source.Read(focalLengthMode_);
            source.Read(minFocalLength_);
            source.Read(maxFocalLength_);
            source.Read(minFocalLengthScale_);
            source.Read(maxFocalLengthScale_);
            source.Read(minZoomVelocity_);
            source.Read(maxZoomVelocity_);
            source.Read(minZoomSpeed_);
            source.Read(maxZoomSpeed_);
            source.Read(imageSensorWidth_);
            source.Read(imageSensorHeight_);
            source.Read(homePanAngle_);
            source.Read(homeTiltAngle_);
            source.Read(homeFocalLength_);
            source.Read(panOffset_);
            source.Read(tiltOffset_);
            source.Read(aimAltitude_);
            source.Read(minimumTargetWidth_);
            source.Read(targetLockTimeout_);
            source.Read(updateStatusInterval_);
            source.Read(readTimeout_);
            source.Read(moveCommandStatusDelay_);
            ptzProfileName_.ReadFrom( source );
            ptzConfigurationToken_.ReadFrom( source );
            videoSourceToken_.ReadFrom( source );
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<CameraConfigurationData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<CameraConfigurationData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const CameraConfigurationData& >( other );
                if ( dataObject.rowVersion_ != rowVersion_ )
                {
                    return false;
                }
                if ( dataObject.camera_ != camera_ )
                {
                    return false;
                }
                if ( dataObject.timestamp_ != timestamp_ )
                {
                    return false;
                }
                if ( dataObject.cameraControlProtocol_ != cameraControlProtocol_ )
                {
                    return false;
                }
                if ( dataObject.cameraAddress_ != cameraAddress_ )
                {
                    return false;
                }
                if ( dataObject.cameraPort_ != cameraPort_ )
                {
                    return false;
                }
                if ( dataObject.cameraControlAddress_ != cameraControlAddress_ )
                {
                    return false;
                }
                if ( dataObject.cameraControlPort_ != cameraControlPort_ )
                {
                    return false;
                }
                if ( dataObject.cameraUserName_ != cameraUserName_ )
                {
                    return false;
                }
                if ( dataObject.cameraPassword_ != cameraPassword_ )
                {
                    return false;
                }
                if ( dataObject.useRtspUriOverride_ != useRtspUriOverride_ )
                {
                    return false;
                }
                if ( dataObject.rtspUriOverride_ != rtspUriOverride_ )
                {
                    return false;
                }
                if ( dataObject.latitude_ != latitude_ )
                {
                    return false;
                }
                if ( dataObject.longitude_ != longitude_ )
                {
                    return false;
                }
                if ( dataObject.altitude_ != altitude_ )
                {
                    return false;
                }
                if ( dataObject.useRelativePosition_ != useRelativePosition_ )
                {
                    return false;
                }
                if ( dataObject.azimuthFromGPS_ != azimuthFromGPS_ )
                {
                    return false;
                }
                if ( dataObject.distanceFromGPS_ != distanceFromGPS_ )
                {
                    return false;
                }
                if ( dataObject.panTiltMode_ != panTiltMode_ )
                {
                    return false;
                }
                if ( dataObject.minTiltAngle_ != minTiltAngle_ )
                {
                    return false;
                }
                if ( dataObject.maxTiltAngle_ != maxTiltAngle_ )
                {
                    return false;
                }
                if ( dataObject.minTiltScaleAngle_ != minTiltScaleAngle_ )
                {
                    return false;
                }
                if ( dataObject.maxTiltScaleAngle_ != maxTiltScaleAngle_ )
                {
                    return false;
                }
                if ( dataObject.useReverseTiltAngle_ != useReverseTiltAngle_ )
                {
                    return false;
                }
                if ( dataObject.useReverseNormalizedTiltAngle_ != useReverseNormalizedTiltAngle_ )
                {
                    return false;
                }
                if ( dataObject.minTiltVelocity_ != minTiltVelocity_ )
                {
                    return false;
                }
                if ( dataObject.maxTiltVelocity_ != maxTiltVelocity_ )
                {
                    return false;
                }
                if ( dataObject.minTiltSpeed_ != minTiltSpeed_ )
                {
                    return false;
                }
                if ( dataObject.maxTiltSpeed_ != maxTiltSpeed_ )
                {
                    return false;
                }
                if ( dataObject.minPanAngle_ != minPanAngle_ )
                {
                    return false;
                }
                if ( dataObject.maxPanAngle_ != maxPanAngle_ )
                {
                    return false;
                }
                if ( dataObject.minPanScaleAngle_ != minPanScaleAngle_ )
                {
                    return false;
                }
                if ( dataObject.maxPanScaleAngle_ != maxPanScaleAngle_ )
                {
                    return false;
                }
                if ( dataObject.useReversePanAngle_ != useReversePanAngle_ )
                {
                    return false;
                }
                if ( dataObject.useReverseNormalizedPanAngle_ != useReverseNormalizedPanAngle_ )
                {
                    return false;
                }
                if ( dataObject.minPanVelocity_ != minPanVelocity_ )
                {
                    return false;
                }
                if ( dataObject.maxPanVelocity_ != maxPanVelocity_ )
                {
                    return false;
                }
                if ( dataObject.minPanSpeed_ != minPanSpeed_ )
                {
                    return false;
                }
                if ( dataObject.maxPanSpeed_ != maxPanSpeed_ )
                {
                    return false;
                }
                if ( dataObject.focalLengthMode_ != focalLengthMode_ )
                {
                    return false;
                }
                if ( dataObject.minFocalLength_ != minFocalLength_ )
                {
                    return false;
                }
                if ( dataObject.maxFocalLength_ != maxFocalLength_ )
                {
                    return false;
                }
                if ( dataObject.minFocalLengthScale_ != minFocalLengthScale_ )
                {
                    return false;
                }
                if ( dataObject.maxFocalLengthScale_ != maxFocalLengthScale_ )
                {
                    return false;
                }
                if ( dataObject.minZoomVelocity_ != minZoomVelocity_ )
                {
                    return false;
                }
                if ( dataObject.maxZoomVelocity_ != maxZoomVelocity_ )
                {
                    return false;
                }
                if ( dataObject.minZoomSpeed_ != minZoomSpeed_ )
                {
                    return false;
                }
                if ( dataObject.maxZoomSpeed_ != maxZoomSpeed_ )
                {
                    return false;
                }
                if ( dataObject.imageSensorWidth_ != imageSensorWidth_ )
                {
                    return false;
                }
                if ( dataObject.imageSensorHeight_ != imageSensorHeight_ )
                {
                    return false;
                }
                if ( dataObject.homePanAngle_ != homePanAngle_ )
                {
                    return false;
                }
                if ( dataObject.homeTiltAngle_ != homeTiltAngle_ )
                {
                    return false;
                }
                if ( dataObject.homeFocalLength_ != homeFocalLength_ )
                {
                    return false;
                }
                if ( dataObject.panOffset_ != panOffset_ )
                {
                    return false;
                }
                if ( dataObject.tiltOffset_ != tiltOffset_ )
                {
                    return false;
                }
                if ( dataObject.aimAltitude_ != aimAltitude_ )
                {
                    return false;
                }
                if ( dataObject.minimumTargetWidth_ != minimumTargetWidth_ )
                {
                    return false;
                }
                if ( dataObject.targetLockTimeout_ != targetLockTimeout_ )
                {
                    return false;
                }
                if ( dataObject.updateStatusInterval_ != updateStatusInterval_ )
                {
                    return false;
                }
                if ( dataObject.readTimeout_ != readTimeout_ )
                {
                    return false;
                }
                if ( dataObject.moveCommandStatusDelay_ != moveCommandStatusDelay_ )
                {
                    return false;
                }
                if ( dataObject.ptzProfileName_ != ptzProfileName_ )
                {
                    return false;
                }
                if ( dataObject.ptzConfigurationToken_ != ptzConfigurationToken_ )
                {
                    return false;
                }
                if ( dataObject.videoSourceToken_ != videoSourceToken_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
    };
    class CameraPanCalibrationData : public BaseData<Kind, Guid>
    {
    public:
        using Base = BaseData<Kind, Guid>;
        static constexpr Kind KIND = Kind::CameraPanCalibration;
    private:
        Int64 rowVersion_ = 0;
        Guid camera_;
        DateTime timestamp_;
    public:
        CameraPanCalibrationData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(rowVersion_);
            destination.Write(camera_);
            destination.Write(timestamp_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(rowVersion_);
            source.Read(camera_);
            source.Read(timestamp_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<CameraPanCalibrationData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<CameraPanCalibrationData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const CameraPanCalibrationData& >( other );
                if ( dataObject.rowVersion_ != rowVersion_ )
                {
                    return false;
                }
                if ( dataObject.camera_ != camera_ )
                {
                    return false;
                }
                if ( dataObject.timestamp_ != timestamp_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
    };
    class CameraPanCalibrationValueData : public BaseData<Kind, Guid>
    {
    public:
        using Base = BaseData<Kind, Guid>;
        static constexpr Kind KIND = Kind::CameraPanCalibrationValue;
    private:
        Int64 rowVersion_ = 0;
        Guid panCalibration_;
        double panAngle_ = 0.0;
        double panOffset_ = 0.0;
    public:
        CameraPanCalibrationValueData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(rowVersion_);
            destination.Write(panCalibration_);
            destination.Write(panAngle_);
            destination.Write(panOffset_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(rowVersion_);
            source.Read(panCalibration_);
            source.Read(panAngle_);
            source.Read(panOffset_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<CameraPanCalibrationValueData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<CameraPanCalibrationValueData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const CameraPanCalibrationValueData& >( other );
                if ( dataObject.rowVersion_ != rowVersion_ )
                {
                    return false;
                }
                if ( dataObject.panCalibration_ != panCalibration_ )
                {
                    return false;
                }
                if ( dataObject.panAngle_ != panAngle_ )
                {
                    return false;
                }
                if ( dataObject.panOffset_ != panOffset_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
    };
    class CameraStatusData : public BaseData<Kind, Guid>
    {
    public:
        using Base = BaseData<Kind, Guid>;
        static constexpr Kind KIND = Kind::CameraStatus;
    private:
        Int64 rowVersion_ = 0;
        Guid camera_;
        Guid track_;
        DateTime timestamp_;
        Data::CameraPanTiltMode positionPanTiltMode_ = Data::CameraPanTiltMode::Unknown;
        double panAngle_ = 0.0;
        double tiltAngle_ = 0.0;
        Data::CameraFocalLengthMode positionFocalLengthMode_ = Data::CameraFocalLengthMode::Unknown;
        double focalLength_ = 0.0;
        Data::CameraMoveStatus panTiltMoveStatus_ = Data::CameraMoveStatus::Unknown;
        Data::CameraMoveStatus zoomMoveStatus_ = Data::CameraMoveStatus::Unknown;
        Data::CameraPanTiltMode velocityPanTiltMode_ = Data::CameraPanTiltMode::Unknown;
        DBDouble panVelocity_;
        DBDouble tiltVelocity_;
        Data::CameraFocalLengthMode velocityFocalLengthMode_ = Data::CameraFocalLengthMode::Unknown;
        DBDouble zoomVelocity_;
        Data::CameraFeatures activeFeatures_ = Data::CameraFeatures::None;
        WideString error_;
        SQLLEN errorLength_ = SQL_NULL_DATA;
    public:
        CameraStatusData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(rowVersion_);
            destination.Write(camera_);
            destination.Write(track_);
            destination.Write(timestamp_);
            destination.Write(positionPanTiltMode_);
            destination.Write(panAngle_);
            destination.Write(tiltAngle_);
            destination.Write(positionFocalLengthMode_);
            destination.Write(focalLength_);
            destination.Write(panTiltMoveStatus_);
            destination.Write(zoomMoveStatus_);
            destination.Write(velocityPanTiltMode_);
            panVelocity_.WriteTo( destination );
            tiltVelocity_.WriteTo( destination );
            destination.Write(velocityFocalLengthMode_);
            zoomVelocity_.WriteTo( destination );
            destination.Write(activeFeatures_);
            destination.Write(error_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(rowVersion_);
            source.Read(camera_);
            source.Read(track_);
            source.Read(timestamp_);
            source.Read(positionPanTiltMode_);
            source.Read(panAngle_);
            source.Read(tiltAngle_);
            source.Read(positionFocalLengthMode_);
            source.Read(focalLength_);
            source.Read(panTiltMoveStatus_);
            source.Read(zoomMoveStatus_);
            source.Read(velocityPanTiltMode_);
            panVelocity_.ReadFrom( source );
            tiltVelocity_.ReadFrom( source );
            source.Read(velocityFocalLengthMode_);
            zoomVelocity_.ReadFrom( source );
            source.Read(activeFeatures_);
            source.Read(error_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<CameraStatusData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<CameraStatusData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const CameraStatusData& >( other );
                if ( dataObject.rowVersion_ != rowVersion_ )
                {
                    return false;
                }
                if ( dataObject.camera_ != camera_ )
                {
                    return false;
                }
                if ( dataObject.track_ != track_ )
                {
                    return false;
                }
                if ( dataObject.timestamp_ != timestamp_ )
                {
                    return false;
                }
                if ( dataObject.positionPanTiltMode_ != positionPanTiltMode_ )
                {
                    return false;
                }
                if ( dataObject.panAngle_ != panAngle_ )
                {
                    return false;
                }
                if ( dataObject.tiltAngle_ != tiltAngle_ )
                {
                    return false;
                }
                if ( dataObject.positionFocalLengthMode_ != positionFocalLengthMode_ )
                {
                    return false;
                }
                if ( dataObject.focalLength_ != focalLength_ )
                {
                    return false;
                }
                if ( dataObject.panTiltMoveStatus_ != panTiltMoveStatus_ )
                {
                    return false;
                }
                if ( dataObject.zoomMoveStatus_ != zoomMoveStatus_ )
                {
                    return false;
                }
                if ( dataObject.velocityPanTiltMode_ != velocityPanTiltMode_ )
                {
                    return false;
                }
                if ( dataObject.panVelocity_ != panVelocity_ )
                {
                    return false;
                }
                if ( dataObject.tiltVelocity_ != tiltVelocity_ )
                {
                    return false;
                }
                if ( dataObject.velocityFocalLengthMode_ != velocityFocalLengthMode_ )
                {
                    return false;
                }
                if ( dataObject.zoomVelocity_ != zoomVelocity_ )
                {
                    return false;
                }
                if ( dataObject.activeFeatures_ != activeFeatures_ )
                {
                    return false;
                }
                if ( dataObject.error_ != error_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
    };
    class CameraTiltCalibrationData : public BaseData<Kind, Guid>
    {
    public:
        using Base = BaseData<Kind, Guid>;
        static constexpr Kind KIND = Kind::CameraTiltCalibration;
    private:
        Int64 rowVersion_ = 0;
        Guid camera_;
        DateTime timestamp_;
    public:
        CameraTiltCalibrationData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(rowVersion_);
            destination.Write(camera_);
            destination.Write(timestamp_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(rowVersion_);
            source.Read(camera_);
            source.Read(timestamp_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<CameraTiltCalibrationData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<CameraTiltCalibrationData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const CameraTiltCalibrationData& >( other );
                if ( dataObject.rowVersion_ != rowVersion_ )
                {
                    return false;
                }
                if ( dataObject.camera_ != camera_ )
                {
                    return false;
                }
                if ( dataObject.timestamp_ != timestamp_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
    };
    class CameraTiltCalibrationValueData : public BaseData<Kind, Guid>
    {
    public:
        using Base = BaseData<Kind, Guid>;
        static constexpr Kind KIND = Kind::CameraTiltCalibrationValue;
    private:
        Int64 rowVersion_ = 0;
        Guid tiltCalibration_;
        double panAngle_ = 0.0;
        double tiltOffset_ = 0.0;
    public:
        CameraTiltCalibrationValueData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(rowVersion_);
            destination.Write(tiltCalibration_);
            destination.Write(panAngle_);
            destination.Write(tiltOffset_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(rowVersion_);
            source.Read(tiltCalibration_);
            source.Read(panAngle_);
            source.Read(tiltOffset_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<CameraTiltCalibrationValueData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<CameraTiltCalibrationValueData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const CameraTiltCalibrationValueData& >( other );
                if ( dataObject.rowVersion_ != rowVersion_ )
                {
                    return false;
                }
                if ( dataObject.tiltCalibration_ != tiltCalibration_ )
                {
                    return false;
                }
                if ( dataObject.panAngle_ != panAngle_ )
                {
                    return false;
                }
                if ( dataObject.tiltOffset_ != tiltOffset_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
    };
    class CameraZoomCalibrationData : public BaseData<Kind, Guid>
    {
    public:
        using Base = BaseData<Kind, Guid>;
        static constexpr Kind KIND = Kind::CameraZoomCalibration;
    private:
        Int64 rowVersion_ = 0;
        Guid camera_;
        DateTime timestamp_;
    public:
        CameraZoomCalibrationData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(rowVersion_);
            destination.Write(camera_);
            destination.Write(timestamp_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(rowVersion_);
            source.Read(camera_);
            source.Read(timestamp_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<CameraZoomCalibrationData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<CameraZoomCalibrationData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const CameraZoomCalibrationData& >( other );
                if ( dataObject.rowVersion_ != rowVersion_ )
                {
                    return false;
                }
                if ( dataObject.camera_ != camera_ )
                {
                    return false;
                }
                if ( dataObject.timestamp_ != timestamp_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
    };
    class CameraZoomCalibrationValueData : public BaseData<Kind, Guid>
    {
    public:
        using Base = BaseData<Kind, Guid>;
        static constexpr Kind KIND = Kind::CameraZoomCalibrationValue;
    private:
        Int64 rowVersion_ = 0;
        Guid zoomCalibration_;
        double focalLength_ = 0.0;
        double focalLengthOffset_ = 0.0;
    public:
        CameraZoomCalibrationValueData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(rowVersion_);
            destination.Write(zoomCalibration_);
            destination.Write(focalLength_);
            destination.Write(focalLengthOffset_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(rowVersion_);
            source.Read(zoomCalibration_);
            source.Read(focalLength_);
            source.Read(focalLengthOffset_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<CameraZoomCalibrationValueData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<CameraZoomCalibrationValueData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const CameraZoomCalibrationValueData& >( other );
                if ( dataObject.rowVersion_ != rowVersion_ )
                {
                    return false;
                }
                if ( dataObject.zoomCalibration_ != zoomCalibration_ )
                {
                    return false;
                }
                if ( dataObject.focalLength_ != focalLength_ )
                {
                    return false;
                }
                if ( dataObject.focalLengthOffset_ != focalLengthOffset_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
    };
    class CatalogElementData : public BaseData<Kind, Guid>
    {
    public:
        using Base = BaseData<Kind, Guid>;
        static constexpr Kind KIND = Kind::CatalogElement;
    private:
        Int64 rowVersion_ = 0;
        Guid catalog_;
        FixedDBWideString<127> name_;
    public:
        CatalogElementData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(rowVersion_);
            destination.Write(catalog_);
            name_.WriteTo( destination );
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(rowVersion_);
            source.Read(catalog_);
            name_.ReadFrom( source );
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<CatalogElementData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<CatalogElementData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const CatalogElementData& >( other );
                if ( dataObject.rowVersion_ != rowVersion_ )
                {
                    return false;
                }
                if ( dataObject.catalog_ != catalog_ )
                {
                    return false;
                }
                if ( dataObject.name_ != name_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
    };
    class CatalogData : public CatalogElementData
    {
    public:
        using Base = CatalogElementData;
        static constexpr Kind KIND = Kind::Catalog;
    private:
    public:
        CatalogData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<CatalogData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<CatalogData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const CatalogData& >( other );
                return true;
            }
            return false;
        }
    };
    class ElementData : public CatalogElementData
    {
    public:
        using Base = CatalogElementData;
        static constexpr Kind KIND = Kind::Element;
    private:
        Guid elementType_;
    public:
        ElementData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(elementType_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(elementType_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<ElementData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<ElementData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const ElementData& >( other );
                if ( dataObject.elementType_ != elementType_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
    };
    class CollectionInfoData : public BaseData<Kind, Guid>
    {
    public:
        using Base = BaseData<Kind, Guid>;
        static constexpr Kind KIND = Kind::CollectionInfo;
    private:
        Int64 rowVersion_ = 0;
        Int64 count_ = 0;
    public:
        CollectionInfoData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(rowVersion_);
            destination.Write(count_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(rowVersion_);
            source.Read(count_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<CollectionInfoData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<CollectionInfoData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const CollectionInfoData& >( other );
                if ( dataObject.rowVersion_ != rowVersion_ )
                {
                    return false;
                }
                if ( dataObject.count_ != count_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
    };
    class CountryData : public BaseData<Kind, Guid>
    {
    public:
        using Base = BaseData<Kind, Guid>;
        static constexpr Kind KIND = Kind::Country;
    private:
        Int64 rowVersion_ = 0;
        FixedDBWideString<127> name_;
        Int32 code_ = 0;
        FixedDBWideString<2> alpha2_;
        FixedDBWideString<3> alpha3_;
    public:
        CountryData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(rowVersion_);
            name_.WriteTo( destination );
            destination.Write(code_);
            alpha2_.WriteTo( destination );
            alpha3_.WriteTo( destination );
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(rowVersion_);
            name_.ReadFrom( source );
            source.Read(code_);
            alpha2_.ReadFrom( source );
            alpha3_.ReadFrom( source );
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<CountryData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<CountryData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const CountryData& >( other );
                if ( dataObject.rowVersion_ != rowVersion_ )
                {
                    return false;
                }
                if ( dataObject.name_ != name_ )
                {
                    return false;
                }
                if ( dataObject.code_ != code_ )
                {
                    return false;
                }
                if ( dataObject.alpha2_ != alpha2_ )
                {
                    return false;
                }
                if ( dataObject.alpha3_ != alpha3_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
    };
    class CursorInfoData : public BaseData<Kind, Guid>
    {
    public:
        using Base = BaseData<Kind, Guid>;
        static constexpr Kind KIND = Kind::CursorInfo;
    private:
        Int64 rowVersion_ = 0;
        Int32 typeCode_ = 0;
    public:
        CursorInfoData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(rowVersion_);
            destination.Write(typeCode_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(rowVersion_);
            source.Read(typeCode_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<CursorInfoData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<CursorInfoData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const CursorInfoData& >( other );
                if ( dataObject.rowVersion_ != rowVersion_ )
                {
                    return false;
                }
                if ( dataObject.typeCode_ != typeCode_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
    };
    class DateTimeTimeseriesValueData : public BaseData<Kind, Guid>
    {
    public:
        using Base = BaseData<Kind, Guid>;
        static constexpr Kind KIND = Kind::DateTimeTimeseriesValue;
    private:
        Int64 rowVersion_ = 0;
        Guid timeseries_;
        DateTime timestamp_;
        DBDateTime value_;
    public:
        DateTimeTimeseriesValueData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(rowVersion_);
            destination.Write(timeseries_);
            destination.Write(timestamp_);
            value_.WriteTo( destination );
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(rowVersion_);
            source.Read(timeseries_);
            source.Read(timestamp_);
            value_.ReadFrom( source );
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<DateTimeTimeseriesValueData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<DateTimeTimeseriesValueData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const DateTimeTimeseriesValueData& >( other );
                if ( dataObject.rowVersion_ != rowVersion_ )
                {
                    return false;
                }
                if ( dataObject.timeseries_ != timeseries_ )
                {
                    return false;
                }
                if ( dataObject.timestamp_ != timestamp_ )
                {
                    return false;
                }
                if ( dataObject.value_ != value_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
    };
    class DeviceHostData : public BaseData<Kind, Guid>
    {
    public:
        using Base = BaseData<Kind, Guid>;
        static constexpr Kind KIND = Kind::DeviceHost;
    private:
        Int64 rowVersion_ = 0;
        FixedDBWideString<127> name_;
    public:
        DeviceHostData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(rowVersion_);
            name_.WriteTo( destination );
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(rowVersion_);
            name_.ReadFrom( source );
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<DeviceHostData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<DeviceHostData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const DeviceHostData& >( other );
                if ( dataObject.rowVersion_ != rowVersion_ )
                {
                    return false;
                }
                if ( dataObject.name_ != name_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
    };
    class DeviceHostConfigurationData : public BaseData<Kind, Guid>
    {
    public:
        using Base = BaseData<Kind, Guid>;
        static constexpr Kind KIND = Kind::DeviceHostConfiguration;
    private:
        Int64 rowVersion_ = 0;
        Guid host_;
        DateTime timestamp_;
        FixedDBWideString<127> hostname_;
        Int32 port_ = 0;
        FixedDBWideString<100> queueName_;
    public:
        DeviceHostConfigurationData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(rowVersion_);
            destination.Write(host_);
            destination.Write(timestamp_);
            hostname_.WriteTo( destination );
            destination.Write(port_);
            queueName_.WriteTo( destination );
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(rowVersion_);
            source.Read(host_);
            source.Read(timestamp_);
            hostname_.ReadFrom( source );
            source.Read(port_);
            queueName_.ReadFrom( source );
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<DeviceHostConfigurationData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<DeviceHostConfigurationData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const DeviceHostConfigurationData& >( other );
                if ( dataObject.rowVersion_ != rowVersion_ )
                {
                    return false;
                }
                if ( dataObject.host_ != host_ )
                {
                    return false;
                }
                if ( dataObject.timestamp_ != timestamp_ )
                {
                    return false;
                }
                if ( dataObject.hostname_ != hostname_ )
                {
                    return false;
                }
                if ( dataObject.port_ != port_ )
                {
                    return false;
                }
                if ( dataObject.queueName_ != queueName_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
    };
    class DeviceTypeData : public BaseData<Kind, Guid>
    {
    public:
        using Base = BaseData<Kind, Guid>;
        static constexpr Kind KIND = Kind::DeviceType;
    private:
        Int64 rowVersion_ = 0;
        FixedDBWideString<100> assemblyName_;
        FixedDBWideString<100> className_;
        FixedDBWideString<100> proxyAssemblyName_;
        FixedDBWideString<100> proxyClassName_;
    public:
        DeviceTypeData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(rowVersion_);
            assemblyName_.WriteTo( destination );
            className_.WriteTo( destination );
            proxyAssemblyName_.WriteTo( destination );
            proxyClassName_.WriteTo( destination );
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(rowVersion_);
            assemblyName_.ReadFrom( source );
            className_.ReadFrom( source );
            proxyAssemblyName_.ReadFrom( source );
            proxyClassName_.ReadFrom( source );
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<DeviceTypeData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<DeviceTypeData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const DeviceTypeData& >( other );
                if ( dataObject.rowVersion_ != rowVersion_ )
                {
                    return false;
                }
                if ( dataObject.assemblyName_ != assemblyName_ )
                {
                    return false;
                }
                if ( dataObject.className_ != className_ )
                {
                    return false;
                }
                if ( dataObject.proxyAssemblyName_ != proxyAssemblyName_ )
                {
                    return false;
                }
                if ( dataObject.proxyClassName_ != proxyClassName_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
    };
    class AisTransceiverTypeData : public DeviceTypeData
    {
    public:
        using Base = DeviceTypeData;
        static constexpr Kind KIND = Kind::AisTransceiverType;
    private:
        FixedDBWideString<127> name_;
    public:
        AisTransceiverTypeData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            name_.WriteTo( destination );
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            name_.ReadFrom( source );
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<AisTransceiverTypeData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<AisTransceiverTypeData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const AisTransceiverTypeData& >( other );
                if ( dataObject.name_ != name_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
    };
    class CameraTypeData : public DeviceTypeData
    {
    public:
        using Base = DeviceTypeData;
        static constexpr Kind KIND = Kind::CameraType;
    private:
        FixedDBWideString<127> name_;
        Data::CameraFeatures cameraFeatures_ = Data::CameraFeatures::None;
    public:
        CameraTypeData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            name_.WriteTo( destination );
            destination.Write(cameraFeatures_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            name_.ReadFrom( source );
            source.Read(cameraFeatures_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<CameraTypeData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<CameraTypeData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const CameraTypeData& >( other );
                if ( dataObject.name_ != name_ )
                {
                    return false;
                }
                if ( dataObject.cameraFeatures_ != cameraFeatures_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
    };
    class GNSSDeviceTypeData : public DeviceTypeData
    {
    public:
        using Base = DeviceTypeData;
        static constexpr Kind KIND = Kind::GNSSDeviceType;
    private:
        FixedDBWideString<127> name_;
    public:
        GNSSDeviceTypeData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            name_.WriteTo( destination );
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            name_.ReadFrom( source );
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<GNSSDeviceTypeData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<GNSSDeviceTypeData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const GNSSDeviceTypeData& >( other );
                if ( dataObject.name_ != name_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
    };
    class GyroDeviceTypeData : public DeviceTypeData
    {
    public:
        using Base = DeviceTypeData;
        static constexpr Kind KIND = Kind::GyroDeviceType;
    private:
        FixedDBWideString<127> name_;
    public:
        GyroDeviceTypeData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            name_.WriteTo( destination );
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            name_.ReadFrom( source );
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<GyroDeviceTypeData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<GyroDeviceTypeData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const GyroDeviceTypeData& >( other );
                if ( dataObject.name_ != name_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
    };
    class LineInputDeviceTypeData : public DeviceTypeData
    {
    public:
        using Base = DeviceTypeData;
        static constexpr Kind KIND = Kind::LineInputDeviceType;
    private:
        FixedDBWideString<127> name_;
    public:
        LineInputDeviceTypeData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            name_.WriteTo( destination );
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            name_.ReadFrom( source );
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<LineInputDeviceTypeData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<LineInputDeviceTypeData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const LineInputDeviceTypeData& >( other );
                if ( dataObject.name_ != name_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
    };
    class OilspillDetectorTypeData : public DeviceTypeData
    {
    public:
        using Base = DeviceTypeData;
        static constexpr Kind KIND = Kind::OilspillDetectorType;
    private:
        FixedDBWideString<127> name_;
    public:
        OilspillDetectorTypeData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            name_.WriteTo( destination );
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            name_.ReadFrom( source );
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<OilspillDetectorTypeData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<OilspillDetectorTypeData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const OilspillDetectorTypeData& >( other );
                if ( dataObject.name_ != name_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
    };
    class RadarTypeData : public DeviceTypeData
    {
    public:
        using Base = DeviceTypeData;
        static constexpr Kind KIND = Kind::RadarType;
    private:
        FixedDBWideString<127> name_;
        DBInt32 pulseShortMinusValue_;
        FixedDBWideString<50> pulseShortMinusDisplayText_;
        DBInt32 pulseShortValue_;
        FixedDBWideString<50> pulseShortDisplayText_;
        DBInt32 pulseShortPlusValue_;
        FixedDBWideString<50> pulseShortPlusDisplayText_;
        DBInt32 pulseMediumMinusValue_;
        FixedDBWideString<50> pulseMediumMinusDisplayText_;
        DBInt32 pulseMediumValue_;
        FixedDBWideString<50> pulseMediumDisplayText_;
        DBInt32 pulseMediumPlusValue_;
        FixedDBWideString<50> pulseMediumPlusDisplayText_;
        DBInt32 pulseLongMinusValue_;
        FixedDBWideString<50> pulseLongMinusDisplayText_;
        DBInt32 pulseLongValue_;
        FixedDBWideString<50> pulseLongDisplayText_;
        DBInt32 pulseLongPlusValue_;
        FixedDBWideString<50> pulseLongPlusDisplayText_;
    public:
        RadarTypeData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            name_.WriteTo( destination );
            pulseShortMinusValue_.WriteTo( destination );
            pulseShortMinusDisplayText_.WriteTo( destination );
            pulseShortValue_.WriteTo( destination );
            pulseShortDisplayText_.WriteTo( destination );
            pulseShortPlusValue_.WriteTo( destination );
            pulseShortPlusDisplayText_.WriteTo( destination );
            pulseMediumMinusValue_.WriteTo( destination );
            pulseMediumMinusDisplayText_.WriteTo( destination );
            pulseMediumValue_.WriteTo( destination );
            pulseMediumDisplayText_.WriteTo( destination );
            pulseMediumPlusValue_.WriteTo( destination );
            pulseMediumPlusDisplayText_.WriteTo( destination );
            pulseLongMinusValue_.WriteTo( destination );
            pulseLongMinusDisplayText_.WriteTo( destination );
            pulseLongValue_.WriteTo( destination );
            pulseLongDisplayText_.WriteTo( destination );
            pulseLongPlusValue_.WriteTo( destination );
            pulseLongPlusDisplayText_.WriteTo( destination );
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            name_.ReadFrom( source );
            pulseShortMinusValue_.ReadFrom( source );
            pulseShortMinusDisplayText_.ReadFrom( source );
            pulseShortValue_.ReadFrom( source );
            pulseShortDisplayText_.ReadFrom( source );
            pulseShortPlusValue_.ReadFrom( source );
            pulseShortPlusDisplayText_.ReadFrom( source );
            pulseMediumMinusValue_.ReadFrom( source );
            pulseMediumMinusDisplayText_.ReadFrom( source );
            pulseMediumValue_.ReadFrom( source );
            pulseMediumDisplayText_.ReadFrom( source );
            pulseMediumPlusValue_.ReadFrom( source );
            pulseMediumPlusDisplayText_.ReadFrom( source );
            pulseLongMinusValue_.ReadFrom( source );
            pulseLongMinusDisplayText_.ReadFrom( source );
            pulseLongValue_.ReadFrom( source );
            pulseLongDisplayText_.ReadFrom( source );
            pulseLongPlusValue_.ReadFrom( source );
            pulseLongPlusDisplayText_.ReadFrom( source );
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<RadarTypeData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<RadarTypeData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const RadarTypeData& >( other );
                if ( dataObject.name_ != name_ )
                {
                    return false;
                }
                if ( dataObject.pulseShortMinusValue_ != pulseShortMinusValue_ )
                {
                    return false;
                }
                if ( dataObject.pulseShortMinusDisplayText_ != pulseShortMinusDisplayText_ )
                {
                    return false;
                }
                if ( dataObject.pulseShortValue_ != pulseShortValue_ )
                {
                    return false;
                }
                if ( dataObject.pulseShortDisplayText_ != pulseShortDisplayText_ )
                {
                    return false;
                }
                if ( dataObject.pulseShortPlusValue_ != pulseShortPlusValue_ )
                {
                    return false;
                }
                if ( dataObject.pulseShortPlusDisplayText_ != pulseShortPlusDisplayText_ )
                {
                    return false;
                }
                if ( dataObject.pulseMediumMinusValue_ != pulseMediumMinusValue_ )
                {
                    return false;
                }
                if ( dataObject.pulseMediumMinusDisplayText_ != pulseMediumMinusDisplayText_ )
                {
                    return false;
                }
                if ( dataObject.pulseMediumValue_ != pulseMediumValue_ )
                {
                    return false;
                }
                if ( dataObject.pulseMediumDisplayText_ != pulseMediumDisplayText_ )
                {
                    return false;
                }
                if ( dataObject.pulseMediumPlusValue_ != pulseMediumPlusValue_ )
                {
                    return false;
                }
                if ( dataObject.pulseMediumPlusDisplayText_ != pulseMediumPlusDisplayText_ )
                {
                    return false;
                }
                if ( dataObject.pulseLongMinusValue_ != pulseLongMinusValue_ )
                {
                    return false;
                }
                if ( dataObject.pulseLongMinusDisplayText_ != pulseLongMinusDisplayText_ )
                {
                    return false;
                }
                if ( dataObject.pulseLongValue_ != pulseLongValue_ )
                {
                    return false;
                }
                if ( dataObject.pulseLongDisplayText_ != pulseLongDisplayText_ )
                {
                    return false;
                }
                if ( dataObject.pulseLongPlusValue_ != pulseLongPlusValue_ )
                {
                    return false;
                }
                if ( dataObject.pulseLongPlusDisplayText_ != pulseLongPlusDisplayText_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
    };
    class RadioTypeData : public DeviceTypeData
    {
    public:
        using Base = DeviceTypeData;
        static constexpr Kind KIND = Kind::RadioType;
    private:
        FixedDBWideString<127> name_;
    public:
        RadioTypeData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            name_.WriteTo( destination );
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            name_.ReadFrom( source );
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<RadioTypeData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<RadioTypeData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const RadioTypeData& >( other );
                if ( dataObject.name_ != name_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
    };
    class RadomeTypeData : public DeviceTypeData
    {
    public:
        using Base = DeviceTypeData;
        static constexpr Kind KIND = Kind::RadomeType;
    private:
        FixedDBWideString<127> name_;
    public:
        RadomeTypeData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            name_.WriteTo( destination );
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            name_.ReadFrom( source );
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<RadomeTypeData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<RadomeTypeData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const RadomeTypeData& >( other );
                if ( dataObject.name_ != name_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
    };
    class WeatherStationTypeData : public DeviceTypeData
    {
    public:
        using Base = DeviceTypeData;
        static constexpr Kind KIND = Kind::WeatherStationType;
    private:
        FixedDBWideString<127> name_;
    public:
        WeatherStationTypeData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            name_.WriteTo( destination );
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            name_.ReadFrom( source );
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<WeatherStationTypeData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<WeatherStationTypeData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const WeatherStationTypeData& >( other );
                if ( dataObject.name_ != name_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
    };
    class DoubleTimeseriesValueData : public BaseData<Kind, Guid>
    {
    public:
        using Base = BaseData<Kind, Guid>;
        static constexpr Kind KIND = Kind::DoubleTimeseriesValue;
    private:
        Int64 rowVersion_ = 0;
        Guid timeseries_;
        DateTime timestamp_;
        DBDouble value_;
    public:
        DoubleTimeseriesValueData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(rowVersion_);
            destination.Write(timeseries_);
            destination.Write(timestamp_);
            value_.WriteTo( destination );
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(rowVersion_);
            source.Read(timeseries_);
            source.Read(timestamp_);
            value_.ReadFrom( source );
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<DoubleTimeseriesValueData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<DoubleTimeseriesValueData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const DoubleTimeseriesValueData& >( other );
                if ( dataObject.rowVersion_ != rowVersion_ )
                {
                    return false;
                }
                if ( dataObject.timeseries_ != timeseries_ )
                {
                    return false;
                }
                if ( dataObject.timestamp_ != timestamp_ )
                {
                    return false;
                }
                if ( dataObject.value_ != value_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
    };
    class FacilityTypeData : public BaseData<Kind, Guid>
    {
    public:
        using Base = BaseData<Kind, Guid>;
        static constexpr Kind KIND = Kind::FacilityType;
    private:
        Int64 rowVersion_ = 0;
        FixedDBWideString<127> name_;
    public:
        FacilityTypeData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(rowVersion_);
            name_.WriteTo( destination );
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(rowVersion_);
            name_.ReadFrom( source );
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<FacilityTypeData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<FacilityTypeData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const FacilityTypeData& >( other );
                if ( dataObject.rowVersion_ != rowVersion_ )
                {
                    return false;
                }
                if ( dataObject.name_ != name_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
    };
    class GeoPosition2DTimeseriesValueData : public BaseData<Kind, Guid>
    {
    public:
        using Base = BaseData<Kind, Guid>;
        static constexpr Kind KIND = Kind::GeoPosition2DTimeseriesValue;
    private:
        Int64 rowVersion_ = 0;
        Guid timeseries_;
        DateTime timestamp_;
        DBDouble latitude_;
        DBDouble longitude_;
    public:
        GeoPosition2DTimeseriesValueData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(rowVersion_);
            destination.Write(timeseries_);
            destination.Write(timestamp_);
            latitude_.WriteTo( destination );
            longitude_.WriteTo( destination );
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(rowVersion_);
            source.Read(timeseries_);
            source.Read(timestamp_);
            latitude_.ReadFrom( source );
            longitude_.ReadFrom( source );
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<GeoPosition2DTimeseriesValueData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<GeoPosition2DTimeseriesValueData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const GeoPosition2DTimeseriesValueData& >( other );
                if ( dataObject.rowVersion_ != rowVersion_ )
                {
                    return false;
                }
                if ( dataObject.timeseries_ != timeseries_ )
                {
                    return false;
                }
                if ( dataObject.timestamp_ != timestamp_ )
                {
                    return false;
                }
                if ( dataObject.latitude_ != latitude_ )
                {
                    return false;
                }
                if ( dataObject.longitude_ != longitude_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
    };
    class GeoPosition3DTimeseriesValueData : public BaseData<Kind, Guid>
    {
    public:
        using Base = BaseData<Kind, Guid>;
        static constexpr Kind KIND = Kind::GeoPosition3DTimeseriesValue;
    private:
        Int64 rowVersion_ = 0;
        Guid timeseries_;
        DateTime timestamp_;
        DBDouble latitude_;
        DBDouble longitude_;
        DBDouble altitude_;
    public:
        GeoPosition3DTimeseriesValueData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(rowVersion_);
            destination.Write(timeseries_);
            destination.Write(timestamp_);
            latitude_.WriteTo( destination );
            longitude_.WriteTo( destination );
            altitude_.WriteTo( destination );
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(rowVersion_);
            source.Read(timeseries_);
            source.Read(timestamp_);
            latitude_.ReadFrom( source );
            longitude_.ReadFrom( source );
            altitude_.ReadFrom( source );
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<GeoPosition3DTimeseriesValueData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<GeoPosition3DTimeseriesValueData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const GeoPosition3DTimeseriesValueData& >( other );
                if ( dataObject.rowVersion_ != rowVersion_ )
                {
                    return false;
                }
                if ( dataObject.timeseries_ != timeseries_ )
                {
                    return false;
                }
                if ( dataObject.timestamp_ != timestamp_ )
                {
                    return false;
                }
                if ( dataObject.latitude_ != latitude_ )
                {
                    return false;
                }
                if ( dataObject.longitude_ != longitude_ )
                {
                    return false;
                }
                if ( dataObject.altitude_ != altitude_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
    };
    class GNSSDeviceCommandData : public BaseData<Kind, Guid>
    {
    public:
        using Base = BaseData<Kind, Guid>;
        static constexpr Kind KIND = Kind::GNSSDeviceCommand;
    private:
        Int64 rowVersion_ = 0;
        Guid gNSSDevice_;
        DateTime timestamp_;
        Data::DeviceCommandSourceType deviceCommandSourceType_ = Data::DeviceCommandSourceType::Unknown;
        Guid deviceCommandSourceId_;
        Guid reply_;
    public:
        GNSSDeviceCommandData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(rowVersion_);
            destination.Write(gNSSDevice_);
            destination.Write(timestamp_);
            destination.Write(deviceCommandSourceType_);
            destination.Write(deviceCommandSourceId_);
            destination.Write(reply_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(rowVersion_);
            source.Read(gNSSDevice_);
            source.Read(timestamp_);
            source.Read(deviceCommandSourceType_);
            source.Read(deviceCommandSourceId_);
            source.Read(reply_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<GNSSDeviceCommandData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<GNSSDeviceCommandData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const GNSSDeviceCommandData& >( other );
                if ( dataObject.rowVersion_ != rowVersion_ )
                {
                    return false;
                }
                if ( dataObject.gNSSDevice_ != gNSSDevice_ )
                {
                    return false;
                }
                if ( dataObject.timestamp_ != timestamp_ )
                {
                    return false;
                }
                if ( dataObject.deviceCommandSourceType_ != deviceCommandSourceType_ )
                {
                    return false;
                }
                if ( dataObject.deviceCommandSourceId_ != deviceCommandSourceId_ )
                {
                    return false;
                }
                if ( dataObject.reply_ != reply_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
    };
    class GNSSDeviceCommandReplyData : public BaseData<Kind, Guid>
    {
    public:
        using Base = BaseData<Kind, Guid>;
        static constexpr Kind KIND = Kind::GNSSDeviceCommandReply;
    private:
        Int64 rowVersion_ = 0;
        Guid gNSSDevice_;
        DateTime timestamp_;
        Guid command_;
        Data::DeviceCommandReplyStatus status_ = Data::DeviceCommandReplyStatus::Unknown;
        WideString message_;
        SQLLEN messageLength_ = SQL_NULL_DATA;
    public:
        GNSSDeviceCommandReplyData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(rowVersion_);
            destination.Write(gNSSDevice_);
            destination.Write(timestamp_);
            destination.Write(command_);
            destination.Write(status_);
            destination.Write(message_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(rowVersion_);
            source.Read(gNSSDevice_);
            source.Read(timestamp_);
            source.Read(command_);
            source.Read(status_);
            source.Read(message_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<GNSSDeviceCommandReplyData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<GNSSDeviceCommandReplyData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const GNSSDeviceCommandReplyData& >( other );
                if ( dataObject.rowVersion_ != rowVersion_ )
                {
                    return false;
                }
                if ( dataObject.gNSSDevice_ != gNSSDevice_ )
                {
                    return false;
                }
                if ( dataObject.timestamp_ != timestamp_ )
                {
                    return false;
                }
                if ( dataObject.command_ != command_ )
                {
                    return false;
                }
                if ( dataObject.status_ != status_ )
                {
                    return false;
                }
                if ( dataObject.message_ != message_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
    };
    class GNSSDeviceConfigurationData : public BaseData<Kind, Guid>
    {
    public:
        using Base = BaseData<Kind, Guid>;
        static constexpr Kind KIND = Kind::GNSSDeviceConfiguration;
    private:
        Int64 rowVersion_ = 0;
        Guid gNSSDevice_;
        DateTime timestamp_;
        double defaultLatitude_ = 0.0;
        double defaultLongitude_ = 0.0;
        double defaultAltitude_ = 0.0;
        double latitudeOffset_ = 0.0;
        double longitudeOffset_ = 0.0;
        double altitudeOffset_ = 0.0;
    public:
        GNSSDeviceConfigurationData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(rowVersion_);
            destination.Write(gNSSDevice_);
            destination.Write(timestamp_);
            destination.Write(defaultLatitude_);
            destination.Write(defaultLongitude_);
            destination.Write(defaultAltitude_);
            destination.Write(latitudeOffset_);
            destination.Write(longitudeOffset_);
            destination.Write(altitudeOffset_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(rowVersion_);
            source.Read(gNSSDevice_);
            source.Read(timestamp_);
            source.Read(defaultLatitude_);
            source.Read(defaultLongitude_);
            source.Read(defaultAltitude_);
            source.Read(latitudeOffset_);
            source.Read(longitudeOffset_);
            source.Read(altitudeOffset_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<GNSSDeviceConfigurationData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<GNSSDeviceConfigurationData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const GNSSDeviceConfigurationData& >( other );
                if ( dataObject.rowVersion_ != rowVersion_ )
                {
                    return false;
                }
                if ( dataObject.gNSSDevice_ != gNSSDevice_ )
                {
                    return false;
                }
                if ( dataObject.timestamp_ != timestamp_ )
                {
                    return false;
                }
                if ( dataObject.defaultLatitude_ != defaultLatitude_ )
                {
                    return false;
                }
                if ( dataObject.defaultLongitude_ != defaultLongitude_ )
                {
                    return false;
                }
                if ( dataObject.defaultAltitude_ != defaultAltitude_ )
                {
                    return false;
                }
                if ( dataObject.latitudeOffset_ != latitudeOffset_ )
                {
                    return false;
                }
                if ( dataObject.longitudeOffset_ != longitudeOffset_ )
                {
                    return false;
                }
                if ( dataObject.altitudeOffset_ != altitudeOffset_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
    };
    class GuidTimeseriesValueData : public BaseData<Kind, Guid>
    {
    public:
        using Base = BaseData<Kind, Guid>;
        static constexpr Kind KIND = Kind::GuidTimeseriesValue;
    private:
        Int64 rowVersion_ = 0;
        Guid timeseries_;
        DateTime timestamp_;
        DBGuid value_;
    public:
        GuidTimeseriesValueData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(rowVersion_);
            destination.Write(timeseries_);
            destination.Write(timestamp_);
            value_.WriteTo( destination );
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(rowVersion_);
            source.Read(timeseries_);
            source.Read(timestamp_);
            value_.ReadFrom( source );
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<GuidTimeseriesValueData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<GuidTimeseriesValueData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const GuidTimeseriesValueData& >( other );
                if ( dataObject.rowVersion_ != rowVersion_ )
                {
                    return false;
                }
                if ( dataObject.timeseries_ != timeseries_ )
                {
                    return false;
                }
                if ( dataObject.timestamp_ != timestamp_ )
                {
                    return false;
                }
                if ( dataObject.value_ != value_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
    };
    class GyroDeviceCommandData : public BaseData<Kind, Guid>
    {
    public:
        using Base = BaseData<Kind, Guid>;
        static constexpr Kind KIND = Kind::GyroDeviceCommand;
    private:
        Int64 rowVersion_ = 0;
        Guid gyroDevice_;
        DateTime timestamp_;
        Data::DeviceCommandSourceType deviceCommandSourceType_ = Data::DeviceCommandSourceType::Unknown;
        Guid deviceCommandSourceId_;
        Guid reply_;
    public:
        GyroDeviceCommandData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(rowVersion_);
            destination.Write(gyroDevice_);
            destination.Write(timestamp_);
            destination.Write(deviceCommandSourceType_);
            destination.Write(deviceCommandSourceId_);
            destination.Write(reply_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(rowVersion_);
            source.Read(gyroDevice_);
            source.Read(timestamp_);
            source.Read(deviceCommandSourceType_);
            source.Read(deviceCommandSourceId_);
            source.Read(reply_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<GyroDeviceCommandData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<GyroDeviceCommandData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const GyroDeviceCommandData& >( other );
                if ( dataObject.rowVersion_ != rowVersion_ )
                {
                    return false;
                }
                if ( dataObject.gyroDevice_ != gyroDevice_ )
                {
                    return false;
                }
                if ( dataObject.timestamp_ != timestamp_ )
                {
                    return false;
                }
                if ( dataObject.deviceCommandSourceType_ != deviceCommandSourceType_ )
                {
                    return false;
                }
                if ( dataObject.deviceCommandSourceId_ != deviceCommandSourceId_ )
                {
                    return false;
                }
                if ( dataObject.reply_ != reply_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
    };
    class GyroDeviceCommandReplyData : public BaseData<Kind, Guid>
    {
    public:
        using Base = BaseData<Kind, Guid>;
        static constexpr Kind KIND = Kind::GyroDeviceCommandReply;
    private:
        Int64 rowVersion_ = 0;
        Guid gyroDevice_;
        DateTime timestamp_;
        Guid command_;
        Data::DeviceCommandReplyStatus status_ = Data::DeviceCommandReplyStatus::Unknown;
        WideString message_;
        SQLLEN messageLength_ = SQL_NULL_DATA;
    public:
        GyroDeviceCommandReplyData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(rowVersion_);
            destination.Write(gyroDevice_);
            destination.Write(timestamp_);
            destination.Write(command_);
            destination.Write(status_);
            destination.Write(message_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(rowVersion_);
            source.Read(gyroDevice_);
            source.Read(timestamp_);
            source.Read(command_);
            source.Read(status_);
            source.Read(message_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<GyroDeviceCommandReplyData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<GyroDeviceCommandReplyData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const GyroDeviceCommandReplyData& >( other );
                if ( dataObject.rowVersion_ != rowVersion_ )
                {
                    return false;
                }
                if ( dataObject.gyroDevice_ != gyroDevice_ )
                {
                    return false;
                }
                if ( dataObject.timestamp_ != timestamp_ )
                {
                    return false;
                }
                if ( dataObject.command_ != command_ )
                {
                    return false;
                }
                if ( dataObject.status_ != status_ )
                {
                    return false;
                }
                if ( dataObject.message_ != message_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
    };
    class GyroDeviceConfigurationData : public BaseData<Kind, Guid>
    {
    public:
        using Base = BaseData<Kind, Guid>;
        static constexpr Kind KIND = Kind::GyroDeviceConfiguration;
    private:
        Int64 rowVersion_ = 0;
        Guid gyroDevice_;
        DateTime timestamp_;
        double defaultHeadingTrueNorth_ = 0.0;
        double defaultMagneticTrueNorth_ = 0.0;
        double headingTrueNorthOffset_ = 0.0;
        double headingMagneticNorthOffset_ = 0.0;
        FixedDBWideString<64> pitchTransducerName_;
        FixedDBWideString<64> rollTransducerName_;
    public:
        GyroDeviceConfigurationData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(rowVersion_);
            destination.Write(gyroDevice_);
            destination.Write(timestamp_);
            destination.Write(defaultHeadingTrueNorth_);
            destination.Write(defaultMagneticTrueNorth_);
            destination.Write(headingTrueNorthOffset_);
            destination.Write(headingMagneticNorthOffset_);
            pitchTransducerName_.WriteTo( destination );
            rollTransducerName_.WriteTo( destination );
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(rowVersion_);
            source.Read(gyroDevice_);
            source.Read(timestamp_);
            source.Read(defaultHeadingTrueNorth_);
            source.Read(defaultMagneticTrueNorth_);
            source.Read(headingTrueNorthOffset_);
            source.Read(headingMagneticNorthOffset_);
            pitchTransducerName_.ReadFrom( source );
            rollTransducerName_.ReadFrom( source );
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<GyroDeviceConfigurationData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<GyroDeviceConfigurationData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const GyroDeviceConfigurationData& >( other );
                if ( dataObject.rowVersion_ != rowVersion_ )
                {
                    return false;
                }
                if ( dataObject.gyroDevice_ != gyroDevice_ )
                {
                    return false;
                }
                if ( dataObject.timestamp_ != timestamp_ )
                {
                    return false;
                }
                if ( dataObject.defaultHeadingTrueNorth_ != defaultHeadingTrueNorth_ )
                {
                    return false;
                }
                if ( dataObject.defaultMagneticTrueNorth_ != defaultMagneticTrueNorth_ )
                {
                    return false;
                }
                if ( dataObject.headingTrueNorthOffset_ != headingTrueNorthOffset_ )
                {
                    return false;
                }
                if ( dataObject.headingMagneticNorthOffset_ != headingMagneticNorthOffset_ )
                {
                    return false;
                }
                if ( dataObject.pitchTransducerName_ != pitchTransducerName_ )
                {
                    return false;
                }
                if ( dataObject.rollTransducerName_ != rollTransducerName_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
    };
    class IdentityData : public BaseData<Kind, Guid>
    {
    public:
        using Base = BaseData<Kind, Guid>;
        static constexpr Kind KIND = Kind::Identity;
    private:
        Int64 rowVersion_ = 0;
    public:
        IdentityData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(rowVersion_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(rowVersion_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<IdentityData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<IdentityData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const IdentityData& >( other );
                if ( dataObject.rowVersion_ != rowVersion_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
    };
    class CallsignData : public IdentityData
    {
    public:
        using Base = IdentityData;
        static constexpr Kind KIND = Kind::Callsign;
    private:
        FixedDBWideString<127> identifier_;
    public:
        CallsignData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            identifier_.WriteTo( destination );
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            identifier_.ReadFrom( source );
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<CallsignData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<CallsignData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const CallsignData& >( other );
                if ( dataObject.identifier_ != identifier_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
    };
    class InternationalMaritimeOrganizationNumberData : public IdentityData
    {
    public:
        using Base = IdentityData;
        static constexpr Kind KIND = Kind::InternationalMaritimeOrganizationNumber;
    private:
        Int64 identifier_ = 0;
    public:
        InternationalMaritimeOrganizationNumberData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(identifier_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(identifier_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<InternationalMaritimeOrganizationNumberData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<InternationalMaritimeOrganizationNumberData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const InternationalMaritimeOrganizationNumberData& >( other );
                if ( dataObject.identifier_ != identifier_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
    };
    class MaritimeMobileServiceIdentityData : public IdentityData
    {
    public:
        using Base = IdentityData;
        static constexpr Kind KIND = Kind::MaritimeMobileServiceIdentity;
    private:
        Int64 identifier_ = 0;
    public:
        MaritimeMobileServiceIdentityData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(identifier_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(identifier_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<MaritimeMobileServiceIdentityData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<MaritimeMobileServiceIdentityData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const MaritimeMobileServiceIdentityData& >( other );
                if ( dataObject.identifier_ != identifier_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
    };
    class NameData : public IdentityData
    {
    public:
        using Base = IdentityData;
        static constexpr Kind KIND = Kind::Name;
    private:
        FixedDBWideString<100> text_;
    public:
        NameData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            text_.WriteTo( destination );
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            text_.ReadFrom( source );
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<NameData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<NameData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const NameData& >( other );
                if ( dataObject.text_ != text_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
    };
    class Int16TimeseriesValueData : public BaseData<Kind, Guid>
    {
    public:
        using Base = BaseData<Kind, Guid>;
        static constexpr Kind KIND = Kind::Int16TimeseriesValue;
    private:
        Int64 rowVersion_ = 0;
        Guid timeseries_;
        DateTime timestamp_;
        DBInt16 value_;
    public:
        Int16TimeseriesValueData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(rowVersion_);
            destination.Write(timeseries_);
            destination.Write(timestamp_);
            value_.WriteTo( destination );
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(rowVersion_);
            source.Read(timeseries_);
            source.Read(timestamp_);
            value_.ReadFrom( source );
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<Int16TimeseriesValueData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<Int16TimeseriesValueData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const Int16TimeseriesValueData& >( other );
                if ( dataObject.rowVersion_ != rowVersion_ )
                {
                    return false;
                }
                if ( dataObject.timeseries_ != timeseries_ )
                {
                    return false;
                }
                if ( dataObject.timestamp_ != timestamp_ )
                {
                    return false;
                }
                if ( dataObject.value_ != value_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
    };
    class Int32TimeseriesValueData : public BaseData<Kind, Guid>
    {
    public:
        using Base = BaseData<Kind, Guid>;
        static constexpr Kind KIND = Kind::Int32TimeseriesValue;
    private:
        Int64 rowVersion_ = 0;
        Guid timeseries_;
        DateTime timestamp_;
        DBInt32 value_;
    public:
        Int32TimeseriesValueData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(rowVersion_);
            destination.Write(timeseries_);
            destination.Write(timestamp_);
            value_.WriteTo( destination );
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(rowVersion_);
            source.Read(timeseries_);
            source.Read(timestamp_);
            value_.ReadFrom( source );
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<Int32TimeseriesValueData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<Int32TimeseriesValueData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const Int32TimeseriesValueData& >( other );
                if ( dataObject.rowVersion_ != rowVersion_ )
                {
                    return false;
                }
                if ( dataObject.timeseries_ != timeseries_ )
                {
                    return false;
                }
                if ( dataObject.timestamp_ != timestamp_ )
                {
                    return false;
                }
                if ( dataObject.value_ != value_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
    };
    class Int64TimeseriesValueData : public BaseData<Kind, Guid>
    {
    public:
        using Base = BaseData<Kind, Guid>;
        static constexpr Kind KIND = Kind::Int64TimeseriesValue;
    private:
        Int64 rowVersion_ = 0;
        Guid timeseries_;
        DateTime timestamp_;
        DBInt64 value_;
    public:
        Int64TimeseriesValueData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(rowVersion_);
            destination.Write(timeseries_);
            destination.Write(timestamp_);
            value_.WriteTo( destination );
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(rowVersion_);
            source.Read(timeseries_);
            source.Read(timestamp_);
            value_.ReadFrom( source );
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<Int64TimeseriesValueData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<Int64TimeseriesValueData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const Int64TimeseriesValueData& >( other );
                if ( dataObject.rowVersion_ != rowVersion_ )
                {
                    return false;
                }
                if ( dataObject.timeseries_ != timeseries_ )
                {
                    return false;
                }
                if ( dataObject.timestamp_ != timestamp_ )
                {
                    return false;
                }
                if ( dataObject.value_ != value_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
    };
    class ItemData : public BaseData<Kind, Guid>
    {
    public:
        using Base = BaseData<Kind, Guid>;
        static constexpr Kind KIND = Kind::Item;
    private:
        Int64 rowVersion_ = 0;
    public:
        ItemData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(rowVersion_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(rowVersion_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<ItemData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<ItemData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const ItemData& >( other );
                if ( dataObject.rowVersion_ != rowVersion_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
    };
    class BaseStationData : public ItemData
    {
    public:
        using Base = ItemData;
        static constexpr Kind KIND = Kind::BaseStation;
    private:
        FixedDBWideString<127> name_;
        Guid type_;
    public:
        BaseStationData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            name_.WriteTo( destination );
            destination.Write(type_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            name_.ReadFrom( source );
            source.Read(type_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<BaseStationData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<BaseStationData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const BaseStationData& >( other );
                if ( dataObject.name_ != name_ )
                {
                    return false;
                }
                if ( dataObject.type_ != type_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
    };
    class DeviceData : public ItemData
    {
    public:
        using Base = ItemData;
        static constexpr Kind KIND = Kind::Device;
    private:
        Guid host_;
        FixedDBWideString<127> name_;
        WideString description_;
        SQLLEN descriptionLength_ = SQL_NULL_DATA;
        Guid enabledTimeseries_;
    public:
        DeviceData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(host_);
            name_.WriteTo( destination );
            destination.Write(description_);
            destination.Write(enabledTimeseries_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(host_);
            name_.ReadFrom( source );
            source.Read(description_);
            source.Read(enabledTimeseries_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<DeviceData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<DeviceData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const DeviceData& >( other );
                if ( dataObject.host_ != host_ )
                {
                    return false;
                }
                if ( dataObject.name_ != name_ )
                {
                    return false;
                }
                if ( dataObject.description_ != description_ )
                {
                    return false;
                }
                if ( dataObject.enabledTimeseries_ != enabledTimeseries_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
    };
    class CameraData : public DeviceData
    {
    public:
        using Base = DeviceData;
        static constexpr Kind KIND = Kind::Camera;
    private:
        Guid type_;
    public:
        CameraData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(type_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(type_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<CameraData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<CameraData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const CameraData& >( other );
                if ( dataObject.type_ != type_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
    };
    class GNSSDeviceData : public DeviceData
    {
    public:
        using Base = DeviceData;
        static constexpr Kind KIND = Kind::GNSSDevice;
    private:
        Guid type_;
        Guid latitudeTimeseries_;
        Guid longitudeTimeseries_;
        Guid altitudeTimeseries_;
    public:
        GNSSDeviceData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(type_);
            destination.Write(latitudeTimeseries_);
            destination.Write(longitudeTimeseries_);
            destination.Write(altitudeTimeseries_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(type_);
            source.Read(latitudeTimeseries_);
            source.Read(longitudeTimeseries_);
            source.Read(altitudeTimeseries_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<GNSSDeviceData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<GNSSDeviceData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const GNSSDeviceData& >( other );
                if ( dataObject.type_ != type_ )
                {
                    return false;
                }
                if ( dataObject.latitudeTimeseries_ != latitudeTimeseries_ )
                {
                    return false;
                }
                if ( dataObject.longitudeTimeseries_ != longitudeTimeseries_ )
                {
                    return false;
                }
                if ( dataObject.altitudeTimeseries_ != altitudeTimeseries_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
    };
    class GyroDeviceData : public DeviceData
    {
    public:
        using Base = DeviceData;
        static constexpr Kind KIND = Kind::GyroDevice;
    private:
        Guid type_;
        Guid headingTrueNorthTimeseries_;
        Guid headingMagneticNorthTimeseries_;
        Guid pitchTimeseries_;
        Guid rateOfTurnTimeseries_;
        Guid rollTimeseries_;
        Guid courseTimeseries_;
        Guid speedTimeseries_;
        Guid gNSSDevice_;
    public:
        GyroDeviceData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(type_);
            destination.Write(headingTrueNorthTimeseries_);
            destination.Write(headingMagneticNorthTimeseries_);
            destination.Write(pitchTimeseries_);
            destination.Write(rateOfTurnTimeseries_);
            destination.Write(rollTimeseries_);
            destination.Write(courseTimeseries_);
            destination.Write(speedTimeseries_);
            destination.Write(gNSSDevice_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(type_);
            source.Read(headingTrueNorthTimeseries_);
            source.Read(headingMagneticNorthTimeseries_);
            source.Read(pitchTimeseries_);
            source.Read(rateOfTurnTimeseries_);
            source.Read(rollTimeseries_);
            source.Read(courseTimeseries_);
            source.Read(speedTimeseries_);
            source.Read(gNSSDevice_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<GyroDeviceData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<GyroDeviceData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const GyroDeviceData& >( other );
                if ( dataObject.type_ != type_ )
                {
                    return false;
                }
                if ( dataObject.headingTrueNorthTimeseries_ != headingTrueNorthTimeseries_ )
                {
                    return false;
                }
                if ( dataObject.headingMagneticNorthTimeseries_ != headingMagneticNorthTimeseries_ )
                {
                    return false;
                }
                if ( dataObject.pitchTimeseries_ != pitchTimeseries_ )
                {
                    return false;
                }
                if ( dataObject.rateOfTurnTimeseries_ != rateOfTurnTimeseries_ )
                {
                    return false;
                }
                if ( dataObject.rollTimeseries_ != rollTimeseries_ )
                {
                    return false;
                }
                if ( dataObject.courseTimeseries_ != courseTimeseries_ )
                {
                    return false;
                }
                if ( dataObject.speedTimeseries_ != speedTimeseries_ )
                {
                    return false;
                }
                if ( dataObject.gNSSDevice_ != gNSSDevice_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
    };
    class LineInputDeviceData : public DeviceData
    {
    public:
        using Base = DeviceData;
        static constexpr Kind KIND = Kind::LineInputDevice;
    private:
        Guid type_;
    public:
        LineInputDeviceData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(type_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(type_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<LineInputDeviceData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<LineInputDeviceData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const LineInputDeviceData& >( other );
                if ( dataObject.type_ != type_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
    };
    class OilspillDetectorData : public DeviceData
    {
    public:
        using Base = DeviceData;
        static constexpr Kind KIND = Kind::OilspillDetector;
    private:
        Guid type_;
    public:
        OilspillDetectorData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(type_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(type_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<OilspillDetectorData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<OilspillDetectorData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const OilspillDetectorData& >( other );
                if ( dataObject.type_ != type_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
    };
    class RadioData : public DeviceData
    {
    public:
        using Base = DeviceData;
        static constexpr Kind KIND = Kind::Radio;
    private:
        Guid type_;
    public:
        RadioData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(type_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(type_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<RadioData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<RadioData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const RadioData& >( other );
                if ( dataObject.type_ != type_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
    };
    class RadomeData : public DeviceData
    {
    public:
        using Base = DeviceData;
        static constexpr Kind KIND = Kind::Radome;
    private:
        Guid type_;
        Guid radar_;
        Guid pressureTimeseries_;
        Guid temperatureTimeseries_;
        Guid dewPointTimeseries_;
        Guid statusTimeseries_;
    public:
        RadomeData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(type_);
            destination.Write(radar_);
            destination.Write(pressureTimeseries_);
            destination.Write(temperatureTimeseries_);
            destination.Write(dewPointTimeseries_);
            destination.Write(statusTimeseries_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(type_);
            source.Read(radar_);
            source.Read(pressureTimeseries_);
            source.Read(temperatureTimeseries_);
            source.Read(dewPointTimeseries_);
            source.Read(statusTimeseries_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<RadomeData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<RadomeData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const RadomeData& >( other );
                if ( dataObject.type_ != type_ )
                {
                    return false;
                }
                if ( dataObject.radar_ != radar_ )
                {
                    return false;
                }
                if ( dataObject.pressureTimeseries_ != pressureTimeseries_ )
                {
                    return false;
                }
                if ( dataObject.temperatureTimeseries_ != temperatureTimeseries_ )
                {
                    return false;
                }
                if ( dataObject.dewPointTimeseries_ != dewPointTimeseries_ )
                {
                    return false;
                }
                if ( dataObject.statusTimeseries_ != statusTimeseries_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
    };
    class TrackerData : public DeviceData
    {
    public:
        using Base = DeviceData;
        static constexpr Kind KIND = Kind::Tracker;
    private:
    public:
        TrackerData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<TrackerData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<TrackerData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const TrackerData& >( other );
                return true;
            }
            return false;
        }
    };
    class AisTransceiverData : public TrackerData
    {
    public:
        using Base = TrackerData;
        static constexpr Kind KIND = Kind::AisTransceiver;
    private:
        Guid type_;
    public:
        AisTransceiverData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(type_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(type_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<AisTransceiverData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<AisTransceiverData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const AisTransceiverData& >( other );
                if ( dataObject.type_ != type_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
    };
    class RadarData : public TrackerData
    {
    public:
        using Base = TrackerData;
        static constexpr Kind KIND = Kind::Radar;
    private:
        Guid type_;
        Guid saveSettingsTimeseries_;
        Guid powerOnTimeseries_;
        Guid trackingOnTimeseries_;
        Guid radarPulseTimeseries_;
        Guid tuningTimeseries_;
        Guid blankSector1Timeseries_;
        Guid sector1StartTimeseries_;
        Guid sector1EndTimeseries_;
        Guid blankSector2Timeseries_;
        Guid sector2StartTimeseries_;
        Guid sector2EndTimeseries_;
        Guid enableAutomaticFrequencyControlTimeseries_;
        Guid azimuthOffsetTimeseries_;
        Guid enableSensitivityTimeControlTimeseries_;
        Guid automaticSensitivityTimeControlTimeseries_;
        Guid sensitivityTimeControlLevelTimeseries_;
        Guid enableFastTimeConstantTimeseries_;
        Guid fastTimeConstantLevelTimeseries_;
        Guid fastTimeConstantModeTimeseries_;
        Guid latitudeTimeseries_;
        Guid longitudeTimeseries_;
        Guid radome_;
        Guid gNSSDevice_;
    public:
        RadarData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(type_);
            destination.Write(saveSettingsTimeseries_);
            destination.Write(powerOnTimeseries_);
            destination.Write(trackingOnTimeseries_);
            destination.Write(radarPulseTimeseries_);
            destination.Write(tuningTimeseries_);
            destination.Write(blankSector1Timeseries_);
            destination.Write(sector1StartTimeseries_);
            destination.Write(sector1EndTimeseries_);
            destination.Write(blankSector2Timeseries_);
            destination.Write(sector2StartTimeseries_);
            destination.Write(sector2EndTimeseries_);
            destination.Write(enableAutomaticFrequencyControlTimeseries_);
            destination.Write(azimuthOffsetTimeseries_);
            destination.Write(enableSensitivityTimeControlTimeseries_);
            destination.Write(automaticSensitivityTimeControlTimeseries_);
            destination.Write(sensitivityTimeControlLevelTimeseries_);
            destination.Write(enableFastTimeConstantTimeseries_);
            destination.Write(fastTimeConstantLevelTimeseries_);
            destination.Write(fastTimeConstantModeTimeseries_);
            destination.Write(latitudeTimeseries_);
            destination.Write(longitudeTimeseries_);
            destination.Write(radome_);
            destination.Write(gNSSDevice_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(type_);
            source.Read(saveSettingsTimeseries_);
            source.Read(powerOnTimeseries_);
            source.Read(trackingOnTimeseries_);
            source.Read(radarPulseTimeseries_);
            source.Read(tuningTimeseries_);
            source.Read(blankSector1Timeseries_);
            source.Read(sector1StartTimeseries_);
            source.Read(sector1EndTimeseries_);
            source.Read(blankSector2Timeseries_);
            source.Read(sector2StartTimeseries_);
            source.Read(sector2EndTimeseries_);
            source.Read(enableAutomaticFrequencyControlTimeseries_);
            source.Read(azimuthOffsetTimeseries_);
            source.Read(enableSensitivityTimeControlTimeseries_);
            source.Read(automaticSensitivityTimeControlTimeseries_);
            source.Read(sensitivityTimeControlLevelTimeseries_);
            source.Read(enableFastTimeConstantTimeseries_);
            source.Read(fastTimeConstantLevelTimeseries_);
            source.Read(fastTimeConstantModeTimeseries_);
            source.Read(latitudeTimeseries_);
            source.Read(longitudeTimeseries_);
            source.Read(radome_);
            source.Read(gNSSDevice_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<RadarData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<RadarData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const RadarData& >( other );
                if ( dataObject.type_ != type_ )
                {
                    return false;
                }
                if ( dataObject.saveSettingsTimeseries_ != saveSettingsTimeseries_ )
                {
                    return false;
                }
                if ( dataObject.powerOnTimeseries_ != powerOnTimeseries_ )
                {
                    return false;
                }
                if ( dataObject.trackingOnTimeseries_ != trackingOnTimeseries_ )
                {
                    return false;
                }
                if ( dataObject.radarPulseTimeseries_ != radarPulseTimeseries_ )
                {
                    return false;
                }
                if ( dataObject.tuningTimeseries_ != tuningTimeseries_ )
                {
                    return false;
                }
                if ( dataObject.blankSector1Timeseries_ != blankSector1Timeseries_ )
                {
                    return false;
                }
                if ( dataObject.sector1StartTimeseries_ != sector1StartTimeseries_ )
                {
                    return false;
                }
                if ( dataObject.sector1EndTimeseries_ != sector1EndTimeseries_ )
                {
                    return false;
                }
                if ( dataObject.blankSector2Timeseries_ != blankSector2Timeseries_ )
                {
                    return false;
                }
                if ( dataObject.sector2StartTimeseries_ != sector2StartTimeseries_ )
                {
                    return false;
                }
                if ( dataObject.sector2EndTimeseries_ != sector2EndTimeseries_ )
                {
                    return false;
                }
                if ( dataObject.enableAutomaticFrequencyControlTimeseries_ != enableAutomaticFrequencyControlTimeseries_ )
                {
                    return false;
                }
                if ( dataObject.azimuthOffsetTimeseries_ != azimuthOffsetTimeseries_ )
                {
                    return false;
                }
                if ( dataObject.enableSensitivityTimeControlTimeseries_ != enableSensitivityTimeControlTimeseries_ )
                {
                    return false;
                }
                if ( dataObject.automaticSensitivityTimeControlTimeseries_ != automaticSensitivityTimeControlTimeseries_ )
                {
                    return false;
                }
                if ( dataObject.sensitivityTimeControlLevelTimeseries_ != sensitivityTimeControlLevelTimeseries_ )
                {
                    return false;
                }
                if ( dataObject.enableFastTimeConstantTimeseries_ != enableFastTimeConstantTimeseries_ )
                {
                    return false;
                }
                if ( dataObject.fastTimeConstantLevelTimeseries_ != fastTimeConstantLevelTimeseries_ )
                {
                    return false;
                }
                if ( dataObject.fastTimeConstantModeTimeseries_ != fastTimeConstantModeTimeseries_ )
                {
                    return false;
                }
                if ( dataObject.latitudeTimeseries_ != latitudeTimeseries_ )
                {
                    return false;
                }
                if ( dataObject.longitudeTimeseries_ != longitudeTimeseries_ )
                {
                    return false;
                }
                if ( dataObject.radome_ != radome_ )
                {
                    return false;
                }
                if ( dataObject.gNSSDevice_ != gNSSDevice_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
    };
    class WeatherStationData : public DeviceData
    {
    public:
        using Base = DeviceData;
        static constexpr Kind KIND = Kind::WeatherStation;
    private:
        Guid type_;
        Guid barometricPressureTimeseries_;
        Guid airTemperatureTimeseries_;
        Guid waterTemperatureTimeseries_;
        Guid relativeHumidityTimeseries_;
        Guid absoluteHumidityTimeseries_;
        Guid dewPointTimeseries_;
        Guid windDirectionTimeseries_;
        Guid windSpeedTimeseries_;
        Guid gyro_;
    public:
        WeatherStationData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(type_);
            destination.Write(barometricPressureTimeseries_);
            destination.Write(airTemperatureTimeseries_);
            destination.Write(waterTemperatureTimeseries_);
            destination.Write(relativeHumidityTimeseries_);
            destination.Write(absoluteHumidityTimeseries_);
            destination.Write(dewPointTimeseries_);
            destination.Write(windDirectionTimeseries_);
            destination.Write(windSpeedTimeseries_);
            destination.Write(gyro_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(type_);
            source.Read(barometricPressureTimeseries_);
            source.Read(airTemperatureTimeseries_);
            source.Read(waterTemperatureTimeseries_);
            source.Read(relativeHumidityTimeseries_);
            source.Read(absoluteHumidityTimeseries_);
            source.Read(dewPointTimeseries_);
            source.Read(windDirectionTimeseries_);
            source.Read(windSpeedTimeseries_);
            source.Read(gyro_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<WeatherStationData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<WeatherStationData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const WeatherStationData& >( other );
                if ( dataObject.type_ != type_ )
                {
                    return false;
                }
                if ( dataObject.barometricPressureTimeseries_ != barometricPressureTimeseries_ )
                {
                    return false;
                }
                if ( dataObject.airTemperatureTimeseries_ != airTemperatureTimeseries_ )
                {
                    return false;
                }
                if ( dataObject.waterTemperatureTimeseries_ != waterTemperatureTimeseries_ )
                {
                    return false;
                }
                if ( dataObject.relativeHumidityTimeseries_ != relativeHumidityTimeseries_ )
                {
                    return false;
                }
                if ( dataObject.absoluteHumidityTimeseries_ != absoluteHumidityTimeseries_ )
                {
                    return false;
                }
                if ( dataObject.dewPointTimeseries_ != dewPointTimeseries_ )
                {
                    return false;
                }
                if ( dataObject.windDirectionTimeseries_ != windDirectionTimeseries_ )
                {
                    return false;
                }
                if ( dataObject.windSpeedTimeseries_ != windSpeedTimeseries_ )
                {
                    return false;
                }
                if ( dataObject.gyro_ != gyro_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
    };
    class FacilityData : public ItemData
    {
    public:
        using Base = ItemData;
        static constexpr Kind KIND = Kind::Facility;
    private:
        FixedDBWideString<127> name_;
        Guid type_;
        double longitude_ = 0.0;
        double latitude_ = 0.0;
        double altitude_ = 0.0;
    public:
        FacilityData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            name_.WriteTo( destination );
            destination.Write(type_);
            destination.Write(longitude_);
            destination.Write(latitude_);
            destination.Write(altitude_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            name_.ReadFrom( source );
            source.Read(type_);
            source.Read(longitude_);
            source.Read(latitude_);
            source.Read(altitude_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<FacilityData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<FacilityData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const FacilityData& >( other );
                if ( dataObject.name_ != name_ )
                {
                    return false;
                }
                if ( dataObject.type_ != type_ )
                {
                    return false;
                }
                if ( dataObject.longitude_ != longitude_ )
                {
                    return false;
                }
                if ( dataObject.latitude_ != latitude_ )
                {
                    return false;
                }
                if ( dataObject.altitude_ != altitude_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
    };
    class TrackableItemData : public ItemData
    {
    public:
        using Base = ItemData;
        static constexpr Kind KIND = Kind::TrackableItem;
    private:
    public:
        TrackableItemData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<TrackableItemData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<TrackableItemData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const TrackableItemData& >( other );
                return true;
            }
            return false;
        }
    };
    class AircraftData : public TrackableItemData
    {
    public:
        using Base = TrackableItemData;
        static constexpr Kind KIND = Kind::Aircraft;
    private:
        FixedDBWideString<127> name_;
        Guid type_;
    public:
        AircraftData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            name_.WriteTo( destination );
            destination.Write(type_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            name_.ReadFrom( source );
            source.Read(type_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<AircraftData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<AircraftData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const AircraftData& >( other );
                if ( dataObject.name_ != name_ )
                {
                    return false;
                }
                if ( dataObject.type_ != type_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
    };
    class AisAidToNavigationData : public TrackableItemData
    {
    public:
        using Base = TrackableItemData;
        static constexpr Kind KIND = Kind::AisAidToNavigation;
    private:
        FixedDBWideString<127> name_;
        Guid mMSI_;
        Data::NavigationalAidType navigationalAidType_ = Data::NavigationalAidType::NotSpecified;
        Guid position_;
        bool isVirtual_ = false;
        Int32 toBow_ = 0;
        Int32 toStern_ = 0;
        Int32 toPort_ = 0;
        Int32 toStarboard_ = 0;
        Guid offPositionTimeseries_;
    public:
        AisAidToNavigationData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            name_.WriteTo( destination );
            destination.Write(mMSI_);
            destination.Write(navigationalAidType_);
            destination.Write(position_);
            destination.Write(isVirtual_);
            destination.Write(toBow_);
            destination.Write(toStern_);
            destination.Write(toPort_);
            destination.Write(toStarboard_);
            destination.Write(offPositionTimeseries_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            name_.ReadFrom( source );
            source.Read(mMSI_);
            source.Read(navigationalAidType_);
            source.Read(position_);
            source.Read(isVirtual_);
            source.Read(toBow_);
            source.Read(toStern_);
            source.Read(toPort_);
            source.Read(toStarboard_);
            source.Read(offPositionTimeseries_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<AisAidToNavigationData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<AisAidToNavigationData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const AisAidToNavigationData& >( other );
                if ( dataObject.name_ != name_ )
                {
                    return false;
                }
                if ( dataObject.mMSI_ != mMSI_ )
                {
                    return false;
                }
                if ( dataObject.navigationalAidType_ != navigationalAidType_ )
                {
                    return false;
                }
                if ( dataObject.position_ != position_ )
                {
                    return false;
                }
                if ( dataObject.isVirtual_ != isVirtual_ )
                {
                    return false;
                }
                if ( dataObject.toBow_ != toBow_ )
                {
                    return false;
                }
                if ( dataObject.toStern_ != toStern_ )
                {
                    return false;
                }
                if ( dataObject.toPort_ != toPort_ )
                {
                    return false;
                }
                if ( dataObject.toStarboard_ != toStarboard_ )
                {
                    return false;
                }
                if ( dataObject.offPositionTimeseries_ != offPositionTimeseries_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
    };
    class VehicleData : public TrackableItemData
    {
    public:
        using Base = TrackableItemData;
        static constexpr Kind KIND = Kind::Vehicle;
    private:
        FixedDBWideString<127> name_;
        Guid type_;
    public:
        VehicleData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            name_.WriteTo( destination );
            destination.Write(type_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            name_.ReadFrom( source );
            source.Read(type_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<VehicleData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<VehicleData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const VehicleData& >( other );
                if ( dataObject.name_ != name_ )
                {
                    return false;
                }
                if ( dataObject.type_ != type_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
    };
    class VesselData : public TrackableItemData
    {
    public:
        using Base = TrackableItemData;
        static constexpr Kind KIND = Kind::Vessel;
    private:
        FixedDBWideString<127> name_;
        Guid type_;
        Int32 toBow_ = 0;
        Int32 toStern_ = 0;
        Int32 toPort_ = 0;
        Int32 toStarboard_ = 0;
        Guid draughtTimeseries_;
        Guid personsOnBoardTimeseries_;
    public:
        VesselData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            name_.WriteTo( destination );
            destination.Write(type_);
            destination.Write(toBow_);
            destination.Write(toStern_);
            destination.Write(toPort_);
            destination.Write(toStarboard_);
            destination.Write(draughtTimeseries_);
            destination.Write(personsOnBoardTimeseries_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            name_.ReadFrom( source );
            source.Read(type_);
            source.Read(toBow_);
            source.Read(toStern_);
            source.Read(toPort_);
            source.Read(toStarboard_);
            source.Read(draughtTimeseries_);
            source.Read(personsOnBoardTimeseries_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<VesselData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<VesselData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const VesselData& >( other );
                if ( dataObject.name_ != name_ )
                {
                    return false;
                }
                if ( dataObject.type_ != type_ )
                {
                    return false;
                }
                if ( dataObject.toBow_ != toBow_ )
                {
                    return false;
                }
                if ( dataObject.toStern_ != toStern_ )
                {
                    return false;
                }
                if ( dataObject.toPort_ != toPort_ )
                {
                    return false;
                }
                if ( dataObject.toStarboard_ != toStarboard_ )
                {
                    return false;
                }
                if ( dataObject.draughtTimeseries_ != draughtTimeseries_ )
                {
                    return false;
                }
                if ( dataObject.personsOnBoardTimeseries_ != personsOnBoardTimeseries_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
    };
    class ItemIdentityLinkData : public BaseData<Kind, Guid>
    {
    public:
        using Base = BaseData<Kind, Guid>;
        static constexpr Kind KIND = Kind::ItemIdentityLink;
    private:
        Int64 rowVersion_ = 0;
        Guid item_;
        Guid identity_;
        DateTime start_;
        DBDateTime end_;
    public:
        ItemIdentityLinkData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(rowVersion_);
            destination.Write(item_);
            destination.Write(identity_);
            destination.Write(start_);
            end_.WriteTo( destination );
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(rowVersion_);
            source.Read(item_);
            source.Read(identity_);
            source.Read(start_);
            end_.ReadFrom( source );
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<ItemIdentityLinkData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<ItemIdentityLinkData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const ItemIdentityLinkData& >( other );
                if ( dataObject.rowVersion_ != rowVersion_ )
                {
                    return false;
                }
                if ( dataObject.item_ != item_ )
                {
                    return false;
                }
                if ( dataObject.identity_ != identity_ )
                {
                    return false;
                }
                if ( dataObject.start_ != start_ )
                {
                    return false;
                }
                if ( dataObject.end_ != end_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
    };
    class ItemParentChildLinkData : public BaseData<Kind, Guid>
    {
    public:
        using Base = BaseData<Kind, Guid>;
        static constexpr Kind KIND = Kind::ItemParentChildLink;
    private:
        Int64 rowVersion_ = 0;
        Guid parent_;
        Guid child_;
        DateTime timestamp_;
    public:
        ItemParentChildLinkData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(rowVersion_);
            destination.Write(parent_);
            destination.Write(child_);
            destination.Write(timestamp_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(rowVersion_);
            source.Read(parent_);
            source.Read(child_);
            source.Read(timestamp_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<ItemParentChildLinkData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<ItemParentChildLinkData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const ItemParentChildLinkData& >( other );
                if ( dataObject.rowVersion_ != rowVersion_ )
                {
                    return false;
                }
                if ( dataObject.parent_ != parent_ )
                {
                    return false;
                }
                if ( dataObject.child_ != child_ )
                {
                    return false;
                }
                if ( dataObject.timestamp_ != timestamp_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
    };
    class LineInputDeviceCommandData : public BaseData<Kind, Guid>
    {
    public:
        using Base = BaseData<Kind, Guid>;
        static constexpr Kind KIND = Kind::LineInputDeviceCommand;
    private:
        Int64 rowVersion_ = 0;
        Guid lineInputDevice_;
        DateTime timestamp_;
        Data::DeviceCommandSourceType deviceCommandSourceType_ = Data::DeviceCommandSourceType::Unknown;
        Guid deviceCommandSourceId_;
        Guid reply_;
    public:
        LineInputDeviceCommandData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(rowVersion_);
            destination.Write(lineInputDevice_);
            destination.Write(timestamp_);
            destination.Write(deviceCommandSourceType_);
            destination.Write(deviceCommandSourceId_);
            destination.Write(reply_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(rowVersion_);
            source.Read(lineInputDevice_);
            source.Read(timestamp_);
            source.Read(deviceCommandSourceType_);
            source.Read(deviceCommandSourceId_);
            source.Read(reply_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<LineInputDeviceCommandData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<LineInputDeviceCommandData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const LineInputDeviceCommandData& >( other );
                if ( dataObject.rowVersion_ != rowVersion_ )
                {
                    return false;
                }
                if ( dataObject.lineInputDevice_ != lineInputDevice_ )
                {
                    return false;
                }
                if ( dataObject.timestamp_ != timestamp_ )
                {
                    return false;
                }
                if ( dataObject.deviceCommandSourceType_ != deviceCommandSourceType_ )
                {
                    return false;
                }
                if ( dataObject.deviceCommandSourceId_ != deviceCommandSourceId_ )
                {
                    return false;
                }
                if ( dataObject.reply_ != reply_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
    };
    class LineInputDeviceCommandReplyData : public BaseData<Kind, Guid>
    {
    public:
        using Base = BaseData<Kind, Guid>;
        static constexpr Kind KIND = Kind::LineInputDeviceCommandReply;
    private:
        Int64 rowVersion_ = 0;
        Guid lineInputDevice_;
        DateTime timestamp_;
        Guid command_;
        Data::DeviceCommandReplyStatus status_ = Data::DeviceCommandReplyStatus::Unknown;
        WideString message_;
        SQLLEN messageLength_ = SQL_NULL_DATA;
    public:
        LineInputDeviceCommandReplyData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(rowVersion_);
            destination.Write(lineInputDevice_);
            destination.Write(timestamp_);
            destination.Write(command_);
            destination.Write(status_);
            destination.Write(message_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(rowVersion_);
            source.Read(lineInputDevice_);
            source.Read(timestamp_);
            source.Read(command_);
            source.Read(status_);
            source.Read(message_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<LineInputDeviceCommandReplyData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<LineInputDeviceCommandReplyData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const LineInputDeviceCommandReplyData& >( other );
                if ( dataObject.rowVersion_ != rowVersion_ )
                {
                    return false;
                }
                if ( dataObject.lineInputDevice_ != lineInputDevice_ )
                {
                    return false;
                }
                if ( dataObject.timestamp_ != timestamp_ )
                {
                    return false;
                }
                if ( dataObject.command_ != command_ )
                {
                    return false;
                }
                if ( dataObject.status_ != status_ )
                {
                    return false;
                }
                if ( dataObject.message_ != message_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
    };
    class LineInputDeviceConfigurationData : public BaseData<Kind, Guid>
    {
    public:
        using Base = BaseData<Kind, Guid>;
        static constexpr Kind KIND = Kind::LineInputDeviceConfiguration;
    private:
        Int64 rowVersion_ = 0;
        Guid lineInputDevice_;
        DateTime timestamp_;
        bool storeReceivedSentences_ = false;
        bool storeSentMessages_ = false;
        bool storeUnsentMessages_ = false;
        bool nMEA_ = false;
        bool strictNMEA_ = false;
        Data::LineInputDeviceConnectionType connectionType_ = Data::LineInputDeviceConnectionType::Unknown;
        Int32 udpReceivePort_ = 0;
        FixedDBWideString<100> udpSendHostname_;
        Int32 udpSendPort_ = 0;
        FixedDBWideString<100> tcpHostname_;
        Int32 tcpPort_ = 0;
        bool useHttpLogin_ = false;
        FixedDBWideString<100> loginHostname_;
        Int32 loginPort_ = 0;
        FixedDBWideString<100> userName_;
        FixedDBWideString<100> password_;
        FixedDBWideString<100> comPort_;
        Int32 baudRate_ = 0;
        Int32 dataBits_ = 0;
        bool discardNull_ = false;
        bool dtrEnable_ = false;
        Data::Handshake handshake_ = Data::Handshake::None;
        FixedDBWideString<100> newLine_;
        Data::Parity parity_ = Data::Parity::None;
        Byte parityReplace_ = 0;
        Int32 readBufferSize_ = 0;
        TimeSpan readTimeout_;
        Int32 receivedBytesThreshold_ = 0;
        bool rtsEnable_ = false;
        Data::StopBits stopBits_ = Data::StopBits::None;
        Int32 writeBufferSize_ = 0;
        TimeSpan writeTimeout_;
        FixedDBWideString<100> pairedComPort_;
    public:
        LineInputDeviceConfigurationData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(rowVersion_);
            destination.Write(lineInputDevice_);
            destination.Write(timestamp_);
            destination.Write(storeReceivedSentences_);
            destination.Write(storeSentMessages_);
            destination.Write(storeUnsentMessages_);
            destination.Write(nMEA_);
            destination.Write(strictNMEA_);
            destination.Write(connectionType_);
            destination.Write(udpReceivePort_);
            udpSendHostname_.WriteTo( destination );
            destination.Write(udpSendPort_);
            tcpHostname_.WriteTo( destination );
            destination.Write(tcpPort_);
            destination.Write(useHttpLogin_);
            loginHostname_.WriteTo( destination );
            destination.Write(loginPort_);
            userName_.WriteTo( destination );
            password_.WriteTo( destination );
            comPort_.WriteTo( destination );
            destination.Write(baudRate_);
            destination.Write(dataBits_);
            destination.Write(discardNull_);
            destination.Write(dtrEnable_);
            destination.Write(handshake_);
            newLine_.WriteTo( destination );
            destination.Write(parity_);
            destination.Write(parityReplace_);
            destination.Write(readBufferSize_);
            destination.Write(readTimeout_);
            destination.Write(receivedBytesThreshold_);
            destination.Write(rtsEnable_);
            destination.Write(stopBits_);
            destination.Write(writeBufferSize_);
            destination.Write(writeTimeout_);
            pairedComPort_.WriteTo( destination );
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(rowVersion_);
            source.Read(lineInputDevice_);
            source.Read(timestamp_);
            source.Read(storeReceivedSentences_);
            source.Read(storeSentMessages_);
            source.Read(storeUnsentMessages_);
            source.Read(nMEA_);
            source.Read(strictNMEA_);
            source.Read(connectionType_);
            source.Read(udpReceivePort_);
            udpSendHostname_.ReadFrom( source );
            source.Read(udpSendPort_);
            tcpHostname_.ReadFrom( source );
            source.Read(tcpPort_);
            source.Read(useHttpLogin_);
            loginHostname_.ReadFrom( source );
            source.Read(loginPort_);
            userName_.ReadFrom( source );
            password_.ReadFrom( source );
            comPort_.ReadFrom( source );
            source.Read(baudRate_);
            source.Read(dataBits_);
            source.Read(discardNull_);
            source.Read(dtrEnable_);
            source.Read(handshake_);
            newLine_.ReadFrom( source );
            source.Read(parity_);
            source.Read(parityReplace_);
            source.Read(readBufferSize_);
            source.Read(readTimeout_);
            source.Read(receivedBytesThreshold_);
            source.Read(rtsEnable_);
            source.Read(stopBits_);
            source.Read(writeBufferSize_);
            source.Read(writeTimeout_);
            pairedComPort_.ReadFrom( source );
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<LineInputDeviceConfigurationData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<LineInputDeviceConfigurationData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const LineInputDeviceConfigurationData& >( other );
                if ( dataObject.rowVersion_ != rowVersion_ )
                {
                    return false;
                }
                if ( dataObject.lineInputDevice_ != lineInputDevice_ )
                {
                    return false;
                }
                if ( dataObject.timestamp_ != timestamp_ )
                {
                    return false;
                }
                if ( dataObject.storeReceivedSentences_ != storeReceivedSentences_ )
                {
                    return false;
                }
                if ( dataObject.storeSentMessages_ != storeSentMessages_ )
                {
                    return false;
                }
                if ( dataObject.storeUnsentMessages_ != storeUnsentMessages_ )
                {
                    return false;
                }
                if ( dataObject.nMEA_ != nMEA_ )
                {
                    return false;
                }
                if ( dataObject.strictNMEA_ != strictNMEA_ )
                {
                    return false;
                }
                if ( dataObject.connectionType_ != connectionType_ )
                {
                    return false;
                }
                if ( dataObject.udpReceivePort_ != udpReceivePort_ )
                {
                    return false;
                }
                if ( dataObject.udpSendHostname_ != udpSendHostname_ )
                {
                    return false;
                }
                if ( dataObject.udpSendPort_ != udpSendPort_ )
                {
                    return false;
                }
                if ( dataObject.tcpHostname_ != tcpHostname_ )
                {
                    return false;
                }
                if ( dataObject.tcpPort_ != tcpPort_ )
                {
                    return false;
                }
                if ( dataObject.useHttpLogin_ != useHttpLogin_ )
                {
                    return false;
                }
                if ( dataObject.loginHostname_ != loginHostname_ )
                {
                    return false;
                }
                if ( dataObject.loginPort_ != loginPort_ )
                {
                    return false;
                }
                if ( dataObject.userName_ != userName_ )
                {
                    return false;
                }
                if ( dataObject.password_ != password_ )
                {
                    return false;
                }
                if ( dataObject.comPort_ != comPort_ )
                {
                    return false;
                }
                if ( dataObject.baudRate_ != baudRate_ )
                {
                    return false;
                }
                if ( dataObject.dataBits_ != dataBits_ )
                {
                    return false;
                }
                if ( dataObject.discardNull_ != discardNull_ )
                {
                    return false;
                }
                if ( dataObject.dtrEnable_ != dtrEnable_ )
                {
                    return false;
                }
                if ( dataObject.handshake_ != handshake_ )
                {
                    return false;
                }
                if ( dataObject.newLine_ != newLine_ )
                {
                    return false;
                }
                if ( dataObject.parity_ != parity_ )
                {
                    return false;
                }
                if ( dataObject.parityReplace_ != parityReplace_ )
                {
                    return false;
                }
                if ( dataObject.readBufferSize_ != readBufferSize_ )
                {
                    return false;
                }
                if ( dataObject.readTimeout_ != readTimeout_ )
                {
                    return false;
                }
                if ( dataObject.receivedBytesThreshold_ != receivedBytesThreshold_ )
                {
                    return false;
                }
                if ( dataObject.rtsEnable_ != rtsEnable_ )
                {
                    return false;
                }
                if ( dataObject.stopBits_ != stopBits_ )
                {
                    return false;
                }
                if ( dataObject.writeBufferSize_ != writeBufferSize_ )
                {
                    return false;
                }
                if ( dataObject.writeTimeout_ != writeTimeout_ )
                {
                    return false;
                }
                if ( dataObject.pairedComPort_ != pairedComPort_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
    };
    class LineInputMessageRoutingData : public BaseData<Kind, Guid>
    {
    public:
        using Base = BaseData<Kind, Guid>;
        static constexpr Kind KIND = Kind::LineInputMessageRouting;
    private:
        Int64 rowVersion_ = 0;
        Guid lineInputDevice_;
        FixedDBWideString<100> type_;
    public:
        LineInputMessageRoutingData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(rowVersion_);
            destination.Write(lineInputDevice_);
            type_.WriteTo( destination );
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(rowVersion_);
            source.Read(lineInputDevice_);
            type_.ReadFrom( source );
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<LineInputMessageRoutingData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<LineInputMessageRoutingData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const LineInputMessageRoutingData& >( other );
                if ( dataObject.rowVersion_ != rowVersion_ )
                {
                    return false;
                }
                if ( dataObject.lineInputDevice_ != lineInputDevice_ )
                {
                    return false;
                }
                if ( dataObject.type_ != type_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
    };
    class LineInputMessageRoutingDestinationData : public BaseData<Kind, Guid>
    {
    public:
        using Base = BaseData<Kind, Guid>;
        static constexpr Kind KIND = Kind::LineInputMessageRoutingDestination;
    private:
        Int64 rowVersion_ = 0;
        Guid routing_;
        Guid listener_;
    public:
        LineInputMessageRoutingDestinationData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(rowVersion_);
            destination.Write(routing_);
            destination.Write(listener_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(rowVersion_);
            source.Read(routing_);
            source.Read(listener_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<LineInputMessageRoutingDestinationData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<LineInputMessageRoutingDestinationData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const LineInputMessageRoutingDestinationData& >( other );
                if ( dataObject.rowVersion_ != rowVersion_ )
                {
                    return false;
                }
                if ( dataObject.routing_ != routing_ )
                {
                    return false;
                }
                if ( dataObject.listener_ != listener_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
    };
    class LineInputWhiteListEntryData : public BaseData<Kind, Guid>
    {
    public:
        using Base = BaseData<Kind, Guid>;
        static constexpr Kind KIND = Kind::LineInputWhiteListEntry;
    private:
        Int64 rowVersion_ = 0;
        Guid lineInputDevice_;
        FixedDBWideString<128> hostName_;
        Int32 port_ = 0;
    public:
        LineInputWhiteListEntryData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(rowVersion_);
            destination.Write(lineInputDevice_);
            hostName_.WriteTo( destination );
            destination.Write(port_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(rowVersion_);
            source.Read(lineInputDevice_);
            hostName_.ReadFrom( source );
            source.Read(port_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<LineInputWhiteListEntryData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<LineInputWhiteListEntryData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const LineInputWhiteListEntryData& >( other );
                if ( dataObject.rowVersion_ != rowVersion_ )
                {
                    return false;
                }
                if ( dataObject.lineInputDevice_ != lineInputDevice_ )
                {
                    return false;
                }
                if ( dataObject.hostName_ != hostName_ )
                {
                    return false;
                }
                if ( dataObject.port_ != port_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
    };
    class LogApplicationData : public BaseData<Kind, Guid>
    {
    public:
        using Base = BaseData<Kind, Guid>;
        static constexpr Kind KIND = Kind::LogApplication;
    private:
        Int64 rowVersion_ = 0;
        FixedDBWideString<127> name_;
        WideString description_;
        SQLLEN descriptionLength_ = SQL_NULL_DATA;
    public:
        LogApplicationData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(rowVersion_);
            name_.WriteTo( destination );
            destination.Write(description_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(rowVersion_);
            name_.ReadFrom( source );
            source.Read(description_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<LogApplicationData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<LogApplicationData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const LogApplicationData& >( other );
                if ( dataObject.rowVersion_ != rowVersion_ )
                {
                    return false;
                }
                if ( dataObject.name_ != name_ )
                {
                    return false;
                }
                if ( dataObject.description_ != description_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
    };
    class LogApplicationConfigurationData : public BaseData<Kind, Guid>
    {
    public:
        using Base = BaseData<Kind, Guid>;
        static constexpr Kind KIND = Kind::LogApplicationConfiguration;
    private:
        Int64 rowVersion_ = 0;
        Guid application_;
        DateTime timestamp_;
        bool finest_ = false;
        bool finer_ = false;
        bool fine_ = false;
        bool info_ = false;
        bool notice_ = false;
        bool warn_ = false;
        bool error_ = false;
        bool severe_ = false;
        bool critical_ = false;
        bool alert_ = false;
        bool fatal_ = false;
        bool emergency_ = false;
    public:
        LogApplicationConfigurationData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(rowVersion_);
            destination.Write(application_);
            destination.Write(timestamp_);
            destination.Write(finest_);
            destination.Write(finer_);
            destination.Write(fine_);
            destination.Write(info_);
            destination.Write(notice_);
            destination.Write(warn_);
            destination.Write(error_);
            destination.Write(severe_);
            destination.Write(critical_);
            destination.Write(alert_);
            destination.Write(fatal_);
            destination.Write(emergency_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(rowVersion_);
            source.Read(application_);
            source.Read(timestamp_);
            source.Read(finest_);
            source.Read(finer_);
            source.Read(fine_);
            source.Read(info_);
            source.Read(notice_);
            source.Read(warn_);
            source.Read(error_);
            source.Read(severe_);
            source.Read(critical_);
            source.Read(alert_);
            source.Read(fatal_);
            source.Read(emergency_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<LogApplicationConfigurationData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<LogApplicationConfigurationData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const LogApplicationConfigurationData& >( other );
                if ( dataObject.rowVersion_ != rowVersion_ )
                {
                    return false;
                }
                if ( dataObject.application_ != application_ )
                {
                    return false;
                }
                if ( dataObject.timestamp_ != timestamp_ )
                {
                    return false;
                }
                if ( dataObject.finest_ != finest_ )
                {
                    return false;
                }
                if ( dataObject.finer_ != finer_ )
                {
                    return false;
                }
                if ( dataObject.fine_ != fine_ )
                {
                    return false;
                }
                if ( dataObject.info_ != info_ )
                {
                    return false;
                }
                if ( dataObject.notice_ != notice_ )
                {
                    return false;
                }
                if ( dataObject.warn_ != warn_ )
                {
                    return false;
                }
                if ( dataObject.error_ != error_ )
                {
                    return false;
                }
                if ( dataObject.severe_ != severe_ )
                {
                    return false;
                }
                if ( dataObject.critical_ != critical_ )
                {
                    return false;
                }
                if ( dataObject.alert_ != alert_ )
                {
                    return false;
                }
                if ( dataObject.fatal_ != fatal_ )
                {
                    return false;
                }
                if ( dataObject.emergency_ != emergency_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
    };
    class LogHostData : public BaseData<Kind, Guid>
    {
    public:
        using Base = BaseData<Kind, Guid>;
        static constexpr Kind KIND = Kind::LogHost;
    private:
        Int64 rowVersion_ = 0;
        FixedDBWideString<127> computerName_;
        WideString description_;
        SQLLEN descriptionLength_ = SQL_NULL_DATA;
    public:
        LogHostData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(rowVersion_);
            computerName_.WriteTo( destination );
            destination.Write(description_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(rowVersion_);
            computerName_.ReadFrom( source );
            source.Read(description_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<LogHostData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<LogHostData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const LogHostData& >( other );
                if ( dataObject.rowVersion_ != rowVersion_ )
                {
                    return false;
                }
                if ( dataObject.computerName_ != computerName_ )
                {
                    return false;
                }
                if ( dataObject.description_ != description_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
    };
    class LogHostConfigurationData : public BaseData<Kind, Guid>
    {
    public:
        using Base = BaseData<Kind, Guid>;
        static constexpr Kind KIND = Kind::LogHostConfiguration;
    private:
        Int64 rowVersion_ = 0;
        Guid host_;
        DateTime timestamp_;
        bool finest_ = false;
        bool finer_ = false;
        bool fine_ = false;
        bool info_ = false;
        bool notice_ = false;
        bool warn_ = false;
        bool error_ = false;
        bool severe_ = false;
        bool critical_ = false;
        bool alert_ = false;
        bool fatal_ = false;
        bool emergency_ = false;
    public:
        LogHostConfigurationData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(rowVersion_);
            destination.Write(host_);
            destination.Write(timestamp_);
            destination.Write(finest_);
            destination.Write(finer_);
            destination.Write(fine_);
            destination.Write(info_);
            destination.Write(notice_);
            destination.Write(warn_);
            destination.Write(error_);
            destination.Write(severe_);
            destination.Write(critical_);
            destination.Write(alert_);
            destination.Write(fatal_);
            destination.Write(emergency_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(rowVersion_);
            source.Read(host_);
            source.Read(timestamp_);
            source.Read(finest_);
            source.Read(finer_);
            source.Read(fine_);
            source.Read(info_);
            source.Read(notice_);
            source.Read(warn_);
            source.Read(error_);
            source.Read(severe_);
            source.Read(critical_);
            source.Read(alert_);
            source.Read(fatal_);
            source.Read(emergency_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<LogHostConfigurationData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<LogHostConfigurationData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const LogHostConfigurationData& >( other );
                if ( dataObject.rowVersion_ != rowVersion_ )
                {
                    return false;
                }
                if ( dataObject.host_ != host_ )
                {
                    return false;
                }
                if ( dataObject.timestamp_ != timestamp_ )
                {
                    return false;
                }
                if ( dataObject.finest_ != finest_ )
                {
                    return false;
                }
                if ( dataObject.finer_ != finer_ )
                {
                    return false;
                }
                if ( dataObject.fine_ != fine_ )
                {
                    return false;
                }
                if ( dataObject.info_ != info_ )
                {
                    return false;
                }
                if ( dataObject.notice_ != notice_ )
                {
                    return false;
                }
                if ( dataObject.warn_ != warn_ )
                {
                    return false;
                }
                if ( dataObject.error_ != error_ )
                {
                    return false;
                }
                if ( dataObject.severe_ != severe_ )
                {
                    return false;
                }
                if ( dataObject.critical_ != critical_ )
                {
                    return false;
                }
                if ( dataObject.alert_ != alert_ )
                {
                    return false;
                }
                if ( dataObject.fatal_ != fatal_ )
                {
                    return false;
                }
                if ( dataObject.emergency_ != emergency_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
    };
    class LogLocationData : public BaseData<Kind, Guid>
    {
    public:
        using Base = BaseData<Kind, Guid>;
        static constexpr Kind KIND = Kind::LogLocation;
    private:
        Int64 rowVersion_ = 0;
        FixedDBWideString<260> fileName_;
        Int32 lineNumber_ = 0;
        WideString namespace_;
        SQLLEN namespaceLength_ = SQL_NULL_DATA;
        WideString className_;
        SQLLEN classNameLength_ = SQL_NULL_DATA;
        FixedDBWideString<255> methodName_;
    public:
        LogLocationData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(rowVersion_);
            fileName_.WriteTo( destination );
            destination.Write(lineNumber_);
            destination.Write(namespace_);
            destination.Write(className_);
            methodName_.WriteTo( destination );
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(rowVersion_);
            fileName_.ReadFrom( source );
            source.Read(lineNumber_);
            source.Read(namespace_);
            source.Read(className_);
            methodName_.ReadFrom( source );
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<LogLocationData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<LogLocationData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const LogLocationData& >( other );
                if ( dataObject.rowVersion_ != rowVersion_ )
                {
                    return false;
                }
                if ( dataObject.fileName_ != fileName_ )
                {
                    return false;
                }
                if ( dataObject.lineNumber_ != lineNumber_ )
                {
                    return false;
                }
                if ( dataObject.namespace_ != namespace_ )
                {
                    return false;
                }
                if ( dataObject.className_ != className_ )
                {
                    return false;
                }
                if ( dataObject.methodName_ != methodName_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
    };
    class LogProcessData : public BaseData<Kind, Guid>
    {
    public:
        using Base = BaseData<Kind, Guid>;
        static constexpr Kind KIND = Kind::LogProcess;
    private:
        Int64 rowVersion_ = 0;
        Guid application_;
        Guid host_;
        DateTime started_;
        DBDateTime stopped_;
        Int64 processId_ = 0;
        WideString path_;
        SQLLEN pathLength_ = SQL_NULL_DATA;
        FixedDBWideString<127> identity_;
    public:
        LogProcessData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(rowVersion_);
            destination.Write(application_);
            destination.Write(host_);
            destination.Write(started_);
            stopped_.WriteTo( destination );
            destination.Write(processId_);
            destination.Write(path_);
            identity_.WriteTo( destination );
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(rowVersion_);
            source.Read(application_);
            source.Read(host_);
            source.Read(started_);
            stopped_.ReadFrom( source );
            source.Read(processId_);
            source.Read(path_);
            identity_.ReadFrom( source );
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<LogProcessData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<LogProcessData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const LogProcessData& >( other );
                if ( dataObject.rowVersion_ != rowVersion_ )
                {
                    return false;
                }
                if ( dataObject.application_ != application_ )
                {
                    return false;
                }
                if ( dataObject.host_ != host_ )
                {
                    return false;
                }
                if ( dataObject.started_ != started_ )
                {
                    return false;
                }
                if ( dataObject.stopped_ != stopped_ )
                {
                    return false;
                }
                if ( dataObject.processId_ != processId_ )
                {
                    return false;
                }
                if ( dataObject.path_ != path_ )
                {
                    return false;
                }
                if ( dataObject.identity_ != identity_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
    };
    class LogRecordData : public BaseData<Kind, Guid>
    {
    public:
        using Base = BaseData<Kind, Guid>;
        static constexpr Kind KIND = Kind::LogRecord;
    private:
        Int64 rowVersion_ = 0;
        Guid thread_;
        Int64 sequenceNumber_ = 0;
        Data::LogLevel level_ = Data::LogLevel::Unknown;
        DateTime timestamp_;
        Int32 depth_ = 0;
        Guid location_;
        WideString message_;
        SQLLEN messageLength_ = SQL_NULL_DATA;
        WideString exceptionString_;
        SQLLEN exceptionStringLength_ = SQL_NULL_DATA;
        Binary propertiesData_;
        SQLLEN propertiesDataLength_ = SQL_NULL_DATA;
    public:
        LogRecordData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(rowVersion_);
            destination.Write(thread_);
            destination.Write(sequenceNumber_);
            destination.Write(level_);
            destination.Write(timestamp_);
            destination.Write(depth_);
            destination.Write(location_);
            destination.Write(message_);
            destination.Write(exceptionString_);
            destination.Write(propertiesData_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(rowVersion_);
            source.Read(thread_);
            source.Read(sequenceNumber_);
            source.Read(level_);
            source.Read(timestamp_);
            source.Read(depth_);
            source.Read(location_);
            source.Read(message_);
            source.Read(exceptionString_);
            source.Read(propertiesData_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<LogRecordData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<LogRecordData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const LogRecordData& >( other );
                if ( dataObject.rowVersion_ != rowVersion_ )
                {
                    return false;
                }
                if ( dataObject.thread_ != thread_ )
                {
                    return false;
                }
                if ( dataObject.sequenceNumber_ != sequenceNumber_ )
                {
                    return false;
                }
                if ( dataObject.level_ != level_ )
                {
                    return false;
                }
                if ( dataObject.timestamp_ != timestamp_ )
                {
                    return false;
                }
                if ( dataObject.depth_ != depth_ )
                {
                    return false;
                }
                if ( dataObject.location_ != location_ )
                {
                    return false;
                }
                if ( dataObject.message_ != message_ )
                {
                    return false;
                }
                if ( dataObject.exceptionString_ != exceptionString_ )
                {
                    return false;
                }
                if ( dataObject.propertiesData_ != propertiesData_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
    };
    class LogThreadData : public BaseData<Kind, Guid>
    {
    public:
        using Base = BaseData<Kind, Guid>;
        static constexpr Kind KIND = Kind::LogThread;
    private:
        Int64 rowVersion_ = 0;
        Guid process_;
        DateTime started_;
        DBDateTime stopped_;
        Int64 threadId_ = 0;
        FixedDBWideString<127> name_;
    public:
        LogThreadData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(rowVersion_);
            destination.Write(process_);
            destination.Write(started_);
            stopped_.WriteTo( destination );
            destination.Write(threadId_);
            name_.WriteTo( destination );
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(rowVersion_);
            source.Read(process_);
            source.Read(started_);
            stopped_.ReadFrom( source );
            source.Read(threadId_);
            name_.ReadFrom( source );
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<LogThreadData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<LogThreadData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const LogThreadData& >( other );
                if ( dataObject.rowVersion_ != rowVersion_ )
                {
                    return false;
                }
                if ( dataObject.process_ != process_ )
                {
                    return false;
                }
                if ( dataObject.started_ != started_ )
                {
                    return false;
                }
                if ( dataObject.stopped_ != stopped_ )
                {
                    return false;
                }
                if ( dataObject.threadId_ != threadId_ )
                {
                    return false;
                }
                if ( dataObject.name_ != name_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
    };
    class LogTraceEntryData : public BaseData<Kind, Guid>
    {
    public:
        using Base = BaseData<Kind, Guid>;
        static constexpr Kind KIND = Kind::LogTraceEntry;
    private:
        Int64 rowVersion_ = 0;
        Guid thread_;
        Int64 sequenceNumber_ = 0;
        Guid location_;
        Int32 depth_ = 0;
        DateTime entered_;
        DBDateTime ended_;
    public:
        LogTraceEntryData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(rowVersion_);
            destination.Write(thread_);
            destination.Write(sequenceNumber_);
            destination.Write(location_);
            destination.Write(depth_);
            destination.Write(entered_);
            ended_.WriteTo( destination );
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(rowVersion_);
            source.Read(thread_);
            source.Read(sequenceNumber_);
            source.Read(location_);
            source.Read(depth_);
            source.Read(entered_);
            ended_.ReadFrom( source );
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<LogTraceEntryData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<LogTraceEntryData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const LogTraceEntryData& >( other );
                if ( dataObject.rowVersion_ != rowVersion_ )
                {
                    return false;
                }
                if ( dataObject.thread_ != thread_ )
                {
                    return false;
                }
                if ( dataObject.sequenceNumber_ != sequenceNumber_ )
                {
                    return false;
                }
                if ( dataObject.location_ != location_ )
                {
                    return false;
                }
                if ( dataObject.depth_ != depth_ )
                {
                    return false;
                }
                if ( dataObject.entered_ != entered_ )
                {
                    return false;
                }
                if ( dataObject.ended_ != ended_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
    };
    class MapElementData : public BaseData<Kind, Guid>
    {
    public:
        using Base = BaseData<Kind, Guid>;
        static constexpr Kind KIND = Kind::MapElement;
    private:
        Int64 rowVersion_ = 0;
        Guid item_;
        Data::MapElementType elementType_ = Data::MapElementType::Unknown;
        double latitude_ = 0.0;
        double longitude_ = 0.0;
        double angle_ = 0.0;
        double left_ = 0.0;
        double top_ = 0.0;
        double width_ = 0.0;
        double height_ = 0.0;
        FixedDBWideString<100> label_;
        Binary data_;
        SQLLEN dataLength_ = SQL_NULL_DATA;
    public:
        MapElementData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(rowVersion_);
            destination.Write(item_);
            destination.Write(elementType_);
            destination.Write(latitude_);
            destination.Write(longitude_);
            destination.Write(angle_);
            destination.Write(left_);
            destination.Write(top_);
            destination.Write(width_);
            destination.Write(height_);
            label_.WriteTo( destination );
            destination.Write(data_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(rowVersion_);
            source.Read(item_);
            source.Read(elementType_);
            source.Read(latitude_);
            source.Read(longitude_);
            source.Read(angle_);
            source.Read(left_);
            source.Read(top_);
            source.Read(width_);
            source.Read(height_);
            label_.ReadFrom( source );
            source.Read(data_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<MapElementData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<MapElementData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const MapElementData& >( other );
                if ( dataObject.rowVersion_ != rowVersion_ )
                {
                    return false;
                }
                if ( dataObject.item_ != item_ )
                {
                    return false;
                }
                if ( dataObject.elementType_ != elementType_ )
                {
                    return false;
                }
                if ( dataObject.latitude_ != latitude_ )
                {
                    return false;
                }
                if ( dataObject.longitude_ != longitude_ )
                {
                    return false;
                }
                if ( dataObject.angle_ != angle_ )
                {
                    return false;
                }
                if ( dataObject.left_ != left_ )
                {
                    return false;
                }
                if ( dataObject.top_ != top_ )
                {
                    return false;
                }
                if ( dataObject.width_ != width_ )
                {
                    return false;
                }
                if ( dataObject.height_ != height_ )
                {
                    return false;
                }
                if ( dataObject.label_ != label_ )
                {
                    return false;
                }
                if ( dataObject.data_ != data_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
    };
    class MapInfoData : public BaseData<Kind, Guid>
    {
    public:
        using Base = BaseData<Kind, Guid>;
        static constexpr Kind KIND = Kind::MapInfo;
    private:
        Int64 rowVersion_ = 0;
        Int32 scale_ = 0;
        double latitude_ = 0.0;
        double longitude_ = 0.0;
        double northWestLatitude_ = 0.0;
        double northWestLongitude_ = 0.0;
        double southEastLatitude_ = 0.0;
        double southEastLongitude_ = 0.0;
        Binary image_;
        SQLLEN imageLength_ = SQL_NULL_DATA;
    public:
        MapInfoData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(rowVersion_);
            destination.Write(scale_);
            destination.Write(latitude_);
            destination.Write(longitude_);
            destination.Write(northWestLatitude_);
            destination.Write(northWestLongitude_);
            destination.Write(southEastLatitude_);
            destination.Write(southEastLongitude_);
            destination.Write(image_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(rowVersion_);
            source.Read(scale_);
            source.Read(latitude_);
            source.Read(longitude_);
            source.Read(northWestLatitude_);
            source.Read(northWestLongitude_);
            source.Read(southEastLatitude_);
            source.Read(southEastLongitude_);
            source.Read(image_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<MapInfoData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<MapInfoData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const MapInfoData& >( other );
                if ( dataObject.rowVersion_ != rowVersion_ )
                {
                    return false;
                }
                if ( dataObject.scale_ != scale_ )
                {
                    return false;
                }
                if ( dataObject.latitude_ != latitude_ )
                {
                    return false;
                }
                if ( dataObject.longitude_ != longitude_ )
                {
                    return false;
                }
                if ( dataObject.northWestLatitude_ != northWestLatitude_ )
                {
                    return false;
                }
                if ( dataObject.northWestLongitude_ != northWestLongitude_ )
                {
                    return false;
                }
                if ( dataObject.southEastLatitude_ != southEastLatitude_ )
                {
                    return false;
                }
                if ( dataObject.southEastLongitude_ != southEastLongitude_ )
                {
                    return false;
                }
                if ( dataObject.image_ != image_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
    };
    class MapServiceOptionsData : public BaseData<Kind, Guid>
    {
    public:
        using Base = BaseData<Kind, Guid>;
        static constexpr Kind KIND = Kind::MapServiceOptions;
    private:
        Int64 rowVersion_ = 0;
        DateTime timestamp_;
        FixedDBWideString<127> ipAddress_;
        Int32 port_ = 0;
        double imageScaleFactorX_ = 0.0;
        double imageOffsetX_ = 0.0;
        double imageScaleFactorY_ = 0.0;
        double imageOffsetY_ = 0.0;
    public:
        MapServiceOptionsData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(rowVersion_);
            destination.Write(timestamp_);
            ipAddress_.WriteTo( destination );
            destination.Write(port_);
            destination.Write(imageScaleFactorX_);
            destination.Write(imageOffsetX_);
            destination.Write(imageScaleFactorY_);
            destination.Write(imageOffsetY_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(rowVersion_);
            source.Read(timestamp_);
            ipAddress_.ReadFrom( source );
            source.Read(port_);
            source.Read(imageScaleFactorX_);
            source.Read(imageOffsetX_);
            source.Read(imageScaleFactorY_);
            source.Read(imageOffsetY_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<MapServiceOptionsData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<MapServiceOptionsData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const MapServiceOptionsData& >( other );
                if ( dataObject.rowVersion_ != rowVersion_ )
                {
                    return false;
                }
                if ( dataObject.timestamp_ != timestamp_ )
                {
                    return false;
                }
                if ( dataObject.ipAddress_ != ipAddress_ )
                {
                    return false;
                }
                if ( dataObject.port_ != port_ )
                {
                    return false;
                }
                if ( dataObject.imageScaleFactorX_ != imageScaleFactorX_ )
                {
                    return false;
                }
                if ( dataObject.imageOffsetX_ != imageOffsetX_ )
                {
                    return false;
                }
                if ( dataObject.imageScaleFactorY_ != imageScaleFactorY_ )
                {
                    return false;
                }
                if ( dataObject.imageOffsetY_ != imageOffsetY_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
    };
    class MaritimeIdentificationDigitsData : public BaseData<Kind, Guid>
    {
    public:
        using Base = BaseData<Kind, Guid>;
        static constexpr Kind KIND = Kind::MaritimeIdentificationDigits;
    private:
        Int64 rowVersion_ = 0;
        Int32 code_ = 0;
        Guid country_;
    public:
        MaritimeIdentificationDigitsData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(rowVersion_);
            destination.Write(code_);
            destination.Write(country_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(rowVersion_);
            source.Read(code_);
            source.Read(country_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<MaritimeIdentificationDigitsData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<MaritimeIdentificationDigitsData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const MaritimeIdentificationDigitsData& >( other );
                if ( dataObject.rowVersion_ != rowVersion_ )
                {
                    return false;
                }
                if ( dataObject.code_ != code_ )
                {
                    return false;
                }
                if ( dataObject.country_ != country_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
    };
    class MediaProxySessionData : public BaseData<Kind, Guid>
    {
    public:
        using Base = BaseData<Kind, Guid>;
        static constexpr Kind KIND = Kind::MediaProxySession;
    private:
        Int64 rowVersion_ = 0;
        Guid service_;
        FixedDBWideString<128> name_;
        Guid enabledTimeseries_;
    public:
        MediaProxySessionData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(rowVersion_);
            destination.Write(service_);
            name_.WriteTo( destination );
            destination.Write(enabledTimeseries_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(rowVersion_);
            source.Read(service_);
            name_.ReadFrom( source );
            source.Read(enabledTimeseries_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<MediaProxySessionData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<MediaProxySessionData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const MediaProxySessionData& >( other );
                if ( dataObject.rowVersion_ != rowVersion_ )
                {
                    return false;
                }
                if ( dataObject.service_ != service_ )
                {
                    return false;
                }
                if ( dataObject.name_ != name_ )
                {
                    return false;
                }
                if ( dataObject.enabledTimeseries_ != enabledTimeseries_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
    };
    class MediaProxySessionFileData : public BaseData<Kind, Guid>
    {
    public:
        using Base = BaseData<Kind, Guid>;
        static constexpr Kind KIND = Kind::MediaProxySessionFile;
    private:
        Int64 rowVersion_ = 0;
        Guid proxySession_;
        DateTime timestamp_;
        FixedDBWideString<100> streamName_;
    public:
        MediaProxySessionFileData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(rowVersion_);
            destination.Write(proxySession_);
            destination.Write(timestamp_);
            streamName_.WriteTo( destination );
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(rowVersion_);
            source.Read(proxySession_);
            source.Read(timestamp_);
            streamName_.ReadFrom( source );
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<MediaProxySessionFileData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<MediaProxySessionFileData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const MediaProxySessionFileData& >( other );
                if ( dataObject.rowVersion_ != rowVersion_ )
                {
                    return false;
                }
                if ( dataObject.proxySession_ != proxySession_ )
                {
                    return false;
                }
                if ( dataObject.timestamp_ != timestamp_ )
                {
                    return false;
                }
                if ( dataObject.streamName_ != streamName_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
    };
    class MediaProxySessionOptionsData : public BaseData<Kind, Guid>
    {
    public:
        using Base = BaseData<Kind, Guid>;
        static constexpr Kind KIND = Kind::MediaProxySessionOptions;
    private:
        Int64 rowVersion_ = 0;
        Guid proxySession_;
        DateTime timestamp_;
        FixedDBWideString<255> sourceStreamUrl_;
        FixedDBWideString<255> streamName_;
        Data::MediaProxySessionMode mode_ = Data::MediaProxySessionMode::Unknown;
        Int32 tunnelOverHTTPPortNumber_ = 0;
        FixedDBWideString<128> username_;
        FixedDBWideString<128> password_;
        Int32 recorderPortNumber_ = 0;
        Data::MediaProxySessionType sessionType_ = Data::MediaProxySessionType::Unknown;
        TimeSpan maxFileTime_;
        TimeSpan maxFileRetention_;
        FixedDBWideString<260> videoDirectory_;
    public:
        MediaProxySessionOptionsData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(rowVersion_);
            destination.Write(proxySession_);
            destination.Write(timestamp_);
            sourceStreamUrl_.WriteTo( destination );
            streamName_.WriteTo( destination );
            destination.Write(mode_);
            destination.Write(tunnelOverHTTPPortNumber_);
            username_.WriteTo( destination );
            password_.WriteTo( destination );
            destination.Write(recorderPortNumber_);
            destination.Write(sessionType_);
            destination.Write(maxFileTime_);
            destination.Write(maxFileRetention_);
            videoDirectory_.WriteTo( destination );
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(rowVersion_);
            source.Read(proxySession_);
            source.Read(timestamp_);
            sourceStreamUrl_.ReadFrom( source );
            streamName_.ReadFrom( source );
            source.Read(mode_);
            source.Read(tunnelOverHTTPPortNumber_);
            username_.ReadFrom( source );
            password_.ReadFrom( source );
            source.Read(recorderPortNumber_);
            source.Read(sessionType_);
            source.Read(maxFileTime_);
            source.Read(maxFileRetention_);
            videoDirectory_.ReadFrom( source );
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<MediaProxySessionOptionsData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<MediaProxySessionOptionsData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const MediaProxySessionOptionsData& >( other );
                if ( dataObject.rowVersion_ != rowVersion_ )
                {
                    return false;
                }
                if ( dataObject.proxySession_ != proxySession_ )
                {
                    return false;
                }
                if ( dataObject.timestamp_ != timestamp_ )
                {
                    return false;
                }
                if ( dataObject.sourceStreamUrl_ != sourceStreamUrl_ )
                {
                    return false;
                }
                if ( dataObject.streamName_ != streamName_ )
                {
                    return false;
                }
                if ( dataObject.mode_ != mode_ )
                {
                    return false;
                }
                if ( dataObject.tunnelOverHTTPPortNumber_ != tunnelOverHTTPPortNumber_ )
                {
                    return false;
                }
                if ( dataObject.username_ != username_ )
                {
                    return false;
                }
                if ( dataObject.password_ != password_ )
                {
                    return false;
                }
                if ( dataObject.recorderPortNumber_ != recorderPortNumber_ )
                {
                    return false;
                }
                if ( dataObject.sessionType_ != sessionType_ )
                {
                    return false;
                }
                if ( dataObject.maxFileTime_ != maxFileTime_ )
                {
                    return false;
                }
                if ( dataObject.maxFileRetention_ != maxFileRetention_ )
                {
                    return false;
                }
                if ( dataObject.videoDirectory_ != videoDirectory_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
    };
    class MediaServiceData : public BaseData<Kind, Guid>
    {
    public:
        using Base = BaseData<Kind, Guid>;
        static constexpr Kind KIND = Kind::MediaService;
    private:
        Int64 rowVersion_ = 0;
        Guid enabledTimeseries_;
    public:
        MediaServiceData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(rowVersion_);
            destination.Write(enabledTimeseries_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(rowVersion_);
            source.Read(enabledTimeseries_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<MediaServiceData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<MediaServiceData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const MediaServiceData& >( other );
                if ( dataObject.rowVersion_ != rowVersion_ )
                {
                    return false;
                }
                if ( dataObject.enabledTimeseries_ != enabledTimeseries_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
    };
    class MediaServiceOptionsData : public BaseData<Kind, Guid>
    {
    public:
        using Base = BaseData<Kind, Guid>;
        static constexpr Kind KIND = Kind::MediaServiceOptions;
    private:
        Int64 rowVersion_ = 0;
        Guid mediaService_;
        DateTime timestamp_;
        Int32 rtspPortNumber_ = 0;
        Int32 httpPortNumber_ = 0;
    public:
        MediaServiceOptionsData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(rowVersion_);
            destination.Write(mediaService_);
            destination.Write(timestamp_);
            destination.Write(rtspPortNumber_);
            destination.Write(httpPortNumber_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(rowVersion_);
            source.Read(mediaService_);
            source.Read(timestamp_);
            source.Read(rtspPortNumber_);
            source.Read(httpPortNumber_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<MediaServiceOptionsData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<MediaServiceOptionsData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const MediaServiceOptionsData& >( other );
                if ( dataObject.rowVersion_ != rowVersion_ )
                {
                    return false;
                }
                if ( dataObject.mediaService_ != mediaService_ )
                {
                    return false;
                }
                if ( dataObject.timestamp_ != timestamp_ )
                {
                    return false;
                }
                if ( dataObject.rtspPortNumber_ != rtspPortNumber_ )
                {
                    return false;
                }
                if ( dataObject.httpPortNumber_ != httpPortNumber_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
    };
    class NamespaceElementData : public BaseData<Kind, Guid>
    {
    public:
        using Base = BaseData<Kind, Guid>;
        static constexpr Kind KIND = Kind::NamespaceElement;
    private:
        Int64 rowVersion_ = 0;
        Guid namespace_;
        FixedDBWideString<127> name_;
        WideString description_;
        SQLLEN descriptionLength_ = SQL_NULL_DATA;
    public:
        NamespaceElementData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(rowVersion_);
            destination.Write(namespace_);
            name_.WriteTo( destination );
            destination.Write(description_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(rowVersion_);
            source.Read(namespace_);
            name_.ReadFrom( source );
            source.Read(description_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<NamespaceElementData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<NamespaceElementData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const NamespaceElementData& >( other );
                if ( dataObject.rowVersion_ != rowVersion_ )
                {
                    return false;
                }
                if ( dataObject.namespace_ != namespace_ )
                {
                    return false;
                }
                if ( dataObject.name_ != name_ )
                {
                    return false;
                }
                if ( dataObject.description_ != description_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
    };
    class ElementTypeData : public NamespaceElementData
    {
    public:
        using Base = NamespaceElementData;
        static constexpr Kind KIND = Kind::ElementType;
    private:
    public:
        ElementTypeData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<ElementTypeData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<ElementTypeData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const ElementTypeData& >( other );
                return true;
            }
            return false;
        }
    };
    class NamespaceData : public NamespaceElementData
    {
    public:
        using Base = NamespaceElementData;
        static constexpr Kind KIND = Kind::Namespace;
    private:
    public:
        NamespaceData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<NamespaceData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<NamespaceData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const NamespaceData& >( other );
                return true;
            }
            return false;
        }
    };
    class OilspillData : public BaseData<Kind, Guid>
    {
    public:
        using Base = BaseData<Kind, Guid>;
        static constexpr Kind KIND = Kind::Oilspill;
    private:
        Int64 rowVersion_ = 0;
        Guid oilSpillDetector_;
        DateTime timestamp_;
        double oilArea_ = 0.0;
        Binary shape_;
        SQLLEN shapeLength_ = SQL_NULL_DATA;
        Binary bSI_;
        SQLLEN bSILength_ = SQL_NULL_DATA;
        Binary oil_;
        SQLLEN oilLength_ = SQL_NULL_DATA;
        Binary trace_;
        SQLLEN traceLength_ = SQL_NULL_DATA;
    public:
        OilspillData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(rowVersion_);
            destination.Write(oilSpillDetector_);
            destination.Write(timestamp_);
            destination.Write(oilArea_);
            destination.Write(shape_);
            destination.Write(bSI_);
            destination.Write(oil_);
            destination.Write(trace_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(rowVersion_);
            source.Read(oilSpillDetector_);
            source.Read(timestamp_);
            source.Read(oilArea_);
            source.Read(shape_);
            source.Read(bSI_);
            source.Read(oil_);
            source.Read(trace_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<OilspillData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<OilspillData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const OilspillData& >( other );
                if ( dataObject.rowVersion_ != rowVersion_ )
                {
                    return false;
                }
                if ( dataObject.oilSpillDetector_ != oilSpillDetector_ )
                {
                    return false;
                }
                if ( dataObject.timestamp_ != timestamp_ )
                {
                    return false;
                }
                if ( dataObject.oilArea_ != oilArea_ )
                {
                    return false;
                }
                if ( dataObject.shape_ != shape_ )
                {
                    return false;
                }
                if ( dataObject.bSI_ != bSI_ )
                {
                    return false;
                }
                if ( dataObject.oil_ != oil_ )
                {
                    return false;
                }
                if ( dataObject.trace_ != trace_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
    };
    class OilspillDetectorCommandData : public BaseData<Kind, Guid>
    {
    public:
        using Base = BaseData<Kind, Guid>;
        static constexpr Kind KIND = Kind::OilspillDetectorCommand;
    private:
        Int64 rowVersion_ = 0;
        Guid oilSpillDetector_;
        DateTime timestamp_;
        Data::DeviceCommandSourceType deviceCommandSourceType_ = Data::DeviceCommandSourceType::Unknown;
        Guid deviceCommandSourceId_;
        Guid reply_;
    public:
        OilspillDetectorCommandData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(rowVersion_);
            destination.Write(oilSpillDetector_);
            destination.Write(timestamp_);
            destination.Write(deviceCommandSourceType_);
            destination.Write(deviceCommandSourceId_);
            destination.Write(reply_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(rowVersion_);
            source.Read(oilSpillDetector_);
            source.Read(timestamp_);
            source.Read(deviceCommandSourceType_);
            source.Read(deviceCommandSourceId_);
            source.Read(reply_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<OilspillDetectorCommandData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<OilspillDetectorCommandData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const OilspillDetectorCommandData& >( other );
                if ( dataObject.rowVersion_ != rowVersion_ )
                {
                    return false;
                }
                if ( dataObject.oilSpillDetector_ != oilSpillDetector_ )
                {
                    return false;
                }
                if ( dataObject.timestamp_ != timestamp_ )
                {
                    return false;
                }
                if ( dataObject.deviceCommandSourceType_ != deviceCommandSourceType_ )
                {
                    return false;
                }
                if ( dataObject.deviceCommandSourceId_ != deviceCommandSourceId_ )
                {
                    return false;
                }
                if ( dataObject.reply_ != reply_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
    };
    class OilspillDetectorCommandReplyData : public BaseData<Kind, Guid>
    {
    public:
        using Base = BaseData<Kind, Guid>;
        static constexpr Kind KIND = Kind::OilspillDetectorCommandReply;
    private:
        Int64 rowVersion_ = 0;
        Guid oilSpillDetector_;
        DateTime timestamp_;
        Guid command_;
        Data::DeviceCommandReplyStatus status_ = Data::DeviceCommandReplyStatus::Unknown;
        WideString message_;
        SQLLEN messageLength_ = SQL_NULL_DATA;
    public:
        OilspillDetectorCommandReplyData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(rowVersion_);
            destination.Write(oilSpillDetector_);
            destination.Write(timestamp_);
            destination.Write(command_);
            destination.Write(status_);
            destination.Write(message_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(rowVersion_);
            source.Read(oilSpillDetector_);
            source.Read(timestamp_);
            source.Read(command_);
            source.Read(status_);
            source.Read(message_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<OilspillDetectorCommandReplyData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<OilspillDetectorCommandReplyData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const OilspillDetectorCommandReplyData& >( other );
                if ( dataObject.rowVersion_ != rowVersion_ )
                {
                    return false;
                }
                if ( dataObject.oilSpillDetector_ != oilSpillDetector_ )
                {
                    return false;
                }
                if ( dataObject.timestamp_ != timestamp_ )
                {
                    return false;
                }
                if ( dataObject.command_ != command_ )
                {
                    return false;
                }
                if ( dataObject.status_ != status_ )
                {
                    return false;
                }
                if ( dataObject.message_ != message_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
    };
    class OilspillDetectorConfigurationData : public BaseData<Kind, Guid>
    {
    public:
        using Base = BaseData<Kind, Guid>;
        static constexpr Kind KIND = Kind::OilspillDetectorConfiguration;
    private:
        Int64 rowVersion_ = 0;
        Guid oilSpillDetector_;
        DateTime timestamp_;
        double range_ = 0.0;
        double startAngle_ = 0.0;
        double endAngle_ = 0.0;
        double startRange_ = 0.0;
        double endRange_ = 0.0;
        Int32 updateRate_ = 0;
        TimeSpan statusSendTime_;
        bool drawBorder_ = false;
        Binary colors_;
        SQLLEN colorsLength_ = SQL_NULL_DATA;
        bool sendToServer_ = false;
        FixedDBWideString<100> directory_;
        bool transparentWater_ = false;
        bool savePictures_ = false;
        bool sendAsTarget_ = false;
        bool writeLog_ = false;
        FixedDBWideString<100> targetFilePrefix_;
        Guid targetMMSI_;
        double latitude_ = 0.0;
        double longitude_ = 0.0;
        bool testSourceEnabled_ = false;
        FixedDBWideString<100> proxyServer_;
        bool useProxyServer_ = false;
    public:
        OilspillDetectorConfigurationData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(rowVersion_);
            destination.Write(oilSpillDetector_);
            destination.Write(timestamp_);
            destination.Write(range_);
            destination.Write(startAngle_);
            destination.Write(endAngle_);
            destination.Write(startRange_);
            destination.Write(endRange_);
            destination.Write(updateRate_);
            destination.Write(statusSendTime_);
            destination.Write(drawBorder_);
            destination.Write(colors_);
            destination.Write(sendToServer_);
            directory_.WriteTo( destination );
            destination.Write(transparentWater_);
            destination.Write(savePictures_);
            destination.Write(sendAsTarget_);
            destination.Write(writeLog_);
            targetFilePrefix_.WriteTo( destination );
            destination.Write(targetMMSI_);
            destination.Write(latitude_);
            destination.Write(longitude_);
            destination.Write(testSourceEnabled_);
            proxyServer_.WriteTo( destination );
            destination.Write(useProxyServer_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(rowVersion_);
            source.Read(oilSpillDetector_);
            source.Read(timestamp_);
            source.Read(range_);
            source.Read(startAngle_);
            source.Read(endAngle_);
            source.Read(startRange_);
            source.Read(endRange_);
            source.Read(updateRate_);
            source.Read(statusSendTime_);
            source.Read(drawBorder_);
            source.Read(colors_);
            source.Read(sendToServer_);
            directory_.ReadFrom( source );
            source.Read(transparentWater_);
            source.Read(savePictures_);
            source.Read(sendAsTarget_);
            source.Read(writeLog_);
            targetFilePrefix_.ReadFrom( source );
            source.Read(targetMMSI_);
            source.Read(latitude_);
            source.Read(longitude_);
            source.Read(testSourceEnabled_);
            proxyServer_.ReadFrom( source );
            source.Read(useProxyServer_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<OilspillDetectorConfigurationData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<OilspillDetectorConfigurationData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const OilspillDetectorConfigurationData& >( other );
                if ( dataObject.rowVersion_ != rowVersion_ )
                {
                    return false;
                }
                if ( dataObject.oilSpillDetector_ != oilSpillDetector_ )
                {
                    return false;
                }
                if ( dataObject.timestamp_ != timestamp_ )
                {
                    return false;
                }
                if ( dataObject.range_ != range_ )
                {
                    return false;
                }
                if ( dataObject.startAngle_ != startAngle_ )
                {
                    return false;
                }
                if ( dataObject.endAngle_ != endAngle_ )
                {
                    return false;
                }
                if ( dataObject.startRange_ != startRange_ )
                {
                    return false;
                }
                if ( dataObject.endRange_ != endRange_ )
                {
                    return false;
                }
                if ( dataObject.updateRate_ != updateRate_ )
                {
                    return false;
                }
                if ( dataObject.statusSendTime_ != statusSendTime_ )
                {
                    return false;
                }
                if ( dataObject.drawBorder_ != drawBorder_ )
                {
                    return false;
                }
                if ( dataObject.colors_ != colors_ )
                {
                    return false;
                }
                if ( dataObject.sendToServer_ != sendToServer_ )
                {
                    return false;
                }
                if ( dataObject.directory_ != directory_ )
                {
                    return false;
                }
                if ( dataObject.transparentWater_ != transparentWater_ )
                {
                    return false;
                }
                if ( dataObject.savePictures_ != savePictures_ )
                {
                    return false;
                }
                if ( dataObject.sendAsTarget_ != sendAsTarget_ )
                {
                    return false;
                }
                if ( dataObject.writeLog_ != writeLog_ )
                {
                    return false;
                }
                if ( dataObject.targetFilePrefix_ != targetFilePrefix_ )
                {
                    return false;
                }
                if ( dataObject.targetMMSI_ != targetMMSI_ )
                {
                    return false;
                }
                if ( dataObject.latitude_ != latitude_ )
                {
                    return false;
                }
                if ( dataObject.longitude_ != longitude_ )
                {
                    return false;
                }
                if ( dataObject.testSourceEnabled_ != testSourceEnabled_ )
                {
                    return false;
                }
                if ( dataObject.proxyServer_ != proxyServer_ )
                {
                    return false;
                }
                if ( dataObject.useProxyServer_ != useProxyServer_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
    };
    class Position2DTimeseriesValueData : public BaseData<Kind, Guid>
    {
    public:
        using Base = BaseData<Kind, Guid>;
        static constexpr Kind KIND = Kind::Position2DTimeseriesValue;
    private:
        Int64 rowVersion_ = 0;
        Guid timeseries_;
        DateTime timestamp_;
        DBDouble x_;
        DBDouble y_;
    public:
        Position2DTimeseriesValueData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(rowVersion_);
            destination.Write(timeseries_);
            destination.Write(timestamp_);
            x_.WriteTo( destination );
            y_.WriteTo( destination );
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(rowVersion_);
            source.Read(timeseries_);
            source.Read(timestamp_);
            x_.ReadFrom( source );
            y_.ReadFrom( source );
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<Position2DTimeseriesValueData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<Position2DTimeseriesValueData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const Position2DTimeseriesValueData& >( other );
                if ( dataObject.rowVersion_ != rowVersion_ )
                {
                    return false;
                }
                if ( dataObject.timeseries_ != timeseries_ )
                {
                    return false;
                }
                if ( dataObject.timestamp_ != timestamp_ )
                {
                    return false;
                }
                if ( dataObject.x_ != x_ )
                {
                    return false;
                }
                if ( dataObject.y_ != y_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
    };
    class Position3DTimeseriesValueData : public BaseData<Kind, Guid>
    {
    public:
        using Base = BaseData<Kind, Guid>;
        static constexpr Kind KIND = Kind::Position3DTimeseriesValue;
    private:
        Int64 rowVersion_ = 0;
        Guid timeseries_;
        DateTime timestamp_;
        DBDouble x_;
        DBDouble y_;
        DBDouble z_;
    public:
        Position3DTimeseriesValueData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(rowVersion_);
            destination.Write(timeseries_);
            destination.Write(timestamp_);
            x_.WriteTo( destination );
            y_.WriteTo( destination );
            z_.WriteTo( destination );
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(rowVersion_);
            source.Read(timeseries_);
            source.Read(timestamp_);
            x_.ReadFrom( source );
            y_.ReadFrom( source );
            z_.ReadFrom( source );
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<Position3DTimeseriesValueData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<Position3DTimeseriesValueData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const Position3DTimeseriesValueData& >( other );
                if ( dataObject.rowVersion_ != rowVersion_ )
                {
                    return false;
                }
                if ( dataObject.timeseries_ != timeseries_ )
                {
                    return false;
                }
                if ( dataObject.timestamp_ != timestamp_ )
                {
                    return false;
                }
                if ( dataObject.x_ != x_ )
                {
                    return false;
                }
                if ( dataObject.y_ != y_ )
                {
                    return false;
                }
                if ( dataObject.z_ != z_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
    };
    class ProcessTrackValueResultData : public BaseData<Kind, Guid>
    {
    public:
        using Base = BaseData<Kind, Guid>;
        static constexpr Kind KIND = Kind::ProcessTrackValueResult;
    private:
        Int64 rowVersion_ = 0;
        bool createdNewTrack_ = false;
        Guid trackId_;
    public:
        ProcessTrackValueResultData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(rowVersion_);
            destination.Write(createdNewTrack_);
            destination.Write(trackId_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(rowVersion_);
            source.Read(createdNewTrack_);
            source.Read(trackId_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<ProcessTrackValueResultData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<ProcessTrackValueResultData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const ProcessTrackValueResultData& >( other );
                if ( dataObject.rowVersion_ != rowVersion_ )
                {
                    return false;
                }
                if ( dataObject.createdNewTrack_ != createdNewTrack_ )
                {
                    return false;
                }
                if ( dataObject.trackId_ != trackId_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
    };
    class PropertyData : public BaseData<Kind, Guid>
    {
    public:
        using Base = BaseData<Kind, Guid>;
        static constexpr Kind KIND = Kind::Property;
    private:
        Int64 rowVersion_ = 0;
        Guid element_;
        Guid definition_;
    public:
        PropertyData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(rowVersion_);
            destination.Write(element_);
            destination.Write(definition_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(rowVersion_);
            source.Read(element_);
            source.Read(definition_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<PropertyData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<PropertyData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const PropertyData& >( other );
                if ( dataObject.rowVersion_ != rowVersion_ )
                {
                    return false;
                }
                if ( dataObject.element_ != element_ )
                {
                    return false;
                }
                if ( dataObject.definition_ != definition_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
    };
    class BinaryPropertyData : public PropertyData
    {
    public:
        using Base = PropertyData;
        static constexpr Kind KIND = Kind::BinaryProperty;
    private:
        Binary value_;
        SQLLEN valueLength_ = SQL_NULL_DATA;
    public:
        BinaryPropertyData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(value_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(value_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<BinaryPropertyData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<BinaryPropertyData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const BinaryPropertyData& >( other );
                if ( dataObject.value_ != value_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
    };
    class BooleanPropertyData : public PropertyData
    {
    public:
        using Base = PropertyData;
        static constexpr Kind KIND = Kind::BooleanProperty;
    private:
        bool value_ = false;
    public:
        BooleanPropertyData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(value_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(value_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<BooleanPropertyData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<BooleanPropertyData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const BooleanPropertyData& >( other );
                if ( dataObject.value_ != value_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
    };
    class BytePropertyData : public PropertyData
    {
    public:
        using Base = PropertyData;
        static constexpr Kind KIND = Kind::ByteProperty;
    private:
        Byte value_ = 0;
    public:
        BytePropertyData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(value_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(value_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<BytePropertyData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<BytePropertyData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const BytePropertyData& >( other );
                if ( dataObject.value_ != value_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
    };
    class DateTimePropertyData : public PropertyData
    {
    public:
        using Base = PropertyData;
        static constexpr Kind KIND = Kind::DateTimeProperty;
    private:
        DateTime value_;
    public:
        DateTimePropertyData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(value_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(value_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<DateTimePropertyData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<DateTimePropertyData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const DateTimePropertyData& >( other );
                if ( dataObject.value_ != value_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
    };
    class DoublePropertyData : public PropertyData
    {
    public:
        using Base = PropertyData;
        static constexpr Kind KIND = Kind::DoubleProperty;
    private:
        double value_ = 0.0;
    public:
        DoublePropertyData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(value_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(value_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<DoublePropertyData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<DoublePropertyData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const DoublePropertyData& >( other );
                if ( dataObject.value_ != value_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
    };
    class GuidPropertyData : public PropertyData
    {
    public:
        using Base = PropertyData;
        static constexpr Kind KIND = Kind::GuidProperty;
    private:
        Guid value_;
    public:
        GuidPropertyData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(value_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(value_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<GuidPropertyData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<GuidPropertyData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const GuidPropertyData& >( other );
                if ( dataObject.value_ != value_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
    };
    class Int16PropertyData : public PropertyData
    {
    public:
        using Base = PropertyData;
        static constexpr Kind KIND = Kind::Int16Property;
    private:
        Int16 value_ = 0;
    public:
        Int16PropertyData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(value_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(value_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<Int16PropertyData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<Int16PropertyData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const Int16PropertyData& >( other );
                if ( dataObject.value_ != value_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
    };
    class Int32PropertyData : public PropertyData
    {
    public:
        using Base = PropertyData;
        static constexpr Kind KIND = Kind::Int32Property;
    private:
        Int32 value_ = 0;
    public:
        Int32PropertyData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(value_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(value_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<Int32PropertyData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<Int32PropertyData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const Int32PropertyData& >( other );
                if ( dataObject.value_ != value_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
    };
    class Int64PropertyData : public PropertyData
    {
    public:
        using Base = PropertyData;
        static constexpr Kind KIND = Kind::Int64Property;
    private:
        Int64 value_ = 0;
    public:
        Int64PropertyData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(value_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(value_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<Int64PropertyData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<Int64PropertyData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const Int64PropertyData& >( other );
                if ( dataObject.value_ != value_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
    };
    class ReferencePropertyData : public PropertyData
    {
    public:
        using Base = PropertyData;
        static constexpr Kind KIND = Kind::ReferenceProperty;
    private:
        Guid value_;
    public:
        ReferencePropertyData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(value_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(value_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<ReferencePropertyData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<ReferencePropertyData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const ReferencePropertyData& >( other );
                if ( dataObject.value_ != value_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
    };
    class SBytePropertyData : public PropertyData
    {
    public:
        using Base = PropertyData;
        static constexpr Kind KIND = Kind::SByteProperty;
    private:
        SByte value_ = 0;
    public:
        SBytePropertyData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(value_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(value_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<SBytePropertyData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<SBytePropertyData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const SBytePropertyData& >( other );
                if ( dataObject.value_ != value_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
    };
    class SinglePropertyData : public PropertyData
    {
    public:
        using Base = PropertyData;
        static constexpr Kind KIND = Kind::SingleProperty;
    private:
        float value_ = 0.0f;
    public:
        SinglePropertyData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(value_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(value_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<SinglePropertyData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<SinglePropertyData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const SinglePropertyData& >( other );
                if ( dataObject.value_ != value_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
    };
    class StringPropertyData : public PropertyData
    {
    public:
        using Base = PropertyData;
        static constexpr Kind KIND = Kind::StringProperty;
    private:
        FixedDBWideString<100> value_;
    public:
        StringPropertyData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            value_.WriteTo( destination );
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            value_.ReadFrom( source );
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<StringPropertyData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<StringPropertyData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const StringPropertyData& >( other );
                if ( dataObject.value_ != value_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
    };
    class TimeseriesPropertyData : public PropertyData
    {
    public:
        using Base = PropertyData;
        static constexpr Kind KIND = Kind::TimeseriesProperty;
    private:
    public:
        TimeseriesPropertyData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<TimeseriesPropertyData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<TimeseriesPropertyData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const TimeseriesPropertyData& >( other );
                return true;
            }
            return false;
        }
    };
    class BinaryTimeseriesPropertyData : public TimeseriesPropertyData
    {
    public:
        using Base = TimeseriesPropertyData;
        static constexpr Kind KIND = Kind::BinaryTimeseriesProperty;
    private:
        Guid timeseries_;
    public:
        BinaryTimeseriesPropertyData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(timeseries_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(timeseries_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<BinaryTimeseriesPropertyData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<BinaryTimeseriesPropertyData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const BinaryTimeseriesPropertyData& >( other );
                if ( dataObject.timeseries_ != timeseries_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
    };
    class BooleanTimeseriesPropertyData : public TimeseriesPropertyData
    {
    public:
        using Base = TimeseriesPropertyData;
        static constexpr Kind KIND = Kind::BooleanTimeseriesProperty;
    private:
        Guid timeseries_;
    public:
        BooleanTimeseriesPropertyData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(timeseries_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(timeseries_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<BooleanTimeseriesPropertyData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<BooleanTimeseriesPropertyData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const BooleanTimeseriesPropertyData& >( other );
                if ( dataObject.timeseries_ != timeseries_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
    };
    class ByteTimeseriesPropertyData : public TimeseriesPropertyData
    {
    public:
        using Base = TimeseriesPropertyData;
        static constexpr Kind KIND = Kind::ByteTimeseriesProperty;
    private:
        Guid timeseries_;
    public:
        ByteTimeseriesPropertyData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(timeseries_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(timeseries_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<ByteTimeseriesPropertyData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<ByteTimeseriesPropertyData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const ByteTimeseriesPropertyData& >( other );
                if ( dataObject.timeseries_ != timeseries_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
    };
    class DateTimeTimeseriesPropertyData : public TimeseriesPropertyData
    {
    public:
        using Base = TimeseriesPropertyData;
        static constexpr Kind KIND = Kind::DateTimeTimeseriesProperty;
    private:
        Guid timeseries_;
    public:
        DateTimeTimeseriesPropertyData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(timeseries_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(timeseries_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<DateTimeTimeseriesPropertyData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<DateTimeTimeseriesPropertyData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const DateTimeTimeseriesPropertyData& >( other );
                if ( dataObject.timeseries_ != timeseries_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
    };
    class DoubleTimeseriesPropertyData : public TimeseriesPropertyData
    {
    public:
        using Base = TimeseriesPropertyData;
        static constexpr Kind KIND = Kind::DoubleTimeseriesProperty;
    private:
        Guid timeseries_;
    public:
        DoubleTimeseriesPropertyData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(timeseries_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(timeseries_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<DoubleTimeseriesPropertyData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<DoubleTimeseriesPropertyData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const DoubleTimeseriesPropertyData& >( other );
                if ( dataObject.timeseries_ != timeseries_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
    };
    class GuidTimeseriesPropertyData : public TimeseriesPropertyData
    {
    public:
        using Base = TimeseriesPropertyData;
        static constexpr Kind KIND = Kind::GuidTimeseriesProperty;
    private:
        Guid timeseries_;
    public:
        GuidTimeseriesPropertyData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(timeseries_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(timeseries_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<GuidTimeseriesPropertyData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<GuidTimeseriesPropertyData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const GuidTimeseriesPropertyData& >( other );
                if ( dataObject.timeseries_ != timeseries_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
    };
    class Int16TimeseriesPropertyData : public TimeseriesPropertyData
    {
    public:
        using Base = TimeseriesPropertyData;
        static constexpr Kind KIND = Kind::Int16TimeseriesProperty;
    private:
        Guid timeseries_;
    public:
        Int16TimeseriesPropertyData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(timeseries_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(timeseries_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<Int16TimeseriesPropertyData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<Int16TimeseriesPropertyData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const Int16TimeseriesPropertyData& >( other );
                if ( dataObject.timeseries_ != timeseries_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
    };
    class Int32TimeseriesPropertyData : public TimeseriesPropertyData
    {
    public:
        using Base = TimeseriesPropertyData;
        static constexpr Kind KIND = Kind::Int32TimeseriesProperty;
    private:
        Guid timeseries_;
    public:
        Int32TimeseriesPropertyData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(timeseries_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(timeseries_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<Int32TimeseriesPropertyData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<Int32TimeseriesPropertyData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const Int32TimeseriesPropertyData& >( other );
                if ( dataObject.timeseries_ != timeseries_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
    };
    class Int64TimeseriesPropertyData : public TimeseriesPropertyData
    {
    public:
        using Base = TimeseriesPropertyData;
        static constexpr Kind KIND = Kind::Int64TimeseriesProperty;
    private:
        Guid timeseries_;
    public:
        Int64TimeseriesPropertyData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(timeseries_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(timeseries_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<Int64TimeseriesPropertyData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<Int64TimeseriesPropertyData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const Int64TimeseriesPropertyData& >( other );
                if ( dataObject.timeseries_ != timeseries_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
    };
    class ReferenceTimeseriesPropertyData : public TimeseriesPropertyData
    {
    public:
        using Base = TimeseriesPropertyData;
        static constexpr Kind KIND = Kind::ReferenceTimeseriesProperty;
    private:
        Guid timeseries_;
    public:
        ReferenceTimeseriesPropertyData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(timeseries_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(timeseries_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<ReferenceTimeseriesPropertyData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<ReferenceTimeseriesPropertyData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const ReferenceTimeseriesPropertyData& >( other );
                if ( dataObject.timeseries_ != timeseries_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
    };
    class SByteTimeseriesPropertyData : public TimeseriesPropertyData
    {
    public:
        using Base = TimeseriesPropertyData;
        static constexpr Kind KIND = Kind::SByteTimeseriesProperty;
    private:
        Guid timeseries_;
    public:
        SByteTimeseriesPropertyData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(timeseries_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(timeseries_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<SByteTimeseriesPropertyData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<SByteTimeseriesPropertyData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const SByteTimeseriesPropertyData& >( other );
                if ( dataObject.timeseries_ != timeseries_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
    };
    class SingleTimeseriesPropertyData : public TimeseriesPropertyData
    {
    public:
        using Base = TimeseriesPropertyData;
        static constexpr Kind KIND = Kind::SingleTimeseriesProperty;
    private:
        Guid timeseries_;
    public:
        SingleTimeseriesPropertyData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(timeseries_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(timeseries_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<SingleTimeseriesPropertyData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<SingleTimeseriesPropertyData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const SingleTimeseriesPropertyData& >( other );
                if ( dataObject.timeseries_ != timeseries_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
    };
    class StringTimeseriesPropertyData : public TimeseriesPropertyData
    {
    public:
        using Base = TimeseriesPropertyData;
        static constexpr Kind KIND = Kind::StringTimeseriesProperty;
    private:
        Guid timeseries_;
    public:
        StringTimeseriesPropertyData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(timeseries_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(timeseries_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<StringTimeseriesPropertyData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<StringTimeseriesPropertyData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const StringTimeseriesPropertyData& >( other );
                if ( dataObject.timeseries_ != timeseries_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
    };
    class TimeSpanTimeseriesPropertyData : public TimeseriesPropertyData
    {
    public:
        using Base = TimeseriesPropertyData;
        static constexpr Kind KIND = Kind::TimeSpanTimeseriesProperty;
    private:
        Guid timeseries_;
    public:
        TimeSpanTimeseriesPropertyData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(timeseries_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(timeseries_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<TimeSpanTimeseriesPropertyData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<TimeSpanTimeseriesPropertyData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const TimeSpanTimeseriesPropertyData& >( other );
                if ( dataObject.timeseries_ != timeseries_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
    };
    class UInt16TimeseriesPropertyData : public TimeseriesPropertyData
    {
    public:
        using Base = TimeseriesPropertyData;
        static constexpr Kind KIND = Kind::UInt16TimeseriesProperty;
    private:
        Guid timeseries_;
    public:
        UInt16TimeseriesPropertyData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(timeseries_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(timeseries_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<UInt16TimeseriesPropertyData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<UInt16TimeseriesPropertyData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const UInt16TimeseriesPropertyData& >( other );
                if ( dataObject.timeseries_ != timeseries_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
    };
    class UInt32TimeseriesPropertyData : public TimeseriesPropertyData
    {
    public:
        using Base = TimeseriesPropertyData;
        static constexpr Kind KIND = Kind::UInt32TimeseriesProperty;
    private:
        Guid timeseries_;
    public:
        UInt32TimeseriesPropertyData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(timeseries_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(timeseries_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<UInt32TimeseriesPropertyData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<UInt32TimeseriesPropertyData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const UInt32TimeseriesPropertyData& >( other );
                if ( dataObject.timeseries_ != timeseries_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
    };
    class UInt64TimeseriesPropertyData : public TimeseriesPropertyData
    {
    public:
        using Base = TimeseriesPropertyData;
        static constexpr Kind KIND = Kind::UInt64TimeseriesProperty;
    private:
        Guid timeseries_;
    public:
        UInt64TimeseriesPropertyData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(timeseries_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(timeseries_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<UInt64TimeseriesPropertyData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<UInt64TimeseriesPropertyData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const UInt64TimeseriesPropertyData& >( other );
                if ( dataObject.timeseries_ != timeseries_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
    };
    class TimeSpanPropertyData : public PropertyData
    {
    public:
        using Base = PropertyData;
        static constexpr Kind KIND = Kind::TimeSpanProperty;
    private:
        TimeSpan value_;
    public:
        TimeSpanPropertyData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(value_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(value_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<TimeSpanPropertyData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<TimeSpanPropertyData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const TimeSpanPropertyData& >( other );
                if ( dataObject.value_ != value_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
    };
    class UInt16PropertyData : public PropertyData
    {
    public:
        using Base = PropertyData;
        static constexpr Kind KIND = Kind::UInt16Property;
    private:
        UInt16 value_ = 0;
    public:
        UInt16PropertyData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(value_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(value_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<UInt16PropertyData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<UInt16PropertyData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const UInt16PropertyData& >( other );
                if ( dataObject.value_ != value_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
    };
    class UInt32PropertyData : public PropertyData
    {
    public:
        using Base = PropertyData;
        static constexpr Kind KIND = Kind::UInt32Property;
    private:
        UInt32 value_ = 0;
    public:
        UInt32PropertyData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(value_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(value_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<UInt32PropertyData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<UInt32PropertyData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const UInt32PropertyData& >( other );
                if ( dataObject.value_ != value_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
    };
    class UInt64PropertyData : public PropertyData
    {
    public:
        using Base = PropertyData;
        static constexpr Kind KIND = Kind::UInt64Property;
    private:
        Int64 value_ = 0;
    public:
        UInt64PropertyData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(value_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(value_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<UInt64PropertyData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<UInt64PropertyData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const UInt64PropertyData& >( other );
                if ( dataObject.value_ != value_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
    };
    class PropertyDefinitionData : public BaseData<Kind, Guid>
    {
    public:
        using Base = BaseData<Kind, Guid>;
        static constexpr Kind KIND = Kind::PropertyDefinition;
    private:
        Int64 rowVersion_ = 0;
        Guid elementType_;
        FixedDBWideString<127> name_;
        WideString description_;
        SQLLEN descriptionLength_ = SQL_NULL_DATA;
    public:
        PropertyDefinitionData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(rowVersion_);
            destination.Write(elementType_);
            name_.WriteTo( destination );
            destination.Write(description_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(rowVersion_);
            source.Read(elementType_);
            name_.ReadFrom( source );
            source.Read(description_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<PropertyDefinitionData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<PropertyDefinitionData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const PropertyDefinitionData& >( other );
                if ( dataObject.rowVersion_ != rowVersion_ )
                {
                    return false;
                }
                if ( dataObject.elementType_ != elementType_ )
                {
                    return false;
                }
                if ( dataObject.name_ != name_ )
                {
                    return false;
                }
                if ( dataObject.description_ != description_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
    };
    class BinaryPropertyDefinitionData : public PropertyDefinitionData
    {
    public:
        using Base = PropertyDefinitionData;
        static constexpr Kind KIND = Kind::BinaryPropertyDefinition;
    private:
        Binary defaultValue_;
        SQLLEN defaultValueLength_ = SQL_NULL_DATA;
    public:
        BinaryPropertyDefinitionData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(defaultValue_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(defaultValue_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<BinaryPropertyDefinitionData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<BinaryPropertyDefinitionData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const BinaryPropertyDefinitionData& >( other );
                if ( dataObject.defaultValue_ != defaultValue_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
    };
    class BooleanPropertyDefinitionData : public PropertyDefinitionData
    {
    public:
        using Base = PropertyDefinitionData;
        static constexpr Kind KIND = Kind::BooleanPropertyDefinition;
    private:
        bool defaultValue_ = false;
    public:
        BooleanPropertyDefinitionData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(defaultValue_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(defaultValue_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<BooleanPropertyDefinitionData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<BooleanPropertyDefinitionData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const BooleanPropertyDefinitionData& >( other );
                if ( dataObject.defaultValue_ != defaultValue_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
    };
    class BytePropertyDefinitionData : public PropertyDefinitionData
    {
    public:
        using Base = PropertyDefinitionData;
        static constexpr Kind KIND = Kind::BytePropertyDefinition;
    private:
        Byte defaultValue_ = 0;
        Byte minValue_ = 0;
        Byte maxValue_ = 0;
    public:
        BytePropertyDefinitionData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(defaultValue_);
            destination.Write(minValue_);
            destination.Write(maxValue_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(defaultValue_);
            source.Read(minValue_);
            source.Read(maxValue_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<BytePropertyDefinitionData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<BytePropertyDefinitionData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const BytePropertyDefinitionData& >( other );
                if ( dataObject.defaultValue_ != defaultValue_ )
                {
                    return false;
                }
                if ( dataObject.minValue_ != minValue_ )
                {
                    return false;
                }
                if ( dataObject.maxValue_ != maxValue_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
    };
    class DateTimePropertyDefinitionData : public PropertyDefinitionData
    {
    public:
        using Base = PropertyDefinitionData;
        static constexpr Kind KIND = Kind::DateTimePropertyDefinition;
    private:
        FixedDBWideString<100> defaultValue_;
        FixedDBWideString<100> minValue_;
        FixedDBWideString<100> maxValue_;
    public:
        DateTimePropertyDefinitionData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            defaultValue_.WriteTo( destination );
            minValue_.WriteTo( destination );
            maxValue_.WriteTo( destination );
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            defaultValue_.ReadFrom( source );
            minValue_.ReadFrom( source );
            maxValue_.ReadFrom( source );
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<DateTimePropertyDefinitionData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<DateTimePropertyDefinitionData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const DateTimePropertyDefinitionData& >( other );
                if ( dataObject.defaultValue_ != defaultValue_ )
                {
                    return false;
                }
                if ( dataObject.minValue_ != minValue_ )
                {
                    return false;
                }
                if ( dataObject.maxValue_ != maxValue_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
    };
    class DoublePropertyDefinitionData : public PropertyDefinitionData
    {
    public:
        using Base = PropertyDefinitionData;
        static constexpr Kind KIND = Kind::DoublePropertyDefinition;
    private:
        double defaultValue_ = 0.0;
        double minValue_ = 0.0;
        double maxValue_ = 0.0;
    public:
        DoublePropertyDefinitionData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(defaultValue_);
            destination.Write(minValue_);
            destination.Write(maxValue_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(defaultValue_);
            source.Read(minValue_);
            source.Read(maxValue_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<DoublePropertyDefinitionData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<DoublePropertyDefinitionData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const DoublePropertyDefinitionData& >( other );
                if ( dataObject.defaultValue_ != defaultValue_ )
                {
                    return false;
                }
                if ( dataObject.minValue_ != minValue_ )
                {
                    return false;
                }
                if ( dataObject.maxValue_ != maxValue_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
    };
    class GuidPropertyDefinitionData : public PropertyDefinitionData
    {
    public:
        using Base = PropertyDefinitionData;
        static constexpr Kind KIND = Kind::GuidPropertyDefinition;
    private:
        Guid defaultValue_;
    public:
        GuidPropertyDefinitionData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(defaultValue_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(defaultValue_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<GuidPropertyDefinitionData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<GuidPropertyDefinitionData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const GuidPropertyDefinitionData& >( other );
                if ( dataObject.defaultValue_ != defaultValue_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
    };
    class Int16PropertyDefinitionData : public PropertyDefinitionData
    {
    public:
        using Base = PropertyDefinitionData;
        static constexpr Kind KIND = Kind::Int16PropertyDefinition;
    private:
        Int16 defaultValue_ = 0;
        Int16 minValue_ = 0;
        Int16 maxValue_ = 0;
    public:
        Int16PropertyDefinitionData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(defaultValue_);
            destination.Write(minValue_);
            destination.Write(maxValue_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(defaultValue_);
            source.Read(minValue_);
            source.Read(maxValue_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<Int16PropertyDefinitionData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<Int16PropertyDefinitionData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const Int16PropertyDefinitionData& >( other );
                if ( dataObject.defaultValue_ != defaultValue_ )
                {
                    return false;
                }
                if ( dataObject.minValue_ != minValue_ )
                {
                    return false;
                }
                if ( dataObject.maxValue_ != maxValue_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
    };
    class Int32PropertyDefinitionData : public PropertyDefinitionData
    {
    public:
        using Base = PropertyDefinitionData;
        static constexpr Kind KIND = Kind::Int32PropertyDefinition;
    private:
        Int32 defaultValue_ = 0;
        Int32 minValue_ = 0;
        Int32 maxValue_ = 0;
    public:
        Int32PropertyDefinitionData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(defaultValue_);
            destination.Write(minValue_);
            destination.Write(maxValue_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(defaultValue_);
            source.Read(minValue_);
            source.Read(maxValue_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<Int32PropertyDefinitionData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<Int32PropertyDefinitionData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const Int32PropertyDefinitionData& >( other );
                if ( dataObject.defaultValue_ != defaultValue_ )
                {
                    return false;
                }
                if ( dataObject.minValue_ != minValue_ )
                {
                    return false;
                }
                if ( dataObject.maxValue_ != maxValue_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
    };
    class Int64PropertyDefinitionData : public PropertyDefinitionData
    {
    public:
        using Base = PropertyDefinitionData;
        static constexpr Kind KIND = Kind::Int64PropertyDefinition;
    private:
        Int64 defaultValue_ = 0;
        Int64 minValue_ = 0;
        Int64 maxValue_ = 0;
    public:
        Int64PropertyDefinitionData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(defaultValue_);
            destination.Write(minValue_);
            destination.Write(maxValue_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(defaultValue_);
            source.Read(minValue_);
            source.Read(maxValue_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<Int64PropertyDefinitionData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<Int64PropertyDefinitionData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const Int64PropertyDefinitionData& >( other );
                if ( dataObject.defaultValue_ != defaultValue_ )
                {
                    return false;
                }
                if ( dataObject.minValue_ != minValue_ )
                {
                    return false;
                }
                if ( dataObject.maxValue_ != maxValue_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
    };
    class ReferencePropertyDefinitionData : public PropertyDefinitionData
    {
    public:
        using Base = PropertyDefinitionData;
        static constexpr Kind KIND = Kind::ReferencePropertyDefinition;
    private:
        Guid defaultValue_;
        Guid referencedElementType_;
    public:
        ReferencePropertyDefinitionData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(defaultValue_);
            destination.Write(referencedElementType_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(defaultValue_);
            source.Read(referencedElementType_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<ReferencePropertyDefinitionData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<ReferencePropertyDefinitionData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const ReferencePropertyDefinitionData& >( other );
                if ( dataObject.defaultValue_ != defaultValue_ )
                {
                    return false;
                }
                if ( dataObject.referencedElementType_ != referencedElementType_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
    };
    class SBytePropertyDefinitionData : public PropertyDefinitionData
    {
    public:
        using Base = PropertyDefinitionData;
        static constexpr Kind KIND = Kind::SBytePropertyDefinition;
    private:
        SByte defaultValue_ = 0;
        SByte minValue_ = 0;
        SByte maxValue_ = 0;
    public:
        SBytePropertyDefinitionData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(defaultValue_);
            destination.Write(minValue_);
            destination.Write(maxValue_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(defaultValue_);
            source.Read(minValue_);
            source.Read(maxValue_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<SBytePropertyDefinitionData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<SBytePropertyDefinitionData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const SBytePropertyDefinitionData& >( other );
                if ( dataObject.defaultValue_ != defaultValue_ )
                {
                    return false;
                }
                if ( dataObject.minValue_ != minValue_ )
                {
                    return false;
                }
                if ( dataObject.maxValue_ != maxValue_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
    };
    class SinglePropertyDefinitionData : public PropertyDefinitionData
    {
    public:
        using Base = PropertyDefinitionData;
        static constexpr Kind KIND = Kind::SinglePropertyDefinition;
    private:
        float defaultValue_ = 0.0f;
        float minValue_ = 0.0f;
        float maxValue_ = 0.0f;
    public:
        SinglePropertyDefinitionData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(defaultValue_);
            destination.Write(minValue_);
            destination.Write(maxValue_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(defaultValue_);
            source.Read(minValue_);
            source.Read(maxValue_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<SinglePropertyDefinitionData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<SinglePropertyDefinitionData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const SinglePropertyDefinitionData& >( other );
                if ( dataObject.defaultValue_ != defaultValue_ )
                {
                    return false;
                }
                if ( dataObject.minValue_ != minValue_ )
                {
                    return false;
                }
                if ( dataObject.maxValue_ != maxValue_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
    };
    class StringPropertyDefinitionData : public PropertyDefinitionData
    {
    public:
        using Base = PropertyDefinitionData;
        static constexpr Kind KIND = Kind::StringPropertyDefinition;
    private:
        FixedDBWideString<100> defaultValue_;
        FixedDBWideString<100> pattern_;
    public:
        StringPropertyDefinitionData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            defaultValue_.WriteTo( destination );
            pattern_.WriteTo( destination );
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            defaultValue_.ReadFrom( source );
            pattern_.ReadFrom( source );
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<StringPropertyDefinitionData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<StringPropertyDefinitionData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const StringPropertyDefinitionData& >( other );
                if ( dataObject.defaultValue_ != defaultValue_ )
                {
                    return false;
                }
                if ( dataObject.pattern_ != pattern_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
    };
    class TimeseriesPropertyDefinitionData : public PropertyDefinitionData
    {
    public:
        using Base = PropertyDefinitionData;
        static constexpr Kind KIND = Kind::TimeseriesPropertyDefinition;
    private:
    public:
        TimeseriesPropertyDefinitionData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<TimeseriesPropertyDefinitionData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<TimeseriesPropertyDefinitionData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const TimeseriesPropertyDefinitionData& >( other );
                return true;
            }
            return false;
        }
    };
    class BinaryTimeseriesPropertyDefinitionData : public TimeseriesPropertyDefinitionData
    {
    public:
        using Base = TimeseriesPropertyDefinitionData;
        static constexpr Kind KIND = Kind::BinaryTimeseriesPropertyDefinition;
    private:
    public:
        BinaryTimeseriesPropertyDefinitionData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<BinaryTimeseriesPropertyDefinitionData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<BinaryTimeseriesPropertyDefinitionData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const BinaryTimeseriesPropertyDefinitionData& >( other );
                return true;
            }
            return false;
        }
    };
    class BooleanTimeseriesPropertyDefinitionData : public TimeseriesPropertyDefinitionData
    {
    public:
        using Base = TimeseriesPropertyDefinitionData;
        static constexpr Kind KIND = Kind::BooleanTimeseriesPropertyDefinition;
    private:
    public:
        BooleanTimeseriesPropertyDefinitionData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<BooleanTimeseriesPropertyDefinitionData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<BooleanTimeseriesPropertyDefinitionData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const BooleanTimeseriesPropertyDefinitionData& >( other );
                return true;
            }
            return false;
        }
    };
    class ByteTimeseriesPropertyDefinitionData : public TimeseriesPropertyDefinitionData
    {
    public:
        using Base = TimeseriesPropertyDefinitionData;
        static constexpr Kind KIND = Kind::ByteTimeseriesPropertyDefinition;
    private:
        Byte minValue_ = 0;
        Byte maxValue_ = 0;
    public:
        ByteTimeseriesPropertyDefinitionData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(minValue_);
            destination.Write(maxValue_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(minValue_);
            source.Read(maxValue_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<ByteTimeseriesPropertyDefinitionData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<ByteTimeseriesPropertyDefinitionData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const ByteTimeseriesPropertyDefinitionData& >( other );
                if ( dataObject.minValue_ != minValue_ )
                {
                    return false;
                }
                if ( dataObject.maxValue_ != maxValue_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
    };
    class DateTimeTimeseriesPropertyDefinitionData : public TimeseriesPropertyDefinitionData
    {
    public:
        using Base = TimeseriesPropertyDefinitionData;
        static constexpr Kind KIND = Kind::DateTimeTimeseriesPropertyDefinition;
    private:
        FixedDBWideString<100> minValue_;
        FixedDBWideString<100> maxValue_;
    public:
        DateTimeTimeseriesPropertyDefinitionData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            minValue_.WriteTo( destination );
            maxValue_.WriteTo( destination );
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            minValue_.ReadFrom( source );
            maxValue_.ReadFrom( source );
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<DateTimeTimeseriesPropertyDefinitionData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<DateTimeTimeseriesPropertyDefinitionData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const DateTimeTimeseriesPropertyDefinitionData& >( other );
                if ( dataObject.minValue_ != minValue_ )
                {
                    return false;
                }
                if ( dataObject.maxValue_ != maxValue_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
    };
    class DoubleTimeseriesPropertyDefinitionData : public TimeseriesPropertyDefinitionData
    {
    public:
        using Base = TimeseriesPropertyDefinitionData;
        static constexpr Kind KIND = Kind::DoubleTimeseriesPropertyDefinition;
    private:
        double minValue_ = 0.0;
        double maxValue_ = 0.0;
    public:
        DoubleTimeseriesPropertyDefinitionData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(minValue_);
            destination.Write(maxValue_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(minValue_);
            source.Read(maxValue_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<DoubleTimeseriesPropertyDefinitionData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<DoubleTimeseriesPropertyDefinitionData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const DoubleTimeseriesPropertyDefinitionData& >( other );
                if ( dataObject.minValue_ != minValue_ )
                {
                    return false;
                }
                if ( dataObject.maxValue_ != maxValue_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
    };
    class GuidTimeseriesPropertyDefinitionData : public TimeseriesPropertyDefinitionData
    {
    public:
        using Base = TimeseriesPropertyDefinitionData;
        static constexpr Kind KIND = Kind::GuidTimeseriesPropertyDefinition;
    private:
    public:
        GuidTimeseriesPropertyDefinitionData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<GuidTimeseriesPropertyDefinitionData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<GuidTimeseriesPropertyDefinitionData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const GuidTimeseriesPropertyDefinitionData& >( other );
                return true;
            }
            return false;
        }
    };
    class Int16TimeseriesPropertyDefinitionData : public TimeseriesPropertyDefinitionData
    {
    public:
        using Base = TimeseriesPropertyDefinitionData;
        static constexpr Kind KIND = Kind::Int16TimeseriesPropertyDefinition;
    private:
        Int16 minValue_ = 0;
        Int16 maxValue_ = 0;
    public:
        Int16TimeseriesPropertyDefinitionData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(minValue_);
            destination.Write(maxValue_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(minValue_);
            source.Read(maxValue_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<Int16TimeseriesPropertyDefinitionData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<Int16TimeseriesPropertyDefinitionData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const Int16TimeseriesPropertyDefinitionData& >( other );
                if ( dataObject.minValue_ != minValue_ )
                {
                    return false;
                }
                if ( dataObject.maxValue_ != maxValue_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
    };
    class Int32TimeseriesPropertyDefinitionData : public TimeseriesPropertyDefinitionData
    {
    public:
        using Base = TimeseriesPropertyDefinitionData;
        static constexpr Kind KIND = Kind::Int32TimeseriesPropertyDefinition;
    private:
        Int32 minValue_ = 0;
        Int32 maxValue_ = 0;
    public:
        Int32TimeseriesPropertyDefinitionData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(minValue_);
            destination.Write(maxValue_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(minValue_);
            source.Read(maxValue_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<Int32TimeseriesPropertyDefinitionData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<Int32TimeseriesPropertyDefinitionData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const Int32TimeseriesPropertyDefinitionData& >( other );
                if ( dataObject.minValue_ != minValue_ )
                {
                    return false;
                }
                if ( dataObject.maxValue_ != maxValue_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
    };
    class Int64TimeseriesPropertyDefinitionData : public TimeseriesPropertyDefinitionData
    {
    public:
        using Base = TimeseriesPropertyDefinitionData;
        static constexpr Kind KIND = Kind::Int64TimeseriesPropertyDefinition;
    private:
        Int64 minValue_ = 0;
        Int64 maxValue_ = 0;
    public:
        Int64TimeseriesPropertyDefinitionData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(minValue_);
            destination.Write(maxValue_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(minValue_);
            source.Read(maxValue_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<Int64TimeseriesPropertyDefinitionData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<Int64TimeseriesPropertyDefinitionData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const Int64TimeseriesPropertyDefinitionData& >( other );
                if ( dataObject.minValue_ != minValue_ )
                {
                    return false;
                }
                if ( dataObject.maxValue_ != maxValue_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
    };
    class ReferenceTimeseriesPropertyDefinitionData : public TimeseriesPropertyDefinitionData
    {
    public:
        using Base = TimeseriesPropertyDefinitionData;
        static constexpr Kind KIND = Kind::ReferenceTimeseriesPropertyDefinition;
    private:
        Guid referencedElementType_;
    public:
        ReferenceTimeseriesPropertyDefinitionData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(referencedElementType_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(referencedElementType_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<ReferenceTimeseriesPropertyDefinitionData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<ReferenceTimeseriesPropertyDefinitionData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const ReferenceTimeseriesPropertyDefinitionData& >( other );
                if ( dataObject.referencedElementType_ != referencedElementType_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
    };
    class SByteTimeseriesPropertyDefinitionData : public TimeseriesPropertyDefinitionData
    {
    public:
        using Base = TimeseriesPropertyDefinitionData;
        static constexpr Kind KIND = Kind::SByteTimeseriesPropertyDefinition;
    private:
        SByte minValue_ = 0;
        SByte maxValue_ = 0;
    public:
        SByteTimeseriesPropertyDefinitionData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(minValue_);
            destination.Write(maxValue_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(minValue_);
            source.Read(maxValue_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<SByteTimeseriesPropertyDefinitionData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<SByteTimeseriesPropertyDefinitionData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const SByteTimeseriesPropertyDefinitionData& >( other );
                if ( dataObject.minValue_ != minValue_ )
                {
                    return false;
                }
                if ( dataObject.maxValue_ != maxValue_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
    };
    class SingleTimeseriesPropertyDefinitionData : public TimeseriesPropertyDefinitionData
    {
    public:
        using Base = TimeseriesPropertyDefinitionData;
        static constexpr Kind KIND = Kind::SingleTimeseriesPropertyDefinition;
    private:
        float minValue_ = 0.0f;
        float maxValue_ = 0.0f;
    public:
        SingleTimeseriesPropertyDefinitionData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(minValue_);
            destination.Write(maxValue_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(minValue_);
            source.Read(maxValue_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<SingleTimeseriesPropertyDefinitionData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<SingleTimeseriesPropertyDefinitionData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const SingleTimeseriesPropertyDefinitionData& >( other );
                if ( dataObject.minValue_ != minValue_ )
                {
                    return false;
                }
                if ( dataObject.maxValue_ != maxValue_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
    };
    class StringTimeseriesPropertyDefinitionData : public TimeseriesPropertyDefinitionData
    {
    public:
        using Base = TimeseriesPropertyDefinitionData;
        static constexpr Kind KIND = Kind::StringTimeseriesPropertyDefinition;
    private:
        FixedDBWideString<100> pattern_;
    public:
        StringTimeseriesPropertyDefinitionData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            pattern_.WriteTo( destination );
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            pattern_.ReadFrom( source );
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<StringTimeseriesPropertyDefinitionData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<StringTimeseriesPropertyDefinitionData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const StringTimeseriesPropertyDefinitionData& >( other );
                if ( dataObject.pattern_ != pattern_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
    };
    class TimeSpanTimeseriesPropertyDefinitionData : public TimeseriesPropertyDefinitionData
    {
    public:
        using Base = TimeseriesPropertyDefinitionData;
        static constexpr Kind KIND = Kind::TimeSpanTimeseriesPropertyDefinition;
    private:
        TimeSpan minValue_;
        TimeSpan maxValue_;
    public:
        TimeSpanTimeseriesPropertyDefinitionData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(minValue_);
            destination.Write(maxValue_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(minValue_);
            source.Read(maxValue_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<TimeSpanTimeseriesPropertyDefinitionData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<TimeSpanTimeseriesPropertyDefinitionData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const TimeSpanTimeseriesPropertyDefinitionData& >( other );
                if ( dataObject.minValue_ != minValue_ )
                {
                    return false;
                }
                if ( dataObject.maxValue_ != maxValue_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
    };
    class UInt16TimeseriesPropertyDefinitionData : public TimeseriesPropertyDefinitionData
    {
    public:
        using Base = TimeseriesPropertyDefinitionData;
        static constexpr Kind KIND = Kind::UInt16TimeseriesPropertyDefinition;
    private:
        UInt16 minValue_ = 0;
        UInt16 maxValue_ = 0;
    public:
        UInt16TimeseriesPropertyDefinitionData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(minValue_);
            destination.Write(maxValue_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(minValue_);
            source.Read(maxValue_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<UInt16TimeseriesPropertyDefinitionData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<UInt16TimeseriesPropertyDefinitionData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const UInt16TimeseriesPropertyDefinitionData& >( other );
                if ( dataObject.minValue_ != minValue_ )
                {
                    return false;
                }
                if ( dataObject.maxValue_ != maxValue_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
    };
    class UInt32TimeseriesPropertyDefinitionData : public TimeseriesPropertyDefinitionData
    {
    public:
        using Base = TimeseriesPropertyDefinitionData;
        static constexpr Kind KIND = Kind::UInt32TimeseriesPropertyDefinition;
    private:
        UInt32 minValue_ = 0;
        UInt32 maxValue_ = 0;
    public:
        UInt32TimeseriesPropertyDefinitionData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(minValue_);
            destination.Write(maxValue_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(minValue_);
            source.Read(maxValue_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<UInt32TimeseriesPropertyDefinitionData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<UInt32TimeseriesPropertyDefinitionData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const UInt32TimeseriesPropertyDefinitionData& >( other );
                if ( dataObject.minValue_ != minValue_ )
                {
                    return false;
                }
                if ( dataObject.maxValue_ != maxValue_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
    };
    class UInt64TimeseriesPropertyDefinitionData : public TimeseriesPropertyDefinitionData
    {
    public:
        using Base = TimeseriesPropertyDefinitionData;
        static constexpr Kind KIND = Kind::UInt64TimeseriesPropertyDefinition;
    private:
        Int64 minValue_ = 0;
        Int64 maxValue_ = 0;
    public:
        UInt64TimeseriesPropertyDefinitionData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(minValue_);
            destination.Write(maxValue_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(minValue_);
            source.Read(maxValue_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<UInt64TimeseriesPropertyDefinitionData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<UInt64TimeseriesPropertyDefinitionData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const UInt64TimeseriesPropertyDefinitionData& >( other );
                if ( dataObject.minValue_ != minValue_ )
                {
                    return false;
                }
                if ( dataObject.maxValue_ != maxValue_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
    };
    class TimeSpanPropertyDefinitionData : public PropertyDefinitionData
    {
    public:
        using Base = PropertyDefinitionData;
        static constexpr Kind KIND = Kind::TimeSpanPropertyDefinition;
    private:
        TimeSpan defaultValue_;
        TimeSpan minValue_;
        TimeSpan maxValue_;
    public:
        TimeSpanPropertyDefinitionData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(defaultValue_);
            destination.Write(minValue_);
            destination.Write(maxValue_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(defaultValue_);
            source.Read(minValue_);
            source.Read(maxValue_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<TimeSpanPropertyDefinitionData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<TimeSpanPropertyDefinitionData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const TimeSpanPropertyDefinitionData& >( other );
                if ( dataObject.defaultValue_ != defaultValue_ )
                {
                    return false;
                }
                if ( dataObject.minValue_ != minValue_ )
                {
                    return false;
                }
                if ( dataObject.maxValue_ != maxValue_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
    };
    class UInt16PropertyDefinitionData : public PropertyDefinitionData
    {
    public:
        using Base = PropertyDefinitionData;
        static constexpr Kind KIND = Kind::UInt16PropertyDefinition;
    private:
        UInt16 defaultValue_ = 0;
        UInt16 minValue_ = 0;
        UInt16 maxValue_ = 0;
    public:
        UInt16PropertyDefinitionData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(defaultValue_);
            destination.Write(minValue_);
            destination.Write(maxValue_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(defaultValue_);
            source.Read(minValue_);
            source.Read(maxValue_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<UInt16PropertyDefinitionData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<UInt16PropertyDefinitionData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const UInt16PropertyDefinitionData& >( other );
                if ( dataObject.defaultValue_ != defaultValue_ )
                {
                    return false;
                }
                if ( dataObject.minValue_ != minValue_ )
                {
                    return false;
                }
                if ( dataObject.maxValue_ != maxValue_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
    };
    class UInt32PropertyDefinitionData : public PropertyDefinitionData
    {
    public:
        using Base = PropertyDefinitionData;
        static constexpr Kind KIND = Kind::UInt32PropertyDefinition;
    private:
        UInt32 defaultValue_ = 0;
        UInt32 minValue_ = 0;
        UInt32 maxValue_ = 0;
    public:
        UInt32PropertyDefinitionData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(defaultValue_);
            destination.Write(minValue_);
            destination.Write(maxValue_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(defaultValue_);
            source.Read(minValue_);
            source.Read(maxValue_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<UInt32PropertyDefinitionData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<UInt32PropertyDefinitionData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const UInt32PropertyDefinitionData& >( other );
                if ( dataObject.defaultValue_ != defaultValue_ )
                {
                    return false;
                }
                if ( dataObject.minValue_ != minValue_ )
                {
                    return false;
                }
                if ( dataObject.maxValue_ != maxValue_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
    };
    class UInt64PropertyDefinitionData : public PropertyDefinitionData
    {
    public:
        using Base = PropertyDefinitionData;
        static constexpr Kind KIND = Kind::UInt64PropertyDefinition;
    private:
        Int64 defaultValue_ = 0;
        Int64 minValue_ = 0;
        Int64 maxValue_ = 0;
    public:
        UInt64PropertyDefinitionData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(defaultValue_);
            destination.Write(minValue_);
            destination.Write(maxValue_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(defaultValue_);
            source.Read(minValue_);
            source.Read(maxValue_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<UInt64PropertyDefinitionData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<UInt64PropertyDefinitionData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const UInt64PropertyDefinitionData& >( other );
                if ( dataObject.defaultValue_ != defaultValue_ )
                {
                    return false;
                }
                if ( dataObject.minValue_ != minValue_ )
                {
                    return false;
                }
                if ( dataObject.maxValue_ != maxValue_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
    };
    class RadarAlarmStatusData : public BaseData<Kind, Guid>
    {
    public:
        using Base = BaseData<Kind, Guid>;
        static constexpr Kind KIND = Kind::RadarAlarmStatus;
    private:
        Int64 rowVersion_ = 0;
        Guid radar_;
        DateTime timestamp_;
        Data::AlarmState type_ = Data::AlarmState::Unknown;
    public:
        RadarAlarmStatusData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(rowVersion_);
            destination.Write(radar_);
            destination.Write(timestamp_);
            destination.Write(type_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(rowVersion_);
            source.Read(radar_);
            source.Read(timestamp_);
            source.Read(type_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<RadarAlarmStatusData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<RadarAlarmStatusData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const RadarAlarmStatusData& >( other );
                if ( dataObject.rowVersion_ != rowVersion_ )
                {
                    return false;
                }
                if ( dataObject.radar_ != radar_ )
                {
                    return false;
                }
                if ( dataObject.timestamp_ != timestamp_ )
                {
                    return false;
                }
                if ( dataObject.type_ != type_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
    };
    class RadarCommandData : public BaseData<Kind, Guid>
    {
    public:
        using Base = BaseData<Kind, Guid>;
        static constexpr Kind KIND = Kind::RadarCommand;
    private:
        Int64 rowVersion_ = 0;
        Guid radar_;
        DateTime timestamp_;
        Data::DeviceCommandSourceType deviceCommandSourceType_ = Data::DeviceCommandSourceType::Unknown;
        Guid deviceCommandSourceId_;
        Guid reply_;
    public:
        RadarCommandData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(rowVersion_);
            destination.Write(radar_);
            destination.Write(timestamp_);
            destination.Write(deviceCommandSourceType_);
            destination.Write(deviceCommandSourceId_);
            destination.Write(reply_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(rowVersion_);
            source.Read(radar_);
            source.Read(timestamp_);
            source.Read(deviceCommandSourceType_);
            source.Read(deviceCommandSourceId_);
            source.Read(reply_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<RadarCommandData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<RadarCommandData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const RadarCommandData& >( other );
                if ( dataObject.rowVersion_ != rowVersion_ )
                {
                    return false;
                }
                if ( dataObject.radar_ != radar_ )
                {
                    return false;
                }
                if ( dataObject.timestamp_ != timestamp_ )
                {
                    return false;
                }
                if ( dataObject.deviceCommandSourceType_ != deviceCommandSourceType_ )
                {
                    return false;
                }
                if ( dataObject.deviceCommandSourceId_ != deviceCommandSourceId_ )
                {
                    return false;
                }
                if ( dataObject.reply_ != reply_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
    };
    class RadarCommandGetStatusData : public RadarCommandData
    {
    public:
        using Base = RadarCommandData;
        static constexpr Kind KIND = Kind::RadarCommandGetStatus;
    private:
    public:
        RadarCommandGetStatusData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<RadarCommandGetStatusData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<RadarCommandGetStatusData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const RadarCommandGetStatusData& >( other );
                return true;
            }
            return false;
        }
    };
    class RadarCommandReplyData : public BaseData<Kind, Guid>
    {
    public:
        using Base = BaseData<Kind, Guid>;
        static constexpr Kind KIND = Kind::RadarCommandReply;
    private:
        Int64 rowVersion_ = 0;
        Guid radar_;
        DateTime timestamp_;
        Guid command_;
        Data::DeviceCommandReplyStatus status_ = Data::DeviceCommandReplyStatus::Unknown;
        WideString message_;
        SQLLEN messageLength_ = SQL_NULL_DATA;
    public:
        RadarCommandReplyData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(rowVersion_);
            destination.Write(radar_);
            destination.Write(timestamp_);
            destination.Write(command_);
            destination.Write(status_);
            destination.Write(message_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(rowVersion_);
            source.Read(radar_);
            source.Read(timestamp_);
            source.Read(command_);
            source.Read(status_);
            source.Read(message_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<RadarCommandReplyData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<RadarCommandReplyData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const RadarCommandReplyData& >( other );
                if ( dataObject.rowVersion_ != rowVersion_ )
                {
                    return false;
                }
                if ( dataObject.radar_ != radar_ )
                {
                    return false;
                }
                if ( dataObject.timestamp_ != timestamp_ )
                {
                    return false;
                }
                if ( dataObject.command_ != command_ )
                {
                    return false;
                }
                if ( dataObject.status_ != status_ )
                {
                    return false;
                }
                if ( dataObject.message_ != message_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
    };
    class RadarCommandReplyGetStatusData : public RadarCommandReplyData
    {
    public:
        using Base = RadarCommandReplyData;
        static constexpr Kind KIND = Kind::RadarCommandReplyGetStatus;
    private:
        Int32 azimuthCount_ = 0;
        Int32 triggerCount_ = 0;
        TimeSpan rotationCount_;
        Data::RadarPulse pulse_ = Data::RadarPulse::Short;
        bool tx_ = false;
    public:
        RadarCommandReplyGetStatusData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(azimuthCount_);
            destination.Write(triggerCount_);
            destination.Write(rotationCount_);
            destination.Write(pulse_);
            destination.Write(tx_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(azimuthCount_);
            source.Read(triggerCount_);
            source.Read(rotationCount_);
            source.Read(pulse_);
            source.Read(tx_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<RadarCommandReplyGetStatusData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<RadarCommandReplyGetStatusData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const RadarCommandReplyGetStatusData& >( other );
                if ( dataObject.azimuthCount_ != azimuthCount_ )
                {
                    return false;
                }
                if ( dataObject.triggerCount_ != triggerCount_ )
                {
                    return false;
                }
                if ( dataObject.rotationCount_ != rotationCount_ )
                {
                    return false;
                }
                if ( dataObject.pulse_ != pulse_ )
                {
                    return false;
                }
                if ( dataObject.tx_ != tx_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
    };
    class RadarConfigurationData : public BaseData<Kind, Guid>
    {
    public:
        using Base = BaseData<Kind, Guid>;
        static constexpr Kind KIND = Kind::RadarConfiguration;
    private:
        Int64 rowVersion_ = 0;
        Guid radar_;
        DateTime timestamp_;
        Int32 radarProtocolVersion_ = 0;
        FixedDBWideString<100> radarIPAddress_;
        Int32 radarPort_ = 0;
        Int32 radarConfigurationPort_ = 0;
        TimeSpan skipMagicTimeout_;
        TimeSpan readTimeout_;
        TimeSpan synchronizationInterval_;
        Int32 targetsRefreshRate_ = 0;
        Int32 range_ = 0;
        Int32 sectorCount_ = 0;
        Int32 sectorOffset_ = 0;
        UInt32 imageColor_ = 0;
        DBUInt32 imageSubstitutionColor_;
        UInt32 transparentColor_ = 0;
        double imageScaleFactorX_ = 0.0;
        double imageOffsetX_ = 0.0;
        double imageScaleFactorY_ = 0.0;
        double imageOffsetY_ = 0.0;
        Data::RadarImageType radarImageType_ = Data::RadarImageType::MaskedProcessed;
        UInt32 trackColor_ = 0;
        UInt32 vectorColor_ = 0;
        bool enableNmea_ = false;
        FixedDBWideString<100> nmeaReceiverIPAddress_;
        Int32 nmeaReceiverPort_ = 0;
        FixedDBWideString<100> nmeaReceiverSourceId_;
    public:
        RadarConfigurationData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(rowVersion_);
            destination.Write(radar_);
            destination.Write(timestamp_);
            destination.Write(radarProtocolVersion_);
            radarIPAddress_.WriteTo( destination );
            destination.Write(radarPort_);
            destination.Write(radarConfigurationPort_);
            destination.Write(skipMagicTimeout_);
            destination.Write(readTimeout_);
            destination.Write(synchronizationInterval_);
            destination.Write(targetsRefreshRate_);
            destination.Write(range_);
            destination.Write(sectorCount_);
            destination.Write(sectorOffset_);
            destination.Write(imageColor_);
            imageSubstitutionColor_.WriteTo( destination );
            destination.Write(transparentColor_);
            destination.Write(imageScaleFactorX_);
            destination.Write(imageOffsetX_);
            destination.Write(imageScaleFactorY_);
            destination.Write(imageOffsetY_);
            destination.Write(radarImageType_);
            destination.Write(trackColor_);
            destination.Write(vectorColor_);
            destination.Write(enableNmea_);
            nmeaReceiverIPAddress_.WriteTo( destination );
            destination.Write(nmeaReceiverPort_);
            nmeaReceiverSourceId_.WriteTo( destination );
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(rowVersion_);
            source.Read(radar_);
            source.Read(timestamp_);
            source.Read(radarProtocolVersion_);
            radarIPAddress_.ReadFrom( source );
            source.Read(radarPort_);
            source.Read(radarConfigurationPort_);
            source.Read(skipMagicTimeout_);
            source.Read(readTimeout_);
            source.Read(synchronizationInterval_);
            source.Read(targetsRefreshRate_);
            source.Read(range_);
            source.Read(sectorCount_);
            source.Read(sectorOffset_);
            source.Read(imageColor_);
            imageSubstitutionColor_.ReadFrom( source );
            source.Read(transparentColor_);
            source.Read(imageScaleFactorX_);
            source.Read(imageOffsetX_);
            source.Read(imageScaleFactorY_);
            source.Read(imageOffsetY_);
            source.Read(radarImageType_);
            source.Read(trackColor_);
            source.Read(vectorColor_);
            source.Read(enableNmea_);
            nmeaReceiverIPAddress_.ReadFrom( source );
            source.Read(nmeaReceiverPort_);
            nmeaReceiverSourceId_.ReadFrom( source );
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<RadarConfigurationData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<RadarConfigurationData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const RadarConfigurationData& >( other );
                if ( dataObject.rowVersion_ != rowVersion_ )
                {
                    return false;
                }
                if ( dataObject.radar_ != radar_ )
                {
                    return false;
                }
                if ( dataObject.timestamp_ != timestamp_ )
                {
                    return false;
                }
                if ( dataObject.radarProtocolVersion_ != radarProtocolVersion_ )
                {
                    return false;
                }
                if ( dataObject.radarIPAddress_ != radarIPAddress_ )
                {
                    return false;
                }
                if ( dataObject.radarPort_ != radarPort_ )
                {
                    return false;
                }
                if ( dataObject.radarConfigurationPort_ != radarConfigurationPort_ )
                {
                    return false;
                }
                if ( dataObject.skipMagicTimeout_ != skipMagicTimeout_ )
                {
                    return false;
                }
                if ( dataObject.readTimeout_ != readTimeout_ )
                {
                    return false;
                }
                if ( dataObject.synchronizationInterval_ != synchronizationInterval_ )
                {
                    return false;
                }
                if ( dataObject.targetsRefreshRate_ != targetsRefreshRate_ )
                {
                    return false;
                }
                if ( dataObject.range_ != range_ )
                {
                    return false;
                }
                if ( dataObject.sectorCount_ != sectorCount_ )
                {
                    return false;
                }
                if ( dataObject.sectorOffset_ != sectorOffset_ )
                {
                    return false;
                }
                if ( dataObject.imageColor_ != imageColor_ )
                {
                    return false;
                }
                if ( dataObject.imageSubstitutionColor_ != imageSubstitutionColor_ )
                {
                    return false;
                }
                if ( dataObject.transparentColor_ != transparentColor_ )
                {
                    return false;
                }
                if ( dataObject.imageScaleFactorX_ != imageScaleFactorX_ )
                {
                    return false;
                }
                if ( dataObject.imageOffsetX_ != imageOffsetX_ )
                {
                    return false;
                }
                if ( dataObject.imageScaleFactorY_ != imageScaleFactorY_ )
                {
                    return false;
                }
                if ( dataObject.imageOffsetY_ != imageOffsetY_ )
                {
                    return false;
                }
                if ( dataObject.radarImageType_ != radarImageType_ )
                {
                    return false;
                }
                if ( dataObject.trackColor_ != trackColor_ )
                {
                    return false;
                }
                if ( dataObject.vectorColor_ != vectorColor_ )
                {
                    return false;
                }
                if ( dataObject.enableNmea_ != enableNmea_ )
                {
                    return false;
                }
                if ( dataObject.nmeaReceiverIPAddress_ != nmeaReceiverIPAddress_ )
                {
                    return false;
                }
                if ( dataObject.nmeaReceiverPort_ != nmeaReceiverPort_ )
                {
                    return false;
                }
                if ( dataObject.nmeaReceiverSourceId_ != nmeaReceiverSourceId_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
    };
    class RadarImageData : public BaseData<Kind, Guid>
    {
    public:
        using Base = BaseData<Kind, Guid>;
        static constexpr Kind KIND = Kind::RadarImage;
    private:
        Int64 rowVersion_ = 0;
        Guid radar_;
        DateTime timestamp_;
        UInt32 depth_ = 0;
        Int32 resolution_ = 0;
        Int32 range_ = 0;
        Binary image_;
        SQLLEN imageLength_ = SQL_NULL_DATA;
    public:
        RadarImageData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(rowVersion_);
            destination.Write(radar_);
            destination.Write(timestamp_);
            destination.Write(depth_);
            destination.Write(resolution_);
            destination.Write(range_);
            destination.Write(image_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(rowVersion_);
            source.Read(radar_);
            source.Read(timestamp_);
            source.Read(depth_);
            source.Read(resolution_);
            source.Read(range_);
            source.Read(image_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<RadarImageData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<RadarImageData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const RadarImageData& >( other );
                if ( dataObject.rowVersion_ != rowVersion_ )
                {
                    return false;
                }
                if ( dataObject.radar_ != radar_ )
                {
                    return false;
                }
                if ( dataObject.timestamp_ != timestamp_ )
                {
                    return false;
                }
                if ( dataObject.depth_ != depth_ )
                {
                    return false;
                }
                if ( dataObject.resolution_ != resolution_ )
                {
                    return false;
                }
                if ( dataObject.range_ != range_ )
                {
                    return false;
                }
                if ( dataObject.image_ != image_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
    };
    class RadarRawTrackTableData : public BaseData<Kind, Guid>
    {
    public:
        using Base = BaseData<Kind, Guid>;
        static constexpr Kind KIND = Kind::RadarRawTrackTable;
    private:
        Int64 rowVersion_ = 0;
        Guid radar_;
        DateTime timestamp_;
        Int32 count_ = 0;
        Binary table_;
        SQLLEN tableLength_ = SQL_NULL_DATA;
    public:
        RadarRawTrackTableData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(rowVersion_);
            destination.Write(radar_);
            destination.Write(timestamp_);
            destination.Write(count_);
            destination.Write(table_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(rowVersion_);
            source.Read(radar_);
            source.Read(timestamp_);
            source.Read(count_);
            source.Read(table_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<RadarRawTrackTableData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<RadarRawTrackTableData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const RadarRawTrackTableData& >( other );
                if ( dataObject.rowVersion_ != rowVersion_ )
                {
                    return false;
                }
                if ( dataObject.radar_ != radar_ )
                {
                    return false;
                }
                if ( dataObject.timestamp_ != timestamp_ )
                {
                    return false;
                }
                if ( dataObject.count_ != count_ )
                {
                    return false;
                }
                if ( dataObject.table_ != table_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
    };
    class RadarStatusData : public BaseData<Kind, Guid>
    {
    public:
        using Base = BaseData<Kind, Guid>;
        static constexpr Kind KIND = Kind::RadarStatus;
    private:
        Int64 rowVersion_ = 0;
        Guid radar_;
        DateTime timestamp_;
        Int32 azimuthCount_ = 0;
        Int32 triggerCount_ = 0;
        TimeSpan rotationTime_;
        Data::RadarPulse pulse_ = Data::RadarPulse::Short;
        bool tx_ = false;
        bool tracking_ = false;
    public:
        RadarStatusData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(rowVersion_);
            destination.Write(radar_);
            destination.Write(timestamp_);
            destination.Write(azimuthCount_);
            destination.Write(triggerCount_);
            destination.Write(rotationTime_);
            destination.Write(pulse_);
            destination.Write(tx_);
            destination.Write(tracking_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(rowVersion_);
            source.Read(radar_);
            source.Read(timestamp_);
            source.Read(azimuthCount_);
            source.Read(triggerCount_);
            source.Read(rotationTime_);
            source.Read(pulse_);
            source.Read(tx_);
            source.Read(tracking_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<RadarStatusData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<RadarStatusData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const RadarStatusData& >( other );
                if ( dataObject.rowVersion_ != rowVersion_ )
                {
                    return false;
                }
                if ( dataObject.radar_ != radar_ )
                {
                    return false;
                }
                if ( dataObject.timestamp_ != timestamp_ )
                {
                    return false;
                }
                if ( dataObject.azimuthCount_ != azimuthCount_ )
                {
                    return false;
                }
                if ( dataObject.triggerCount_ != triggerCount_ )
                {
                    return false;
                }
                if ( dataObject.rotationTime_ != rotationTime_ )
                {
                    return false;
                }
                if ( dataObject.pulse_ != pulse_ )
                {
                    return false;
                }
                if ( dataObject.tx_ != tx_ )
                {
                    return false;
                }
                if ( dataObject.tracking_ != tracking_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
    };
    class RadioCommandData : public BaseData<Kind, Guid>
    {
    public:
        using Base = BaseData<Kind, Guid>;
        static constexpr Kind KIND = Kind::RadioCommand;
    private:
        Int64 rowVersion_ = 0;
        Guid radio_;
        DateTime timestamp_;
        Data::DeviceCommandSourceType deviceCommandSourceType_ = Data::DeviceCommandSourceType::Unknown;
        Guid deviceCommandSourceId_;
        Guid reply_;
    public:
        RadioCommandData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(rowVersion_);
            destination.Write(radio_);
            destination.Write(timestamp_);
            destination.Write(deviceCommandSourceType_);
            destination.Write(deviceCommandSourceId_);
            destination.Write(reply_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(rowVersion_);
            source.Read(radio_);
            source.Read(timestamp_);
            source.Read(deviceCommandSourceType_);
            source.Read(deviceCommandSourceId_);
            source.Read(reply_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<RadioCommandData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<RadioCommandData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const RadioCommandData& >( other );
                if ( dataObject.rowVersion_ != rowVersion_ )
                {
                    return false;
                }
                if ( dataObject.radio_ != radio_ )
                {
                    return false;
                }
                if ( dataObject.timestamp_ != timestamp_ )
                {
                    return false;
                }
                if ( dataObject.deviceCommandSourceType_ != deviceCommandSourceType_ )
                {
                    return false;
                }
                if ( dataObject.deviceCommandSourceId_ != deviceCommandSourceId_ )
                {
                    return false;
                }
                if ( dataObject.reply_ != reply_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
    };
    class RadioCommandReplyData : public BaseData<Kind, Guid>
    {
    public:
        using Base = BaseData<Kind, Guid>;
        static constexpr Kind KIND = Kind::RadioCommandReply;
    private:
        Int64 rowVersion_ = 0;
        Guid radio_;
        DateTime timestamp_;
        Guid command_;
        Data::DeviceCommandReplyStatus status_ = Data::DeviceCommandReplyStatus::Unknown;
        WideString message_;
        SQLLEN messageLength_ = SQL_NULL_DATA;
    public:
        RadioCommandReplyData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(rowVersion_);
            destination.Write(radio_);
            destination.Write(timestamp_);
            destination.Write(command_);
            destination.Write(status_);
            destination.Write(message_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(rowVersion_);
            source.Read(radio_);
            source.Read(timestamp_);
            source.Read(command_);
            source.Read(status_);
            source.Read(message_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<RadioCommandReplyData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<RadioCommandReplyData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const RadioCommandReplyData& >( other );
                if ( dataObject.rowVersion_ != rowVersion_ )
                {
                    return false;
                }
                if ( dataObject.radio_ != radio_ )
                {
                    return false;
                }
                if ( dataObject.timestamp_ != timestamp_ )
                {
                    return false;
                }
                if ( dataObject.command_ != command_ )
                {
                    return false;
                }
                if ( dataObject.status_ != status_ )
                {
                    return false;
                }
                if ( dataObject.message_ != message_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
    };
    class RadioConfigurationData : public BaseData<Kind, Guid>
    {
    public:
        using Base = BaseData<Kind, Guid>;
        static constexpr Kind KIND = Kind::RadioConfiguration;
    private:
        Int64 rowVersion_ = 0;
        Guid radio_;
        DateTime timestamp_;
        double longitude_ = 0.0;
        double latitude_ = 0.0;
        FixedDBWideString<100> playbackUrl_;
        FixedDBWideString<100> radioIPAddress_;
        Int32 radioPort_ = 0;
        FixedDBWideString<100> ed137IPAddress_;
        Int32 ed137Port_ = 0;
    public:
        RadioConfigurationData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(rowVersion_);
            destination.Write(radio_);
            destination.Write(timestamp_);
            destination.Write(longitude_);
            destination.Write(latitude_);
            playbackUrl_.WriteTo( destination );
            radioIPAddress_.WriteTo( destination );
            destination.Write(radioPort_);
            ed137IPAddress_.WriteTo( destination );
            destination.Write(ed137Port_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(rowVersion_);
            source.Read(radio_);
            source.Read(timestamp_);
            source.Read(longitude_);
            source.Read(latitude_);
            playbackUrl_.ReadFrom( source );
            radioIPAddress_.ReadFrom( source );
            source.Read(radioPort_);
            ed137IPAddress_.ReadFrom( source );
            source.Read(ed137Port_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<RadioConfigurationData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<RadioConfigurationData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const RadioConfigurationData& >( other );
                if ( dataObject.rowVersion_ != rowVersion_ )
                {
                    return false;
                }
                if ( dataObject.radio_ != radio_ )
                {
                    return false;
                }
                if ( dataObject.timestamp_ != timestamp_ )
                {
                    return false;
                }
                if ( dataObject.longitude_ != longitude_ )
                {
                    return false;
                }
                if ( dataObject.latitude_ != latitude_ )
                {
                    return false;
                }
                if ( dataObject.playbackUrl_ != playbackUrl_ )
                {
                    return false;
                }
                if ( dataObject.radioIPAddress_ != radioIPAddress_ )
                {
                    return false;
                }
                if ( dataObject.radioPort_ != radioPort_ )
                {
                    return false;
                }
                if ( dataObject.ed137IPAddress_ != ed137IPAddress_ )
                {
                    return false;
                }
                if ( dataObject.ed137Port_ != ed137Port_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
    };
    class RadomeCommandData : public BaseData<Kind, Guid>
    {
    public:
        using Base = BaseData<Kind, Guid>;
        static constexpr Kind KIND = Kind::RadomeCommand;
    private:
        Int64 rowVersion_ = 0;
        Guid radome_;
        DateTime timestamp_;
        Data::DeviceCommandSourceType deviceCommandSourceType_ = Data::DeviceCommandSourceType::Unknown;
        Guid deviceCommandSourceId_;
        Guid reply_;
    public:
        RadomeCommandData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(rowVersion_);
            destination.Write(radome_);
            destination.Write(timestamp_);
            destination.Write(deviceCommandSourceType_);
            destination.Write(deviceCommandSourceId_);
            destination.Write(reply_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(rowVersion_);
            source.Read(radome_);
            source.Read(timestamp_);
            source.Read(deviceCommandSourceType_);
            source.Read(deviceCommandSourceId_);
            source.Read(reply_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<RadomeCommandData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<RadomeCommandData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const RadomeCommandData& >( other );
                if ( dataObject.rowVersion_ != rowVersion_ )
                {
                    return false;
                }
                if ( dataObject.radome_ != radome_ )
                {
                    return false;
                }
                if ( dataObject.timestamp_ != timestamp_ )
                {
                    return false;
                }
                if ( dataObject.deviceCommandSourceType_ != deviceCommandSourceType_ )
                {
                    return false;
                }
                if ( dataObject.deviceCommandSourceId_ != deviceCommandSourceId_ )
                {
                    return false;
                }
                if ( dataObject.reply_ != reply_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
    };
    class RadomeCommandReplyData : public BaseData<Kind, Guid>
    {
    public:
        using Base = BaseData<Kind, Guid>;
        static constexpr Kind KIND = Kind::RadomeCommandReply;
    private:
        Int64 rowVersion_ = 0;
        Guid radome_;
        DateTime timestamp_;
        Guid command_;
        Data::DeviceCommandReplyStatus status_ = Data::DeviceCommandReplyStatus::Unknown;
        WideString message_;
        SQLLEN messageLength_ = SQL_NULL_DATA;
    public:
        RadomeCommandReplyData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(rowVersion_);
            destination.Write(radome_);
            destination.Write(timestamp_);
            destination.Write(command_);
            destination.Write(status_);
            destination.Write(message_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(rowVersion_);
            source.Read(radome_);
            source.Read(timestamp_);
            source.Read(command_);
            source.Read(status_);
            source.Read(message_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<RadomeCommandReplyData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<RadomeCommandReplyData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const RadomeCommandReplyData& >( other );
                if ( dataObject.rowVersion_ != rowVersion_ )
                {
                    return false;
                }
                if ( dataObject.radome_ != radome_ )
                {
                    return false;
                }
                if ( dataObject.timestamp_ != timestamp_ )
                {
                    return false;
                }
                if ( dataObject.command_ != command_ )
                {
                    return false;
                }
                if ( dataObject.status_ != status_ )
                {
                    return false;
                }
                if ( dataObject.message_ != message_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
    };
    class RadomeConfigurationData : public BaseData<Kind, Guid>
    {
    public:
        using Base = BaseData<Kind, Guid>;
        static constexpr Kind KIND = Kind::RadomeConfiguration;
    private:
        Int64 rowVersion_ = 0;
        Guid radome_;
        DateTime timestamp_;
        TimeSpan interval_;
        double lowPressureLimit_ = 0.0;
        double highPressureLimit_ = 0.0;
        double lowTemperatureLimit_ = 0.0;
        double highTemperatureLimit_ = 0.0;
    public:
        RadomeConfigurationData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(rowVersion_);
            destination.Write(radome_);
            destination.Write(timestamp_);
            destination.Write(interval_);
            destination.Write(lowPressureLimit_);
            destination.Write(highPressureLimit_);
            destination.Write(lowTemperatureLimit_);
            destination.Write(highTemperatureLimit_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(rowVersion_);
            source.Read(radome_);
            source.Read(timestamp_);
            source.Read(interval_);
            source.Read(lowPressureLimit_);
            source.Read(highPressureLimit_);
            source.Read(lowTemperatureLimit_);
            source.Read(highTemperatureLimit_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<RadomeConfigurationData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<RadomeConfigurationData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const RadomeConfigurationData& >( other );
                if ( dataObject.rowVersion_ != rowVersion_ )
                {
                    return false;
                }
                if ( dataObject.radome_ != radome_ )
                {
                    return false;
                }
                if ( dataObject.timestamp_ != timestamp_ )
                {
                    return false;
                }
                if ( dataObject.interval_ != interval_ )
                {
                    return false;
                }
                if ( dataObject.lowPressureLimit_ != lowPressureLimit_ )
                {
                    return false;
                }
                if ( dataObject.highPressureLimit_ != highPressureLimit_ )
                {
                    return false;
                }
                if ( dataObject.lowTemperatureLimit_ != lowTemperatureLimit_ )
                {
                    return false;
                }
                if ( dataObject.highTemperatureLimit_ != highTemperatureLimit_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
    };
    class ReferenceTimeseriesValueData : public BaseData<Kind, Guid>
    {
    public:
        using Base = BaseData<Kind, Guid>;
        static constexpr Kind KIND = Kind::ReferenceTimeseriesValue;
    private:
        Int64 rowVersion_ = 0;
        Guid timeseries_;
        DateTime timestamp_;
        Guid value_;
    public:
        ReferenceTimeseriesValueData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(rowVersion_);
            destination.Write(timeseries_);
            destination.Write(timestamp_);
            destination.Write(value_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(rowVersion_);
            source.Read(timeseries_);
            source.Read(timestamp_);
            source.Read(value_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<ReferenceTimeseriesValueData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<ReferenceTimeseriesValueData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const ReferenceTimeseriesValueData& >( other );
                if ( dataObject.rowVersion_ != rowVersion_ )
                {
                    return false;
                }
                if ( dataObject.timeseries_ != timeseries_ )
                {
                    return false;
                }
                if ( dataObject.timestamp_ != timestamp_ )
                {
                    return false;
                }
                if ( dataObject.value_ != value_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
    };
    class SByteTimeseriesValueData : public BaseData<Kind, Guid>
    {
    public:
        using Base = BaseData<Kind, Guid>;
        static constexpr Kind KIND = Kind::SByteTimeseriesValue;
    private:
        Int64 rowVersion_ = 0;
        Guid timeseries_;
        DateTime timestamp_;
        DBSByte value_;
    public:
        SByteTimeseriesValueData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(rowVersion_);
            destination.Write(timeseries_);
            destination.Write(timestamp_);
            value_.WriteTo( destination );
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(rowVersion_);
            source.Read(timeseries_);
            source.Read(timestamp_);
            value_.ReadFrom( source );
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<SByteTimeseriesValueData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<SByteTimeseriesValueData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const SByteTimeseriesValueData& >( other );
                if ( dataObject.rowVersion_ != rowVersion_ )
                {
                    return false;
                }
                if ( dataObject.timeseries_ != timeseries_ )
                {
                    return false;
                }
                if ( dataObject.timestamp_ != timestamp_ )
                {
                    return false;
                }
                if ( dataObject.value_ != value_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
    };
    class SecurityDomainData : public BaseData<Kind, Guid>
    {
    public:
        using Base = BaseData<Kind, Guid>;
        static constexpr Kind KIND = Kind::SecurityDomain;
    private:
        Int64 rowVersion_ = 0;
        FixedDBWideString<127> name_;
        WideString description_;
        SQLLEN descriptionLength_ = SQL_NULL_DATA;
    public:
        SecurityDomainData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(rowVersion_);
            name_.WriteTo( destination );
            destination.Write(description_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(rowVersion_);
            name_.ReadFrom( source );
            source.Read(description_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<SecurityDomainData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<SecurityDomainData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const SecurityDomainData& >( other );
                if ( dataObject.rowVersion_ != rowVersion_ )
                {
                    return false;
                }
                if ( dataObject.name_ != name_ )
                {
                    return false;
                }
                if ( dataObject.description_ != description_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
    };
    class SecurityIdentifierData : public BaseData<Kind, Guid>
    {
    public:
        using Base = BaseData<Kind, Guid>;
        static constexpr Kind KIND = Kind::SecurityIdentifier;
    private:
        Int64 rowVersion_ = 0;
        Guid domain_;
        FixedDBWideString<255> identity_;
        WideString description_;
        SQLLEN descriptionLength_ = SQL_NULL_DATA;
    public:
        SecurityIdentifierData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(rowVersion_);
            destination.Write(domain_);
            identity_.WriteTo( destination );
            destination.Write(description_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(rowVersion_);
            source.Read(domain_);
            identity_.ReadFrom( source );
            source.Read(description_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<SecurityIdentifierData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<SecurityIdentifierData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const SecurityIdentifierData& >( other );
                if ( dataObject.rowVersion_ != rowVersion_ )
                {
                    return false;
                }
                if ( dataObject.domain_ != domain_ )
                {
                    return false;
                }
                if ( dataObject.identity_ != identity_ )
                {
                    return false;
                }
                if ( dataObject.description_ != description_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
    };
    class SecurityLoginData : public SecurityIdentifierData
    {
    public:
        using Base = SecurityIdentifierData;
        static constexpr Kind KIND = Kind::SecurityLogin;
    private:
    public:
        SecurityLoginData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<SecurityLoginData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<SecurityLoginData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const SecurityLoginData& >( other );
                return true;
            }
            return false;
        }
    };
    class SecurityRoleData : public SecurityIdentifierData
    {
    public:
        using Base = SecurityIdentifierData;
        static constexpr Kind KIND = Kind::SecurityRole;
    private:
        FixedDBWideString<127> name_;
    public:
        SecurityRoleData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            name_.WriteTo( destination );
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            name_.ReadFrom( source );
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<SecurityRoleData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<SecurityRoleData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const SecurityRoleData& >( other );
                if ( dataObject.name_ != name_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
    };
    class SecurityIdentifierRoleLinkData : public BaseData<Kind, Guid>
    {
    public:
        using Base = BaseData<Kind, Guid>;
        static constexpr Kind KIND = Kind::SecurityIdentifierRoleLink;
    private:
        Int64 rowVersion_ = 0;
        Guid member_;
        Guid role_;
        DateTime start_;
        DBDateTime end_;
    public:
        SecurityIdentifierRoleLinkData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(rowVersion_);
            destination.Write(member_);
            destination.Write(role_);
            destination.Write(start_);
            end_.WriteTo( destination );
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(rowVersion_);
            source.Read(member_);
            source.Read(role_);
            source.Read(start_);
            end_.ReadFrom( source );
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<SecurityIdentifierRoleLinkData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<SecurityIdentifierRoleLinkData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const SecurityIdentifierRoleLinkData& >( other );
                if ( dataObject.rowVersion_ != rowVersion_ )
                {
                    return false;
                }
                if ( dataObject.member_ != member_ )
                {
                    return false;
                }
                if ( dataObject.role_ != role_ )
                {
                    return false;
                }
                if ( dataObject.start_ != start_ )
                {
                    return false;
                }
                if ( dataObject.end_ != end_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
    };
    class SecurityLoginSessionData : public BaseData<Kind, Guid>
    {
    public:
        using Base = BaseData<Kind, Guid>;
        static constexpr Kind KIND = Kind::SecurityLoginSession;
    private:
        Int64 rowVersion_ = 0;
        Guid login_;
        DateTime fromTime_;
        DBDateTime throughTime_;
        Guid clientSession_;
        FixedDBWideString<260> notificationQueueName_;
        FixedDBWideString<260> messageQueueName_;
    public:
        SecurityLoginSessionData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(rowVersion_);
            destination.Write(login_);
            destination.Write(fromTime_);
            throughTime_.WriteTo( destination );
            destination.Write(clientSession_);
            notificationQueueName_.WriteTo( destination );
            messageQueueName_.WriteTo( destination );
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(rowVersion_);
            source.Read(login_);
            source.Read(fromTime_);
            throughTime_.ReadFrom( source );
            source.Read(clientSession_);
            notificationQueueName_.ReadFrom( source );
            messageQueueName_.ReadFrom( source );
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<SecurityLoginSessionData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<SecurityLoginSessionData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const SecurityLoginSessionData& >( other );
                if ( dataObject.rowVersion_ != rowVersion_ )
                {
                    return false;
                }
                if ( dataObject.login_ != login_ )
                {
                    return false;
                }
                if ( dataObject.fromTime_ != fromTime_ )
                {
                    return false;
                }
                if ( dataObject.throughTime_ != throughTime_ )
                {
                    return false;
                }
                if ( dataObject.clientSession_ != clientSession_ )
                {
                    return false;
                }
                if ( dataObject.notificationQueueName_ != notificationQueueName_ )
                {
                    return false;
                }
                if ( dataObject.messageQueueName_ != messageQueueName_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
    };
    class SecurityPermissionData : public BaseData<Kind, Guid>
    {
    public:
        using Base = BaseData<Kind, Guid>;
        static constexpr Kind KIND = Kind::SecurityPermission;
    private:
        Int64 rowVersion_ = 0;
        Guid identifier_;
        DateTime timestamp_;
        Int32 typeCode_ = 0;
        bool canCreate_ = false;
        bool canRead_ = false;
        bool canUpdate_ = false;
        bool canDelete_ = false;
    public:
        SecurityPermissionData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(rowVersion_);
            destination.Write(identifier_);
            destination.Write(timestamp_);
            destination.Write(typeCode_);
            destination.Write(canCreate_);
            destination.Write(canRead_);
            destination.Write(canUpdate_);
            destination.Write(canDelete_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(rowVersion_);
            source.Read(identifier_);
            source.Read(timestamp_);
            source.Read(typeCode_);
            source.Read(canCreate_);
            source.Read(canRead_);
            source.Read(canUpdate_);
            source.Read(canDelete_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<SecurityPermissionData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<SecurityPermissionData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const SecurityPermissionData& >( other );
                if ( dataObject.rowVersion_ != rowVersion_ )
                {
                    return false;
                }
                if ( dataObject.identifier_ != identifier_ )
                {
                    return false;
                }
                if ( dataObject.timestamp_ != timestamp_ )
                {
                    return false;
                }
                if ( dataObject.typeCode_ != typeCode_ )
                {
                    return false;
                }
                if ( dataObject.canCreate_ != canCreate_ )
                {
                    return false;
                }
                if ( dataObject.canRead_ != canRead_ )
                {
                    return false;
                }
                if ( dataObject.canUpdate_ != canUpdate_ )
                {
                    return false;
                }
                if ( dataObject.canDelete_ != canDelete_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
    };
    class SingleTimeseriesValueData : public BaseData<Kind, Guid>
    {
    public:
        using Base = BaseData<Kind, Guid>;
        static constexpr Kind KIND = Kind::SingleTimeseriesValue;
    private:
        Int64 rowVersion_ = 0;
        Guid timeseries_;
        DateTime timestamp_;
        DBSingle value_;
    public:
        SingleTimeseriesValueData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(rowVersion_);
            destination.Write(timeseries_);
            destination.Write(timestamp_);
            value_.WriteTo( destination );
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(rowVersion_);
            source.Read(timeseries_);
            source.Read(timestamp_);
            value_.ReadFrom( source );
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<SingleTimeseriesValueData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<SingleTimeseriesValueData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const SingleTimeseriesValueData& >( other );
                if ( dataObject.rowVersion_ != rowVersion_ )
                {
                    return false;
                }
                if ( dataObject.timeseries_ != timeseries_ )
                {
                    return false;
                }
                if ( dataObject.timestamp_ != timestamp_ )
                {
                    return false;
                }
                if ( dataObject.value_ != value_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
    };
    class StringTimeseriesValueData : public BaseData<Kind, Guid>
    {
    public:
        using Base = BaseData<Kind, Guid>;
        static constexpr Kind KIND = Kind::StringTimeseriesValue;
    private:
        Int64 rowVersion_ = 0;
        Guid timeseries_;
        DateTime timestamp_;
        WideString value_;
        SQLLEN valueLength_ = SQL_NULL_DATA;
    public:
        StringTimeseriesValueData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(rowVersion_);
            destination.Write(timeseries_);
            destination.Write(timestamp_);
            destination.Write(value_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(rowVersion_);
            source.Read(timeseries_);
            source.Read(timestamp_);
            source.Read(value_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<StringTimeseriesValueData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<StringTimeseriesValueData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const StringTimeseriesValueData& >( other );
                if ( dataObject.rowVersion_ != rowVersion_ )
                {
                    return false;
                }
                if ( dataObject.timeseries_ != timeseries_ )
                {
                    return false;
                }
                if ( dataObject.timestamp_ != timestamp_ )
                {
                    return false;
                }
                if ( dataObject.value_ != value_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
    };
    class TimeseriesCatalogElementData : public BaseData<Kind, Guid>
    {
    public:
        using Base = BaseData<Kind, Guid>;
        static constexpr Kind KIND = Kind::TimeseriesCatalogElement;
    private:
        Int64 rowVersion_ = 0;
        Guid catalog_;
        FixedDBWideString<100> name_;
    public:
        TimeseriesCatalogElementData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(rowVersion_);
            destination.Write(catalog_);
            name_.WriteTo( destination );
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(rowVersion_);
            source.Read(catalog_);
            name_.ReadFrom( source );
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<TimeseriesCatalogElementData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<TimeseriesCatalogElementData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const TimeseriesCatalogElementData& >( other );
                if ( dataObject.rowVersion_ != rowVersion_ )
                {
                    return false;
                }
                if ( dataObject.catalog_ != catalog_ )
                {
                    return false;
                }
                if ( dataObject.name_ != name_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
    };
    class TimeseriesData : public TimeseriesCatalogElementData
    {
    public:
        using Base = TimeseriesCatalogElementData;
        static constexpr Kind KIND = Kind::Timeseries;
    private:
        TimeSpan maxRetention_;
    public:
        TimeseriesData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(maxRetention_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(maxRetention_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<TimeseriesData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<TimeseriesData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const TimeseriesData& >( other );
                if ( dataObject.maxRetention_ != maxRetention_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
    };
    class BinaryTimeseriesData : public TimeseriesData
    {
    public:
        using Base = TimeseriesData;
        static constexpr Kind KIND = Kind::BinaryTimeseries;
    private:
    public:
        BinaryTimeseriesData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<BinaryTimeseriesData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<BinaryTimeseriesData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const BinaryTimeseriesData& >( other );
                return true;
            }
            return false;
        }
    };
    class BooleanTimeseriesData : public TimeseriesData
    {
    public:
        using Base = TimeseriesData;
        static constexpr Kind KIND = Kind::BooleanTimeseries;
    private:
    public:
        BooleanTimeseriesData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<BooleanTimeseriesData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<BooleanTimeseriesData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const BooleanTimeseriesData& >( other );
                return true;
            }
            return false;
        }
    };
    class AisAidToNavigationOffPositionTimeseriesData : public BooleanTimeseriesData
    {
    public:
        using Base = BooleanTimeseriesData;
        static constexpr Kind KIND = Kind::AisAidToNavigationOffPositionTimeseries;
    private:
        Guid aidToNavigation_;
    public:
        AisAidToNavigationOffPositionTimeseriesData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(aidToNavigation_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(aidToNavigation_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<AisAidToNavigationOffPositionTimeseriesData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<AisAidToNavigationOffPositionTimeseriesData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const AisAidToNavigationOffPositionTimeseriesData& >( other );
                if ( dataObject.aidToNavigation_ != aidToNavigation_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
    };
    class DeviceEnabledTimeseriesData : public BooleanTimeseriesData
    {
    public:
        using Base = BooleanTimeseriesData;
        static constexpr Kind KIND = Kind::DeviceEnabledTimeseries;
    private:
        Guid device_;
    public:
        DeviceEnabledTimeseriesData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(device_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(device_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<DeviceEnabledTimeseriesData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<DeviceEnabledTimeseriesData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const DeviceEnabledTimeseriesData& >( other );
                if ( dataObject.device_ != device_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
    };
    class RadarAutomaticSensitivityTimeControlTimeseriesData : public BooleanTimeseriesData
    {
    public:
        using Base = BooleanTimeseriesData;
        static constexpr Kind KIND = Kind::RadarAutomaticSensitivityTimeControlTimeseries;
    private:
        Guid radar_;
    public:
        RadarAutomaticSensitivityTimeControlTimeseriesData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(radar_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(radar_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<RadarAutomaticSensitivityTimeControlTimeseriesData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<RadarAutomaticSensitivityTimeControlTimeseriesData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const RadarAutomaticSensitivityTimeControlTimeseriesData& >( other );
                if ( dataObject.radar_ != radar_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
    };
    class RadarBlankSector1TimeseriesData : public BooleanTimeseriesData
    {
    public:
        using Base = BooleanTimeseriesData;
        static constexpr Kind KIND = Kind::RadarBlankSector1Timeseries;
    private:
        Guid radar_;
    public:
        RadarBlankSector1TimeseriesData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(radar_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(radar_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<RadarBlankSector1TimeseriesData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<RadarBlankSector1TimeseriesData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const RadarBlankSector1TimeseriesData& >( other );
                if ( dataObject.radar_ != radar_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
    };
    class RadarBlankSector2TimeseriesData : public BooleanTimeseriesData
    {
    public:
        using Base = BooleanTimeseriesData;
        static constexpr Kind KIND = Kind::RadarBlankSector2Timeseries;
    private:
        Guid radar_;
    public:
        RadarBlankSector2TimeseriesData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(radar_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(radar_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<RadarBlankSector2TimeseriesData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<RadarBlankSector2TimeseriesData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const RadarBlankSector2TimeseriesData& >( other );
                if ( dataObject.radar_ != radar_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
    };
    class RadarEnableAutomaticFrequencyControlTimeseriesData : public BooleanTimeseriesData
    {
    public:
        using Base = BooleanTimeseriesData;
        static constexpr Kind KIND = Kind::RadarEnableAutomaticFrequencyControlTimeseries;
    private:
        Guid radar_;
    public:
        RadarEnableAutomaticFrequencyControlTimeseriesData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(radar_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(radar_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<RadarEnableAutomaticFrequencyControlTimeseriesData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<RadarEnableAutomaticFrequencyControlTimeseriesData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const RadarEnableAutomaticFrequencyControlTimeseriesData& >( other );
                if ( dataObject.radar_ != radar_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
    };
    class RadarEnableFastTimeConstantTimeseriesData : public BooleanTimeseriesData
    {
    public:
        using Base = BooleanTimeseriesData;
        static constexpr Kind KIND = Kind::RadarEnableFastTimeConstantTimeseries;
    private:
        Guid radar_;
    public:
        RadarEnableFastTimeConstantTimeseriesData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(radar_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(radar_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<RadarEnableFastTimeConstantTimeseriesData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<RadarEnableFastTimeConstantTimeseriesData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const RadarEnableFastTimeConstantTimeseriesData& >( other );
                if ( dataObject.radar_ != radar_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
    };
    class RadarEnableSensitivityTimeControlTimeseriesData : public BooleanTimeseriesData
    {
    public:
        using Base = BooleanTimeseriesData;
        static constexpr Kind KIND = Kind::RadarEnableSensitivityTimeControlTimeseries;
    private:
        Guid radar_;
    public:
        RadarEnableSensitivityTimeControlTimeseriesData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(radar_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(radar_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<RadarEnableSensitivityTimeControlTimeseriesData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<RadarEnableSensitivityTimeControlTimeseriesData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const RadarEnableSensitivityTimeControlTimeseriesData& >( other );
                if ( dataObject.radar_ != radar_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
    };
    class RadarPowerOnTimeseriesData : public BooleanTimeseriesData
    {
    public:
        using Base = BooleanTimeseriesData;
        static constexpr Kind KIND = Kind::RadarPowerOnTimeseries;
    private:
        Guid radar_;
    public:
        RadarPowerOnTimeseriesData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(radar_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(radar_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<RadarPowerOnTimeseriesData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<RadarPowerOnTimeseriesData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const RadarPowerOnTimeseriesData& >( other );
                if ( dataObject.radar_ != radar_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
    };
    class RadarSaveSettingsTimeseriesData : public BooleanTimeseriesData
    {
    public:
        using Base = BooleanTimeseriesData;
        static constexpr Kind KIND = Kind::RadarSaveSettingsTimeseries;
    private:
        Guid radar_;
    public:
        RadarSaveSettingsTimeseriesData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(radar_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(radar_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<RadarSaveSettingsTimeseriesData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<RadarSaveSettingsTimeseriesData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const RadarSaveSettingsTimeseriesData& >( other );
                if ( dataObject.radar_ != radar_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
    };
    class RadarTrackingTimeseriesData : public BooleanTimeseriesData
    {
    public:
        using Base = BooleanTimeseriesData;
        static constexpr Kind KIND = Kind::RadarTrackingTimeseries;
    private:
        Guid radar_;
    public:
        RadarTrackingTimeseriesData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(radar_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(radar_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<RadarTrackingTimeseriesData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<RadarTrackingTimeseriesData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const RadarTrackingTimeseriesData& >( other );
                if ( dataObject.radar_ != radar_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
    };
    class MediaProxySessionEnabledTimeseriesData : public BooleanTimeseriesData
    {
    public:
        using Base = BooleanTimeseriesData;
        static constexpr Kind KIND = Kind::MediaProxySessionEnabledTimeseries;
    private:
        Guid proxySession_;
    public:
        MediaProxySessionEnabledTimeseriesData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(proxySession_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(proxySession_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<MediaProxySessionEnabledTimeseriesData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<MediaProxySessionEnabledTimeseriesData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const MediaProxySessionEnabledTimeseriesData& >( other );
                if ( dataObject.proxySession_ != proxySession_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
    };
    class MediaServiceEnabledTimeseriesData : public BooleanTimeseriesData
    {
    public:
        using Base = BooleanTimeseriesData;
        static constexpr Kind KIND = Kind::MediaServiceEnabledTimeseries;
    private:
        Guid service_;
    public:
        MediaServiceEnabledTimeseriesData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(service_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(service_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<MediaServiceEnabledTimeseriesData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<MediaServiceEnabledTimeseriesData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const MediaServiceEnabledTimeseriesData& >( other );
                if ( dataObject.service_ != service_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
    };
    class ByteTimeseriesData : public TimeseriesData
    {
    public:
        using Base = TimeseriesData;
        static constexpr Kind KIND = Kind::ByteTimeseries;
    private:
    public:
        ByteTimeseriesData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<ByteTimeseriesData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<ByteTimeseriesData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const ByteTimeseriesData& >( other );
                return true;
            }
            return false;
        }
    };
    class DateTimeTimeseriesData : public TimeseriesData
    {
    public:
        using Base = TimeseriesData;
        static constexpr Kind KIND = Kind::DateTimeTimeseries;
    private:
    public:
        DateTimeTimeseriesData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<DateTimeTimeseriesData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<DateTimeTimeseriesData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const DateTimeTimeseriesData& >( other );
                return true;
            }
            return false;
        }
    };
    class DoubleTimeseriesData : public TimeseriesData
    {
    public:
        using Base = TimeseriesData;
        static constexpr Kind KIND = Kind::DoubleTimeseries;
    private:
    public:
        DoubleTimeseriesData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<DoubleTimeseriesData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<DoubleTimeseriesData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const DoubleTimeseriesData& >( other );
                return true;
            }
            return false;
        }
    };
    class GNSSAltitudeTimeseriesData : public DoubleTimeseriesData
    {
    public:
        using Base = DoubleTimeseriesData;
        static constexpr Kind KIND = Kind::GNSSAltitudeTimeseries;
    private:
        Guid gNSSDevice_;
    public:
        GNSSAltitudeTimeseriesData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(gNSSDevice_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(gNSSDevice_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<GNSSAltitudeTimeseriesData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<GNSSAltitudeTimeseriesData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const GNSSAltitudeTimeseriesData& >( other );
                if ( dataObject.gNSSDevice_ != gNSSDevice_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
    };
    class GNSSLatitudeTimeseriesData : public DoubleTimeseriesData
    {
    public:
        using Base = DoubleTimeseriesData;
        static constexpr Kind KIND = Kind::GNSSLatitudeTimeseries;
    private:
        Guid gNSSDevice_;
    public:
        GNSSLatitudeTimeseriesData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(gNSSDevice_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(gNSSDevice_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<GNSSLatitudeTimeseriesData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<GNSSLatitudeTimeseriesData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const GNSSLatitudeTimeseriesData& >( other );
                if ( dataObject.gNSSDevice_ != gNSSDevice_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
    };
    class GNSSLongitudeTimeseriesData : public DoubleTimeseriesData
    {
    public:
        using Base = DoubleTimeseriesData;
        static constexpr Kind KIND = Kind::GNSSLongitudeTimeseries;
    private:
        Guid gNSSDevice_;
    public:
        GNSSLongitudeTimeseriesData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(gNSSDevice_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(gNSSDevice_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<GNSSLongitudeTimeseriesData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<GNSSLongitudeTimeseriesData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const GNSSLongitudeTimeseriesData& >( other );
                if ( dataObject.gNSSDevice_ != gNSSDevice_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
    };
    class GyroCourseTimeseriesData : public DoubleTimeseriesData
    {
    public:
        using Base = DoubleTimeseriesData;
        static constexpr Kind KIND = Kind::GyroCourseTimeseries;
    private:
        Guid gyroDevice_;
    public:
        GyroCourseTimeseriesData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(gyroDevice_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(gyroDevice_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<GyroCourseTimeseriesData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<GyroCourseTimeseriesData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const GyroCourseTimeseriesData& >( other );
                if ( dataObject.gyroDevice_ != gyroDevice_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
    };
    class GyroHeadingMagneticNorthTimeseriesData : public DoubleTimeseriesData
    {
    public:
        using Base = DoubleTimeseriesData;
        static constexpr Kind KIND = Kind::GyroHeadingMagneticNorthTimeseries;
    private:
        Guid gyroDevice_;
    public:
        GyroHeadingMagneticNorthTimeseriesData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(gyroDevice_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(gyroDevice_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<GyroHeadingMagneticNorthTimeseriesData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<GyroHeadingMagneticNorthTimeseriesData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const GyroHeadingMagneticNorthTimeseriesData& >( other );
                if ( dataObject.gyroDevice_ != gyroDevice_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
    };
    class GyroHeadingTrueNorthTimeseriesData : public DoubleTimeseriesData
    {
    public:
        using Base = DoubleTimeseriesData;
        static constexpr Kind KIND = Kind::GyroHeadingTrueNorthTimeseries;
    private:
        Guid gyroDevice_;
    public:
        GyroHeadingTrueNorthTimeseriesData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(gyroDevice_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(gyroDevice_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<GyroHeadingTrueNorthTimeseriesData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<GyroHeadingTrueNorthTimeseriesData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const GyroHeadingTrueNorthTimeseriesData& >( other );
                if ( dataObject.gyroDevice_ != gyroDevice_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
    };
    class GyroPitchTimeseriesData : public DoubleTimeseriesData
    {
    public:
        using Base = DoubleTimeseriesData;
        static constexpr Kind KIND = Kind::GyroPitchTimeseries;
    private:
        Guid gyroDevice_;
    public:
        GyroPitchTimeseriesData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(gyroDevice_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(gyroDevice_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<GyroPitchTimeseriesData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<GyroPitchTimeseriesData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const GyroPitchTimeseriesData& >( other );
                if ( dataObject.gyroDevice_ != gyroDevice_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
    };
    class GyroRateOfTurnTimeseriesData : public DoubleTimeseriesData
    {
    public:
        using Base = DoubleTimeseriesData;
        static constexpr Kind KIND = Kind::GyroRateOfTurnTimeseries;
    private:
        Guid gyroDevice_;
    public:
        GyroRateOfTurnTimeseriesData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(gyroDevice_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(gyroDevice_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<GyroRateOfTurnTimeseriesData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<GyroRateOfTurnTimeseriesData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const GyroRateOfTurnTimeseriesData& >( other );
                if ( dataObject.gyroDevice_ != gyroDevice_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
    };
    class GyroRollTimeseriesData : public DoubleTimeseriesData
    {
    public:
        using Base = DoubleTimeseriesData;
        static constexpr Kind KIND = Kind::GyroRollTimeseries;
    private:
        Guid gyroDevice_;
    public:
        GyroRollTimeseriesData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(gyroDevice_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(gyroDevice_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<GyroRollTimeseriesData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<GyroRollTimeseriesData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const GyroRollTimeseriesData& >( other );
                if ( dataObject.gyroDevice_ != gyroDevice_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
    };
    class GyroSpeedTimeseriesData : public DoubleTimeseriesData
    {
    public:
        using Base = DoubleTimeseriesData;
        static constexpr Kind KIND = Kind::GyroSpeedTimeseries;
    private:
        Guid gyroDevice_;
    public:
        GyroSpeedTimeseriesData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(gyroDevice_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(gyroDevice_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<GyroSpeedTimeseriesData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<GyroSpeedTimeseriesData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const GyroSpeedTimeseriesData& >( other );
                if ( dataObject.gyroDevice_ != gyroDevice_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
    };
    class RadarLatitudeTimeseriesData : public DoubleTimeseriesData
    {
    public:
        using Base = DoubleTimeseriesData;
        static constexpr Kind KIND = Kind::RadarLatitudeTimeseries;
    private:
        Guid radar_;
    public:
        RadarLatitudeTimeseriesData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(radar_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(radar_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<RadarLatitudeTimeseriesData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<RadarLatitudeTimeseriesData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const RadarLatitudeTimeseriesData& >( other );
                if ( dataObject.radar_ != radar_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
    };
    class RadarLongitudeTimeseriesData : public DoubleTimeseriesData
    {
    public:
        using Base = DoubleTimeseriesData;
        static constexpr Kind KIND = Kind::RadarLongitudeTimeseries;
    private:
        Guid radar_;
    public:
        RadarLongitudeTimeseriesData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(radar_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(radar_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<RadarLongitudeTimeseriesData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<RadarLongitudeTimeseriesData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const RadarLongitudeTimeseriesData& >( other );
                if ( dataObject.radar_ != radar_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
    };
    class RadomeDewPointTimeseriesData : public DoubleTimeseriesData
    {
    public:
        using Base = DoubleTimeseriesData;
        static constexpr Kind KIND = Kind::RadomeDewPointTimeseries;
    private:
        Guid radome_;
    public:
        RadomeDewPointTimeseriesData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(radome_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(radome_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<RadomeDewPointTimeseriesData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<RadomeDewPointTimeseriesData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const RadomeDewPointTimeseriesData& >( other );
                if ( dataObject.radome_ != radome_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
    };
    class RadomePressureTimeseriesData : public DoubleTimeseriesData
    {
    public:
        using Base = DoubleTimeseriesData;
        static constexpr Kind KIND = Kind::RadomePressureTimeseries;
    private:
        Guid radome_;
    public:
        RadomePressureTimeseriesData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(radome_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(radome_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<RadomePressureTimeseriesData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<RadomePressureTimeseriesData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const RadomePressureTimeseriesData& >( other );
                if ( dataObject.radome_ != radome_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
    };
    class RadomeTemperatureTimeseriesData : public DoubleTimeseriesData
    {
    public:
        using Base = DoubleTimeseriesData;
        static constexpr Kind KIND = Kind::RadomeTemperatureTimeseries;
    private:
        Guid radome_;
    public:
        RadomeTemperatureTimeseriesData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(radome_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(radome_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<RadomeTemperatureTimeseriesData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<RadomeTemperatureTimeseriesData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const RadomeTemperatureTimeseriesData& >( other );
                if ( dataObject.radome_ != radome_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
    };
    class VesselDraughtTimeseriesData : public DoubleTimeseriesData
    {
    public:
        using Base = DoubleTimeseriesData;
        static constexpr Kind KIND = Kind::VesselDraughtTimeseries;
    private:
        Guid vessel_;
    public:
        VesselDraughtTimeseriesData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(vessel_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(vessel_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<VesselDraughtTimeseriesData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<VesselDraughtTimeseriesData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const VesselDraughtTimeseriesData& >( other );
                if ( dataObject.vessel_ != vessel_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
    };
    class ViewLatitudeTimeseriesData : public DoubleTimeseriesData
    {
    public:
        using Base = DoubleTimeseriesData;
        static constexpr Kind KIND = Kind::ViewLatitudeTimeseries;
    private:
        Guid view_;
    public:
        ViewLatitudeTimeseriesData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(view_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(view_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<ViewLatitudeTimeseriesData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<ViewLatitudeTimeseriesData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const ViewLatitudeTimeseriesData& >( other );
                if ( dataObject.view_ != view_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
    };
    class ViewLongitudeTimeseriesData : public DoubleTimeseriesData
    {
    public:
        using Base = DoubleTimeseriesData;
        static constexpr Kind KIND = Kind::ViewLongitudeTimeseries;
    private:
        Guid view_;
    public:
        ViewLongitudeTimeseriesData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(view_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(view_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<ViewLongitudeTimeseriesData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<ViewLongitudeTimeseriesData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const ViewLongitudeTimeseriesData& >( other );
                if ( dataObject.view_ != view_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
    };
    class ViewZoomLevelTimeseriesData : public DoubleTimeseriesData
    {
    public:
        using Base = DoubleTimeseriesData;
        static constexpr Kind KIND = Kind::ViewZoomLevelTimeseries;
    private:
        Guid view_;
    public:
        ViewZoomLevelTimeseriesData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(view_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(view_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<ViewZoomLevelTimeseriesData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<ViewZoomLevelTimeseriesData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const ViewZoomLevelTimeseriesData& >( other );
                if ( dataObject.view_ != view_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
    };
    class WeatherStationAbsoluteHumidityTimeseriesData : public DoubleTimeseriesData
    {
    public:
        using Base = DoubleTimeseriesData;
        static constexpr Kind KIND = Kind::WeatherStationAbsoluteHumidityTimeseries;
    private:
        Guid weatherStation_;
    public:
        WeatherStationAbsoluteHumidityTimeseriesData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(weatherStation_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(weatherStation_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<WeatherStationAbsoluteHumidityTimeseriesData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<WeatherStationAbsoluteHumidityTimeseriesData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const WeatherStationAbsoluteHumidityTimeseriesData& >( other );
                if ( dataObject.weatherStation_ != weatherStation_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
    };
    class WeatherStationAirTemperatureTimeseriesData : public DoubleTimeseriesData
    {
    public:
        using Base = DoubleTimeseriesData;
        static constexpr Kind KIND = Kind::WeatherStationAirTemperatureTimeseries;
    private:
        Guid weatherStation_;
    public:
        WeatherStationAirTemperatureTimeseriesData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(weatherStation_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(weatherStation_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<WeatherStationAirTemperatureTimeseriesData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<WeatherStationAirTemperatureTimeseriesData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const WeatherStationAirTemperatureTimeseriesData& >( other );
                if ( dataObject.weatherStation_ != weatherStation_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
    };
    class WeatherStationBarometricPressureTimeseriesData : public DoubleTimeseriesData
    {
    public:
        using Base = DoubleTimeseriesData;
        static constexpr Kind KIND = Kind::WeatherStationBarometricPressureTimeseries;
    private:
        Guid weatherStation_;
    public:
        WeatherStationBarometricPressureTimeseriesData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(weatherStation_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(weatherStation_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<WeatherStationBarometricPressureTimeseriesData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<WeatherStationBarometricPressureTimeseriesData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const WeatherStationBarometricPressureTimeseriesData& >( other );
                if ( dataObject.weatherStation_ != weatherStation_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
    };
    class WeatherStationDewPointTimeseriesData : public DoubleTimeseriesData
    {
    public:
        using Base = DoubleTimeseriesData;
        static constexpr Kind KIND = Kind::WeatherStationDewPointTimeseries;
    private:
        Guid weatherStation_;
    public:
        WeatherStationDewPointTimeseriesData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(weatherStation_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(weatherStation_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<WeatherStationDewPointTimeseriesData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<WeatherStationDewPointTimeseriesData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const WeatherStationDewPointTimeseriesData& >( other );
                if ( dataObject.weatherStation_ != weatherStation_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
    };
    class WeatherStationRelativeHumidityTimeseriesData : public DoubleTimeseriesData
    {
    public:
        using Base = DoubleTimeseriesData;
        static constexpr Kind KIND = Kind::WeatherStationRelativeHumidityTimeseries;
    private:
        Guid weatherStation_;
    public:
        WeatherStationRelativeHumidityTimeseriesData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(weatherStation_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(weatherStation_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<WeatherStationRelativeHumidityTimeseriesData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<WeatherStationRelativeHumidityTimeseriesData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const WeatherStationRelativeHumidityTimeseriesData& >( other );
                if ( dataObject.weatherStation_ != weatherStation_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
    };
    class WeatherStationWaterTemperatureTimeseriesData : public DoubleTimeseriesData
    {
    public:
        using Base = DoubleTimeseriesData;
        static constexpr Kind KIND = Kind::WeatherStationWaterTemperatureTimeseries;
    private:
        Guid weatherStation_;
    public:
        WeatherStationWaterTemperatureTimeseriesData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(weatherStation_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(weatherStation_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<WeatherStationWaterTemperatureTimeseriesData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<WeatherStationWaterTemperatureTimeseriesData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const WeatherStationWaterTemperatureTimeseriesData& >( other );
                if ( dataObject.weatherStation_ != weatherStation_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
    };
    class WeatherStationWindDirectionTimeseriesData : public DoubleTimeseriesData
    {
    public:
        using Base = DoubleTimeseriesData;
        static constexpr Kind KIND = Kind::WeatherStationWindDirectionTimeseries;
    private:
        Guid weatherStation_;
    public:
        WeatherStationWindDirectionTimeseriesData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(weatherStation_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(weatherStation_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<WeatherStationWindDirectionTimeseriesData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<WeatherStationWindDirectionTimeseriesData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const WeatherStationWindDirectionTimeseriesData& >( other );
                if ( dataObject.weatherStation_ != weatherStation_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
    };
    class WeatherStationWindSpeedTimeseriesData : public DoubleTimeseriesData
    {
    public:
        using Base = DoubleTimeseriesData;
        static constexpr Kind KIND = Kind::WeatherStationWindSpeedTimeseries;
    private:
        Guid weatherStation_;
    public:
        WeatherStationWindSpeedTimeseriesData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(weatherStation_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(weatherStation_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<WeatherStationWindSpeedTimeseriesData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<WeatherStationWindSpeedTimeseriesData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const WeatherStationWindSpeedTimeseriesData& >( other );
                if ( dataObject.weatherStation_ != weatherStation_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
    };
    class GeoPosition2DTimeseriesData : public TimeseriesData
    {
    public:
        using Base = TimeseriesData;
        static constexpr Kind KIND = Kind::GeoPosition2DTimeseries;
    private:
    public:
        GeoPosition2DTimeseriesData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<GeoPosition2DTimeseriesData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<GeoPosition2DTimeseriesData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const GeoPosition2DTimeseriesData& >( other );
                return true;
            }
            return false;
        }
    };
    class AisAidToNavigationPositionTimeseriesData : public GeoPosition2DTimeseriesData
    {
    public:
        using Base = GeoPosition2DTimeseriesData;
        static constexpr Kind KIND = Kind::AisAidToNavigationPositionTimeseries;
    private:
        Guid aidToNavigation_;
    public:
        AisAidToNavigationPositionTimeseriesData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(aidToNavigation_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(aidToNavigation_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<AisAidToNavigationPositionTimeseriesData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<AisAidToNavigationPositionTimeseriesData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const AisAidToNavigationPositionTimeseriesData& >( other );
                if ( dataObject.aidToNavigation_ != aidToNavigation_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
    };
    class GeoPosition3DTimeseriesData : public TimeseriesData
    {
    public:
        using Base = TimeseriesData;
        static constexpr Kind KIND = Kind::GeoPosition3DTimeseries;
    private:
    public:
        GeoPosition3DTimeseriesData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<GeoPosition3DTimeseriesData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<GeoPosition3DTimeseriesData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const GeoPosition3DTimeseriesData& >( other );
                return true;
            }
            return false;
        }
    };
    class GuidTimeseriesData : public TimeseriesData
    {
    public:
        using Base = TimeseriesData;
        static constexpr Kind KIND = Kind::GuidTimeseries;
    private:
    public:
        GuidTimeseriesData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<GuidTimeseriesData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<GuidTimeseriesData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const GuidTimeseriesData& >( other );
                return true;
            }
            return false;
        }
    };
    class Int16TimeseriesData : public TimeseriesData
    {
    public:
        using Base = TimeseriesData;
        static constexpr Kind KIND = Kind::Int16Timeseries;
    private:
    public:
        Int16TimeseriesData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<Int16TimeseriesData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<Int16TimeseriesData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const Int16TimeseriesData& >( other );
                return true;
            }
            return false;
        }
    };
    class Int32TimeseriesData : public TimeseriesData
    {
    public:
        using Base = TimeseriesData;
        static constexpr Kind KIND = Kind::Int32Timeseries;
    private:
    public:
        Int32TimeseriesData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<Int32TimeseriesData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<Int32TimeseriesData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const Int32TimeseriesData& >( other );
                return true;
            }
            return false;
        }
    };
    class RadarAzimuthOffsetTimeseriesData : public Int32TimeseriesData
    {
    public:
        using Base = Int32TimeseriesData;
        static constexpr Kind KIND = Kind::RadarAzimuthOffsetTimeseries;
    private:
        Guid radar_;
    public:
        RadarAzimuthOffsetTimeseriesData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(radar_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(radar_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<RadarAzimuthOffsetTimeseriesData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<RadarAzimuthOffsetTimeseriesData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const RadarAzimuthOffsetTimeseriesData& >( other );
                if ( dataObject.radar_ != radar_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
    };
    class RadarFastTimeConstantLevelTimeseriesData : public Int32TimeseriesData
    {
    public:
        using Base = Int32TimeseriesData;
        static constexpr Kind KIND = Kind::RadarFastTimeConstantLevelTimeseries;
    private:
        Guid radar_;
    public:
        RadarFastTimeConstantLevelTimeseriesData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(radar_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(radar_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<RadarFastTimeConstantLevelTimeseriesData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<RadarFastTimeConstantLevelTimeseriesData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const RadarFastTimeConstantLevelTimeseriesData& >( other );
                if ( dataObject.radar_ != radar_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
    };
    class RadarFastTimeConstantModeTimeseriesData : public Int32TimeseriesData
    {
    public:
        using Base = Int32TimeseriesData;
        static constexpr Kind KIND = Kind::RadarFastTimeConstantModeTimeseries;
    private:
        Guid radar_;
    public:
        RadarFastTimeConstantModeTimeseriesData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(radar_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(radar_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<RadarFastTimeConstantModeTimeseriesData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<RadarFastTimeConstantModeTimeseriesData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const RadarFastTimeConstantModeTimeseriesData& >( other );
                if ( dataObject.radar_ != radar_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
    };
    class RadarPulseTimeseriesData : public Int32TimeseriesData
    {
    public:
        using Base = Int32TimeseriesData;
        static constexpr Kind KIND = Kind::RadarPulseTimeseries;
    private:
        Guid radar_;
    public:
        RadarPulseTimeseriesData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(radar_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(radar_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<RadarPulseTimeseriesData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<RadarPulseTimeseriesData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const RadarPulseTimeseriesData& >( other );
                if ( dataObject.radar_ != radar_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
    };
    class RadarSector1EndTimeseriesData : public Int32TimeseriesData
    {
    public:
        using Base = Int32TimeseriesData;
        static constexpr Kind KIND = Kind::RadarSector1EndTimeseries;
    private:
        Guid radar_;
    public:
        RadarSector1EndTimeseriesData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(radar_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(radar_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<RadarSector1EndTimeseriesData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<RadarSector1EndTimeseriesData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const RadarSector1EndTimeseriesData& >( other );
                if ( dataObject.radar_ != radar_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
    };
    class RadarSector1StartTimeseriesData : public Int32TimeseriesData
    {
    public:
        using Base = Int32TimeseriesData;
        static constexpr Kind KIND = Kind::RadarSector1StartTimeseries;
    private:
        Guid radar_;
    public:
        RadarSector1StartTimeseriesData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(radar_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(radar_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<RadarSector1StartTimeseriesData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<RadarSector1StartTimeseriesData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const RadarSector1StartTimeseriesData& >( other );
                if ( dataObject.radar_ != radar_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
    };
    class RadarSector2EndTimeseriesData : public Int32TimeseriesData
    {
    public:
        using Base = Int32TimeseriesData;
        static constexpr Kind KIND = Kind::RadarSector2EndTimeseries;
    private:
        Guid radar_;
    public:
        RadarSector2EndTimeseriesData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(radar_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(radar_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<RadarSector2EndTimeseriesData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<RadarSector2EndTimeseriesData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const RadarSector2EndTimeseriesData& >( other );
                if ( dataObject.radar_ != radar_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
    };
    class RadarSector2StartTimeseriesData : public Int32TimeseriesData
    {
    public:
        using Base = Int32TimeseriesData;
        static constexpr Kind KIND = Kind::RadarSector2StartTimeseries;
    private:
        Guid radar_;
    public:
        RadarSector2StartTimeseriesData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(radar_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(radar_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<RadarSector2StartTimeseriesData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<RadarSector2StartTimeseriesData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const RadarSector2StartTimeseriesData& >( other );
                if ( dataObject.radar_ != radar_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
    };
    class RadarSensitivityTimeControlLevelTimeseriesData : public Int32TimeseriesData
    {
    public:
        using Base = Int32TimeseriesData;
        static constexpr Kind KIND = Kind::RadarSensitivityTimeControlLevelTimeseries;
    private:
        Guid radar_;
    public:
        RadarSensitivityTimeControlLevelTimeseriesData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(radar_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(radar_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<RadarSensitivityTimeControlLevelTimeseriesData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<RadarSensitivityTimeControlLevelTimeseriesData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const RadarSensitivityTimeControlLevelTimeseriesData& >( other );
                if ( dataObject.radar_ != radar_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
    };
    class RadarTuningTimeseriesData : public Int32TimeseriesData
    {
    public:
        using Base = Int32TimeseriesData;
        static constexpr Kind KIND = Kind::RadarTuningTimeseries;
    private:
        Guid radar_;
    public:
        RadarTuningTimeseriesData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(radar_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(radar_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<RadarTuningTimeseriesData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<RadarTuningTimeseriesData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const RadarTuningTimeseriesData& >( other );
                if ( dataObject.radar_ != radar_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
    };
    class VesselPersonsOnBoardTimeseriesData : public Int32TimeseriesData
    {
    public:
        using Base = Int32TimeseriesData;
        static constexpr Kind KIND = Kind::VesselPersonsOnBoardTimeseries;
    private:
        Guid vessel_;
    public:
        VesselPersonsOnBoardTimeseriesData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(vessel_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(vessel_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<VesselPersonsOnBoardTimeseriesData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<VesselPersonsOnBoardTimeseriesData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const VesselPersonsOnBoardTimeseriesData& >( other );
                if ( dataObject.vessel_ != vessel_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
    };
    class Int64TimeseriesData : public TimeseriesData
    {
    public:
        using Base = TimeseriesData;
        static constexpr Kind KIND = Kind::Int64Timeseries;
    private:
    public:
        Int64TimeseriesData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<Int64TimeseriesData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<Int64TimeseriesData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const Int64TimeseriesData& >( other );
                return true;
            }
            return false;
        }
    };
    class Position2DTimeseriesData : public TimeseriesData
    {
    public:
        using Base = TimeseriesData;
        static constexpr Kind KIND = Kind::Position2DTimeseries;
    private:
    public:
        Position2DTimeseriesData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<Position2DTimeseriesData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<Position2DTimeseriesData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const Position2DTimeseriesData& >( other );
                return true;
            }
            return false;
        }
    };
    class Position3DTimeseriesData : public TimeseriesData
    {
    public:
        using Base = TimeseriesData;
        static constexpr Kind KIND = Kind::Position3DTimeseries;
    private:
    public:
        Position3DTimeseriesData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<Position3DTimeseriesData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<Position3DTimeseriesData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const Position3DTimeseriesData& >( other );
                return true;
            }
            return false;
        }
    };
    class ReferenceTimeseriesData : public TimeseriesData
    {
    public:
        using Base = TimeseriesData;
        static constexpr Kind KIND = Kind::ReferenceTimeseries;
    private:
    public:
        ReferenceTimeseriesData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<ReferenceTimeseriesData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<ReferenceTimeseriesData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const ReferenceTimeseriesData& >( other );
                return true;
            }
            return false;
        }
    };
    class SByteTimeseriesData : public TimeseriesData
    {
    public:
        using Base = TimeseriesData;
        static constexpr Kind KIND = Kind::SByteTimeseries;
    private:
    public:
        SByteTimeseriesData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<SByteTimeseriesData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<SByteTimeseriesData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const SByteTimeseriesData& >( other );
                return true;
            }
            return false;
        }
    };
    class SingleTimeseriesData : public TimeseriesData
    {
    public:
        using Base = TimeseriesData;
        static constexpr Kind KIND = Kind::SingleTimeseries;
    private:
    public:
        SingleTimeseriesData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<SingleTimeseriesData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<SingleTimeseriesData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const SingleTimeseriesData& >( other );
                return true;
            }
            return false;
        }
    };
    class StringTimeseriesData : public TimeseriesData
    {
    public:
        using Base = TimeseriesData;
        static constexpr Kind KIND = Kind::StringTimeseries;
    private:
    public:
        StringTimeseriesData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<StringTimeseriesData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<StringTimeseriesData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const StringTimeseriesData& >( other );
                return true;
            }
            return false;
        }
    };
    class TimeSpanTimeseriesData : public TimeseriesData
    {
    public:
        using Base = TimeseriesData;
        static constexpr Kind KIND = Kind::TimeSpanTimeseries;
    private:
    public:
        TimeSpanTimeseriesData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<TimeSpanTimeseriesData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<TimeSpanTimeseriesData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const TimeSpanTimeseriesData& >( other );
                return true;
            }
            return false;
        }
    };
    class UInt16TimeseriesData : public TimeseriesData
    {
    public:
        using Base = TimeseriesData;
        static constexpr Kind KIND = Kind::UInt16Timeseries;
    private:
    public:
        UInt16TimeseriesData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<UInt16TimeseriesData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<UInt16TimeseriesData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const UInt16TimeseriesData& >( other );
                return true;
            }
            return false;
        }
    };
    class UInt32TimeseriesData : public TimeseriesData
    {
    public:
        using Base = TimeseriesData;
        static constexpr Kind KIND = Kind::UInt32Timeseries;
    private:
    public:
        UInt32TimeseriesData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<UInt32TimeseriesData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<UInt32TimeseriesData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const UInt32TimeseriesData& >( other );
                return true;
            }
            return false;
        }
    };
    class RadomeStatusTimeseriesData : public UInt32TimeseriesData
    {
    public:
        using Base = UInt32TimeseriesData;
        static constexpr Kind KIND = Kind::RadomeStatusTimeseries;
    private:
        Guid radome_;
    public:
        RadomeStatusTimeseriesData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(radome_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(radome_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<RadomeStatusTimeseriesData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<RadomeStatusTimeseriesData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const RadomeStatusTimeseriesData& >( other );
                if ( dataObject.radome_ != radome_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
    };
    class UInt64TimeseriesData : public TimeseriesData
    {
    public:
        using Base = TimeseriesData;
        static constexpr Kind KIND = Kind::UInt64Timeseries;
    private:
    public:
        UInt64TimeseriesData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<UInt64TimeseriesData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<UInt64TimeseriesData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const UInt64TimeseriesData& >( other );
                return true;
            }
            return false;
        }
    };
    class TimeseriesCatalogData : public TimeseriesCatalogElementData
    {
    public:
        using Base = TimeseriesCatalogElementData;
        static constexpr Kind KIND = Kind::TimeseriesCatalog;
    private:
    public:
        TimeseriesCatalogData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<TimeseriesCatalogData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<TimeseriesCatalogData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const TimeseriesCatalogData& >( other );
                return true;
            }
            return false;
        }
    };
    class TimeseriesInfoData : public BaseData<Kind, Guid>
    {
    public:
        using Base = BaseData<Kind, Guid>;
        static constexpr Kind KIND = Kind::TimeseriesInfo;
    private:
        Int64 rowVersion_ = 0;
        DBDateTime firstTimestamp_;
        DBDateTime lastTimestamp_;
        Int64 count_ = 0;
    public:
        TimeseriesInfoData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(rowVersion_);
            firstTimestamp_.WriteTo( destination );
            lastTimestamp_.WriteTo( destination );
            destination.Write(count_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(rowVersion_);
            firstTimestamp_.ReadFrom( source );
            lastTimestamp_.ReadFrom( source );
            source.Read(count_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<TimeseriesInfoData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<TimeseriesInfoData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const TimeseriesInfoData& >( other );
                if ( dataObject.rowVersion_ != rowVersion_ )
                {
                    return false;
                }
                if ( dataObject.firstTimestamp_ != firstTimestamp_ )
                {
                    return false;
                }
                if ( dataObject.lastTimestamp_ != lastTimestamp_ )
                {
                    return false;
                }
                if ( dataObject.count_ != count_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
    };
    class TimeSpanTimeseriesValueData : public BaseData<Kind, Guid>
    {
    public:
        using Base = BaseData<Kind, Guid>;
        static constexpr Kind KIND = Kind::TimeSpanTimeseriesValue;
    private:
        Int64 rowVersion_ = 0;
        Guid timeseries_;
        DateTime timestamp_;
        DBTimeSpan value_;
    public:
        TimeSpanTimeseriesValueData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(rowVersion_);
            destination.Write(timeseries_);
            destination.Write(timestamp_);
            value_.WriteTo( destination );
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(rowVersion_);
            source.Read(timeseries_);
            source.Read(timestamp_);
            value_.ReadFrom( source );
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<TimeSpanTimeseriesValueData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<TimeSpanTimeseriesValueData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const TimeSpanTimeseriesValueData& >( other );
                if ( dataObject.rowVersion_ != rowVersion_ )
                {
                    return false;
                }
                if ( dataObject.timeseries_ != timeseries_ )
                {
                    return false;
                }
                if ( dataObject.timestamp_ != timestamp_ )
                {
                    return false;
                }
                if ( dataObject.value_ != value_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
    };
    class TrackableItemTrackLinkData : public BaseData<Kind, Guid>
    {
    public:
        using Base = BaseData<Kind, Guid>;
        static constexpr Kind KIND = Kind::TrackableItemTrackLink;
    private:
        Int64 rowVersion_ = 0;
        Guid item_;
        Guid track_;
        DateTime start_;
        DBDateTime end_;
    public:
        TrackableItemTrackLinkData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(rowVersion_);
            destination.Write(item_);
            destination.Write(track_);
            destination.Write(start_);
            end_.WriteTo( destination );
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(rowVersion_);
            source.Read(item_);
            source.Read(track_);
            source.Read(start_);
            end_.ReadFrom( source );
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<TrackableItemTrackLinkData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<TrackableItemTrackLinkData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const TrackableItemTrackLinkData& >( other );
                if ( dataObject.rowVersion_ != rowVersion_ )
                {
                    return false;
                }
                if ( dataObject.item_ != item_ )
                {
                    return false;
                }
                if ( dataObject.track_ != track_ )
                {
                    return false;
                }
                if ( dataObject.start_ != start_ )
                {
                    return false;
                }
                if ( dataObject.end_ != end_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
    };
    class TrackBaseData : public BaseData<Kind, Guid>
    {
    public:
        using Base = BaseData<Kind, Guid>;
        static constexpr Kind KIND = Kind::TrackBase;
    private:
        Int64 rowVersion_ = 0;
        Guid tracker_;
        Int64 trackNumber_ = 0;
        DateTime timestamp_;
    public:
        TrackBaseData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(rowVersion_);
            destination.Write(tracker_);
            destination.Write(trackNumber_);
            destination.Write(timestamp_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(rowVersion_);
            source.Read(tracker_);
            source.Read(trackNumber_);
            source.Read(timestamp_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<TrackBaseData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<TrackBaseData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const TrackBaseData& >( other );
                if ( dataObject.rowVersion_ != rowVersion_ )
                {
                    return false;
                }
                if ( dataObject.tracker_ != tracker_ )
                {
                    return false;
                }
                if ( dataObject.trackNumber_ != trackNumber_ )
                {
                    return false;
                }
                if ( dataObject.timestamp_ != timestamp_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
    };
    class TrackData : public TrackBaseData
    {
    public:
        using Base = TrackBaseData;
        static constexpr Kind KIND = Kind::Track;
    private:
    public:
        TrackData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<TrackData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<TrackData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const TrackData& >( other );
                return true;
            }
            return false;
        }
    };
    class Track3DData : public TrackBaseData
    {
    public:
        using Base = TrackBaseData;
        static constexpr Kind KIND = Kind::Track3D;
    private:
    public:
        Track3DData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<Track3DData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<Track3DData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const Track3DData& >( other );
                return true;
            }
            return false;
        }
    };
    class TrackerFilterParametersData : public BaseData<Kind, Guid>
    {
    public:
        using Base = BaseData<Kind, Guid>;
        static constexpr Kind KIND = Kind::TrackerFilterParameters;
    private:
        Int64 rowVersion_ = 0;
        Guid tracker_;
        FixedDBWideString<100> name_;
    public:
        TrackerFilterParametersData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(rowVersion_);
            destination.Write(tracker_);
            name_.WriteTo( destination );
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(rowVersion_);
            source.Read(tracker_);
            name_.ReadFrom( source );
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<TrackerFilterParametersData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<TrackerFilterParametersData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const TrackerFilterParametersData& >( other );
                if ( dataObject.rowVersion_ != rowVersion_ )
                {
                    return false;
                }
                if ( dataObject.tracker_ != tracker_ )
                {
                    return false;
                }
                if ( dataObject.name_ != name_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
    };
    class TrackerFilterParametersConfigurationData : public BaseData<Kind, Guid>
    {
    public:
        using Base = BaseData<Kind, Guid>;
        static constexpr Kind KIND = Kind::TrackerFilterParametersConfiguration;
    private:
        Int64 rowVersion_ = 0;
        Guid parameters_;
        DateTime timestamp_;
        bool useNaivePredictor_ = false;
        Int32 numberOfPoints_ = 0;
        Int32 windowSize_ = 0;
        Int32 stabilizeCount_ = 0;
        Int32 maxBadPoints_ = 0;
        Data::TrackerFilterModelType modelType_ = Data::TrackerFilterModelType::Unknown;
        double sigmaR_ = 0.0;
        double sigmaAcc_ = 0.0;
        double tauVel_ = 0.0;
        double tauAcc_ = 0.0;
        double deltaRMin_ = 0.0;
        double deltaVMax_ = 0.0;
        double deltaAMax_ = 0.0;
    public:
        TrackerFilterParametersConfigurationData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(rowVersion_);
            destination.Write(parameters_);
            destination.Write(timestamp_);
            destination.Write(useNaivePredictor_);
            destination.Write(numberOfPoints_);
            destination.Write(windowSize_);
            destination.Write(stabilizeCount_);
            destination.Write(maxBadPoints_);
            destination.Write(modelType_);
            destination.Write(sigmaR_);
            destination.Write(sigmaAcc_);
            destination.Write(tauVel_);
            destination.Write(tauAcc_);
            destination.Write(deltaRMin_);
            destination.Write(deltaVMax_);
            destination.Write(deltaAMax_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(rowVersion_);
            source.Read(parameters_);
            source.Read(timestamp_);
            source.Read(useNaivePredictor_);
            source.Read(numberOfPoints_);
            source.Read(windowSize_);
            source.Read(stabilizeCount_);
            source.Read(maxBadPoints_);
            source.Read(modelType_);
            source.Read(sigmaR_);
            source.Read(sigmaAcc_);
            source.Read(tauVel_);
            source.Read(tauAcc_);
            source.Read(deltaRMin_);
            source.Read(deltaVMax_);
            source.Read(deltaAMax_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<TrackerFilterParametersConfigurationData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<TrackerFilterParametersConfigurationData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const TrackerFilterParametersConfigurationData& >( other );
                if ( dataObject.rowVersion_ != rowVersion_ )
                {
                    return false;
                }
                if ( dataObject.parameters_ != parameters_ )
                {
                    return false;
                }
                if ( dataObject.timestamp_ != timestamp_ )
                {
                    return false;
                }
                if ( dataObject.useNaivePredictor_ != useNaivePredictor_ )
                {
                    return false;
                }
                if ( dataObject.numberOfPoints_ != numberOfPoints_ )
                {
                    return false;
                }
                if ( dataObject.windowSize_ != windowSize_ )
                {
                    return false;
                }
                if ( dataObject.stabilizeCount_ != stabilizeCount_ )
                {
                    return false;
                }
                if ( dataObject.maxBadPoints_ != maxBadPoints_ )
                {
                    return false;
                }
                if ( dataObject.modelType_ != modelType_ )
                {
                    return false;
                }
                if ( dataObject.sigmaR_ != sigmaR_ )
                {
                    return false;
                }
                if ( dataObject.sigmaAcc_ != sigmaAcc_ )
                {
                    return false;
                }
                if ( dataObject.tauVel_ != tauVel_ )
                {
                    return false;
                }
                if ( dataObject.tauAcc_ != tauAcc_ )
                {
                    return false;
                }
                if ( dataObject.deltaRMin_ != deltaRMin_ )
                {
                    return false;
                }
                if ( dataObject.deltaVMax_ != deltaVMax_ )
                {
                    return false;
                }
                if ( dataObject.deltaAMax_ != deltaAMax_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
    };
    class TrackInfoData : public BaseData<Kind, Guid>
    {
    public:
        using Base = BaseData<Kind, Guid>;
        static constexpr Kind KIND = Kind::TrackInfo;
    private:
        Int64 rowVersion_ = 0;
        DBDateTime firstTimestamp_;
        DBDateTime lastTimestamp_;
        Int64 count_ = 0;
        DBDouble northWestLatitude_;
        DBDouble northWestLongitude_;
        DBDouble southEastLatitude_;
        DBDouble southEastLongitude_;
    public:
        TrackInfoData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(rowVersion_);
            firstTimestamp_.WriteTo( destination );
            lastTimestamp_.WriteTo( destination );
            destination.Write(count_);
            northWestLatitude_.WriteTo( destination );
            northWestLongitude_.WriteTo( destination );
            southEastLatitude_.WriteTo( destination );
            southEastLongitude_.WriteTo( destination );
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(rowVersion_);
            firstTimestamp_.ReadFrom( source );
            lastTimestamp_.ReadFrom( source );
            source.Read(count_);
            northWestLatitude_.ReadFrom( source );
            northWestLongitude_.ReadFrom( source );
            southEastLatitude_.ReadFrom( source );
            southEastLongitude_.ReadFrom( source );
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<TrackInfoData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<TrackInfoData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const TrackInfoData& >( other );
                if ( dataObject.rowVersion_ != rowVersion_ )
                {
                    return false;
                }
                if ( dataObject.firstTimestamp_ != firstTimestamp_ )
                {
                    return false;
                }
                if ( dataObject.lastTimestamp_ != lastTimestamp_ )
                {
                    return false;
                }
                if ( dataObject.count_ != count_ )
                {
                    return false;
                }
                if ( dataObject.northWestLatitude_ != northWestLatitude_ )
                {
                    return false;
                }
                if ( dataObject.northWestLongitude_ != northWestLongitude_ )
                {
                    return false;
                }
                if ( dataObject.southEastLatitude_ != southEastLatitude_ )
                {
                    return false;
                }
                if ( dataObject.southEastLongitude_ != southEastLongitude_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
    };
    class TrackingServiceOptionsData : public BaseData<Kind, Guid>
    {
    public:
        using Base = BaseData<Kind, Guid>;
        static constexpr Kind KIND = Kind::TrackingServiceOptions;
    private:
        Int64 rowVersion_ = 0;
        DateTime timestamp_;
        TimeSpan timerInterval_;
        TimeSpan maxAgeOfCurrentTrackValue_;
        double falseThreshold_ = 0.0;
        double distanceThreshold_ = 0.0;
        double distanceUnmergeThreshold_ = 0.0;
        Int64 unmergeLatency_ = 0;
        bool kalmanFiltering_ = false;
        double maxCourseDeviation_ = 0.0;
        double maxSpeedDeviation_ = 0.0;
        double minimumSpeedThreshold_ = 0.0;
    public:
        TrackingServiceOptionsData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(rowVersion_);
            destination.Write(timestamp_);
            destination.Write(timerInterval_);
            destination.Write(maxAgeOfCurrentTrackValue_);
            destination.Write(falseThreshold_);
            destination.Write(distanceThreshold_);
            destination.Write(distanceUnmergeThreshold_);
            destination.Write(unmergeLatency_);
            destination.Write(kalmanFiltering_);
            destination.Write(maxCourseDeviation_);
            destination.Write(maxSpeedDeviation_);
            destination.Write(minimumSpeedThreshold_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(rowVersion_);
            source.Read(timestamp_);
            source.Read(timerInterval_);
            source.Read(maxAgeOfCurrentTrackValue_);
            source.Read(falseThreshold_);
            source.Read(distanceThreshold_);
            source.Read(distanceUnmergeThreshold_);
            source.Read(unmergeLatency_);
            source.Read(kalmanFiltering_);
            source.Read(maxCourseDeviation_);
            source.Read(maxSpeedDeviation_);
            source.Read(minimumSpeedThreshold_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<TrackingServiceOptionsData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<TrackingServiceOptionsData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const TrackingServiceOptionsData& >( other );
                if ( dataObject.rowVersion_ != rowVersion_ )
                {
                    return false;
                }
                if ( dataObject.timestamp_ != timestamp_ )
                {
                    return false;
                }
                if ( dataObject.timerInterval_ != timerInterval_ )
                {
                    return false;
                }
                if ( dataObject.maxAgeOfCurrentTrackValue_ != maxAgeOfCurrentTrackValue_ )
                {
                    return false;
                }
                if ( dataObject.falseThreshold_ != falseThreshold_ )
                {
                    return false;
                }
                if ( dataObject.distanceThreshold_ != distanceThreshold_ )
                {
                    return false;
                }
                if ( dataObject.distanceUnmergeThreshold_ != distanceUnmergeThreshold_ )
                {
                    return false;
                }
                if ( dataObject.unmergeLatency_ != unmergeLatency_ )
                {
                    return false;
                }
                if ( dataObject.kalmanFiltering_ != kalmanFiltering_ )
                {
                    return false;
                }
                if ( dataObject.maxCourseDeviation_ != maxCourseDeviation_ )
                {
                    return false;
                }
                if ( dataObject.maxSpeedDeviation_ != maxSpeedDeviation_ )
                {
                    return false;
                }
                if ( dataObject.minimumSpeedThreshold_ != minimumSpeedThreshold_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
    };
    class TrackLinkData : public BaseData<Kind, Guid>
    {
    public:
        using Base = BaseData<Kind, Guid>;
        static constexpr Kind KIND = Kind::TrackLink;
    private:
        Int64 rowVersion_ = 0;
        Guid primary_;
        Guid secondary_;
        DateTime start_;
        DBDateTime end_;
    public:
        TrackLinkData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(rowVersion_);
            destination.Write(primary_);
            destination.Write(secondary_);
            destination.Write(start_);
            end_.WriteTo( destination );
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(rowVersion_);
            source.Read(primary_);
            source.Read(secondary_);
            source.Read(start_);
            end_.ReadFrom( source );
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<TrackLinkData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<TrackLinkData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const TrackLinkData& >( other );
                if ( dataObject.rowVersion_ != rowVersion_ )
                {
                    return false;
                }
                if ( dataObject.primary_ != primary_ )
                {
                    return false;
                }
                if ( dataObject.secondary_ != secondary_ )
                {
                    return false;
                }
                if ( dataObject.start_ != start_ )
                {
                    return false;
                }
                if ( dataObject.end_ != end_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
    };
    class TrackValueData : public BaseData<Kind, Guid>
    {
    public:
        using Base = BaseData<Kind, Guid>;
        static constexpr Kind KIND = Kind::TrackValue;
    private:
        Int64 rowVersion_ = 0;
        Guid track_;
        DateTime timestamp_;
        Data::TrackFlags flags_ = Data::TrackFlags::None;
        Data::TrackStatus status_ = Data::TrackStatus::Unknown;
        double latitude_ = 0.0;
        double longitude_ = 0.0;
        double speed_ = 0.0;
        double course_ = 0.0;
        double heading_ = 0.0;
    public:
        TrackValueData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(rowVersion_);
            destination.Write(track_);
            destination.Write(timestamp_);
            destination.Write(flags_);
            destination.Write(status_);
            destination.Write(latitude_);
            destination.Write(longitude_);
            destination.Write(speed_);
            destination.Write(course_);
            destination.Write(heading_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(rowVersion_);
            source.Read(track_);
            source.Read(timestamp_);
            source.Read(flags_);
            source.Read(status_);
            source.Read(latitude_);
            source.Read(longitude_);
            source.Read(speed_);
            source.Read(course_);
            source.Read(heading_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<TrackValueData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<TrackValueData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const TrackValueData& >( other );
                if ( dataObject.rowVersion_ != rowVersion_ )
                {
                    return false;
                }
                if ( dataObject.track_ != track_ )
                {
                    return false;
                }
                if ( dataObject.timestamp_ != timestamp_ )
                {
                    return false;
                }
                if ( dataObject.flags_ != flags_ )
                {
                    return false;
                }
                if ( dataObject.status_ != status_ )
                {
                    return false;
                }
                if ( dataObject.latitude_ != latitude_ )
                {
                    return false;
                }
                if ( dataObject.longitude_ != longitude_ )
                {
                    return false;
                }
                if ( dataObject.speed_ != speed_ )
                {
                    return false;
                }
                if ( dataObject.course_ != course_ )
                {
                    return false;
                }
                if ( dataObject.heading_ != heading_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
    };
    class TrackValue3DData : public BaseData<Kind, Guid>
    {
    public:
        using Base = BaseData<Kind, Guid>;
        static constexpr Kind KIND = Kind::TrackValue3D;
    private:
        Int64 rowVersion_ = 0;
        Guid track_;
        DateTime timestamp_;
        Data::TrackFlags3D flags_ = Data::TrackFlags3D::None;
        UInt32 status_ = 0;
        double latitude_ = 0.0;
        double longitude_ = 0.0;
        double altitude_ = 0.0;
        double speed_ = 0.0;
        double course_ = 0.0;
        double rateOfClimb_ = 0.0;
    public:
        TrackValue3DData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(rowVersion_);
            destination.Write(track_);
            destination.Write(timestamp_);
            destination.Write(flags_);
            destination.Write(status_);
            destination.Write(latitude_);
            destination.Write(longitude_);
            destination.Write(altitude_);
            destination.Write(speed_);
            destination.Write(course_);
            destination.Write(rateOfClimb_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(rowVersion_);
            source.Read(track_);
            source.Read(timestamp_);
            source.Read(flags_);
            source.Read(status_);
            source.Read(latitude_);
            source.Read(longitude_);
            source.Read(altitude_);
            source.Read(speed_);
            source.Read(course_);
            source.Read(rateOfClimb_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<TrackValue3DData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<TrackValue3DData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const TrackValue3DData& >( other );
                if ( dataObject.rowVersion_ != rowVersion_ )
                {
                    return false;
                }
                if ( dataObject.track_ != track_ )
                {
                    return false;
                }
                if ( dataObject.timestamp_ != timestamp_ )
                {
                    return false;
                }
                if ( dataObject.flags_ != flags_ )
                {
                    return false;
                }
                if ( dataObject.status_ != status_ )
                {
                    return false;
                }
                if ( dataObject.latitude_ != latitude_ )
                {
                    return false;
                }
                if ( dataObject.longitude_ != longitude_ )
                {
                    return false;
                }
                if ( dataObject.altitude_ != altitude_ )
                {
                    return false;
                }
                if ( dataObject.speed_ != speed_ )
                {
                    return false;
                }
                if ( dataObject.course_ != course_ )
                {
                    return false;
                }
                if ( dataObject.rateOfClimb_ != rateOfClimb_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
    };
    class UInt16TimeseriesValueData : public BaseData<Kind, Guid>
    {
    public:
        using Base = BaseData<Kind, Guid>;
        static constexpr Kind KIND = Kind::UInt16TimeseriesValue;
    private:
        Int64 rowVersion_ = 0;
        Guid timeseries_;
        DateTime timestamp_;
        DBUInt16 value_;
    public:
        UInt16TimeseriesValueData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(rowVersion_);
            destination.Write(timeseries_);
            destination.Write(timestamp_);
            value_.WriteTo( destination );
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(rowVersion_);
            source.Read(timeseries_);
            source.Read(timestamp_);
            value_.ReadFrom( source );
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<UInt16TimeseriesValueData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<UInt16TimeseriesValueData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const UInt16TimeseriesValueData& >( other );
                if ( dataObject.rowVersion_ != rowVersion_ )
                {
                    return false;
                }
                if ( dataObject.timeseries_ != timeseries_ )
                {
                    return false;
                }
                if ( dataObject.timestamp_ != timestamp_ )
                {
                    return false;
                }
                if ( dataObject.value_ != value_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
    };
    class UInt32TimeseriesValueData : public BaseData<Kind, Guid>
    {
    public:
        using Base = BaseData<Kind, Guid>;
        static constexpr Kind KIND = Kind::UInt32TimeseriesValue;
    private:
        Int64 rowVersion_ = 0;
        Guid timeseries_;
        DateTime timestamp_;
        DBUInt32 value_;
    public:
        UInt32TimeseriesValueData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(rowVersion_);
            destination.Write(timeseries_);
            destination.Write(timestamp_);
            value_.WriteTo( destination );
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(rowVersion_);
            source.Read(timeseries_);
            source.Read(timestamp_);
            value_.ReadFrom( source );
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<UInt32TimeseriesValueData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<UInt32TimeseriesValueData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const UInt32TimeseriesValueData& >( other );
                if ( dataObject.rowVersion_ != rowVersion_ )
                {
                    return false;
                }
                if ( dataObject.timeseries_ != timeseries_ )
                {
                    return false;
                }
                if ( dataObject.timestamp_ != timestamp_ )
                {
                    return false;
                }
                if ( dataObject.value_ != value_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
    };
    class UInt64TimeseriesValueData : public BaseData<Kind, Guid>
    {
    public:
        using Base = BaseData<Kind, Guid>;
        static constexpr Kind KIND = Kind::UInt64TimeseriesValue;
    private:
        Int64 rowVersion_ = 0;
        Guid timeseries_;
        DateTime timestamp_;
        DBInt64 value_;
    public:
        UInt64TimeseriesValueData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(rowVersion_);
            destination.Write(timeseries_);
            destination.Write(timestamp_);
            value_.WriteTo( destination );
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(rowVersion_);
            source.Read(timeseries_);
            source.Read(timestamp_);
            value_.ReadFrom( source );
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<UInt64TimeseriesValueData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<UInt64TimeseriesValueData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const UInt64TimeseriesValueData& >( other );
                if ( dataObject.rowVersion_ != rowVersion_ )
                {
                    return false;
                }
                if ( dataObject.timeseries_ != timeseries_ )
                {
                    return false;
                }
                if ( dataObject.timestamp_ != timestamp_ )
                {
                    return false;
                }
                if ( dataObject.value_ != value_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
    };
    class VehicleTypeData : public BaseData<Kind, Guid>
    {
    public:
        using Base = BaseData<Kind, Guid>;
        static constexpr Kind KIND = Kind::VehicleType;
    private:
        Int64 rowVersion_ = 0;
        FixedDBWideString<127> name_;
    public:
        VehicleTypeData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(rowVersion_);
            name_.WriteTo( destination );
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(rowVersion_);
            name_.ReadFrom( source );
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<VehicleTypeData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<VehicleTypeData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const VehicleTypeData& >( other );
                if ( dataObject.rowVersion_ != rowVersion_ )
                {
                    return false;
                }
                if ( dataObject.name_ != name_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
    };
    class VesselTypeData : public BaseData<Kind, Guid>
    {
    public:
        using Base = BaseData<Kind, Guid>;
        static constexpr Kind KIND = Kind::VesselType;
    private:
        Int64 rowVersion_ = 0;
        FixedDBWideString<127> name_;
        Int32 code_ = 0;
    public:
        VesselTypeData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(rowVersion_);
            name_.WriteTo( destination );
            destination.Write(code_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(rowVersion_);
            name_.ReadFrom( source );
            source.Read(code_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<VesselTypeData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<VesselTypeData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const VesselTypeData& >( other );
                if ( dataObject.rowVersion_ != rowVersion_ )
                {
                    return false;
                }
                if ( dataObject.name_ != name_ )
                {
                    return false;
                }
                if ( dataObject.code_ != code_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
    };
    class ViewData : public BaseData<Kind, Guid>
    {
    public:
        using Base = BaseData<Kind, Guid>;
        static constexpr Kind KIND = Kind::View;
    private:
        Int64 rowVersion_ = 0;
        FixedDBWideString<127> name_;
        Guid latitudeTimeseries_;
        Guid longitudeTimeseries_;
        Guid zoomLevelTimeseries_;
    public:
        ViewData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(rowVersion_);
            name_.WriteTo( destination );
            destination.Write(latitudeTimeseries_);
            destination.Write(longitudeTimeseries_);
            destination.Write(zoomLevelTimeseries_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(rowVersion_);
            name_.ReadFrom( source );
            source.Read(latitudeTimeseries_);
            source.Read(longitudeTimeseries_);
            source.Read(zoomLevelTimeseries_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<ViewData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<ViewData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const ViewData& >( other );
                if ( dataObject.rowVersion_ != rowVersion_ )
                {
                    return false;
                }
                if ( dataObject.name_ != name_ )
                {
                    return false;
                }
                if ( dataObject.latitudeTimeseries_ != latitudeTimeseries_ )
                {
                    return false;
                }
                if ( dataObject.longitudeTimeseries_ != longitudeTimeseries_ )
                {
                    return false;
                }
                if ( dataObject.zoomLevelTimeseries_ != zoomLevelTimeseries_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
    };
    class ViewCameraLinkData : public BaseData<Kind, Guid>
    {
    public:
        using Base = BaseData<Kind, Guid>;
        static constexpr Kind KIND = Kind::ViewCameraLink;
    private:
        Int64 rowVersion_ = 0;
        Guid view_;
        Guid camera_;
        DateTime start_;
        DBDateTime end_;
    public:
        ViewCameraLinkData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(rowVersion_);
            destination.Write(view_);
            destination.Write(camera_);
            destination.Write(start_);
            end_.WriteTo( destination );
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(rowVersion_);
            source.Read(view_);
            source.Read(camera_);
            source.Read(start_);
            end_.ReadFrom( source );
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<ViewCameraLinkData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<ViewCameraLinkData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const ViewCameraLinkData& >( other );
                if ( dataObject.rowVersion_ != rowVersion_ )
                {
                    return false;
                }
                if ( dataObject.view_ != view_ )
                {
                    return false;
                }
                if ( dataObject.camera_ != camera_ )
                {
                    return false;
                }
                if ( dataObject.start_ != start_ )
                {
                    return false;
                }
                if ( dataObject.end_ != end_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
    };
    class ViewTrackerLinkData : public BaseData<Kind, Guid>
    {
    public:
        using Base = BaseData<Kind, Guid>;
        static constexpr Kind KIND = Kind::ViewTrackerLink;
    private:
        Int64 rowVersion_ = 0;
        Guid view_;
        Guid tracker_;
        DateTime start_;
        DBDateTime end_;
    public:
        ViewTrackerLinkData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(rowVersion_);
            destination.Write(view_);
            destination.Write(tracker_);
            destination.Write(start_);
            end_.WriteTo( destination );
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(rowVersion_);
            source.Read(view_);
            source.Read(tracker_);
            source.Read(start_);
            end_.ReadFrom( source );
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<ViewTrackerLinkData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<ViewTrackerLinkData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const ViewTrackerLinkData& >( other );
                if ( dataObject.rowVersion_ != rowVersion_ )
                {
                    return false;
                }
                if ( dataObject.view_ != view_ )
                {
                    return false;
                }
                if ( dataObject.tracker_ != tracker_ )
                {
                    return false;
                }
                if ( dataObject.start_ != start_ )
                {
                    return false;
                }
                if ( dataObject.end_ != end_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
    };
    class WeatherStationCommandData : public BaseData<Kind, Guid>
    {
    public:
        using Base = BaseData<Kind, Guid>;
        static constexpr Kind KIND = Kind::WeatherStationCommand;
    private:
        Int64 rowVersion_ = 0;
        Guid weatherStation_;
        DateTime timestamp_;
        Data::DeviceCommandSourceType deviceCommandSourceType_ = Data::DeviceCommandSourceType::Unknown;
        Guid deviceCommandSourceId_;
        Guid reply_;
    public:
        WeatherStationCommandData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(rowVersion_);
            destination.Write(weatherStation_);
            destination.Write(timestamp_);
            destination.Write(deviceCommandSourceType_);
            destination.Write(deviceCommandSourceId_);
            destination.Write(reply_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(rowVersion_);
            source.Read(weatherStation_);
            source.Read(timestamp_);
            source.Read(deviceCommandSourceType_);
            source.Read(deviceCommandSourceId_);
            source.Read(reply_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<WeatherStationCommandData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<WeatherStationCommandData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const WeatherStationCommandData& >( other );
                if ( dataObject.rowVersion_ != rowVersion_ )
                {
                    return false;
                }
                if ( dataObject.weatherStation_ != weatherStation_ )
                {
                    return false;
                }
                if ( dataObject.timestamp_ != timestamp_ )
                {
                    return false;
                }
                if ( dataObject.deviceCommandSourceType_ != deviceCommandSourceType_ )
                {
                    return false;
                }
                if ( dataObject.deviceCommandSourceId_ != deviceCommandSourceId_ )
                {
                    return false;
                }
                if ( dataObject.reply_ != reply_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
    };
    class WeatherStationCommandReplyData : public BaseData<Kind, Guid>
    {
    public:
        using Base = BaseData<Kind, Guid>;
        static constexpr Kind KIND = Kind::WeatherStationCommandReply;
    private:
        Int64 rowVersion_ = 0;
        Guid weatherStation_;
        DateTime timestamp_;
        Guid command_;
        Data::DeviceCommandReplyStatus status_ = Data::DeviceCommandReplyStatus::Unknown;
        WideString message_;
        SQLLEN messageLength_ = SQL_NULL_DATA;
    public:
        WeatherStationCommandReplyData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(rowVersion_);
            destination.Write(weatherStation_);
            destination.Write(timestamp_);
            destination.Write(command_);
            destination.Write(status_);
            destination.Write(message_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(rowVersion_);
            source.Read(weatherStation_);
            source.Read(timestamp_);
            source.Read(command_);
            source.Read(status_);
            source.Read(message_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<WeatherStationCommandReplyData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<WeatherStationCommandReplyData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const WeatherStationCommandReplyData& >( other );
                if ( dataObject.rowVersion_ != rowVersion_ )
                {
                    return false;
                }
                if ( dataObject.weatherStation_ != weatherStation_ )
                {
                    return false;
                }
                if ( dataObject.timestamp_ != timestamp_ )
                {
                    return false;
                }
                if ( dataObject.command_ != command_ )
                {
                    return false;
                }
                if ( dataObject.status_ != status_ )
                {
                    return false;
                }
                if ( dataObject.message_ != message_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
    };
    class WeatherStationConfigurationData : public BaseData<Kind, Guid>
    {
    public:
        using Base = BaseData<Kind, Guid>;
        static constexpr Kind KIND = Kind::WeatherStationConfiguration;
    private:
        Int64 rowVersion_ = 0;
        Guid weatherStation_;
        DateTime timestamp_;
        TimeSpan noDataTimeOut_;
        TimeSpan sendInterval_;
        double latitude_ = 0.0;
        double longitude_ = 0.0;
        double gyroOffset_ = 0.0;
        bool enableAveraging_ = false;
        TimeSpan averagingInterval_;
    public:
        WeatherStationConfigurationData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(rowVersion_);
            destination.Write(weatherStation_);
            destination.Write(timestamp_);
            destination.Write(noDataTimeOut_);
            destination.Write(sendInterval_);
            destination.Write(latitude_);
            destination.Write(longitude_);
            destination.Write(gyroOffset_);
            destination.Write(enableAveraging_);
            destination.Write(averagingInterval_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(rowVersion_);
            source.Read(weatherStation_);
            source.Read(timestamp_);
            source.Read(noDataTimeOut_);
            source.Read(sendInterval_);
            source.Read(latitude_);
            source.Read(longitude_);
            source.Read(gyroOffset_);
            source.Read(enableAveraging_);
            source.Read(averagingInterval_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<WeatherStationConfigurationData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<WeatherStationConfigurationData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const WeatherStationConfigurationData& >( other );
                if ( dataObject.rowVersion_ != rowVersion_ )
                {
                    return false;
                }
                if ( dataObject.weatherStation_ != weatherStation_ )
                {
                    return false;
                }
                if ( dataObject.timestamp_ != timestamp_ )
                {
                    return false;
                }
                if ( dataObject.noDataTimeOut_ != noDataTimeOut_ )
                {
                    return false;
                }
                if ( dataObject.sendInterval_ != sendInterval_ )
                {
                    return false;
                }
                if ( dataObject.latitude_ != latitude_ )
                {
                    return false;
                }
                if ( dataObject.longitude_ != longitude_ )
                {
                    return false;
                }
                if ( dataObject.gyroOffset_ != gyroOffset_ )
                {
                    return false;
                }
                if ( dataObject.enableAveraging_ != enableAveraging_ )
                {
                    return false;
                }
                if ( dataObject.averagingInterval_ != averagingInterval_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
    };
    class ZoneData : public BaseData<Kind, Guid>
    {
    public:
        using Base = BaseData<Kind, Guid>;
        static constexpr Kind KIND = Kind::Zone;
    private:
        Int64 rowVersion_ = 0;
        FixedDBWideString<127> name_;
        double longitude_ = 0.0;
        double latitude_ = 0.0;
        Data::ZoneAlarmType alarmType_ = Data::ZoneAlarmType::None;
        TimeSpan alarmTime_;
        TimeSpan radarTrackMinimumLifetime_;
        double speed_ = 0.0;
        UInt32 strokeColor_ = 0;
        UInt32 fillColor_ = 0;
    public:
        ZoneData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(rowVersion_);
            name_.WriteTo( destination );
            destination.Write(longitude_);
            destination.Write(latitude_);
            destination.Write(alarmType_);
            destination.Write(alarmTime_);
            destination.Write(radarTrackMinimumLifetime_);
            destination.Write(speed_);
            destination.Write(strokeColor_);
            destination.Write(fillColor_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(rowVersion_);
            name_.ReadFrom( source );
            source.Read(longitude_);
            source.Read(latitude_);
            source.Read(alarmType_);
            source.Read(alarmTime_);
            source.Read(radarTrackMinimumLifetime_);
            source.Read(speed_);
            source.Read(strokeColor_);
            source.Read(fillColor_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<ZoneData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<ZoneData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const ZoneData& >( other );
                if ( dataObject.rowVersion_ != rowVersion_ )
                {
                    return false;
                }
                if ( dataObject.name_ != name_ )
                {
                    return false;
                }
                if ( dataObject.longitude_ != longitude_ )
                {
                    return false;
                }
                if ( dataObject.latitude_ != latitude_ )
                {
                    return false;
                }
                if ( dataObject.alarmType_ != alarmType_ )
                {
                    return false;
                }
                if ( dataObject.alarmTime_ != alarmTime_ )
                {
                    return false;
                }
                if ( dataObject.radarTrackMinimumLifetime_ != radarTrackMinimumLifetime_ )
                {
                    return false;
                }
                if ( dataObject.speed_ != speed_ )
                {
                    return false;
                }
                if ( dataObject.strokeColor_ != strokeColor_ )
                {
                    return false;
                }
                if ( dataObject.fillColor_ != fillColor_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
    };
    class CircularZoneData : public ZoneData
    {
    public:
        using Base = ZoneData;
        static constexpr Kind KIND = Kind::CircularZone;
    private:
        double radius_ = 0.0;
    public:
        CircularZoneData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(radius_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(radius_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<CircularZoneData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<CircularZoneData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const CircularZoneData& >( other );
                if ( dataObject.radius_ != radius_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
    };
    class PolygonZoneData : public ZoneData
    {
    public:
        using Base = ZoneData;
        static constexpr Kind KIND = Kind::PolygonZone;
    private:
        Binary polygon_;
        SQLLEN polygonLength_ = SQL_NULL_DATA;
    public:
        PolygonZoneData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(polygon_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(polygon_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<PolygonZoneData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<PolygonZoneData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const PolygonZoneData& >( other );
                if ( dataObject.polygon_ != polygon_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
    };
    class ZoneExceptionsData : public BaseData<Kind, Guid>
    {
    public:
        using Base = BaseData<Kind, Guid>;
        static constexpr Kind KIND = Kind::ZoneExceptions;
    private:
        Int64 rowVersion_ = 0;
        Guid zone_;
        DateTime timestamp_;
    public:
        ZoneExceptionsData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(rowVersion_);
            destination.Write(zone_);
            destination.Write(timestamp_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(rowVersion_);
            source.Read(zone_);
            source.Read(timestamp_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<ZoneExceptionsData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<ZoneExceptionsData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const ZoneExceptionsData& >( other );
                if ( dataObject.rowVersion_ != rowVersion_ )
                {
                    return false;
                }
                if ( dataObject.zone_ != zone_ )
                {
                    return false;
                }
                if ( dataObject.timestamp_ != timestamp_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
    };
    class ZoneExceptionsVesselLinkData : public BaseData<Kind, Guid>
    {
    public:
        using Base = BaseData<Kind, Guid>;
        static constexpr Kind KIND = Kind::ZoneExceptionsVesselLink;
    private:
        Int64 rowVersion_ = 0;
        Guid zoneExceptions_;
        Guid vessel_;
    public:
        ZoneExceptionsVesselLinkData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(rowVersion_);
            destination.Write(zoneExceptions_);
            destination.Write(vessel_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(rowVersion_);
            source.Read(zoneExceptions_);
            source.Read(vessel_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<ZoneExceptionsVesselLinkData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<ZoneExceptionsVesselLinkData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const ZoneExceptionsVesselLinkData& >( other );
                if ( dataObject.rowVersion_ != rowVersion_ )
                {
                    return false;
                }
                if ( dataObject.zoneExceptions_ != zoneExceptions_ )
                {
                    return false;
                }
                if ( dataObject.vessel_ != vessel_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
    };
    class ZoneTrackAlarmData : public BaseData<Kind, Guid>
    {
    public:
        using Base = BaseData<Kind, Guid>;
        static constexpr Kind KIND = Kind::ZoneTrackAlarm;
    private:
        Int64 rowVersion_ = 0;
        Guid track_;
        Guid zone_;
        Guid radarTrack_;
        DateTime timestamp_;
        double latitude_ = 0.0;
        double longitude_ = 0.0;
        double speed_ = 0.0;
        DBDouble course_;
        DBDouble heading_;
        double enterLatitude_ = 0.0;
        double enterLongitude_ = 0.0;
        DBDouble leaveLatitude_;
        DBDouble leaveLongitude_;
    public:
        ZoneTrackAlarmData( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(rowVersion_);
            destination.Write(track_);
            destination.Write(zone_);
            destination.Write(radarTrack_);
            destination.Write(timestamp_);
            destination.Write(latitude_);
            destination.Write(longitude_);
            destination.Write(speed_);
            course_.WriteTo( destination );
            heading_.WriteTo( destination );
            destination.Write(enterLatitude_);
            destination.Write(enterLongitude_);
            leaveLatitude_.WriteTo( destination );
            leaveLongitude_.WriteTo( destination );
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(rowVersion_);
            source.Read(track_);
            source.Read(zone_);
            source.Read(radarTrack_);
            source.Read(timestamp_);
            source.Read(latitude_);
            source.Read(longitude_);
            source.Read(speed_);
            course_.ReadFrom( source );
            heading_.ReadFrom( source );
            source.Read(enterLatitude_);
            source.Read(enterLongitude_);
            leaveLatitude_.ReadFrom( source );
            leaveLongitude_.ReadFrom( source );
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<ZoneTrackAlarmData>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<ZoneTrackAlarmData&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const ZoneTrackAlarmData& >( other );
                if ( dataObject.rowVersion_ != rowVersion_ )
                {
                    return false;
                }
                if ( dataObject.track_ != track_ )
                {
                    return false;
                }
                if ( dataObject.zone_ != zone_ )
                {
                    return false;
                }
                if ( dataObject.radarTrack_ != radarTrack_ )
                {
                    return false;
                }
                if ( dataObject.timestamp_ != timestamp_ )
                {
                    return false;
                }
                if ( dataObject.latitude_ != latitude_ )
                {
                    return false;
                }
                if ( dataObject.longitude_ != longitude_ )
                {
                    return false;
                }
                if ( dataObject.speed_ != speed_ )
                {
                    return false;
                }
                if ( dataObject.course_ != course_ )
                {
                    return false;
                }
                if ( dataObject.heading_ != heading_ )
                {
                    return false;
                }
                if ( dataObject.enterLatitude_ != enterLatitude_ )
                {
                    return false;
                }
                if ( dataObject.enterLongitude_ != enterLongitude_ )
                {
                    return false;
                }
                if ( dataObject.leaveLatitude_ != leaveLatitude_ )
                {
                    return false;
                }
                if ( dataObject.leaveLongitude_ != leaveLongitude_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
    };
    class BaseColumnData
    {
    public:
        virtual ~BaseColumnData( ) = default;
        virtual Kind GetKind() const = 0;
        void ReadUnboundData( const ODBC::Statement& statement )
        {
        }
    protected:
        static void ThrowBoundsExceededException( )
        {
            throw Exception( L"Bounds exceeded." );
        }
        static void Assign( const WideString& str, WideString& destination, SQLLEN& lengthOrNullIndicator )
        {
            auto strLength = str.Length( );
            destination = str;
            lengthOrNullIndicator = static_cast< SQLLEN >( strLength );
        }
        static void Assign( const std::vector<Byte>& data, std::vector<Byte>& destination, SQLLEN& lengthOrNullIndicator )
        {
            auto dataLength = data.size( );
            destination = data;
            lengthOrNullIndicator = static_cast< SQLLEN >( dataLength );
        }
        static void Bind( const ODBC::Statement& statement, SQLUSMALLINT fieldId, bool& value )
        {
            statement.BindBooleanColumn( fieldId, reinterpret_cast< Byte* >( &value ), nullptr );
        }
        static void Bind( const ODBC::Statement& statement, SQLUSMALLINT fieldId, DBBoolean& value )
        {
            statement.BindBooleanColumn( fieldId, reinterpret_cast< Byte* >( value.data() ), value.Indicator() );
        }
        static void Bind( const ODBC::Statement& statement, SQLUSMALLINT fieldId, SByte& value )
        {
            statement.BindSByteColumn( fieldId, &value, nullptr );
        }
        static void Bind( const ODBC::Statement& statement, SQLUSMALLINT fieldId, DBSByte& value )
        {
            statement.BindSByteColumn( fieldId, value.data( ), value.Indicator( ) );
        }
        static void Bind( const ODBC::Statement& statement, SQLUSMALLINT fieldId, Byte& value )
        {
            statement.BindByteColumn( fieldId, &value, nullptr );
        }
        static void Bind( const ODBC::Statement& statement, SQLUSMALLINT fieldId, DBByte& value )
        {
            statement.BindByteColumn( fieldId, value.data(), value.Indicator( ) );
        }
        static void Bind( const ODBC::Statement& statement, SQLUSMALLINT fieldId, Int16& value )
        {
            statement.BindInt16Column( fieldId, &value, nullptr );
        }
        static void Bind( const ODBC::Statement& statement, SQLUSMALLINT fieldId, DBInt16& value )
        {
            statement.BindInt16Column( fieldId, value.data(), value.Indicator( ) );
        }
        static void Bind( const ODBC::Statement& statement, SQLUSMALLINT fieldId, UInt16& value )
        {
            statement.BindUInt16Column( fieldId, &value, nullptr );
        }
        static void Bind( const ODBC::Statement& statement, SQLUSMALLINT fieldId, DBUInt16& value )
        {
            statement.BindUInt16Column( fieldId, value.data( ), value.Indicator( ) );
        }
        static void Bind( const ODBC::Statement& statement, SQLUSMALLINT fieldId, Int32& value )
        {
            statement.BindInt32Column( fieldId, &value, nullptr );
        }
        static void Bind( const ODBC::Statement& statement, SQLUSMALLINT fieldId, DBInt32& value )
        {
            statement.BindInt32Column( fieldId, value.data( ), value.Indicator( ) );
        }
        static void Bind( const ODBC::Statement& statement, SQLUSMALLINT fieldId, UInt32& value )
        {
            statement.BindUInt32Column( fieldId, &value, nullptr );
        }
        static void Bind( const ODBC::Statement& statement, SQLUSMALLINT fieldId, DBUInt32& value )
        {
            statement.BindUInt32Column( fieldId, value.data( ), value.Indicator( ) );
        }
        static void Bind( const ODBC::Statement& statement, SQLUSMALLINT fieldId, Int64& value )
        {
            statement.BindInt64Column( fieldId, &value, nullptr );
        }
        static void Bind( const ODBC::Statement& statement, SQLUSMALLINT fieldId, DBInt64& value )
        {
            statement.BindInt64Column( fieldId, value.data( ), value.Indicator( ) );
        }
        static void Bind( const ODBC::Statement& statement, SQLUSMALLINT fieldId, UInt64& value )
        {
            statement.BindUInt64Column( fieldId, &value, nullptr );
        }
        static void Bind( const ODBC::Statement& statement, SQLUSMALLINT fieldId, DBUInt64& value )
        {
            statement.BindUInt64Column( fieldId, value.data( ), value.Indicator( ) );
        }
        static void Bind( const ODBC::Statement& statement, SQLUSMALLINT fieldId, float& value )
        {
            statement.BindSingleColumn( fieldId, &value, nullptr );
        }
        static void Bind( const ODBC::Statement& statement, SQLUSMALLINT fieldId, DBSingle& value )
        {
            statement.BindSingleColumn( fieldId, value.data( ), value.Indicator( ) );
        }
        static void Bind( const ODBC::Statement& statement, SQLUSMALLINT fieldId, double& value )
        {
            statement.BindDoubleColumn( fieldId, &value, nullptr );
        }
        static void Bind( const ODBC::Statement& statement, SQLUSMALLINT fieldId, DBDouble& value )
        {
            statement.BindDoubleColumn( fieldId, value.data( ), value.Indicator( ) );
        }
        static void Bind( const ODBC::Statement& statement, SQLUSMALLINT fieldId, Currency& value )
        {
            statement.BindInt64Column( fieldId, reinterpret_cast< Int64* >( &value ), nullptr );
        }
        static void Bind( const ODBC::Statement& statement, SQLUSMALLINT fieldId, DBCurrency& value )
        {
            statement.BindInt64Column( fieldId, reinterpret_cast< Int64* >( value.data() ), value.Indicator( ) );
        }
        static void Bind( const ODBC::Statement& statement, SQLUSMALLINT fieldId, DateTime& value )
        {
            statement.BindInt64Column( fieldId, reinterpret_cast< Int64* >( &value ), nullptr );
        }
        static void Bind( const ODBC::Statement& statement, SQLUSMALLINT fieldId, DBDateTime& value )
        {
            statement.BindInt64Column( fieldId, reinterpret_cast< Int64* >( value.data() ), value.Indicator( ) );
        }
        static void Bind( const ODBC::Statement& statement, SQLUSMALLINT fieldId, TimeSpan& value )
        {
            statement.BindInt64Column( fieldId, reinterpret_cast< Int64* >( &value ), nullptr );
        }
        static void Bind( const ODBC::Statement& statement, SQLUSMALLINT fieldId, DBTimeSpan& value )
        {
            statement.BindInt64Column( fieldId, reinterpret_cast< Int64* >( value.data() ), value.Indicator( ) );
        }
        static void Bind( const ODBC::Statement& statement, SQLUSMALLINT fieldId, Guid& value )
        {
            statement.BindGuidColumn( fieldId, &value, nullptr );
        }
        static void Bind( const ODBC::Statement& statement, SQLUSMALLINT fieldId, DBGuid& value )
        {
            statement.BindGuidColumn( fieldId, value.data( ), value.Indicator( ) );
        }
        template<typename T>
            requires std::is_enum_v<T>
        static void Bind( const ODBC::Statement & statement, SQLUSMALLINT fieldId, T& value )
        {
            using IntegerType = std::underlying_type_t<T>;
            statement.BindColumn( fieldId, NativeType::Int32, &value, sizeof( IntegerType ), nullptr );
        }
        template<typename T>
            requires std::is_enum_v<T>
        static void Bind( const ODBC::Statement & statement, SQLUSMALLINT fieldId, DBEnum<T>& value )
        {
            using IntegerType = std::underlying_type_t<T>;
            statement.BindColumn( fieldId, NativeType::Int32, value.data( ), sizeof( IntegerType ), value.Indicator( ) );
        }
        template<size_t N>
        static void Bind( const ODBC::Statement& statement, SQLUSMALLINT fieldId, FixedDBWideString<N>& value )
        {
            statement.BindColumn( fieldId, NativeType::WideChar, value.data( ), static_cast< SQLLEN >( N * sizeof( wchar_t ) ), value.Indicator( ) );
        }
        template<size_t N>
        static void Bind( const ODBC::Statement& statement, SQLUSMALLINT fieldId, FixedDBBinary<N>& value )
        {
            statement.BindColumn( fieldId, NativeType::Binary, value.data( ), static_cast< SQLLEN >( N ), value.Indicator( ) );
        }
        template<IO::StreamWriter StreamT, typename T>
            requires std::is_same_v<Currency, T> || std::is_same_v<DateTime, T> || std::is_same_v<TimeSpan, T> || std::is_same_v<Guid, T> || std::is_floating_point_v<T> || std::is_integral_v<T> || std::is_enum_v<T>
        void WriteColumnValue( IO::BinaryWriter<StreamT>& destination, T value )
        {
            destination.Write( value );
        }
        template<IO::StreamWriter StreamT, typename T>
            requires std::is_same_v<Currency, T> || std::is_same_v<DateTime, T> || std::is_same_v<TimeSpan, T> || std::is_same_v<Guid, T> || std::is_floating_point_v<T> || std::is_integral_v<T> || std::is_enum_v<T>
        void WriteColumnValue( IO::BinaryWriter<StreamT>& destination, T value, SQLLEN nullIndicator )
        {
            if ( nullIndicator != SQL_NULL_DATA )
            {
                destination.Write( true );
                destination.Write( value );
            }
            else
            {
                destination.Write( false );
            }
        }
        template<IO::StreamWriter StreamT, typename T, size_t N>
        void WriteNullableColumnValue( IO::BinaryWriter<StreamT>& destination, const std::array<T, N>& value, SQLLEN lengthOrNullIndicator )
        {
            if ( lengthOrNullIndicator != SQL_NULL_DATA )
            {
                destination.Write( true );

                if constexpr ( std::is_same_v<T, Byte> )
                {
                    auto size = static_cast< size_t >( lengthOrNullIndicator ) * sizeof( wchar_t );
                    destination.Write7BitEncoded( size );
                    destination.Write( value.data( ), size );
                }
                else
                {
                    auto size = static_cast< size_t >( lengthOrNullIndicator );
                    destination.WriteSize( size );
                    destination.Write( value.data( ), size );
                }

            }
            else
            {
                destination.Write( false );
            }
        }
        template<IO::StreamWriter StreamT, typename T, size_t N>
        void WriteColumnValue( IO::BinaryWriter<StreamT>& destination, const std::array<T, N>& value, SQLLEN length )
        {
            if constexpr ( std::is_same_v<T, wchar_t> )
            {
                auto size = static_cast< size_t >( length ) * sizeof( wchar_t );
                destination.Write7BitEncoded( size );
                destination.Write( value.data( ), size );
            }
            else
            {
                auto size = static_cast< size_t >( length );
                destination.WriteSize( size );
                destination.Write( value.data( ), size );
            }
        }
        template<IO::StreamWriter StreamT, typename T>
            requires std::is_same_v<WideString, T> || std::is_same_v<std::vector<Byte>, T> || std::is_same_v<std::optional<WideString>, T> || std::is_same_v<std::optional<std::vector<Byte>>, T>
        void WriteColumnValue( IO::BinaryWriter<StreamT>& destination, const T& value )
        {
            destination.Write( value );
        }
    };

    template<typename T>
        requires std::is_base_of_v<BaseColumnData, T>
    class SimpleColumnDataReader : public ODBC::DataReader, public T
    {
    public:
        using Base = ODBC::DataReader;
        SimpleColumnDataReader( const ODBC::Statement* statement )
            : Base( statement )
        {
            T::BindColumns( *statement );
        }
    protected:
        virtual void AfterFetch( ) override
        {
            T::ReadUnboundData( Base::Statement( ) );
        }
    };

    class AircraftTypeColumnData : public BaseColumnData
    {
        Guid id_;
        Int64 rowVersion_ = 0;
        FixedDBWideString<127> name_;
    public:
        using Base = BaseColumnData;

        static constexpr std::wstring_view FieldNames = L"[Id],[RowVersion],[Name]";
        static constexpr std::wstring_view ViewName = L"AircraftTypeView";

        static constexpr SQLUSMALLINT ID_FIELD_ID = 1;
        static constexpr SQLUSMALLINT ROWVERSION_FIELD_ID = 2;
        static constexpr SQLUSMALLINT NAME_FIELD_ID = 3;

        AircraftTypeColumnData( ) = default;

        virtual Kind GetKind() const override
        {
            return Kind::AircraftType;
        }

        const Guid& Id( ) const
        {
            return id_;
        }
        void SetId( const Guid& id )
        {
            id_ = id;
        }
        Int64 RowVersion( ) const
        {
            return rowVersion_;
        }
        void SetRowVersion( const Int64& rowVersion )
        {
            rowVersion_ = rowVersion;
        }
        const FixedDBWideString<127>& Name( ) const
        {
            return name_;
        }
        void SetName( const WideString& name )
        {
            name_ = name;
        }
        void BindColumns( const ODBC::Statement& statement )
        {
            Bind(statement, ID_FIELD_ID, id_);
            Bind(statement, ROWVERSION_FIELD_ID, rowVersion_);
            Bind(statement, NAME_FIELD_ID, name_);
        }

        template<IO::StreamWriter StreamT>
        void WriteColumns( IO::BinaryWriter<StreamT>& destination ) const
        {
            WriteColumnValue( destination, id_);
            WriteColumnValue( destination, rowVersion_);
            WriteColumnValue( destination, name_);
        }
    };

    using SimpleAircraftTypeDataReader = SimpleColumnDataReader<AircraftTypeColumnData>;

    class AisMessageColumnData : public BaseColumnData
    {
        Guid id_;
        Int64 rowVersion_ = 0;
        Guid aisTransceiver_;
        DateTime receivedTimestamp_;
        Int64 messageSequenceNumber_ = 0;
        Int32 repeat_ = 0;
        Guid mmsi_;
    public:
        using Base = BaseColumnData;

        static constexpr std::wstring_view FieldNames = L"[Id],[RowVersion],[AisTransceiver],[ReceivedTimestamp],[MessageSequenceNumber],[Repeat],[Mmsi]";
        static constexpr std::wstring_view ViewName = L"AisMessageView";

        static constexpr SQLUSMALLINT ID_FIELD_ID = 1;
        static constexpr SQLUSMALLINT ROWVERSION_FIELD_ID = 2;
        static constexpr SQLUSMALLINT AISTRANSCEIVER_FIELD_ID = 3;
        static constexpr SQLUSMALLINT RECEIVEDTIMESTAMP_FIELD_ID = 4;
        static constexpr SQLUSMALLINT MESSAGESEQUENCENUMBER_FIELD_ID = 5;
        static constexpr SQLUSMALLINT REPEAT_FIELD_ID = 6;
        static constexpr SQLUSMALLINT MMSI_FIELD_ID = 7;

        AisMessageColumnData( ) = default;

        virtual Kind GetKind() const override
        {
            return Kind::AisMessage;
        }

        const Guid& Id( ) const
        {
            return id_;
        }
        void SetId( const Guid& id )
        {
            id_ = id;
        }
        Int64 RowVersion( ) const
        {
            return rowVersion_;
        }
        void SetRowVersion( const Int64& rowVersion )
        {
            rowVersion_ = rowVersion;
        }
        const Guid& AisTransceiver( ) const
        {
            return aisTransceiver_;
        }
        void SetAisTransceiver( const Guid& aisTransceiver )
        {
            aisTransceiver_ = aisTransceiver;
        }
        const DateTime& ReceivedTimestamp( ) const
        {
            return receivedTimestamp_;
        }
        void SetReceivedTimestamp( const DateTime& receivedTimestamp )
        {
            receivedTimestamp_ = receivedTimestamp;
        }
        Int64 MessageSequenceNumber( ) const
        {
            return messageSequenceNumber_;
        }
        void SetMessageSequenceNumber( Int64 messageSequenceNumber )
        {
            messageSequenceNumber_ = messageSequenceNumber;
        }
        Int32 Repeat( ) const
        {
            return repeat_;
        }
        void SetRepeat( Int32 repeat )
        {
            repeat_ = repeat;
        }
        const Guid& Mmsi( ) const
        {
            return mmsi_;
        }
        void SetMmsi( const Guid& mmsi )
        {
            mmsi_ = mmsi;
        }
        void BindColumns( const ODBC::Statement& statement )
        {
            Bind(statement, ID_FIELD_ID, id_);
            Bind(statement, ROWVERSION_FIELD_ID, rowVersion_);
            Bind(statement, AISTRANSCEIVER_FIELD_ID, aisTransceiver_);
            Bind(statement, RECEIVEDTIMESTAMP_FIELD_ID, receivedTimestamp_);
            Bind(statement, MESSAGESEQUENCENUMBER_FIELD_ID, messageSequenceNumber_);
            Bind(statement, REPEAT_FIELD_ID, repeat_);
            Bind(statement, MMSI_FIELD_ID, mmsi_);
        }

        template<IO::StreamWriter StreamT>
        void WriteColumns( IO::BinaryWriter<StreamT>& destination ) const
        {
            WriteColumnValue( destination, id_);
            WriteColumnValue( destination, rowVersion_);
            WriteColumnValue( destination, aisTransceiver_);
            WriteColumnValue( destination, receivedTimestamp_);
            WriteColumnValue( destination, messageSequenceNumber_);
            WriteColumnValue( destination, repeat_);
            WriteColumnValue( destination, mmsi_);
        }
    };

    using SimpleAisMessageDataReader = SimpleColumnDataReader<AisMessageColumnData>;

    class AidToNavigationReportMessageColumnData : public AisMessageColumnData
    {
        Data::NavigationalAidType navigationalAidType_ = Data::NavigationalAidType::NotSpecified;
        FixedDBWideString<100> name_;
        Data::PositionAccuracy positionAccuracy_ = Data::PositionAccuracy::Low;
        double longitude_ = 0.0;
        double latitude_ = 0.0;
        Int32 dimensionToBow_ = 0;
        Int32 dimensionToStern_ = 0;
        Int32 dimensionToPort_ = 0;
        Int32 dimensionToStarboard_ = 0;
        Data::PositionFixType positionFixType_ = Data::PositionFixType::Undefined1;
        Int32 timestamp_ = 0;
        bool offPosition_ = false;
        Int32 regionalReserved_ = 0;
        Data::Raim raim_ = Data::Raim::NotInUse;
        bool virtualAid_ = false;
        bool assigned_ = false;
        Int32 spare_ = 0;
        FixedDBWideString<100> nameExtension_;
    public:
        using Base = AisMessageColumnData;

        static constexpr std::wstring_view FieldNames = L"[Id],[RowVersion],[AisTransceiver],[ReceivedTimestamp],[MessageSequenceNumber],[Repeat],[Mmsi],[NavigationalAidType],[Name],[PositionAccuracy],[Longitude],[Latitude],[DimensionToBow],[DimensionToStern],[DimensionToPort],[DimensionToStarboard],[PositionFixType],[Timestamp],[OffPosition],[RegionalReserved],[Raim],[VirtualAid],[Assigned],[Spare],[NameExtension]";
        static constexpr std::wstring_view ViewName = L"AidToNavigationReportMessageView";

        static constexpr SQLUSMALLINT NAVIGATIONALAIDTYPE_FIELD_ID = 8;
        static constexpr SQLUSMALLINT NAME_FIELD_ID = 9;
        static constexpr SQLUSMALLINT POSITIONACCURACY_FIELD_ID = 10;
        static constexpr SQLUSMALLINT LONGITUDE_FIELD_ID = 11;
        static constexpr SQLUSMALLINT LATITUDE_FIELD_ID = 12;
        static constexpr SQLUSMALLINT DIMENSIONTOBOW_FIELD_ID = 13;
        static constexpr SQLUSMALLINT DIMENSIONTOSTERN_FIELD_ID = 14;
        static constexpr SQLUSMALLINT DIMENSIONTOPORT_FIELD_ID = 15;
        static constexpr SQLUSMALLINT DIMENSIONTOSTARBOARD_FIELD_ID = 16;
        static constexpr SQLUSMALLINT POSITIONFIXTYPE_FIELD_ID = 17;
        static constexpr SQLUSMALLINT TIMESTAMP_FIELD_ID = 18;
        static constexpr SQLUSMALLINT OFFPOSITION_FIELD_ID = 19;
        static constexpr SQLUSMALLINT REGIONALRESERVED_FIELD_ID = 20;
        static constexpr SQLUSMALLINT RAIM_FIELD_ID = 21;
        static constexpr SQLUSMALLINT VIRTUALAID_FIELD_ID = 22;
        static constexpr SQLUSMALLINT ASSIGNED_FIELD_ID = 23;
        static constexpr SQLUSMALLINT SPARE_FIELD_ID = 24;
        static constexpr SQLUSMALLINT NAMEEXTENSION_FIELD_ID = 25;

        AidToNavigationReportMessageColumnData( ) = default;

        virtual Kind GetKind() const override
        {
            return Kind::AidToNavigationReportMessage;
        }

        Data::NavigationalAidType NavigationalAidType( ) const
        {
            return navigationalAidType_;
        }
        void SetNavigationalAidType( Data::NavigationalAidType navigationalAidType )
        {
            navigationalAidType_ = navigationalAidType;
        }
        const FixedDBWideString<100>& Name( ) const
        {
            return name_;
        }
        void SetName( const WideString& name )
        {
            name_ = name;
        }
        Data::PositionAccuracy PositionAccuracy( ) const
        {
            return positionAccuracy_;
        }
        void SetPositionAccuracy( Data::PositionAccuracy positionAccuracy )
        {
            positionAccuracy_ = positionAccuracy;
        }
        double Longitude( ) const
        {
            return longitude_;
        }
        void SetLongitude( double longitude )
        {
            longitude_ = longitude;
        }
        double Latitude( ) const
        {
            return latitude_;
        }
        void SetLatitude( double latitude )
        {
            latitude_ = latitude;
        }
        Int32 DimensionToBow( ) const
        {
            return dimensionToBow_;
        }
        void SetDimensionToBow( Int32 dimensionToBow )
        {
            dimensionToBow_ = dimensionToBow;
        }
        Int32 DimensionToStern( ) const
        {
            return dimensionToStern_;
        }
        void SetDimensionToStern( Int32 dimensionToStern )
        {
            dimensionToStern_ = dimensionToStern;
        }
        Int32 DimensionToPort( ) const
        {
            return dimensionToPort_;
        }
        void SetDimensionToPort( Int32 dimensionToPort )
        {
            dimensionToPort_ = dimensionToPort;
        }
        Int32 DimensionToStarboard( ) const
        {
            return dimensionToStarboard_;
        }
        void SetDimensionToStarboard( Int32 dimensionToStarboard )
        {
            dimensionToStarboard_ = dimensionToStarboard;
        }
        Data::PositionFixType PositionFixType( ) const
        {
            return positionFixType_;
        }
        void SetPositionFixType( Data::PositionFixType positionFixType )
        {
            positionFixType_ = positionFixType;
        }
        Int32 Timestamp( ) const
        {
            return timestamp_;
        }
        void SetTimestamp( Int32 timestamp )
        {
            timestamp_ = timestamp;
        }
        bool OffPosition( ) const
        {
            return offPosition_;
        }
        void SetOffPosition( bool offPosition )
        {
            offPosition_ = offPosition;
        }
        Int32 RegionalReserved( ) const
        {
            return regionalReserved_;
        }
        void SetRegionalReserved( Int32 regionalReserved )
        {
            regionalReserved_ = regionalReserved;
        }
        Data::Raim Raim( ) const
        {
            return raim_;
        }
        void SetRaim( Data::Raim raim )
        {
            raim_ = raim;
        }
        bool VirtualAid( ) const
        {
            return virtualAid_;
        }
        void SetVirtualAid( bool virtualAid )
        {
            virtualAid_ = virtualAid;
        }
        bool Assigned( ) const
        {
            return assigned_;
        }
        void SetAssigned( bool assigned )
        {
            assigned_ = assigned;
        }
        Int32 Spare( ) const
        {
            return spare_;
        }
        void SetSpare( Int32 spare )
        {
            spare_ = spare;
        }
        const FixedDBWideString<100>& NameExtension( ) const
        {
            return nameExtension_;
        }
        void SetNameExtension( const WideString& nameExtension )
        {
            nameExtension_ = nameExtension;
        }
        void BindColumns( const ODBC::Statement& statement )
        {
            Base::BindColumns( statement );

            Bind(statement, NAVIGATIONALAIDTYPE_FIELD_ID, navigationalAidType_);
            Bind(statement, NAME_FIELD_ID, name_);
            Bind(statement, POSITIONACCURACY_FIELD_ID, positionAccuracy_);
            Bind(statement, LONGITUDE_FIELD_ID, longitude_);
            Bind(statement, LATITUDE_FIELD_ID, latitude_);
            Bind(statement, DIMENSIONTOBOW_FIELD_ID, dimensionToBow_);
            Bind(statement, DIMENSIONTOSTERN_FIELD_ID, dimensionToStern_);
            Bind(statement, DIMENSIONTOPORT_FIELD_ID, dimensionToPort_);
            Bind(statement, DIMENSIONTOSTARBOARD_FIELD_ID, dimensionToStarboard_);
            Bind(statement, POSITIONFIXTYPE_FIELD_ID, positionFixType_);
            Bind(statement, TIMESTAMP_FIELD_ID, timestamp_);
            Bind(statement, OFFPOSITION_FIELD_ID, offPosition_);
            Bind(statement, REGIONALRESERVED_FIELD_ID, regionalReserved_);
            Bind(statement, RAIM_FIELD_ID, raim_);
            Bind(statement, VIRTUALAID_FIELD_ID, virtualAid_);
            Bind(statement, ASSIGNED_FIELD_ID, assigned_);
            Bind(statement, SPARE_FIELD_ID, spare_);
            Bind(statement, NAMEEXTENSION_FIELD_ID, nameExtension_);
        }

        template<IO::StreamWriter StreamT>
        void WriteColumns( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteColumns( destination );
            WriteColumnValue( destination, navigationalAidType_);
            WriteColumnValue( destination, name_);
            WriteColumnValue( destination, positionAccuracy_);
            WriteColumnValue( destination, longitude_);
            WriteColumnValue( destination, latitude_);
            WriteColumnValue( destination, dimensionToBow_);
            WriteColumnValue( destination, dimensionToStern_);
            WriteColumnValue( destination, dimensionToPort_);
            WriteColumnValue( destination, dimensionToStarboard_);
            WriteColumnValue( destination, positionFixType_);
            WriteColumnValue( destination, timestamp_);
            WriteColumnValue( destination, offPosition_);
            WriteColumnValue( destination, regionalReserved_);
            WriteColumnValue( destination, raim_);
            WriteColumnValue( destination, virtualAid_);
            WriteColumnValue( destination, assigned_);
            WriteColumnValue( destination, spare_);
            WriteColumnValue( destination, nameExtension_);
        }
    };

    using SimpleAidToNavigationReportMessageDataReader = SimpleColumnDataReader<AidToNavigationReportMessageColumnData>;

    class AisAddressedSafetyRelatedMessageColumnData : public AisMessageColumnData
    {
        Int32 sequenceNumber_ = 0;
        Guid destinationMmsi_;
        bool retransmitFlag_ = false;
        Int32 spare_ = 0;
        FixedDBWideString<100> text_;
    public:
        using Base = AisMessageColumnData;

        static constexpr std::wstring_view FieldNames = L"[Id],[RowVersion],[AisTransceiver],[ReceivedTimestamp],[MessageSequenceNumber],[Repeat],[Mmsi],[SequenceNumber],[DestinationMmsi],[RetransmitFlag],[Spare],[Text]";
        static constexpr std::wstring_view ViewName = L"AisAddressedSafetyRelatedMessageView";

        static constexpr SQLUSMALLINT SEQUENCENUMBER_FIELD_ID = 8;
        static constexpr SQLUSMALLINT DESTINATIONMMSI_FIELD_ID = 9;
        static constexpr SQLUSMALLINT RETRANSMITFLAG_FIELD_ID = 10;
        static constexpr SQLUSMALLINT SPARE_FIELD_ID = 11;
        static constexpr SQLUSMALLINT TEXT_FIELD_ID = 12;

        AisAddressedSafetyRelatedMessageColumnData( ) = default;

        virtual Kind GetKind() const override
        {
            return Kind::AisAddressedSafetyRelatedMessage;
        }

        Int32 SequenceNumber( ) const
        {
            return sequenceNumber_;
        }
        void SetSequenceNumber( Int32 sequenceNumber )
        {
            sequenceNumber_ = sequenceNumber;
        }
        const Guid& DestinationMmsi( ) const
        {
            return destinationMmsi_;
        }
        void SetDestinationMmsi( const Guid& destinationMmsi )
        {
            destinationMmsi_ = destinationMmsi;
        }
        bool RetransmitFlag( ) const
        {
            return retransmitFlag_;
        }
        void SetRetransmitFlag( bool retransmitFlag )
        {
            retransmitFlag_ = retransmitFlag;
        }
        Int32 Spare( ) const
        {
            return spare_;
        }
        void SetSpare( Int32 spare )
        {
            spare_ = spare;
        }
        const FixedDBWideString<100>& Text( ) const
        {
            return text_;
        }
        void SetText( const WideString& text )
        {
            text_ = text;
        }
        void BindColumns( const ODBC::Statement& statement )
        {
            Base::BindColumns( statement );

            Bind(statement, SEQUENCENUMBER_FIELD_ID, sequenceNumber_);
            Bind(statement, DESTINATIONMMSI_FIELD_ID, destinationMmsi_);
            Bind(statement, RETRANSMITFLAG_FIELD_ID, retransmitFlag_);
            Bind(statement, SPARE_FIELD_ID, spare_);
            Bind(statement, TEXT_FIELD_ID, text_);
        }

        template<IO::StreamWriter StreamT>
        void WriteColumns( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteColumns( destination );
            WriteColumnValue( destination, sequenceNumber_);
            WriteColumnValue( destination, destinationMmsi_);
            WriteColumnValue( destination, retransmitFlag_);
            WriteColumnValue( destination, spare_);
            WriteColumnValue( destination, text_);
        }
    };

    using SimpleAisAddressedSafetyRelatedMessageDataReader = SimpleColumnDataReader<AisAddressedSafetyRelatedMessageColumnData>;

    class AisBaseStationReportMessageColumnData : public AisMessageColumnData
    {
        DateTime timestamp_;
        Data::PositionAccuracy positionAccuracy_ = Data::PositionAccuracy::Low;
        double longitude_ = 0.0;
        double latitude_ = 0.0;
        Data::PositionFixType positionFixType_ = Data::PositionFixType::Undefined1;
        Int32 spare_ = 0;
        Data::Raim raim_ = Data::Raim::NotInUse;
        Int32 radioStatus_ = 0;
    public:
        using Base = AisMessageColumnData;

        static constexpr std::wstring_view FieldNames = L"[Id],[RowVersion],[AisTransceiver],[ReceivedTimestamp],[MessageSequenceNumber],[Repeat],[Mmsi],[Timestamp],[PositionAccuracy],[Longitude],[Latitude],[PositionFixType],[Spare],[Raim],[RadioStatus]";
        static constexpr std::wstring_view ViewName = L"AisBaseStationReportMessageView";

        static constexpr SQLUSMALLINT TIMESTAMP_FIELD_ID = 8;
        static constexpr SQLUSMALLINT POSITIONACCURACY_FIELD_ID = 9;
        static constexpr SQLUSMALLINT LONGITUDE_FIELD_ID = 10;
        static constexpr SQLUSMALLINT LATITUDE_FIELD_ID = 11;
        static constexpr SQLUSMALLINT POSITIONFIXTYPE_FIELD_ID = 12;
        static constexpr SQLUSMALLINT SPARE_FIELD_ID = 13;
        static constexpr SQLUSMALLINT RAIM_FIELD_ID = 14;
        static constexpr SQLUSMALLINT RADIOSTATUS_FIELD_ID = 15;

        AisBaseStationReportMessageColumnData( ) = default;

        virtual Kind GetKind() const override
        {
            return Kind::AisBaseStationReportMessage;
        }

        const DateTime& Timestamp( ) const
        {
            return timestamp_;
        }
        void SetTimestamp( const DateTime& timestamp )
        {
            timestamp_ = timestamp;
        }
        Data::PositionAccuracy PositionAccuracy( ) const
        {
            return positionAccuracy_;
        }
        void SetPositionAccuracy( Data::PositionAccuracy positionAccuracy )
        {
            positionAccuracy_ = positionAccuracy;
        }
        double Longitude( ) const
        {
            return longitude_;
        }
        void SetLongitude( double longitude )
        {
            longitude_ = longitude;
        }
        double Latitude( ) const
        {
            return latitude_;
        }
        void SetLatitude( double latitude )
        {
            latitude_ = latitude;
        }
        Data::PositionFixType PositionFixType( ) const
        {
            return positionFixType_;
        }
        void SetPositionFixType( Data::PositionFixType positionFixType )
        {
            positionFixType_ = positionFixType;
        }
        Int32 Spare( ) const
        {
            return spare_;
        }
        void SetSpare( Int32 spare )
        {
            spare_ = spare;
        }
        Data::Raim Raim( ) const
        {
            return raim_;
        }
        void SetRaim( Data::Raim raim )
        {
            raim_ = raim;
        }
        Int32 RadioStatus( ) const
        {
            return radioStatus_;
        }
        void SetRadioStatus( Int32 radioStatus )
        {
            radioStatus_ = radioStatus;
        }
        void BindColumns( const ODBC::Statement& statement )
        {
            Base::BindColumns( statement );

            Bind(statement, TIMESTAMP_FIELD_ID, timestamp_);
            Bind(statement, POSITIONACCURACY_FIELD_ID, positionAccuracy_);
            Bind(statement, LONGITUDE_FIELD_ID, longitude_);
            Bind(statement, LATITUDE_FIELD_ID, latitude_);
            Bind(statement, POSITIONFIXTYPE_FIELD_ID, positionFixType_);
            Bind(statement, SPARE_FIELD_ID, spare_);
            Bind(statement, RAIM_FIELD_ID, raim_);
            Bind(statement, RADIOSTATUS_FIELD_ID, radioStatus_);
        }

        template<IO::StreamWriter StreamT>
        void WriteColumns( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteColumns( destination );
            WriteColumnValue( destination, timestamp_);
            WriteColumnValue( destination, positionAccuracy_);
            WriteColumnValue( destination, longitude_);
            WriteColumnValue( destination, latitude_);
            WriteColumnValue( destination, positionFixType_);
            WriteColumnValue( destination, spare_);
            WriteColumnValue( destination, raim_);
            WriteColumnValue( destination, radioStatus_);
        }
    };

    using SimpleAisBaseStationReportMessageDataReader = SimpleColumnDataReader<AisBaseStationReportMessageColumnData>;

    class AisBinaryAcknowledgeMessageColumnData : public AisMessageColumnData
    {
        Int32 spare_ = 0;
        Int32 sequenceNumber1_ = 0;
        Guid mmsi1_;
        Int32 sequenceNumber2_ = 0;
        Guid mmsi2_;
        Int32 sequenceNumber3_ = 0;
        Guid mmsi3_;
        Int32 sequenceNumber4_ = 0;
        Guid mmsi4_;
    public:
        using Base = AisMessageColumnData;

        static constexpr std::wstring_view FieldNames = L"[Id],[RowVersion],[AisTransceiver],[ReceivedTimestamp],[MessageSequenceNumber],[Repeat],[Mmsi],[Spare],[SequenceNumber1],[Mmsi1],[SequenceNumber2],[Mmsi2],[SequenceNumber3],[Mmsi3],[SequenceNumber4],[Mmsi4]";
        static constexpr std::wstring_view ViewName = L"AisBinaryAcknowledgeMessageView";

        static constexpr SQLUSMALLINT SPARE_FIELD_ID = 8;
        static constexpr SQLUSMALLINT SEQUENCENUMBER1_FIELD_ID = 9;
        static constexpr SQLUSMALLINT MMSI1_FIELD_ID = 10;
        static constexpr SQLUSMALLINT SEQUENCENUMBER2_FIELD_ID = 11;
        static constexpr SQLUSMALLINT MMSI2_FIELD_ID = 12;
        static constexpr SQLUSMALLINT SEQUENCENUMBER3_FIELD_ID = 13;
        static constexpr SQLUSMALLINT MMSI3_FIELD_ID = 14;
        static constexpr SQLUSMALLINT SEQUENCENUMBER4_FIELD_ID = 15;
        static constexpr SQLUSMALLINT MMSI4_FIELD_ID = 16;

        AisBinaryAcknowledgeMessageColumnData( ) = default;

        virtual Kind GetKind() const override
        {
            return Kind::AisBinaryAcknowledgeMessage;
        }

        Int32 Spare( ) const
        {
            return spare_;
        }
        void SetSpare( Int32 spare )
        {
            spare_ = spare;
        }
        Int32 SequenceNumber1( ) const
        {
            return sequenceNumber1_;
        }
        void SetSequenceNumber1( Int32 sequenceNumber1 )
        {
            sequenceNumber1_ = sequenceNumber1;
        }
        const Guid& Mmsi1( ) const
        {
            return mmsi1_;
        }
        void SetMmsi1( const Guid& mmsi1 )
        {
            mmsi1_ = mmsi1;
        }
        Int32 SequenceNumber2( ) const
        {
            return sequenceNumber2_;
        }
        void SetSequenceNumber2( Int32 sequenceNumber2 )
        {
            sequenceNumber2_ = sequenceNumber2;
        }
        const Guid& Mmsi2( ) const
        {
            return mmsi2_;
        }
        void SetMmsi2( const Guid& mmsi2 )
        {
            mmsi2_ = mmsi2;
        }
        Int32 SequenceNumber3( ) const
        {
            return sequenceNumber3_;
        }
        void SetSequenceNumber3( Int32 sequenceNumber3 )
        {
            sequenceNumber3_ = sequenceNumber3;
        }
        const Guid& Mmsi3( ) const
        {
            return mmsi3_;
        }
        void SetMmsi3( const Guid& mmsi3 )
        {
            mmsi3_ = mmsi3;
        }
        Int32 SequenceNumber4( ) const
        {
            return sequenceNumber4_;
        }
        void SetSequenceNumber4( Int32 sequenceNumber4 )
        {
            sequenceNumber4_ = sequenceNumber4;
        }
        const Guid& Mmsi4( ) const
        {
            return mmsi4_;
        }
        void SetMmsi4( const Guid& mmsi4 )
        {
            mmsi4_ = mmsi4;
        }
        void BindColumns( const ODBC::Statement& statement )
        {
            Base::BindColumns( statement );

            Bind(statement, SPARE_FIELD_ID, spare_);
            Bind(statement, SEQUENCENUMBER1_FIELD_ID, sequenceNumber1_);
            Bind(statement, MMSI1_FIELD_ID, mmsi1_);
            Bind(statement, SEQUENCENUMBER2_FIELD_ID, sequenceNumber2_);
            Bind(statement, MMSI2_FIELD_ID, mmsi2_);
            Bind(statement, SEQUENCENUMBER3_FIELD_ID, sequenceNumber3_);
            Bind(statement, MMSI3_FIELD_ID, mmsi3_);
            Bind(statement, SEQUENCENUMBER4_FIELD_ID, sequenceNumber4_);
            Bind(statement, MMSI4_FIELD_ID, mmsi4_);
        }

        template<IO::StreamWriter StreamT>
        void WriteColumns( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteColumns( destination );
            WriteColumnValue( destination, spare_);
            WriteColumnValue( destination, sequenceNumber1_);
            WriteColumnValue( destination, mmsi1_);
            WriteColumnValue( destination, sequenceNumber2_);
            WriteColumnValue( destination, mmsi2_);
            WriteColumnValue( destination, sequenceNumber3_);
            WriteColumnValue( destination, mmsi3_);
            WriteColumnValue( destination, sequenceNumber4_);
            WriteColumnValue( destination, mmsi4_);
        }
    };

    using SimpleAisBinaryAcknowledgeMessageDataReader = SimpleColumnDataReader<AisBinaryAcknowledgeMessageColumnData>;

    class AisBinaryAddressedMessageColumnData : public AisMessageColumnData
    {
        Int32 sequenceNumber_ = 0;
        Guid destinationMmsi_;
        bool retransmitFlag_ = false;
        Int32 spare_ = 0;
        Int32 designatedAreaCode_ = 0;
        Int32 functionalId_ = 0;
        WideString data_;
        SQLLEN dataLength_ = SQL_NULL_DATA;
    public:
        using Base = AisMessageColumnData;

        static constexpr std::wstring_view FieldNames = L"[Id],[RowVersion],[AisTransceiver],[ReceivedTimestamp],[MessageSequenceNumber],[Repeat],[Mmsi],[SequenceNumber],[DestinationMmsi],[RetransmitFlag],[Spare],[DesignatedAreaCode],[FunctionalId],[Data]";
        static constexpr std::wstring_view ViewName = L"AisBinaryAddressedMessageView";

        static constexpr SQLUSMALLINT SEQUENCENUMBER_FIELD_ID = 8;
        static constexpr SQLUSMALLINT DESTINATIONMMSI_FIELD_ID = 9;
        static constexpr SQLUSMALLINT RETRANSMITFLAG_FIELD_ID = 10;
        static constexpr SQLUSMALLINT SPARE_FIELD_ID = 11;
        static constexpr SQLUSMALLINT DESIGNATEDAREACODE_FIELD_ID = 12;
        static constexpr SQLUSMALLINT FUNCTIONALID_FIELD_ID = 13;
        static constexpr SQLUSMALLINT DATA_FIELD_ID = 14;

        AisBinaryAddressedMessageColumnData( ) = default;

        virtual Kind GetKind() const override
        {
            return Kind::AisBinaryAddressedMessage;
        }

        Int32 SequenceNumber( ) const
        {
            return sequenceNumber_;
        }
        void SetSequenceNumber( Int32 sequenceNumber )
        {
            sequenceNumber_ = sequenceNumber;
        }
        const Guid& DestinationMmsi( ) const
        {
            return destinationMmsi_;
        }
        void SetDestinationMmsi( const Guid& destinationMmsi )
        {
            destinationMmsi_ = destinationMmsi;
        }
        bool RetransmitFlag( ) const
        {
            return retransmitFlag_;
        }
        void SetRetransmitFlag( bool retransmitFlag )
        {
            retransmitFlag_ = retransmitFlag;
        }
        Int32 Spare( ) const
        {
            return spare_;
        }
        void SetSpare( Int32 spare )
        {
            spare_ = spare;
        }
        Int32 DesignatedAreaCode( ) const
        {
            return designatedAreaCode_;
        }
        void SetDesignatedAreaCode( Int32 designatedAreaCode )
        {
            designatedAreaCode_ = designatedAreaCode;
        }
        Int32 FunctionalId( ) const
        {
            return functionalId_;
        }
        void SetFunctionalId( Int32 functionalId )
        {
            functionalId_ = functionalId;
        }
        const WideString& Data( ) const
        {
            return data_;
        }
        void SetData( const WideString& data )
        {
            data_ = data;
        }
        void BindColumns( const ODBC::Statement& statement )
        {
            Base::BindColumns( statement );

            Bind(statement, SEQUENCENUMBER_FIELD_ID, sequenceNumber_);
            Bind(statement, DESTINATIONMMSI_FIELD_ID, destinationMmsi_);
            Bind(statement, RETRANSMITFLAG_FIELD_ID, retransmitFlag_);
            Bind(statement, SPARE_FIELD_ID, spare_);
            Bind(statement, DESIGNATEDAREACODE_FIELD_ID, designatedAreaCode_);
            Bind(statement, FUNCTIONALID_FIELD_ID, functionalId_);
        }

        void ReadUnboundData( const ODBC::Statement& statement )
        {
            Base::ReadUnboundData( statement );

            data_ = statement.GetWideString(DATA_FIELD_ID);
        }
        template<IO::StreamWriter StreamT>
        void WriteColumns( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteColumns( destination );
            WriteColumnValue( destination, sequenceNumber_);
            WriteColumnValue( destination, destinationMmsi_);
            WriteColumnValue( destination, retransmitFlag_);
            WriteColumnValue( destination, spare_);
            WriteColumnValue( destination, designatedAreaCode_);
            WriteColumnValue( destination, functionalId_);
            WriteColumnValue( destination, data_);
        }
    };

    using SimpleAisBinaryAddressedMessageDataReader = SimpleColumnDataReader<AisBinaryAddressedMessageColumnData>;

    class AisBinaryBroadcastMessageColumnData : public AisMessageColumnData
    {
        Int32 spare_ = 0;
        Int32 designatedAreaCode_ = 0;
        Int32 functionalId_ = 0;
        WideString data_;
        SQLLEN dataLength_ = SQL_NULL_DATA;
    public:
        using Base = AisMessageColumnData;

        static constexpr std::wstring_view FieldNames = L"[Id],[RowVersion],[AisTransceiver],[ReceivedTimestamp],[MessageSequenceNumber],[Repeat],[Mmsi],[Spare],[DesignatedAreaCode],[FunctionalId],[Data]";
        static constexpr std::wstring_view ViewName = L"AisBinaryBroadcastMessageView";

        static constexpr SQLUSMALLINT SPARE_FIELD_ID = 8;
        static constexpr SQLUSMALLINT DESIGNATEDAREACODE_FIELD_ID = 9;
        static constexpr SQLUSMALLINT FUNCTIONALID_FIELD_ID = 10;
        static constexpr SQLUSMALLINT DATA_FIELD_ID = 11;

        AisBinaryBroadcastMessageColumnData( ) = default;

        virtual Kind GetKind() const override
        {
            return Kind::AisBinaryBroadcastMessage;
        }

        Int32 Spare( ) const
        {
            return spare_;
        }
        void SetSpare( Int32 spare )
        {
            spare_ = spare;
        }
        Int32 DesignatedAreaCode( ) const
        {
            return designatedAreaCode_;
        }
        void SetDesignatedAreaCode( Int32 designatedAreaCode )
        {
            designatedAreaCode_ = designatedAreaCode;
        }
        Int32 FunctionalId( ) const
        {
            return functionalId_;
        }
        void SetFunctionalId( Int32 functionalId )
        {
            functionalId_ = functionalId;
        }
        const WideString& Data( ) const
        {
            return data_;
        }
        void SetData( const WideString& data )
        {
            data_ = data;
        }
        void BindColumns( const ODBC::Statement& statement )
        {
            Base::BindColumns( statement );

            Bind(statement, SPARE_FIELD_ID, spare_);
            Bind(statement, DESIGNATEDAREACODE_FIELD_ID, designatedAreaCode_);
            Bind(statement, FUNCTIONALID_FIELD_ID, functionalId_);
        }

        void ReadUnboundData( const ODBC::Statement& statement )
        {
            Base::ReadUnboundData( statement );

            data_ = statement.GetWideString(DATA_FIELD_ID);
        }
        template<IO::StreamWriter StreamT>
        void WriteColumns( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteColumns( destination );
            WriteColumnValue( destination, spare_);
            WriteColumnValue( destination, designatedAreaCode_);
            WriteColumnValue( destination, functionalId_);
            WriteColumnValue( destination, data_);
        }
    };

    using SimpleAisBinaryBroadcastMessageDataReader = SimpleColumnDataReader<AisBinaryBroadcastMessageColumnData>;

    class AisDataLinkManagementMessageColumnData : public AisMessageColumnData
    {
        Int32 spare_ = 0;
        Int32 offset1_ = 0;
        Int32 reservedSlots1_ = 0;
        Int32 timeout1_ = 0;
        Int32 increment1_ = 0;
        Int32 offset2_ = 0;
        Int32 reservedSlots2_ = 0;
        Int32 timeout2_ = 0;
        Int32 increment2_ = 0;
        Int32 offset3_ = 0;
        Int32 reservedSlots3_ = 0;
        Int32 timeout3_ = 0;
        Int32 increment3_ = 0;
        Int32 offset4_ = 0;
        Int32 reservedSlots4_ = 0;
        Int32 timeout4_ = 0;
        Int32 increment4_ = 0;
    public:
        using Base = AisMessageColumnData;

        static constexpr std::wstring_view FieldNames = L"[Id],[RowVersion],[AisTransceiver],[ReceivedTimestamp],[MessageSequenceNumber],[Repeat],[Mmsi],[Spare],[Offset1],[ReservedSlots1],[Timeout1],[Increment1],[Offset2],[ReservedSlots2],[Timeout2],[Increment2],[Offset3],[ReservedSlots3],[Timeout3],[Increment3],[Offset4],[ReservedSlots4],[Timeout4],[Increment4]";
        static constexpr std::wstring_view ViewName = L"AisDataLinkManagementMessageView";

        static constexpr SQLUSMALLINT SPARE_FIELD_ID = 8;
        static constexpr SQLUSMALLINT OFFSET1_FIELD_ID = 9;
        static constexpr SQLUSMALLINT RESERVEDSLOTS1_FIELD_ID = 10;
        static constexpr SQLUSMALLINT TIMEOUT1_FIELD_ID = 11;
        static constexpr SQLUSMALLINT INCREMENT1_FIELD_ID = 12;
        static constexpr SQLUSMALLINT OFFSET2_FIELD_ID = 13;
        static constexpr SQLUSMALLINT RESERVEDSLOTS2_FIELD_ID = 14;
        static constexpr SQLUSMALLINT TIMEOUT2_FIELD_ID = 15;
        static constexpr SQLUSMALLINT INCREMENT2_FIELD_ID = 16;
        static constexpr SQLUSMALLINT OFFSET3_FIELD_ID = 17;
        static constexpr SQLUSMALLINT RESERVEDSLOTS3_FIELD_ID = 18;
        static constexpr SQLUSMALLINT TIMEOUT3_FIELD_ID = 19;
        static constexpr SQLUSMALLINT INCREMENT3_FIELD_ID = 20;
        static constexpr SQLUSMALLINT OFFSET4_FIELD_ID = 21;
        static constexpr SQLUSMALLINT RESERVEDSLOTS4_FIELD_ID = 22;
        static constexpr SQLUSMALLINT TIMEOUT4_FIELD_ID = 23;
        static constexpr SQLUSMALLINT INCREMENT4_FIELD_ID = 24;

        AisDataLinkManagementMessageColumnData( ) = default;

        virtual Kind GetKind() const override
        {
            return Kind::AisDataLinkManagementMessage;
        }

        Int32 Spare( ) const
        {
            return spare_;
        }
        void SetSpare( Int32 spare )
        {
            spare_ = spare;
        }
        Int32 Offset1( ) const
        {
            return offset1_;
        }
        void SetOffset1( Int32 offset1 )
        {
            offset1_ = offset1;
        }
        Int32 ReservedSlots1( ) const
        {
            return reservedSlots1_;
        }
        void SetReservedSlots1( Int32 reservedSlots1 )
        {
            reservedSlots1_ = reservedSlots1;
        }
        Int32 Timeout1( ) const
        {
            return timeout1_;
        }
        void SetTimeout1( Int32 timeout1 )
        {
            timeout1_ = timeout1;
        }
        Int32 Increment1( ) const
        {
            return increment1_;
        }
        void SetIncrement1( Int32 increment1 )
        {
            increment1_ = increment1;
        }
        Int32 Offset2( ) const
        {
            return offset2_;
        }
        void SetOffset2( Int32 offset2 )
        {
            offset2_ = offset2;
        }
        Int32 ReservedSlots2( ) const
        {
            return reservedSlots2_;
        }
        void SetReservedSlots2( Int32 reservedSlots2 )
        {
            reservedSlots2_ = reservedSlots2;
        }
        Int32 Timeout2( ) const
        {
            return timeout2_;
        }
        void SetTimeout2( Int32 timeout2 )
        {
            timeout2_ = timeout2;
        }
        Int32 Increment2( ) const
        {
            return increment2_;
        }
        void SetIncrement2( Int32 increment2 )
        {
            increment2_ = increment2;
        }
        Int32 Offset3( ) const
        {
            return offset3_;
        }
        void SetOffset3( Int32 offset3 )
        {
            offset3_ = offset3;
        }
        Int32 ReservedSlots3( ) const
        {
            return reservedSlots3_;
        }
        void SetReservedSlots3( Int32 reservedSlots3 )
        {
            reservedSlots3_ = reservedSlots3;
        }
        Int32 Timeout3( ) const
        {
            return timeout3_;
        }
        void SetTimeout3( Int32 timeout3 )
        {
            timeout3_ = timeout3;
        }
        Int32 Increment3( ) const
        {
            return increment3_;
        }
        void SetIncrement3( Int32 increment3 )
        {
            increment3_ = increment3;
        }
        Int32 Offset4( ) const
        {
            return offset4_;
        }
        void SetOffset4( Int32 offset4 )
        {
            offset4_ = offset4;
        }
        Int32 ReservedSlots4( ) const
        {
            return reservedSlots4_;
        }
        void SetReservedSlots4( Int32 reservedSlots4 )
        {
            reservedSlots4_ = reservedSlots4;
        }
        Int32 Timeout4( ) const
        {
            return timeout4_;
        }
        void SetTimeout4( Int32 timeout4 )
        {
            timeout4_ = timeout4;
        }
        Int32 Increment4( ) const
        {
            return increment4_;
        }
        void SetIncrement4( Int32 increment4 )
        {
            increment4_ = increment4;
        }
        void BindColumns( const ODBC::Statement& statement )
        {
            Base::BindColumns( statement );

            Bind(statement, SPARE_FIELD_ID, spare_);
            Bind(statement, OFFSET1_FIELD_ID, offset1_);
            Bind(statement, RESERVEDSLOTS1_FIELD_ID, reservedSlots1_);
            Bind(statement, TIMEOUT1_FIELD_ID, timeout1_);
            Bind(statement, INCREMENT1_FIELD_ID, increment1_);
            Bind(statement, OFFSET2_FIELD_ID, offset2_);
            Bind(statement, RESERVEDSLOTS2_FIELD_ID, reservedSlots2_);
            Bind(statement, TIMEOUT2_FIELD_ID, timeout2_);
            Bind(statement, INCREMENT2_FIELD_ID, increment2_);
            Bind(statement, OFFSET3_FIELD_ID, offset3_);
            Bind(statement, RESERVEDSLOTS3_FIELD_ID, reservedSlots3_);
            Bind(statement, TIMEOUT3_FIELD_ID, timeout3_);
            Bind(statement, INCREMENT3_FIELD_ID, increment3_);
            Bind(statement, OFFSET4_FIELD_ID, offset4_);
            Bind(statement, RESERVEDSLOTS4_FIELD_ID, reservedSlots4_);
            Bind(statement, TIMEOUT4_FIELD_ID, timeout4_);
            Bind(statement, INCREMENT4_FIELD_ID, increment4_);
        }

        template<IO::StreamWriter StreamT>
        void WriteColumns( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteColumns( destination );
            WriteColumnValue( destination, spare_);
            WriteColumnValue( destination, offset1_);
            WriteColumnValue( destination, reservedSlots1_);
            WriteColumnValue( destination, timeout1_);
            WriteColumnValue( destination, increment1_);
            WriteColumnValue( destination, offset2_);
            WriteColumnValue( destination, reservedSlots2_);
            WriteColumnValue( destination, timeout2_);
            WriteColumnValue( destination, increment2_);
            WriteColumnValue( destination, offset3_);
            WriteColumnValue( destination, reservedSlots3_);
            WriteColumnValue( destination, timeout3_);
            WriteColumnValue( destination, increment3_);
            WriteColumnValue( destination, offset4_);
            WriteColumnValue( destination, reservedSlots4_);
            WriteColumnValue( destination, timeout4_);
            WriteColumnValue( destination, increment4_);
        }
    };

    using SimpleAisDataLinkManagementMessageDataReader = SimpleColumnDataReader<AisDataLinkManagementMessageColumnData>;

    class AisExtendedClassBCsPositionReportMessageColumnData : public AisMessageColumnData
    {
        Int32 reserved_ = 0;
        double speedOverGround_ = 0.0;
        Data::PositionAccuracy positionAccuracy_ = Data::PositionAccuracy::Low;
        double longitude_ = 0.0;
        double latitude_ = 0.0;
        double courseOverGround_ = 0.0;
        DBInt32 trueHeading_;
        Int32 timestamp_ = 0;
        Int32 regionalReserved_ = 0;
        Guid name_;
        Data::ShipType shipType_ = Data::ShipType::NotAvailable;
        Int32 dimensionToBow_ = 0;
        Int32 dimensionToStern_ = 0;
        Int32 dimensionToPort_ = 0;
        Int32 dimensionToStarboard_ = 0;
        Data::PositionFixType positionFixType_ = Data::PositionFixType::Undefined1;
        Data::Raim raim_ = Data::Raim::NotInUse;
        bool dataTerminalReady_ = false;
        bool assigned_ = false;
        Int32 spare_ = 0;
    public:
        using Base = AisMessageColumnData;

        static constexpr std::wstring_view FieldNames = L"[Id],[RowVersion],[AisTransceiver],[ReceivedTimestamp],[MessageSequenceNumber],[Repeat],[Mmsi],[Reserved],[SpeedOverGround],[PositionAccuracy],[Longitude],[Latitude],[CourseOverGround],[TrueHeading],[Timestamp],[RegionalReserved],[Name],[ShipType],[DimensionToBow],[DimensionToStern],[DimensionToPort],[DimensionToStarboard],[PositionFixType],[Raim],[DataTerminalReady],[Assigned],[Spare]";
        static constexpr std::wstring_view ViewName = L"AisExtendedClassBCsPositionReportMessageView";

        static constexpr SQLUSMALLINT RESERVED_FIELD_ID = 8;
        static constexpr SQLUSMALLINT SPEEDOVERGROUND_FIELD_ID = 9;
        static constexpr SQLUSMALLINT POSITIONACCURACY_FIELD_ID = 10;
        static constexpr SQLUSMALLINT LONGITUDE_FIELD_ID = 11;
        static constexpr SQLUSMALLINT LATITUDE_FIELD_ID = 12;
        static constexpr SQLUSMALLINT COURSEOVERGROUND_FIELD_ID = 13;
        static constexpr SQLUSMALLINT TRUEHEADING_FIELD_ID = 14;
        static constexpr SQLUSMALLINT TIMESTAMP_FIELD_ID = 15;
        static constexpr SQLUSMALLINT REGIONALRESERVED_FIELD_ID = 16;
        static constexpr SQLUSMALLINT NAME_FIELD_ID = 17;
        static constexpr SQLUSMALLINT SHIPTYPE_FIELD_ID = 18;
        static constexpr SQLUSMALLINT DIMENSIONTOBOW_FIELD_ID = 19;
        static constexpr SQLUSMALLINT DIMENSIONTOSTERN_FIELD_ID = 20;
        static constexpr SQLUSMALLINT DIMENSIONTOPORT_FIELD_ID = 21;
        static constexpr SQLUSMALLINT DIMENSIONTOSTARBOARD_FIELD_ID = 22;
        static constexpr SQLUSMALLINT POSITIONFIXTYPE_FIELD_ID = 23;
        static constexpr SQLUSMALLINT RAIM_FIELD_ID = 24;
        static constexpr SQLUSMALLINT DATATERMINALREADY_FIELD_ID = 25;
        static constexpr SQLUSMALLINT ASSIGNED_FIELD_ID = 26;
        static constexpr SQLUSMALLINT SPARE_FIELD_ID = 27;

        AisExtendedClassBCsPositionReportMessageColumnData( ) = default;

        virtual Kind GetKind() const override
        {
            return Kind::AisExtendedClassBCsPositionReportMessage;
        }

        Int32 Reserved( ) const
        {
            return reserved_;
        }
        void SetReserved( Int32 reserved )
        {
            reserved_ = reserved;
        }
        double SpeedOverGround( ) const
        {
            return speedOverGround_;
        }
        void SetSpeedOverGround( double speedOverGround )
        {
            speedOverGround_ = speedOverGround;
        }
        Data::PositionAccuracy PositionAccuracy( ) const
        {
            return positionAccuracy_;
        }
        void SetPositionAccuracy( Data::PositionAccuracy positionAccuracy )
        {
            positionAccuracy_ = positionAccuracy;
        }
        double Longitude( ) const
        {
            return longitude_;
        }
        void SetLongitude( double longitude )
        {
            longitude_ = longitude;
        }
        double Latitude( ) const
        {
            return latitude_;
        }
        void SetLatitude( double latitude )
        {
            latitude_ = latitude;
        }
        double CourseOverGround( ) const
        {
            return courseOverGround_;
        }
        void SetCourseOverGround( double courseOverGround )
        {
            courseOverGround_ = courseOverGround;
        }
        const DBInt32& TrueHeading( ) const
        {
            return trueHeading_;
        }
        void SetTrueHeading( const DBInt32& trueHeading )
        {
            trueHeading_ = trueHeading;
        }
        Int32 Timestamp( ) const
        {
            return timestamp_;
        }
        void SetTimestamp( Int32 timestamp )
        {
            timestamp_ = timestamp;
        }
        Int32 RegionalReserved( ) const
        {
            return regionalReserved_;
        }
        void SetRegionalReserved( Int32 regionalReserved )
        {
            regionalReserved_ = regionalReserved;
        }
        const Guid& Name( ) const
        {
            return name_;
        }
        void SetName( const Guid& name )
        {
            name_ = name;
        }
        Data::ShipType ShipType( ) const
        {
            return shipType_;
        }
        void SetShipType( Data::ShipType shipType )
        {
            shipType_ = shipType;
        }
        Int32 DimensionToBow( ) const
        {
            return dimensionToBow_;
        }
        void SetDimensionToBow( Int32 dimensionToBow )
        {
            dimensionToBow_ = dimensionToBow;
        }
        Int32 DimensionToStern( ) const
        {
            return dimensionToStern_;
        }
        void SetDimensionToStern( Int32 dimensionToStern )
        {
            dimensionToStern_ = dimensionToStern;
        }
        Int32 DimensionToPort( ) const
        {
            return dimensionToPort_;
        }
        void SetDimensionToPort( Int32 dimensionToPort )
        {
            dimensionToPort_ = dimensionToPort;
        }
        Int32 DimensionToStarboard( ) const
        {
            return dimensionToStarboard_;
        }
        void SetDimensionToStarboard( Int32 dimensionToStarboard )
        {
            dimensionToStarboard_ = dimensionToStarboard;
        }
        Data::PositionFixType PositionFixType( ) const
        {
            return positionFixType_;
        }
        void SetPositionFixType( Data::PositionFixType positionFixType )
        {
            positionFixType_ = positionFixType;
        }
        Data::Raim Raim( ) const
        {
            return raim_;
        }
        void SetRaim( Data::Raim raim )
        {
            raim_ = raim;
        }
        bool DataTerminalReady( ) const
        {
            return dataTerminalReady_;
        }
        void SetDataTerminalReady( bool dataTerminalReady )
        {
            dataTerminalReady_ = dataTerminalReady;
        }
        bool Assigned( ) const
        {
            return assigned_;
        }
        void SetAssigned( bool assigned )
        {
            assigned_ = assigned;
        }
        Int32 Spare( ) const
        {
            return spare_;
        }
        void SetSpare( Int32 spare )
        {
            spare_ = spare;
        }
        void BindColumns( const ODBC::Statement& statement )
        {
            Base::BindColumns( statement );

            Bind(statement, RESERVED_FIELD_ID, reserved_);
            Bind(statement, SPEEDOVERGROUND_FIELD_ID, speedOverGround_);
            Bind(statement, POSITIONACCURACY_FIELD_ID, positionAccuracy_);
            Bind(statement, LONGITUDE_FIELD_ID, longitude_);
            Bind(statement, LATITUDE_FIELD_ID, latitude_);
            Bind(statement, COURSEOVERGROUND_FIELD_ID, courseOverGround_);
            Bind(statement, TRUEHEADING_FIELD_ID, trueHeading_);
            Bind(statement, TIMESTAMP_FIELD_ID, timestamp_);
            Bind(statement, REGIONALRESERVED_FIELD_ID, regionalReserved_);
            Bind(statement, NAME_FIELD_ID, name_);
            Bind(statement, SHIPTYPE_FIELD_ID, shipType_);
            Bind(statement, DIMENSIONTOBOW_FIELD_ID, dimensionToBow_);
            Bind(statement, DIMENSIONTOSTERN_FIELD_ID, dimensionToStern_);
            Bind(statement, DIMENSIONTOPORT_FIELD_ID, dimensionToPort_);
            Bind(statement, DIMENSIONTOSTARBOARD_FIELD_ID, dimensionToStarboard_);
            Bind(statement, POSITIONFIXTYPE_FIELD_ID, positionFixType_);
            Bind(statement, RAIM_FIELD_ID, raim_);
            Bind(statement, DATATERMINALREADY_FIELD_ID, dataTerminalReady_);
            Bind(statement, ASSIGNED_FIELD_ID, assigned_);
            Bind(statement, SPARE_FIELD_ID, spare_);
        }

        template<IO::StreamWriter StreamT>
        void WriteColumns( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteColumns( destination );
            WriteColumnValue( destination, reserved_);
            WriteColumnValue( destination, speedOverGround_);
            WriteColumnValue( destination, positionAccuracy_);
            WriteColumnValue( destination, longitude_);
            WriteColumnValue( destination, latitude_);
            WriteColumnValue( destination, courseOverGround_);
            WriteColumnValue( destination, trueHeading_);
            WriteColumnValue( destination, timestamp_);
            WriteColumnValue( destination, regionalReserved_);
            WriteColumnValue( destination, name_);
            WriteColumnValue( destination, shipType_);
            WriteColumnValue( destination, dimensionToBow_);
            WriteColumnValue( destination, dimensionToStern_);
            WriteColumnValue( destination, dimensionToPort_);
            WriteColumnValue( destination, dimensionToStarboard_);
            WriteColumnValue( destination, positionFixType_);
            WriteColumnValue( destination, raim_);
            WriteColumnValue( destination, dataTerminalReady_);
            WriteColumnValue( destination, assigned_);
            WriteColumnValue( destination, spare_);
        }
    };

    using SimpleAisExtendedClassBCsPositionReportMessageDataReader = SimpleColumnDataReader<AisExtendedClassBCsPositionReportMessageColumnData>;

    class AisInterrogationMessageColumnData : public AisMessageColumnData
    {
        Guid interrogatedMmsi_;
        Data::AisMessageType firstMessageType_ = Data::AisMessageType::PositionReportClassA;
        Int32 firstSlotOffset_ = 0;
        DBEnum<Data::AisMessageType> secondMessageType_;
        DBInt32 secondSlotOffset_;
        Guid secondStationInterrogationMmsi_;
        DBEnum<Data::AisMessageType> secondStationFirstMessageType_;
        DBInt32 secondStationFirstSlotOffset_;
    public:
        using Base = AisMessageColumnData;

        static constexpr std::wstring_view FieldNames = L"[Id],[RowVersion],[AisTransceiver],[ReceivedTimestamp],[MessageSequenceNumber],[Repeat],[Mmsi],[InterrogatedMmsi],[FirstMessageType],[FirstSlotOffset],[SecondMessageType],[SecondSlotOffset],[SecondStationInterrogationMmsi],[SecondStationFirstMessageType],[SecondStationFirstSlotOffset]";
        static constexpr std::wstring_view ViewName = L"AisInterrogationMessageView";

        static constexpr SQLUSMALLINT INTERROGATEDMMSI_FIELD_ID = 8;
        static constexpr SQLUSMALLINT FIRSTMESSAGETYPE_FIELD_ID = 9;
        static constexpr SQLUSMALLINT FIRSTSLOTOFFSET_FIELD_ID = 10;
        static constexpr SQLUSMALLINT SECONDMESSAGETYPE_FIELD_ID = 11;
        static constexpr SQLUSMALLINT SECONDSLOTOFFSET_FIELD_ID = 12;
        static constexpr SQLUSMALLINT SECONDSTATIONINTERROGATIONMMSI_FIELD_ID = 13;
        static constexpr SQLUSMALLINT SECONDSTATIONFIRSTMESSAGETYPE_FIELD_ID = 14;
        static constexpr SQLUSMALLINT SECONDSTATIONFIRSTSLOTOFFSET_FIELD_ID = 15;

        AisInterrogationMessageColumnData( ) = default;

        virtual Kind GetKind() const override
        {
            return Kind::AisInterrogationMessage;
        }

        const Guid& InterrogatedMmsi( ) const
        {
            return interrogatedMmsi_;
        }
        void SetInterrogatedMmsi( const Guid& interrogatedMmsi )
        {
            interrogatedMmsi_ = interrogatedMmsi;
        }
        Data::AisMessageType FirstMessageType( ) const
        {
            return firstMessageType_;
        }
        void SetFirstMessageType( Data::AisMessageType firstMessageType )
        {
            firstMessageType_ = firstMessageType;
        }
        Int32 FirstSlotOffset( ) const
        {
            return firstSlotOffset_;
        }
        void SetFirstSlotOffset( Int32 firstSlotOffset )
        {
            firstSlotOffset_ = firstSlotOffset;
        }
        const DBEnum<Data::AisMessageType>& SecondMessageType( ) const
        {
            return secondMessageType_;
        }
        void SetSecondMessageType( const DBEnum<Data::AisMessageType>& secondMessageType )
        {
            secondMessageType_ = secondMessageType;
        }
        const DBInt32& SecondSlotOffset( ) const
        {
            return secondSlotOffset_;
        }
        void SetSecondSlotOffset( const DBInt32& secondSlotOffset )
        {
            secondSlotOffset_ = secondSlotOffset;
        }
        const Guid& SecondStationInterrogationMmsi( ) const
        {
            return secondStationInterrogationMmsi_;
        }
        void SetSecondStationInterrogationMmsi( const Guid& secondStationInterrogationMmsi )
        {
            secondStationInterrogationMmsi_ = secondStationInterrogationMmsi;
        }
        const DBEnum<Data::AisMessageType>& SecondStationFirstMessageType( ) const
        {
            return secondStationFirstMessageType_;
        }
        void SetSecondStationFirstMessageType( const DBEnum<Data::AisMessageType>& secondStationFirstMessageType )
        {
            secondStationFirstMessageType_ = secondStationFirstMessageType;
        }
        const DBInt32& SecondStationFirstSlotOffset( ) const
        {
            return secondStationFirstSlotOffset_;
        }
        void SetSecondStationFirstSlotOffset( const DBInt32& secondStationFirstSlotOffset )
        {
            secondStationFirstSlotOffset_ = secondStationFirstSlotOffset;
        }
        void BindColumns( const ODBC::Statement& statement )
        {
            Base::BindColumns( statement );

            Bind(statement, INTERROGATEDMMSI_FIELD_ID, interrogatedMmsi_);
            Bind(statement, FIRSTMESSAGETYPE_FIELD_ID, firstMessageType_);
            Bind(statement, FIRSTSLOTOFFSET_FIELD_ID, firstSlotOffset_);
            Bind(statement, SECONDMESSAGETYPE_FIELD_ID, secondMessageType_);
            Bind(statement, SECONDSLOTOFFSET_FIELD_ID, secondSlotOffset_);
            Bind(statement, SECONDSTATIONINTERROGATIONMMSI_FIELD_ID, secondStationInterrogationMmsi_);
            Bind(statement, SECONDSTATIONFIRSTMESSAGETYPE_FIELD_ID, secondStationFirstMessageType_);
            Bind(statement, SECONDSTATIONFIRSTSLOTOFFSET_FIELD_ID, secondStationFirstSlotOffset_);
        }

        template<IO::StreamWriter StreamT>
        void WriteColumns( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteColumns( destination );
            WriteColumnValue( destination, interrogatedMmsi_);
            WriteColumnValue( destination, firstMessageType_);
            WriteColumnValue( destination, firstSlotOffset_);
            WriteColumnValue( destination, secondMessageType_);
            WriteColumnValue( destination, secondSlotOffset_);
            WriteColumnValue( destination, secondStationInterrogationMmsi_);
            WriteColumnValue( destination, secondStationFirstMessageType_);
            WriteColumnValue( destination, secondStationFirstSlotOffset_);
        }
    };

    using SimpleAisInterrogationMessageDataReader = SimpleColumnDataReader<AisInterrogationMessageColumnData>;

    class AisPositionReportClassAMessageBaseColumnData : public AisMessageColumnData
    {
        Data::NavigationStatus navigationStatus_ = Data::NavigationStatus::UnderWayUsingEngine;
        DBInt32 rateOfTurn_;
        double speedOverGround_ = 0.0;
        Data::PositionAccuracy positionAccuracy_ = Data::PositionAccuracy::Low;
        double longitude_ = 0.0;
        double latitude_ = 0.0;
        double courseOverGround_ = 0.0;
        DBInt32 trueHeading_;
        Int32 timestamp_ = 0;
        Data::ManeuverIndicator maneuverIndicator_ = Data::ManeuverIndicator::NotAvailable;
        Int32 spare_ = 0;
        Data::Raim raim_ = Data::Raim::NotInUse;
        Int32 radioStatus_ = 0;
    public:
        using Base = AisMessageColumnData;

        static constexpr std::wstring_view FieldNames = L"[Id],[RowVersion],[AisTransceiver],[ReceivedTimestamp],[MessageSequenceNumber],[Repeat],[Mmsi],[NavigationStatus],[RateOfTurn],[SpeedOverGround],[PositionAccuracy],[Longitude],[Latitude],[CourseOverGround],[TrueHeading],[Timestamp],[ManeuverIndicator],[Spare],[Raim],[RadioStatus]";
        static constexpr std::wstring_view ViewName = L"AisPositionReportClassAMessageBaseView";

        static constexpr SQLUSMALLINT NAVIGATIONSTATUS_FIELD_ID = 8;
        static constexpr SQLUSMALLINT RATEOFTURN_FIELD_ID = 9;
        static constexpr SQLUSMALLINT SPEEDOVERGROUND_FIELD_ID = 10;
        static constexpr SQLUSMALLINT POSITIONACCURACY_FIELD_ID = 11;
        static constexpr SQLUSMALLINT LONGITUDE_FIELD_ID = 12;
        static constexpr SQLUSMALLINT LATITUDE_FIELD_ID = 13;
        static constexpr SQLUSMALLINT COURSEOVERGROUND_FIELD_ID = 14;
        static constexpr SQLUSMALLINT TRUEHEADING_FIELD_ID = 15;
        static constexpr SQLUSMALLINT TIMESTAMP_FIELD_ID = 16;
        static constexpr SQLUSMALLINT MANEUVERINDICATOR_FIELD_ID = 17;
        static constexpr SQLUSMALLINT SPARE_FIELD_ID = 18;
        static constexpr SQLUSMALLINT RAIM_FIELD_ID = 19;
        static constexpr SQLUSMALLINT RADIOSTATUS_FIELD_ID = 20;

        AisPositionReportClassAMessageBaseColumnData( ) = default;

        virtual Kind GetKind() const override
        {
            return Kind::AisPositionReportClassAMessageBase;
        }

        Data::NavigationStatus NavigationStatus( ) const
        {
            return navigationStatus_;
        }
        void SetNavigationStatus( Data::NavigationStatus navigationStatus )
        {
            navigationStatus_ = navigationStatus;
        }
        const DBInt32& RateOfTurn( ) const
        {
            return rateOfTurn_;
        }
        void SetRateOfTurn( const DBInt32& rateOfTurn )
        {
            rateOfTurn_ = rateOfTurn;
        }
        double SpeedOverGround( ) const
        {
            return speedOverGround_;
        }
        void SetSpeedOverGround( double speedOverGround )
        {
            speedOverGround_ = speedOverGround;
        }
        Data::PositionAccuracy PositionAccuracy( ) const
        {
            return positionAccuracy_;
        }
        void SetPositionAccuracy( Data::PositionAccuracy positionAccuracy )
        {
            positionAccuracy_ = positionAccuracy;
        }
        double Longitude( ) const
        {
            return longitude_;
        }
        void SetLongitude( double longitude )
        {
            longitude_ = longitude;
        }
        double Latitude( ) const
        {
            return latitude_;
        }
        void SetLatitude( double latitude )
        {
            latitude_ = latitude;
        }
        double CourseOverGround( ) const
        {
            return courseOverGround_;
        }
        void SetCourseOverGround( double courseOverGround )
        {
            courseOverGround_ = courseOverGround;
        }
        const DBInt32& TrueHeading( ) const
        {
            return trueHeading_;
        }
        void SetTrueHeading( const DBInt32& trueHeading )
        {
            trueHeading_ = trueHeading;
        }
        Int32 Timestamp( ) const
        {
            return timestamp_;
        }
        void SetTimestamp( Int32 timestamp )
        {
            timestamp_ = timestamp;
        }
        Data::ManeuverIndicator ManeuverIndicator( ) const
        {
            return maneuverIndicator_;
        }
        void SetManeuverIndicator( Data::ManeuverIndicator maneuverIndicator )
        {
            maneuverIndicator_ = maneuverIndicator;
        }
        Int32 Spare( ) const
        {
            return spare_;
        }
        void SetSpare( Int32 spare )
        {
            spare_ = spare;
        }
        Data::Raim Raim( ) const
        {
            return raim_;
        }
        void SetRaim( Data::Raim raim )
        {
            raim_ = raim;
        }
        Int32 RadioStatus( ) const
        {
            return radioStatus_;
        }
        void SetRadioStatus( Int32 radioStatus )
        {
            radioStatus_ = radioStatus;
        }
        void BindColumns( const ODBC::Statement& statement )
        {
            Base::BindColumns( statement );

            Bind(statement, NAVIGATIONSTATUS_FIELD_ID, navigationStatus_);
            Bind(statement, RATEOFTURN_FIELD_ID, rateOfTurn_);
            Bind(statement, SPEEDOVERGROUND_FIELD_ID, speedOverGround_);
            Bind(statement, POSITIONACCURACY_FIELD_ID, positionAccuracy_);
            Bind(statement, LONGITUDE_FIELD_ID, longitude_);
            Bind(statement, LATITUDE_FIELD_ID, latitude_);
            Bind(statement, COURSEOVERGROUND_FIELD_ID, courseOverGround_);
            Bind(statement, TRUEHEADING_FIELD_ID, trueHeading_);
            Bind(statement, TIMESTAMP_FIELD_ID, timestamp_);
            Bind(statement, MANEUVERINDICATOR_FIELD_ID, maneuverIndicator_);
            Bind(statement, SPARE_FIELD_ID, spare_);
            Bind(statement, RAIM_FIELD_ID, raim_);
            Bind(statement, RADIOSTATUS_FIELD_ID, radioStatus_);
        }

        template<IO::StreamWriter StreamT>
        void WriteColumns( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteColumns( destination );
            WriteColumnValue( destination, navigationStatus_);
            WriteColumnValue( destination, rateOfTurn_);
            WriteColumnValue( destination, speedOverGround_);
            WriteColumnValue( destination, positionAccuracy_);
            WriteColumnValue( destination, longitude_);
            WriteColumnValue( destination, latitude_);
            WriteColumnValue( destination, courseOverGround_);
            WriteColumnValue( destination, trueHeading_);
            WriteColumnValue( destination, timestamp_);
            WriteColumnValue( destination, maneuverIndicator_);
            WriteColumnValue( destination, spare_);
            WriteColumnValue( destination, raim_);
            WriteColumnValue( destination, radioStatus_);
        }
    };

    using SimpleAisPositionReportClassAMessageBaseDataReader = SimpleColumnDataReader<AisPositionReportClassAMessageBaseColumnData>;

    class AisPositionReportClassAAssignedScheduleMessageColumnData : public AisPositionReportClassAMessageBaseColumnData
    {
    public:
        using Base = AisPositionReportClassAMessageBaseColumnData;

        static constexpr std::wstring_view FieldNames = L"[Id],[RowVersion],[AisTransceiver],[ReceivedTimestamp],[MessageSequenceNumber],[Repeat],[Mmsi],[NavigationStatus],[RateOfTurn],[SpeedOverGround],[PositionAccuracy],[Longitude],[Latitude],[CourseOverGround],[TrueHeading],[Timestamp],[ManeuverIndicator],[Spare],[Raim],[RadioStatus]";
        static constexpr std::wstring_view ViewName = L"AisPositionReportClassAAssignedScheduleMessageView";

        AisPositionReportClassAAssignedScheduleMessageColumnData( ) = default;

        virtual Kind GetKind() const override
        {
            return Kind::AisPositionReportClassAAssignedScheduleMessage;
        }

        template<IO::StreamWriter StreamT>
        void WriteColumns( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteColumns( destination );
        }
    };

    using SimpleAisPositionReportClassAAssignedScheduleMessageDataReader = SimpleColumnDataReader<AisPositionReportClassAAssignedScheduleMessageColumnData>;

    class AisPositionReportClassAMessageColumnData : public AisPositionReportClassAMessageBaseColumnData
    {
    public:
        using Base = AisPositionReportClassAMessageBaseColumnData;

        static constexpr std::wstring_view FieldNames = L"[Id],[RowVersion],[AisTransceiver],[ReceivedTimestamp],[MessageSequenceNumber],[Repeat],[Mmsi],[NavigationStatus],[RateOfTurn],[SpeedOverGround],[PositionAccuracy],[Longitude],[Latitude],[CourseOverGround],[TrueHeading],[Timestamp],[ManeuverIndicator],[Spare],[Raim],[RadioStatus]";
        static constexpr std::wstring_view ViewName = L"AisPositionReportClassAMessageView";

        AisPositionReportClassAMessageColumnData( ) = default;

        virtual Kind GetKind() const override
        {
            return Kind::AisPositionReportClassAMessage;
        }

        template<IO::StreamWriter StreamT>
        void WriteColumns( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteColumns( destination );
        }
    };

    using SimpleAisPositionReportClassAMessageDataReader = SimpleColumnDataReader<AisPositionReportClassAMessageColumnData>;

    class AisPositionReportClassAResponseToInterrogationMessageColumnData : public AisPositionReportClassAMessageBaseColumnData
    {
    public:
        using Base = AisPositionReportClassAMessageBaseColumnData;

        static constexpr std::wstring_view FieldNames = L"[Id],[RowVersion],[AisTransceiver],[ReceivedTimestamp],[MessageSequenceNumber],[Repeat],[Mmsi],[NavigationStatus],[RateOfTurn],[SpeedOverGround],[PositionAccuracy],[Longitude],[Latitude],[CourseOverGround],[TrueHeading],[Timestamp],[ManeuverIndicator],[Spare],[Raim],[RadioStatus]";
        static constexpr std::wstring_view ViewName = L"AisPositionReportClassAResponseToInterrogationMessageView";

        AisPositionReportClassAResponseToInterrogationMessageColumnData( ) = default;

        virtual Kind GetKind() const override
        {
            return Kind::AisPositionReportClassAResponseToInterrogationMessage;
        }

        template<IO::StreamWriter StreamT>
        void WriteColumns( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteColumns( destination );
        }
    };

    using SimpleAisPositionReportClassAResponseToInterrogationMessageDataReader = SimpleColumnDataReader<AisPositionReportClassAResponseToInterrogationMessageColumnData>;

    class AisPositionReportForLongRangeApplicationsMessageColumnData : public AisMessageColumnData
    {
        Data::PositionAccuracy positionAccuracy_ = Data::PositionAccuracy::Low;
        Data::Raim raim_ = Data::Raim::NotInUse;
        Data::NavigationStatus navigationStatus_ = Data::NavigationStatus::UnderWayUsingEngine;
        double longitude_ = 0.0;
        double latitude_ = 0.0;
        double speedOverGround_ = 0.0;
        double courseOverGround_ = 0.0;
        Data::GnssPositionStatus gnssPositionStatus_ = Data::GnssPositionStatus::CurrentGnssPosition;
        Int32 spare_ = 0;
    public:
        using Base = AisMessageColumnData;

        static constexpr std::wstring_view FieldNames = L"[Id],[RowVersion],[AisTransceiver],[ReceivedTimestamp],[MessageSequenceNumber],[Repeat],[Mmsi],[PositionAccuracy],[Raim],[NavigationStatus],[Longitude],[Latitude],[SpeedOverGround],[CourseOverGround],[GnssPositionStatus],[Spare]";
        static constexpr std::wstring_view ViewName = L"AisPositionReportForLongRangeApplicationsMessageView";

        static constexpr SQLUSMALLINT POSITIONACCURACY_FIELD_ID = 8;
        static constexpr SQLUSMALLINT RAIM_FIELD_ID = 9;
        static constexpr SQLUSMALLINT NAVIGATIONSTATUS_FIELD_ID = 10;
        static constexpr SQLUSMALLINT LONGITUDE_FIELD_ID = 11;
        static constexpr SQLUSMALLINT LATITUDE_FIELD_ID = 12;
        static constexpr SQLUSMALLINT SPEEDOVERGROUND_FIELD_ID = 13;
        static constexpr SQLUSMALLINT COURSEOVERGROUND_FIELD_ID = 14;
        static constexpr SQLUSMALLINT GNSSPOSITIONSTATUS_FIELD_ID = 15;
        static constexpr SQLUSMALLINT SPARE_FIELD_ID = 16;

        AisPositionReportForLongRangeApplicationsMessageColumnData( ) = default;

        virtual Kind GetKind() const override
        {
            return Kind::AisPositionReportForLongRangeApplicationsMessage;
        }

        Data::PositionAccuracy PositionAccuracy( ) const
        {
            return positionAccuracy_;
        }
        void SetPositionAccuracy( Data::PositionAccuracy positionAccuracy )
        {
            positionAccuracy_ = positionAccuracy;
        }
        Data::Raim Raim( ) const
        {
            return raim_;
        }
        void SetRaim( Data::Raim raim )
        {
            raim_ = raim;
        }
        Data::NavigationStatus NavigationStatus( ) const
        {
            return navigationStatus_;
        }
        void SetNavigationStatus( Data::NavigationStatus navigationStatus )
        {
            navigationStatus_ = navigationStatus;
        }
        double Longitude( ) const
        {
            return longitude_;
        }
        void SetLongitude( double longitude )
        {
            longitude_ = longitude;
        }
        double Latitude( ) const
        {
            return latitude_;
        }
        void SetLatitude( double latitude )
        {
            latitude_ = latitude;
        }
        double SpeedOverGround( ) const
        {
            return speedOverGround_;
        }
        void SetSpeedOverGround( double speedOverGround )
        {
            speedOverGround_ = speedOverGround;
        }
        double CourseOverGround( ) const
        {
            return courseOverGround_;
        }
        void SetCourseOverGround( double courseOverGround )
        {
            courseOverGround_ = courseOverGround;
        }
        Data::GnssPositionStatus GnssPositionStatus( ) const
        {
            return gnssPositionStatus_;
        }
        void SetGnssPositionStatus( Data::GnssPositionStatus gnssPositionStatus )
        {
            gnssPositionStatus_ = gnssPositionStatus;
        }
        Int32 Spare( ) const
        {
            return spare_;
        }
        void SetSpare( Int32 spare )
        {
            spare_ = spare;
        }
        void BindColumns( const ODBC::Statement& statement )
        {
            Base::BindColumns( statement );

            Bind(statement, POSITIONACCURACY_FIELD_ID, positionAccuracy_);
            Bind(statement, RAIM_FIELD_ID, raim_);
            Bind(statement, NAVIGATIONSTATUS_FIELD_ID, navigationStatus_);
            Bind(statement, LONGITUDE_FIELD_ID, longitude_);
            Bind(statement, LATITUDE_FIELD_ID, latitude_);
            Bind(statement, SPEEDOVERGROUND_FIELD_ID, speedOverGround_);
            Bind(statement, COURSEOVERGROUND_FIELD_ID, courseOverGround_);
            Bind(statement, GNSSPOSITIONSTATUS_FIELD_ID, gnssPositionStatus_);
            Bind(statement, SPARE_FIELD_ID, spare_);
        }

        template<IO::StreamWriter StreamT>
        void WriteColumns( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteColumns( destination );
            WriteColumnValue( destination, positionAccuracy_);
            WriteColumnValue( destination, raim_);
            WriteColumnValue( destination, navigationStatus_);
            WriteColumnValue( destination, longitude_);
            WriteColumnValue( destination, latitude_);
            WriteColumnValue( destination, speedOverGround_);
            WriteColumnValue( destination, courseOverGround_);
            WriteColumnValue( destination, gnssPositionStatus_);
            WriteColumnValue( destination, spare_);
        }
    };

    using SimpleAisPositionReportForLongRangeApplicationsMessageDataReader = SimpleColumnDataReader<AisPositionReportForLongRangeApplicationsMessageColumnData>;

    class AisSafetyRelatedAcknowledgmentMessageColumnData : public AisMessageColumnData
    {
        Int32 spare_ = 0;
        Int32 sequenceNumber1_ = 0;
        Guid mmsi1_;
        Int32 sequenceNumber2_ = 0;
        Guid mmsi2_;
        Int32 sequenceNumber3_ = 0;
        Guid mmsi3_;
        Int32 sequenceNumber4_ = 0;
        Guid mmsi4_;
    public:
        using Base = AisMessageColumnData;

        static constexpr std::wstring_view FieldNames = L"[Id],[RowVersion],[AisTransceiver],[ReceivedTimestamp],[MessageSequenceNumber],[Repeat],[Mmsi],[Spare],[SequenceNumber1],[Mmsi1],[SequenceNumber2],[Mmsi2],[SequenceNumber3],[Mmsi3],[SequenceNumber4],[Mmsi4]";
        static constexpr std::wstring_view ViewName = L"AisSafetyRelatedAcknowledgmentMessageView";

        static constexpr SQLUSMALLINT SPARE_FIELD_ID = 8;
        static constexpr SQLUSMALLINT SEQUENCENUMBER1_FIELD_ID = 9;
        static constexpr SQLUSMALLINT MMSI1_FIELD_ID = 10;
        static constexpr SQLUSMALLINT SEQUENCENUMBER2_FIELD_ID = 11;
        static constexpr SQLUSMALLINT MMSI2_FIELD_ID = 12;
        static constexpr SQLUSMALLINT SEQUENCENUMBER3_FIELD_ID = 13;
        static constexpr SQLUSMALLINT MMSI3_FIELD_ID = 14;
        static constexpr SQLUSMALLINT SEQUENCENUMBER4_FIELD_ID = 15;
        static constexpr SQLUSMALLINT MMSI4_FIELD_ID = 16;

        AisSafetyRelatedAcknowledgmentMessageColumnData( ) = default;

        virtual Kind GetKind() const override
        {
            return Kind::AisSafetyRelatedAcknowledgmentMessage;
        }

        Int32 Spare( ) const
        {
            return spare_;
        }
        void SetSpare( Int32 spare )
        {
            spare_ = spare;
        }
        Int32 SequenceNumber1( ) const
        {
            return sequenceNumber1_;
        }
        void SetSequenceNumber1( Int32 sequenceNumber1 )
        {
            sequenceNumber1_ = sequenceNumber1;
        }
        const Guid& Mmsi1( ) const
        {
            return mmsi1_;
        }
        void SetMmsi1( const Guid& mmsi1 )
        {
            mmsi1_ = mmsi1;
        }
        Int32 SequenceNumber2( ) const
        {
            return sequenceNumber2_;
        }
        void SetSequenceNumber2( Int32 sequenceNumber2 )
        {
            sequenceNumber2_ = sequenceNumber2;
        }
        const Guid& Mmsi2( ) const
        {
            return mmsi2_;
        }
        void SetMmsi2( const Guid& mmsi2 )
        {
            mmsi2_ = mmsi2;
        }
        Int32 SequenceNumber3( ) const
        {
            return sequenceNumber3_;
        }
        void SetSequenceNumber3( Int32 sequenceNumber3 )
        {
            sequenceNumber3_ = sequenceNumber3;
        }
        const Guid& Mmsi3( ) const
        {
            return mmsi3_;
        }
        void SetMmsi3( const Guid& mmsi3 )
        {
            mmsi3_ = mmsi3;
        }
        Int32 SequenceNumber4( ) const
        {
            return sequenceNumber4_;
        }
        void SetSequenceNumber4( Int32 sequenceNumber4 )
        {
            sequenceNumber4_ = sequenceNumber4;
        }
        const Guid& Mmsi4( ) const
        {
            return mmsi4_;
        }
        void SetMmsi4( const Guid& mmsi4 )
        {
            mmsi4_ = mmsi4;
        }
        void BindColumns( const ODBC::Statement& statement )
        {
            Base::BindColumns( statement );

            Bind(statement, SPARE_FIELD_ID, spare_);
            Bind(statement, SEQUENCENUMBER1_FIELD_ID, sequenceNumber1_);
            Bind(statement, MMSI1_FIELD_ID, mmsi1_);
            Bind(statement, SEQUENCENUMBER2_FIELD_ID, sequenceNumber2_);
            Bind(statement, MMSI2_FIELD_ID, mmsi2_);
            Bind(statement, SEQUENCENUMBER3_FIELD_ID, sequenceNumber3_);
            Bind(statement, MMSI3_FIELD_ID, mmsi3_);
            Bind(statement, SEQUENCENUMBER4_FIELD_ID, sequenceNumber4_);
            Bind(statement, MMSI4_FIELD_ID, mmsi4_);
        }

        template<IO::StreamWriter StreamT>
        void WriteColumns( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteColumns( destination );
            WriteColumnValue( destination, spare_);
            WriteColumnValue( destination, sequenceNumber1_);
            WriteColumnValue( destination, mmsi1_);
            WriteColumnValue( destination, sequenceNumber2_);
            WriteColumnValue( destination, mmsi2_);
            WriteColumnValue( destination, sequenceNumber3_);
            WriteColumnValue( destination, mmsi3_);
            WriteColumnValue( destination, sequenceNumber4_);
            WriteColumnValue( destination, mmsi4_);
        }
    };

    using SimpleAisSafetyRelatedAcknowledgmentMessageDataReader = SimpleColumnDataReader<AisSafetyRelatedAcknowledgmentMessageColumnData>;

    class AisStandardClassBCsPositionReportMessageColumnData : public AisMessageColumnData
    {
        Int32 reserved_ = 0;
        double speedOverGround_ = 0.0;
        Data::PositionAccuracy positionAccuracy_ = Data::PositionAccuracy::Low;
        double longitude_ = 0.0;
        double latitude_ = 0.0;
        double courseOverGround_ = 0.0;
        DBInt32 trueHeading_;
        Int32 timestamp_ = 0;
        Int32 regionalReserved_ = 0;
        bool isCsUnit_ = false;
        bool hasDisplay_ = false;
        bool hasDscCapability_ = false;
        bool band_ = false;
        bool canAcceptMessage22_ = false;
        bool assigned_ = false;
        Data::Raim raim_ = Data::Raim::NotInUse;
        Int32 radioStatus_ = 0;
    public:
        using Base = AisMessageColumnData;

        static constexpr std::wstring_view FieldNames = L"[Id],[RowVersion],[AisTransceiver],[ReceivedTimestamp],[MessageSequenceNumber],[Repeat],[Mmsi],[Reserved],[SpeedOverGround],[PositionAccuracy],[Longitude],[Latitude],[CourseOverGround],[TrueHeading],[Timestamp],[RegionalReserved],[IsCsUnit],[HasDisplay],[HasDscCapability],[Band],[CanAcceptMessage22],[Assigned],[Raim],[RadioStatus]";
        static constexpr std::wstring_view ViewName = L"AisStandardClassBCsPositionReportMessageView";

        static constexpr SQLUSMALLINT RESERVED_FIELD_ID = 8;
        static constexpr SQLUSMALLINT SPEEDOVERGROUND_FIELD_ID = 9;
        static constexpr SQLUSMALLINT POSITIONACCURACY_FIELD_ID = 10;
        static constexpr SQLUSMALLINT LONGITUDE_FIELD_ID = 11;
        static constexpr SQLUSMALLINT LATITUDE_FIELD_ID = 12;
        static constexpr SQLUSMALLINT COURSEOVERGROUND_FIELD_ID = 13;
        static constexpr SQLUSMALLINT TRUEHEADING_FIELD_ID = 14;
        static constexpr SQLUSMALLINT TIMESTAMP_FIELD_ID = 15;
        static constexpr SQLUSMALLINT REGIONALRESERVED_FIELD_ID = 16;
        static constexpr SQLUSMALLINT ISCSUNIT_FIELD_ID = 17;
        static constexpr SQLUSMALLINT HASDISPLAY_FIELD_ID = 18;
        static constexpr SQLUSMALLINT HASDSCCAPABILITY_FIELD_ID = 19;
        static constexpr SQLUSMALLINT BAND_FIELD_ID = 20;
        static constexpr SQLUSMALLINT CANACCEPTMESSAGE22_FIELD_ID = 21;
        static constexpr SQLUSMALLINT ASSIGNED_FIELD_ID = 22;
        static constexpr SQLUSMALLINT RAIM_FIELD_ID = 23;
        static constexpr SQLUSMALLINT RADIOSTATUS_FIELD_ID = 24;

        AisStandardClassBCsPositionReportMessageColumnData( ) = default;

        virtual Kind GetKind() const override
        {
            return Kind::AisStandardClassBCsPositionReportMessage;
        }

        Int32 Reserved( ) const
        {
            return reserved_;
        }
        void SetReserved( Int32 reserved )
        {
            reserved_ = reserved;
        }
        double SpeedOverGround( ) const
        {
            return speedOverGround_;
        }
        void SetSpeedOverGround( double speedOverGround )
        {
            speedOverGround_ = speedOverGround;
        }
        Data::PositionAccuracy PositionAccuracy( ) const
        {
            return positionAccuracy_;
        }
        void SetPositionAccuracy( Data::PositionAccuracy positionAccuracy )
        {
            positionAccuracy_ = positionAccuracy;
        }
        double Longitude( ) const
        {
            return longitude_;
        }
        void SetLongitude( double longitude )
        {
            longitude_ = longitude;
        }
        double Latitude( ) const
        {
            return latitude_;
        }
        void SetLatitude( double latitude )
        {
            latitude_ = latitude;
        }
        double CourseOverGround( ) const
        {
            return courseOverGround_;
        }
        void SetCourseOverGround( double courseOverGround )
        {
            courseOverGround_ = courseOverGround;
        }
        const DBInt32& TrueHeading( ) const
        {
            return trueHeading_;
        }
        void SetTrueHeading( const DBInt32& trueHeading )
        {
            trueHeading_ = trueHeading;
        }
        Int32 Timestamp( ) const
        {
            return timestamp_;
        }
        void SetTimestamp( Int32 timestamp )
        {
            timestamp_ = timestamp;
        }
        Int32 RegionalReserved( ) const
        {
            return regionalReserved_;
        }
        void SetRegionalReserved( Int32 regionalReserved )
        {
            regionalReserved_ = regionalReserved;
        }
        bool IsCsUnit( ) const
        {
            return isCsUnit_;
        }
        void SetIsCsUnit( bool isCsUnit )
        {
            isCsUnit_ = isCsUnit;
        }
        bool HasDisplay( ) const
        {
            return hasDisplay_;
        }
        void SetHasDisplay( bool hasDisplay )
        {
            hasDisplay_ = hasDisplay;
        }
        bool HasDscCapability( ) const
        {
            return hasDscCapability_;
        }
        void SetHasDscCapability( bool hasDscCapability )
        {
            hasDscCapability_ = hasDscCapability;
        }
        bool Band( ) const
        {
            return band_;
        }
        void SetBand( bool band )
        {
            band_ = band;
        }
        bool CanAcceptMessage22( ) const
        {
            return canAcceptMessage22_;
        }
        void SetCanAcceptMessage22( bool canAcceptMessage22 )
        {
            canAcceptMessage22_ = canAcceptMessage22;
        }
        bool Assigned( ) const
        {
            return assigned_;
        }
        void SetAssigned( bool assigned )
        {
            assigned_ = assigned;
        }
        Data::Raim Raim( ) const
        {
            return raim_;
        }
        void SetRaim( Data::Raim raim )
        {
            raim_ = raim;
        }
        Int32 RadioStatus( ) const
        {
            return radioStatus_;
        }
        void SetRadioStatus( Int32 radioStatus )
        {
            radioStatus_ = radioStatus;
        }
        void BindColumns( const ODBC::Statement& statement )
        {
            Base::BindColumns( statement );

            Bind(statement, RESERVED_FIELD_ID, reserved_);
            Bind(statement, SPEEDOVERGROUND_FIELD_ID, speedOverGround_);
            Bind(statement, POSITIONACCURACY_FIELD_ID, positionAccuracy_);
            Bind(statement, LONGITUDE_FIELD_ID, longitude_);
            Bind(statement, LATITUDE_FIELD_ID, latitude_);
            Bind(statement, COURSEOVERGROUND_FIELD_ID, courseOverGround_);
            Bind(statement, TRUEHEADING_FIELD_ID, trueHeading_);
            Bind(statement, TIMESTAMP_FIELD_ID, timestamp_);
            Bind(statement, REGIONALRESERVED_FIELD_ID, regionalReserved_);
            Bind(statement, ISCSUNIT_FIELD_ID, isCsUnit_);
            Bind(statement, HASDISPLAY_FIELD_ID, hasDisplay_);
            Bind(statement, HASDSCCAPABILITY_FIELD_ID, hasDscCapability_);
            Bind(statement, BAND_FIELD_ID, band_);
            Bind(statement, CANACCEPTMESSAGE22_FIELD_ID, canAcceptMessage22_);
            Bind(statement, ASSIGNED_FIELD_ID, assigned_);
            Bind(statement, RAIM_FIELD_ID, raim_);
            Bind(statement, RADIOSTATUS_FIELD_ID, radioStatus_);
        }

        template<IO::StreamWriter StreamT>
        void WriteColumns( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteColumns( destination );
            WriteColumnValue( destination, reserved_);
            WriteColumnValue( destination, speedOverGround_);
            WriteColumnValue( destination, positionAccuracy_);
            WriteColumnValue( destination, longitude_);
            WriteColumnValue( destination, latitude_);
            WriteColumnValue( destination, courseOverGround_);
            WriteColumnValue( destination, trueHeading_);
            WriteColumnValue( destination, timestamp_);
            WriteColumnValue( destination, regionalReserved_);
            WriteColumnValue( destination, isCsUnit_);
            WriteColumnValue( destination, hasDisplay_);
            WriteColumnValue( destination, hasDscCapability_);
            WriteColumnValue( destination, band_);
            WriteColumnValue( destination, canAcceptMessage22_);
            WriteColumnValue( destination, assigned_);
            WriteColumnValue( destination, raim_);
            WriteColumnValue( destination, radioStatus_);
        }
    };

    using SimpleAisStandardClassBCsPositionReportMessageDataReader = SimpleColumnDataReader<AisStandardClassBCsPositionReportMessageColumnData>;

    class AisStandardSarAircraftPositionReportMessageColumnData : public AisMessageColumnData
    {
        Int32 altitude_ = 0;
        Int32 speedOverGround_ = 0;
        Data::PositionAccuracy positionAccuracy_ = Data::PositionAccuracy::Low;
        double longitude_ = 0.0;
        double latitude_ = 0.0;
        double courseOverGround_ = 0.0;
        Int32 timestamp_ = 0;
        Int32 reserved_ = 0;
        bool dataTerminalReady_ = false;
        Int32 spare_ = 0;
        bool assigned_ = false;
        Data::Raim raim_ = Data::Raim::NotInUse;
        Int32 radioStatus_ = 0;
    public:
        using Base = AisMessageColumnData;

        static constexpr std::wstring_view FieldNames = L"[Id],[RowVersion],[AisTransceiver],[ReceivedTimestamp],[MessageSequenceNumber],[Repeat],[Mmsi],[Altitude],[SpeedOverGround],[PositionAccuracy],[Longitude],[Latitude],[CourseOverGround],[Timestamp],[Reserved],[DataTerminalReady],[Spare],[Assigned],[Raim],[RadioStatus]";
        static constexpr std::wstring_view ViewName = L"AisStandardSarAircraftPositionReportMessageView";

        static constexpr SQLUSMALLINT ALTITUDE_FIELD_ID = 8;
        static constexpr SQLUSMALLINT SPEEDOVERGROUND_FIELD_ID = 9;
        static constexpr SQLUSMALLINT POSITIONACCURACY_FIELD_ID = 10;
        static constexpr SQLUSMALLINT LONGITUDE_FIELD_ID = 11;
        static constexpr SQLUSMALLINT LATITUDE_FIELD_ID = 12;
        static constexpr SQLUSMALLINT COURSEOVERGROUND_FIELD_ID = 13;
        static constexpr SQLUSMALLINT TIMESTAMP_FIELD_ID = 14;
        static constexpr SQLUSMALLINT RESERVED_FIELD_ID = 15;
        static constexpr SQLUSMALLINT DATATERMINALREADY_FIELD_ID = 16;
        static constexpr SQLUSMALLINT SPARE_FIELD_ID = 17;
        static constexpr SQLUSMALLINT ASSIGNED_FIELD_ID = 18;
        static constexpr SQLUSMALLINT RAIM_FIELD_ID = 19;
        static constexpr SQLUSMALLINT RADIOSTATUS_FIELD_ID = 20;

        AisStandardSarAircraftPositionReportMessageColumnData( ) = default;

        virtual Kind GetKind() const override
        {
            return Kind::AisStandardSarAircraftPositionReportMessage;
        }

        Int32 Altitude( ) const
        {
            return altitude_;
        }
        void SetAltitude( Int32 altitude )
        {
            altitude_ = altitude;
        }
        Int32 SpeedOverGround( ) const
        {
            return speedOverGround_;
        }
        void SetSpeedOverGround( Int32 speedOverGround )
        {
            speedOverGround_ = speedOverGround;
        }
        Data::PositionAccuracy PositionAccuracy( ) const
        {
            return positionAccuracy_;
        }
        void SetPositionAccuracy( Data::PositionAccuracy positionAccuracy )
        {
            positionAccuracy_ = positionAccuracy;
        }
        double Longitude( ) const
        {
            return longitude_;
        }
        void SetLongitude( double longitude )
        {
            longitude_ = longitude;
        }
        double Latitude( ) const
        {
            return latitude_;
        }
        void SetLatitude( double latitude )
        {
            latitude_ = latitude;
        }
        double CourseOverGround( ) const
        {
            return courseOverGround_;
        }
        void SetCourseOverGround( double courseOverGround )
        {
            courseOverGround_ = courseOverGround;
        }
        Int32 Timestamp( ) const
        {
            return timestamp_;
        }
        void SetTimestamp( Int32 timestamp )
        {
            timestamp_ = timestamp;
        }
        Int32 Reserved( ) const
        {
            return reserved_;
        }
        void SetReserved( Int32 reserved )
        {
            reserved_ = reserved;
        }
        bool DataTerminalReady( ) const
        {
            return dataTerminalReady_;
        }
        void SetDataTerminalReady( bool dataTerminalReady )
        {
            dataTerminalReady_ = dataTerminalReady;
        }
        Int32 Spare( ) const
        {
            return spare_;
        }
        void SetSpare( Int32 spare )
        {
            spare_ = spare;
        }
        bool Assigned( ) const
        {
            return assigned_;
        }
        void SetAssigned( bool assigned )
        {
            assigned_ = assigned;
        }
        Data::Raim Raim( ) const
        {
            return raim_;
        }
        void SetRaim( Data::Raim raim )
        {
            raim_ = raim;
        }
        Int32 RadioStatus( ) const
        {
            return radioStatus_;
        }
        void SetRadioStatus( Int32 radioStatus )
        {
            radioStatus_ = radioStatus;
        }
        void BindColumns( const ODBC::Statement& statement )
        {
            Base::BindColumns( statement );

            Bind(statement, ALTITUDE_FIELD_ID, altitude_);
            Bind(statement, SPEEDOVERGROUND_FIELD_ID, speedOverGround_);
            Bind(statement, POSITIONACCURACY_FIELD_ID, positionAccuracy_);
            Bind(statement, LONGITUDE_FIELD_ID, longitude_);
            Bind(statement, LATITUDE_FIELD_ID, latitude_);
            Bind(statement, COURSEOVERGROUND_FIELD_ID, courseOverGround_);
            Bind(statement, TIMESTAMP_FIELD_ID, timestamp_);
            Bind(statement, RESERVED_FIELD_ID, reserved_);
            Bind(statement, DATATERMINALREADY_FIELD_ID, dataTerminalReady_);
            Bind(statement, SPARE_FIELD_ID, spare_);
            Bind(statement, ASSIGNED_FIELD_ID, assigned_);
            Bind(statement, RAIM_FIELD_ID, raim_);
            Bind(statement, RADIOSTATUS_FIELD_ID, radioStatus_);
        }

        template<IO::StreamWriter StreamT>
        void WriteColumns( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteColumns( destination );
            WriteColumnValue( destination, altitude_);
            WriteColumnValue( destination, speedOverGround_);
            WriteColumnValue( destination, positionAccuracy_);
            WriteColumnValue( destination, longitude_);
            WriteColumnValue( destination, latitude_);
            WriteColumnValue( destination, courseOverGround_);
            WriteColumnValue( destination, timestamp_);
            WriteColumnValue( destination, reserved_);
            WriteColumnValue( destination, dataTerminalReady_);
            WriteColumnValue( destination, spare_);
            WriteColumnValue( destination, assigned_);
            WriteColumnValue( destination, raim_);
            WriteColumnValue( destination, radioStatus_);
        }
    };

    using SimpleAisStandardSarAircraftPositionReportMessageDataReader = SimpleColumnDataReader<AisStandardSarAircraftPositionReportMessageColumnData>;

    class AisStaticAndVoyageRelatedDataMessageColumnData : public AisMessageColumnData
    {
        Int32 aisVersion_ = 0;
        Guid imoNumber_;
        Guid callsign_;
        Guid shipName_;
        Data::ShipType shipType_ = Data::ShipType::NotAvailable;
        Int32 dimensionToBow_ = 0;
        Int32 dimensionToStern_ = 0;
        Int32 dimensionToPort_ = 0;
        Int32 dimensionToStarboard_ = 0;
        Data::PositionFixType positionFixType_ = Data::PositionFixType::Undefined1;
        DBDateTime estimatedTimeOfArrival_;
        double draught_ = 0.0;
        FixedDBWideString<100> destination_;
        bool dataTerminalReady_ = false;
        Int32 spare_ = 0;
    public:
        using Base = AisMessageColumnData;

        static constexpr std::wstring_view FieldNames = L"[Id],[RowVersion],[AisTransceiver],[ReceivedTimestamp],[MessageSequenceNumber],[Repeat],[Mmsi],[AisVersion],[ImoNumber],[Callsign],[ShipName],[ShipType],[DimensionToBow],[DimensionToStern],[DimensionToPort],[DimensionToStarboard],[PositionFixType],[EstimatedTimeOfArrival],[Draught],[Destination],[DataTerminalReady],[Spare]";
        static constexpr std::wstring_view ViewName = L"AisStaticAndVoyageRelatedDataMessageView";

        static constexpr SQLUSMALLINT AISVERSION_FIELD_ID = 8;
        static constexpr SQLUSMALLINT IMONUMBER_FIELD_ID = 9;
        static constexpr SQLUSMALLINT CALLSIGN_FIELD_ID = 10;
        static constexpr SQLUSMALLINT SHIPNAME_FIELD_ID = 11;
        static constexpr SQLUSMALLINT SHIPTYPE_FIELD_ID = 12;
        static constexpr SQLUSMALLINT DIMENSIONTOBOW_FIELD_ID = 13;
        static constexpr SQLUSMALLINT DIMENSIONTOSTERN_FIELD_ID = 14;
        static constexpr SQLUSMALLINT DIMENSIONTOPORT_FIELD_ID = 15;
        static constexpr SQLUSMALLINT DIMENSIONTOSTARBOARD_FIELD_ID = 16;
        static constexpr SQLUSMALLINT POSITIONFIXTYPE_FIELD_ID = 17;
        static constexpr SQLUSMALLINT ESTIMATEDTIMEOFARRIVAL_FIELD_ID = 18;
        static constexpr SQLUSMALLINT DRAUGHT_FIELD_ID = 19;
        static constexpr SQLUSMALLINT DESTINATION_FIELD_ID = 20;
        static constexpr SQLUSMALLINT DATATERMINALREADY_FIELD_ID = 21;
        static constexpr SQLUSMALLINT SPARE_FIELD_ID = 22;

        AisStaticAndVoyageRelatedDataMessageColumnData( ) = default;

        virtual Kind GetKind() const override
        {
            return Kind::AisStaticAndVoyageRelatedDataMessage;
        }

        Int32 AisVersion( ) const
        {
            return aisVersion_;
        }
        void SetAisVersion( Int32 aisVersion )
        {
            aisVersion_ = aisVersion;
        }
        const Guid& ImoNumber( ) const
        {
            return imoNumber_;
        }
        void SetImoNumber( const Guid& imoNumber )
        {
            imoNumber_ = imoNumber;
        }
        const Guid& Callsign( ) const
        {
            return callsign_;
        }
        void SetCallsign( const Guid& callsign )
        {
            callsign_ = callsign;
        }
        const Guid& ShipName( ) const
        {
            return shipName_;
        }
        void SetShipName( const Guid& shipName )
        {
            shipName_ = shipName;
        }
        Data::ShipType ShipType( ) const
        {
            return shipType_;
        }
        void SetShipType( Data::ShipType shipType )
        {
            shipType_ = shipType;
        }
        Int32 DimensionToBow( ) const
        {
            return dimensionToBow_;
        }
        void SetDimensionToBow( Int32 dimensionToBow )
        {
            dimensionToBow_ = dimensionToBow;
        }
        Int32 DimensionToStern( ) const
        {
            return dimensionToStern_;
        }
        void SetDimensionToStern( Int32 dimensionToStern )
        {
            dimensionToStern_ = dimensionToStern;
        }
        Int32 DimensionToPort( ) const
        {
            return dimensionToPort_;
        }
        void SetDimensionToPort( Int32 dimensionToPort )
        {
            dimensionToPort_ = dimensionToPort;
        }
        Int32 DimensionToStarboard( ) const
        {
            return dimensionToStarboard_;
        }
        void SetDimensionToStarboard( Int32 dimensionToStarboard )
        {
            dimensionToStarboard_ = dimensionToStarboard;
        }
        Data::PositionFixType PositionFixType( ) const
        {
            return positionFixType_;
        }
        void SetPositionFixType( Data::PositionFixType positionFixType )
        {
            positionFixType_ = positionFixType;
        }
        const DBDateTime& EstimatedTimeOfArrival( ) const
        {
            return estimatedTimeOfArrival_;
        }
        void SetEstimatedTimeOfArrival( const DBDateTime& estimatedTimeOfArrival )
        {
            estimatedTimeOfArrival_ = estimatedTimeOfArrival;
        }
        double Draught( ) const
        {
            return draught_;
        }
        void SetDraught( double draught )
        {
            draught_ = draught;
        }
        const FixedDBWideString<100>& Destination( ) const
        {
            return destination_;
        }
        void SetDestination( const WideString& destination )
        {
            destination_ = destination;
        }
        bool DataTerminalReady( ) const
        {
            return dataTerminalReady_;
        }
        void SetDataTerminalReady( bool dataTerminalReady )
        {
            dataTerminalReady_ = dataTerminalReady;
        }
        Int32 Spare( ) const
        {
            return spare_;
        }
        void SetSpare( Int32 spare )
        {
            spare_ = spare;
        }
        void BindColumns( const ODBC::Statement& statement )
        {
            Base::BindColumns( statement );

            Bind(statement, AISVERSION_FIELD_ID, aisVersion_);
            Bind(statement, IMONUMBER_FIELD_ID, imoNumber_);
            Bind(statement, CALLSIGN_FIELD_ID, callsign_);
            Bind(statement, SHIPNAME_FIELD_ID, shipName_);
            Bind(statement, SHIPTYPE_FIELD_ID, shipType_);
            Bind(statement, DIMENSIONTOBOW_FIELD_ID, dimensionToBow_);
            Bind(statement, DIMENSIONTOSTERN_FIELD_ID, dimensionToStern_);
            Bind(statement, DIMENSIONTOPORT_FIELD_ID, dimensionToPort_);
            Bind(statement, DIMENSIONTOSTARBOARD_FIELD_ID, dimensionToStarboard_);
            Bind(statement, POSITIONFIXTYPE_FIELD_ID, positionFixType_);
            Bind(statement, ESTIMATEDTIMEOFARRIVAL_FIELD_ID, estimatedTimeOfArrival_);
            Bind(statement, DRAUGHT_FIELD_ID, draught_);
            Bind(statement, DESTINATION_FIELD_ID, destination_);
            Bind(statement, DATATERMINALREADY_FIELD_ID, dataTerminalReady_);
            Bind(statement, SPARE_FIELD_ID, spare_);
        }

        template<IO::StreamWriter StreamT>
        void WriteColumns( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteColumns( destination );
            WriteColumnValue( destination, aisVersion_);
            WriteColumnValue( destination, imoNumber_);
            WriteColumnValue( destination, callsign_);
            WriteColumnValue( destination, shipName_);
            WriteColumnValue( destination, shipType_);
            WriteColumnValue( destination, dimensionToBow_);
            WriteColumnValue( destination, dimensionToStern_);
            WriteColumnValue( destination, dimensionToPort_);
            WriteColumnValue( destination, dimensionToStarboard_);
            WriteColumnValue( destination, positionFixType_);
            WriteColumnValue( destination, estimatedTimeOfArrival_);
            WriteColumnValue( destination, draught_);
            WriteColumnValue( destination, destination_);
            WriteColumnValue( destination, dataTerminalReady_);
            WriteColumnValue( destination, spare_);
        }
    };

    using SimpleAisStaticAndVoyageRelatedDataMessageDataReader = SimpleColumnDataReader<AisStaticAndVoyageRelatedDataMessageColumnData>;

    class AisStaticDataReportMessageColumnData : public AisMessageColumnData
    {
        Int32 partNumber_ = 0;
    public:
        using Base = AisMessageColumnData;

        static constexpr std::wstring_view FieldNames = L"[Id],[RowVersion],[AisTransceiver],[ReceivedTimestamp],[MessageSequenceNumber],[Repeat],[Mmsi],[PartNumber]";
        static constexpr std::wstring_view ViewName = L"AisStaticDataReportMessageView";

        static constexpr SQLUSMALLINT PARTNUMBER_FIELD_ID = 8;

        AisStaticDataReportMessageColumnData( ) = default;

        virtual Kind GetKind() const override
        {
            return Kind::AisStaticDataReportMessage;
        }

        Int32 PartNumber( ) const
        {
            return partNumber_;
        }
        void SetPartNumber( Int32 partNumber )
        {
            partNumber_ = partNumber;
        }
        void BindColumns( const ODBC::Statement& statement )
        {
            Base::BindColumns( statement );

            Bind(statement, PARTNUMBER_FIELD_ID, partNumber_);
        }

        template<IO::StreamWriter StreamT>
        void WriteColumns( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteColumns( destination );
            WriteColumnValue( destination, partNumber_);
        }
    };

    using SimpleAisStaticDataReportMessageDataReader = SimpleColumnDataReader<AisStaticDataReportMessageColumnData>;

    class AisStaticDataReportPartAMessageColumnData : public AisStaticDataReportMessageColumnData
    {
        Guid shipName_;
        Int32 spare_ = 0;
    public:
        using Base = AisStaticDataReportMessageColumnData;

        static constexpr std::wstring_view FieldNames = L"[Id],[RowVersion],[AisTransceiver],[ReceivedTimestamp],[MessageSequenceNumber],[Repeat],[Mmsi],[PartNumber],[ShipName],[Spare]";
        static constexpr std::wstring_view ViewName = L"AisStaticDataReportPartAMessageView";

        static constexpr SQLUSMALLINT SHIPNAME_FIELD_ID = 9;
        static constexpr SQLUSMALLINT SPARE_FIELD_ID = 10;

        AisStaticDataReportPartAMessageColumnData( ) = default;

        virtual Kind GetKind() const override
        {
            return Kind::AisStaticDataReportPartAMessage;
        }

        const Guid& ShipName( ) const
        {
            return shipName_;
        }
        void SetShipName( const Guid& shipName )
        {
            shipName_ = shipName;
        }
        Int32 Spare( ) const
        {
            return spare_;
        }
        void SetSpare( Int32 spare )
        {
            spare_ = spare;
        }
        void BindColumns( const ODBC::Statement& statement )
        {
            Base::BindColumns( statement );

            Bind(statement, SHIPNAME_FIELD_ID, shipName_);
            Bind(statement, SPARE_FIELD_ID, spare_);
        }

        template<IO::StreamWriter StreamT>
        void WriteColumns( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteColumns( destination );
            WriteColumnValue( destination, shipName_);
            WriteColumnValue( destination, spare_);
        }
    };

    using SimpleAisStaticDataReportPartAMessageDataReader = SimpleColumnDataReader<AisStaticDataReportPartAMessageColumnData>;

    class AisStaticDataReportPartBMessageColumnData : public AisStaticDataReportMessageColumnData
    {
        Data::ShipType shipType_ = Data::ShipType::NotAvailable;
        FixedDBWideString<100> vendorId_;
        Int32 unitModelCode_ = 0;
        Int32 serialNumber_ = 0;
        Guid callsign_;
        Int32 dimensionToBow_ = 0;
        Int32 dimensionToStern_ = 0;
        Int32 dimensionToPort_ = 0;
        Int32 dimensionToStarboard_ = 0;
        Guid mothershipMmsi_;
        Data::PositionFixType positionFixType_ = Data::PositionFixType::Undefined1;
        Int32 spare_ = 0;
    public:
        using Base = AisStaticDataReportMessageColumnData;

        static constexpr std::wstring_view FieldNames = L"[Id],[RowVersion],[AisTransceiver],[ReceivedTimestamp],[MessageSequenceNumber],[Repeat],[Mmsi],[PartNumber],[ShipType],[VendorId],[UnitModelCode],[SerialNumber],[Callsign],[DimensionToBow],[DimensionToStern],[DimensionToPort],[DimensionToStarboard],[MothershipMmsi],[PositionFixType],[Spare]";
        static constexpr std::wstring_view ViewName = L"AisStaticDataReportPartBMessageView";

        static constexpr SQLUSMALLINT SHIPTYPE_FIELD_ID = 9;
        static constexpr SQLUSMALLINT VENDORID_FIELD_ID = 10;
        static constexpr SQLUSMALLINT UNITMODELCODE_FIELD_ID = 11;
        static constexpr SQLUSMALLINT SERIALNUMBER_FIELD_ID = 12;
        static constexpr SQLUSMALLINT CALLSIGN_FIELD_ID = 13;
        static constexpr SQLUSMALLINT DIMENSIONTOBOW_FIELD_ID = 14;
        static constexpr SQLUSMALLINT DIMENSIONTOSTERN_FIELD_ID = 15;
        static constexpr SQLUSMALLINT DIMENSIONTOPORT_FIELD_ID = 16;
        static constexpr SQLUSMALLINT DIMENSIONTOSTARBOARD_FIELD_ID = 17;
        static constexpr SQLUSMALLINT MOTHERSHIPMMSI_FIELD_ID = 18;
        static constexpr SQLUSMALLINT POSITIONFIXTYPE_FIELD_ID = 19;
        static constexpr SQLUSMALLINT SPARE_FIELD_ID = 20;

        AisStaticDataReportPartBMessageColumnData( ) = default;

        virtual Kind GetKind() const override
        {
            return Kind::AisStaticDataReportPartBMessage;
        }

        Data::ShipType ShipType( ) const
        {
            return shipType_;
        }
        void SetShipType( Data::ShipType shipType )
        {
            shipType_ = shipType;
        }
        const FixedDBWideString<100>& VendorId( ) const
        {
            return vendorId_;
        }
        void SetVendorId( const WideString& vendorId )
        {
            vendorId_ = vendorId;
        }
        Int32 UnitModelCode( ) const
        {
            return unitModelCode_;
        }
        void SetUnitModelCode( Int32 unitModelCode )
        {
            unitModelCode_ = unitModelCode;
        }
        Int32 SerialNumber( ) const
        {
            return serialNumber_;
        }
        void SetSerialNumber( Int32 serialNumber )
        {
            serialNumber_ = serialNumber;
        }
        const Guid& Callsign( ) const
        {
            return callsign_;
        }
        void SetCallsign( const Guid& callsign )
        {
            callsign_ = callsign;
        }
        Int32 DimensionToBow( ) const
        {
            return dimensionToBow_;
        }
        void SetDimensionToBow( Int32 dimensionToBow )
        {
            dimensionToBow_ = dimensionToBow;
        }
        Int32 DimensionToStern( ) const
        {
            return dimensionToStern_;
        }
        void SetDimensionToStern( Int32 dimensionToStern )
        {
            dimensionToStern_ = dimensionToStern;
        }
        Int32 DimensionToPort( ) const
        {
            return dimensionToPort_;
        }
        void SetDimensionToPort( Int32 dimensionToPort )
        {
            dimensionToPort_ = dimensionToPort;
        }
        Int32 DimensionToStarboard( ) const
        {
            return dimensionToStarboard_;
        }
        void SetDimensionToStarboard( Int32 dimensionToStarboard )
        {
            dimensionToStarboard_ = dimensionToStarboard;
        }
        const Guid& MothershipMmsi( ) const
        {
            return mothershipMmsi_;
        }
        void SetMothershipMmsi( const Guid& mothershipMmsi )
        {
            mothershipMmsi_ = mothershipMmsi;
        }
        Data::PositionFixType PositionFixType( ) const
        {
            return positionFixType_;
        }
        void SetPositionFixType( Data::PositionFixType positionFixType )
        {
            positionFixType_ = positionFixType;
        }
        Int32 Spare( ) const
        {
            return spare_;
        }
        void SetSpare( Int32 spare )
        {
            spare_ = spare;
        }
        void BindColumns( const ODBC::Statement& statement )
        {
            Base::BindColumns( statement );

            Bind(statement, SHIPTYPE_FIELD_ID, shipType_);
            Bind(statement, VENDORID_FIELD_ID, vendorId_);
            Bind(statement, UNITMODELCODE_FIELD_ID, unitModelCode_);
            Bind(statement, SERIALNUMBER_FIELD_ID, serialNumber_);
            Bind(statement, CALLSIGN_FIELD_ID, callsign_);
            Bind(statement, DIMENSIONTOBOW_FIELD_ID, dimensionToBow_);
            Bind(statement, DIMENSIONTOSTERN_FIELD_ID, dimensionToStern_);
            Bind(statement, DIMENSIONTOPORT_FIELD_ID, dimensionToPort_);
            Bind(statement, DIMENSIONTOSTARBOARD_FIELD_ID, dimensionToStarboard_);
            Bind(statement, MOTHERSHIPMMSI_FIELD_ID, mothershipMmsi_);
            Bind(statement, POSITIONFIXTYPE_FIELD_ID, positionFixType_);
            Bind(statement, SPARE_FIELD_ID, spare_);
        }

        template<IO::StreamWriter StreamT>
        void WriteColumns( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteColumns( destination );
            WriteColumnValue( destination, shipType_);
            WriteColumnValue( destination, vendorId_);
            WriteColumnValue( destination, unitModelCode_);
            WriteColumnValue( destination, serialNumber_);
            WriteColumnValue( destination, callsign_);
            WriteColumnValue( destination, dimensionToBow_);
            WriteColumnValue( destination, dimensionToStern_);
            WriteColumnValue( destination, dimensionToPort_);
            WriteColumnValue( destination, dimensionToStarboard_);
            WriteColumnValue( destination, mothershipMmsi_);
            WriteColumnValue( destination, positionFixType_);
            WriteColumnValue( destination, spare_);
        }
    };

    using SimpleAisStaticDataReportPartBMessageDataReader = SimpleColumnDataReader<AisStaticDataReportPartBMessageColumnData>;

    class AisUtcAndDateInquiryMessageColumnData : public AisMessageColumnData
    {
        Int32 spare1_ = 0;
        Int32 destinationMmsi_ = 0;
        Int32 spare2_ = 0;
    public:
        using Base = AisMessageColumnData;

        static constexpr std::wstring_view FieldNames = L"[Id],[RowVersion],[AisTransceiver],[ReceivedTimestamp],[MessageSequenceNumber],[Repeat],[Mmsi],[Spare1],[DestinationMmsi],[Spare2]";
        static constexpr std::wstring_view ViewName = L"AisUtcAndDateInquiryMessageView";

        static constexpr SQLUSMALLINT SPARE1_FIELD_ID = 8;
        static constexpr SQLUSMALLINT DESTINATIONMMSI_FIELD_ID = 9;
        static constexpr SQLUSMALLINT SPARE2_FIELD_ID = 10;

        AisUtcAndDateInquiryMessageColumnData( ) = default;

        virtual Kind GetKind() const override
        {
            return Kind::AisUtcAndDateInquiryMessage;
        }

        Int32 Spare1( ) const
        {
            return spare1_;
        }
        void SetSpare1( Int32 spare1 )
        {
            spare1_ = spare1;
        }
        Int32 DestinationMmsi( ) const
        {
            return destinationMmsi_;
        }
        void SetDestinationMmsi( Int32 destinationMmsi )
        {
            destinationMmsi_ = destinationMmsi;
        }
        Int32 Spare2( ) const
        {
            return spare2_;
        }
        void SetSpare2( Int32 spare2 )
        {
            spare2_ = spare2;
        }
        void BindColumns( const ODBC::Statement& statement )
        {
            Base::BindColumns( statement );

            Bind(statement, SPARE1_FIELD_ID, spare1_);
            Bind(statement, DESTINATIONMMSI_FIELD_ID, destinationMmsi_);
            Bind(statement, SPARE2_FIELD_ID, spare2_);
        }

        template<IO::StreamWriter StreamT>
        void WriteColumns( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteColumns( destination );
            WriteColumnValue( destination, spare1_);
            WriteColumnValue( destination, destinationMmsi_);
            WriteColumnValue( destination, spare2_);
        }
    };

    using SimpleAisUtcAndDateInquiryMessageDataReader = SimpleColumnDataReader<AisUtcAndDateInquiryMessageColumnData>;

    class AisUtcAndDateResponseMessageColumnData : public AisMessageColumnData
    {
        DateTime datetime_;
        Data::PositionAccuracy positionAccuracy_ = Data::PositionAccuracy::Low;
        double longitude_ = 0.0;
        double latitude_ = 0.0;
        Data::PositionFixType positionFixType_ = Data::PositionFixType::Undefined1;
        Int32 spare_ = 0;
        Data::Raim raim_ = Data::Raim::NotInUse;
        Int32 radioStatus_ = 0;
    public:
        using Base = AisMessageColumnData;

        static constexpr std::wstring_view FieldNames = L"[Id],[RowVersion],[AisTransceiver],[ReceivedTimestamp],[MessageSequenceNumber],[Repeat],[Mmsi],[Datetime],[PositionAccuracy],[Longitude],[Latitude],[PositionFixType],[Spare],[Raim],[RadioStatus]";
        static constexpr std::wstring_view ViewName = L"AisUtcAndDateResponseMessageView";

        static constexpr SQLUSMALLINT DATETIME_FIELD_ID = 8;
        static constexpr SQLUSMALLINT POSITIONACCURACY_FIELD_ID = 9;
        static constexpr SQLUSMALLINT LONGITUDE_FIELD_ID = 10;
        static constexpr SQLUSMALLINT LATITUDE_FIELD_ID = 11;
        static constexpr SQLUSMALLINT POSITIONFIXTYPE_FIELD_ID = 12;
        static constexpr SQLUSMALLINT SPARE_FIELD_ID = 13;
        static constexpr SQLUSMALLINT RAIM_FIELD_ID = 14;
        static constexpr SQLUSMALLINT RADIOSTATUS_FIELD_ID = 15;

        AisUtcAndDateResponseMessageColumnData( ) = default;

        virtual Kind GetKind() const override
        {
            return Kind::AisUtcAndDateResponseMessage;
        }

        const DateTime& Datetime( ) const
        {
            return datetime_;
        }
        void SetDatetime( const DateTime& datetime )
        {
            datetime_ = datetime;
        }
        Data::PositionAccuracy PositionAccuracy( ) const
        {
            return positionAccuracy_;
        }
        void SetPositionAccuracy( Data::PositionAccuracy positionAccuracy )
        {
            positionAccuracy_ = positionAccuracy;
        }
        double Longitude( ) const
        {
            return longitude_;
        }
        void SetLongitude( double longitude )
        {
            longitude_ = longitude;
        }
        double Latitude( ) const
        {
            return latitude_;
        }
        void SetLatitude( double latitude )
        {
            latitude_ = latitude;
        }
        Data::PositionFixType PositionFixType( ) const
        {
            return positionFixType_;
        }
        void SetPositionFixType( Data::PositionFixType positionFixType )
        {
            positionFixType_ = positionFixType;
        }
        Int32 Spare( ) const
        {
            return spare_;
        }
        void SetSpare( Int32 spare )
        {
            spare_ = spare;
        }
        Data::Raim Raim( ) const
        {
            return raim_;
        }
        void SetRaim( Data::Raim raim )
        {
            raim_ = raim;
        }
        Int32 RadioStatus( ) const
        {
            return radioStatus_;
        }
        void SetRadioStatus( Int32 radioStatus )
        {
            radioStatus_ = radioStatus;
        }
        void BindColumns( const ODBC::Statement& statement )
        {
            Base::BindColumns( statement );

            Bind(statement, DATETIME_FIELD_ID, datetime_);
            Bind(statement, POSITIONACCURACY_FIELD_ID, positionAccuracy_);
            Bind(statement, LONGITUDE_FIELD_ID, longitude_);
            Bind(statement, LATITUDE_FIELD_ID, latitude_);
            Bind(statement, POSITIONFIXTYPE_FIELD_ID, positionFixType_);
            Bind(statement, SPARE_FIELD_ID, spare_);
            Bind(statement, RAIM_FIELD_ID, raim_);
            Bind(statement, RADIOSTATUS_FIELD_ID, radioStatus_);
        }

        template<IO::StreamWriter StreamT>
        void WriteColumns( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteColumns( destination );
            WriteColumnValue( destination, datetime_);
            WriteColumnValue( destination, positionAccuracy_);
            WriteColumnValue( destination, longitude_);
            WriteColumnValue( destination, latitude_);
            WriteColumnValue( destination, positionFixType_);
            WriteColumnValue( destination, spare_);
            WriteColumnValue( destination, raim_);
            WriteColumnValue( destination, radioStatus_);
        }
    };

    using SimpleAisUtcAndDateResponseMessageDataReader = SimpleColumnDataReader<AisUtcAndDateResponseMessageColumnData>;

    class AisTransceiverCommandColumnData : public BaseColumnData
    {
        Guid id_;
        Int64 rowVersion_ = 0;
        Guid aisTransceiver_;
        DateTime timestamp_;
        Data::DeviceCommandSourceType deviceCommandSourceType_ = Data::DeviceCommandSourceType::Unknown;
        Guid deviceCommandSourceId_;
        Guid reply_;
    public:
        using Base = BaseColumnData;

        static constexpr std::wstring_view FieldNames = L"[Id],[RowVersion],[AisTransceiver],[Timestamp],[DeviceCommandSourceType],[DeviceCommandSourceId],[Reply]";
        static constexpr std::wstring_view ViewName = L"AisTransceiverCommandView";

        static constexpr SQLUSMALLINT ID_FIELD_ID = 1;
        static constexpr SQLUSMALLINT ROWVERSION_FIELD_ID = 2;
        static constexpr SQLUSMALLINT AISTRANSCEIVER_FIELD_ID = 3;
        static constexpr SQLUSMALLINT TIMESTAMP_FIELD_ID = 4;
        static constexpr SQLUSMALLINT DEVICECOMMANDSOURCETYPE_FIELD_ID = 5;
        static constexpr SQLUSMALLINT DEVICECOMMANDSOURCEID_FIELD_ID = 6;
        static constexpr SQLUSMALLINT REPLY_FIELD_ID = 7;

        AisTransceiverCommandColumnData( ) = default;

        virtual Kind GetKind() const override
        {
            return Kind::AisTransceiverCommand;
        }

        const Guid& Id( ) const
        {
            return id_;
        }
        void SetId( const Guid& id )
        {
            id_ = id;
        }
        Int64 RowVersion( ) const
        {
            return rowVersion_;
        }
        void SetRowVersion( const Int64& rowVersion )
        {
            rowVersion_ = rowVersion;
        }
        const Guid& AisTransceiver( ) const
        {
            return aisTransceiver_;
        }
        void SetAisTransceiver( const Guid& aisTransceiver )
        {
            aisTransceiver_ = aisTransceiver;
        }
        const DateTime& Timestamp( ) const
        {
            return timestamp_;
        }
        void SetTimestamp( const DateTime& timestamp )
        {
            timestamp_ = timestamp;
        }
        Data::DeviceCommandSourceType DeviceCommandSourceType( ) const
        {
            return deviceCommandSourceType_;
        }
        void SetDeviceCommandSourceType( Data::DeviceCommandSourceType deviceCommandSourceType )
        {
            deviceCommandSourceType_ = deviceCommandSourceType;
        }
        const Guid& DeviceCommandSourceId( ) const
        {
            return deviceCommandSourceId_;
        }
        void SetDeviceCommandSourceId( const Guid& deviceCommandSourceId )
        {
            deviceCommandSourceId_ = deviceCommandSourceId;
        }
        const Guid& Reply( ) const
        {
            return reply_;
        }
        void SetReply( const Guid& reply )
        {
            reply_ = reply;
        }
        void BindColumns( const ODBC::Statement& statement )
        {
            Bind(statement, ID_FIELD_ID, id_);
            Bind(statement, ROWVERSION_FIELD_ID, rowVersion_);
            Bind(statement, AISTRANSCEIVER_FIELD_ID, aisTransceiver_);
            Bind(statement, TIMESTAMP_FIELD_ID, timestamp_);
            Bind(statement, DEVICECOMMANDSOURCETYPE_FIELD_ID, deviceCommandSourceType_);
            Bind(statement, DEVICECOMMANDSOURCEID_FIELD_ID, deviceCommandSourceId_);
            Bind(statement, REPLY_FIELD_ID, reply_);
        }

        template<IO::StreamWriter StreamT>
        void WriteColumns( IO::BinaryWriter<StreamT>& destination ) const
        {
            WriteColumnValue( destination, id_);
            WriteColumnValue( destination, rowVersion_);
            WriteColumnValue( destination, aisTransceiver_);
            WriteColumnValue( destination, timestamp_);
            WriteColumnValue( destination, deviceCommandSourceType_);
            WriteColumnValue( destination, deviceCommandSourceId_);
            WriteColumnValue( destination, reply_);
        }
    };

    using SimpleAisTransceiverCommandDataReader = SimpleColumnDataReader<AisTransceiverCommandColumnData>;

    class AisTransceiverCommandReplyColumnData : public BaseColumnData
    {
        Guid id_;
        Int64 rowVersion_ = 0;
        Guid aisTransceiver_;
        DateTime timestamp_;
        Guid command_;
        Data::DeviceCommandReplyStatus status_ = Data::DeviceCommandReplyStatus::Unknown;
        WideString message_;
        SQLLEN messageLength_ = SQL_NULL_DATA;
    public:
        using Base = BaseColumnData;

        static constexpr std::wstring_view FieldNames = L"[Id],[RowVersion],[AisTransceiver],[Timestamp],[Command],[Status],[Message]";
        static constexpr std::wstring_view ViewName = L"AisTransceiverCommandReplyView";

        static constexpr SQLUSMALLINT ID_FIELD_ID = 1;
        static constexpr SQLUSMALLINT ROWVERSION_FIELD_ID = 2;
        static constexpr SQLUSMALLINT AISTRANSCEIVER_FIELD_ID = 3;
        static constexpr SQLUSMALLINT TIMESTAMP_FIELD_ID = 4;
        static constexpr SQLUSMALLINT COMMAND_FIELD_ID = 5;
        static constexpr SQLUSMALLINT STATUS_FIELD_ID = 6;
        static constexpr SQLUSMALLINT MESSAGE_FIELD_ID = 7;

        AisTransceiverCommandReplyColumnData( ) = default;

        virtual Kind GetKind() const override
        {
            return Kind::AisTransceiverCommandReply;
        }

        const Guid& Id( ) const
        {
            return id_;
        }
        void SetId( const Guid& id )
        {
            id_ = id;
        }
        Int64 RowVersion( ) const
        {
            return rowVersion_;
        }
        void SetRowVersion( const Int64& rowVersion )
        {
            rowVersion_ = rowVersion;
        }
        const Guid& AisTransceiver( ) const
        {
            return aisTransceiver_;
        }
        void SetAisTransceiver( const Guid& aisTransceiver )
        {
            aisTransceiver_ = aisTransceiver;
        }
        const DateTime& Timestamp( ) const
        {
            return timestamp_;
        }
        void SetTimestamp( const DateTime& timestamp )
        {
            timestamp_ = timestamp;
        }
        const Guid& Command( ) const
        {
            return command_;
        }
        void SetCommand( const Guid& command )
        {
            command_ = command;
        }
        Data::DeviceCommandReplyStatus Status( ) const
        {
            return status_;
        }
        void SetStatus( Data::DeviceCommandReplyStatus status )
        {
            status_ = status;
        }
        const WideString& Message( ) const
        {
            return message_;
        }
        void SetMessage( const WideString& message )
        {
            message_ = message;
        }
        void BindColumns( const ODBC::Statement& statement )
        {
            Bind(statement, ID_FIELD_ID, id_);
            Bind(statement, ROWVERSION_FIELD_ID, rowVersion_);
            Bind(statement, AISTRANSCEIVER_FIELD_ID, aisTransceiver_);
            Bind(statement, TIMESTAMP_FIELD_ID, timestamp_);
            Bind(statement, COMMAND_FIELD_ID, command_);
            Bind(statement, STATUS_FIELD_ID, status_);
        }

        void ReadUnboundData( const ODBC::Statement& statement )
        {
            Base::ReadUnboundData( statement );

            message_ = statement.GetWideString(MESSAGE_FIELD_ID);
        }
        template<IO::StreamWriter StreamT>
        void WriteColumns( IO::BinaryWriter<StreamT>& destination ) const
        {
            WriteColumnValue( destination, id_);
            WriteColumnValue( destination, rowVersion_);
            WriteColumnValue( destination, aisTransceiver_);
            WriteColumnValue( destination, timestamp_);
            WriteColumnValue( destination, command_);
            WriteColumnValue( destination, status_);
            WriteColumnValue( destination, message_);
        }
    };

    using SimpleAisTransceiverCommandReplyDataReader = SimpleColumnDataReader<AisTransceiverCommandReplyColumnData>;

    class AisTransceiverConfigurationColumnData : public BaseColumnData
    {
        Guid id_;
        Int64 rowVersion_ = 0;
        Guid aisTransceiver_;
        DateTime timestamp_;
        FixedDBWideString<127> userName_;
        FixedDBWideString<127> password_;
        double latitude_ = 0.0;
        double longitude_ = 0.0;
        FixedDBWideString<127> aisProviderLoginURL_;
        FixedDBWideString<32> comPort_;
        Int32 baudRate_ = 0;
        bool filterByArea_ = false;
        double upperLeftCornerLatitude_ = 0.0;
        double upperLeftCornerLongitude_ = 0.0;
        double bottomRightCornerLatitude_ = 0.0;
        double bottomRightCornerLongitude_ = 0.0;
        FixedDBWideString<127> aisProviderIPAddress_;
        Int32 aisProviderPort_ = 0;
        bool useLogin_ = false;
        Int32 aisProviderLoginPort_ = 0;
        bool canSendAISMessage_ = false;
        WideString textMessageHeader_;
        SQLLEN textMessageHeaderLength_ = SQL_NULL_DATA;
        WideString urls_;
        SQLLEN urlsLength_ = SQL_NULL_DATA;
        Int32 udpPort_ = 0;
        Data::AisTransceiverConnectionType connectionType_ = Data::AisTransceiverConnectionType::Unknown;
        bool enableRefreshAidToNavigationIn30sec_ = false;
        bool enableAidToNavigationFromFile_ = false;
        WideString aidToNavigationHeader_;
        SQLLEN aidToNavigationHeaderLength_ = SQL_NULL_DATA;
        bool sendingMMSI_ = false;
        Int32 sourceUpdateRate_ = 0;
        bool enableRefreshStayingStillTargetIn30sec_ = false;
        WideString excludeSendAisBaseStation_;
        SQLLEN excludeSendAisBaseStationLength_ = SQL_NULL_DATA;
        WideString excludeSendAisA_;
        SQLLEN excludeSendAisALength_ = SQL_NULL_DATA;
        bool enableSendBaseStationAlarms_ = false;
        FixedDBWideString<127> aisWebConfig_;
        bool storeReceivedSentences_ = false;
        bool storeSentMessages_ = false;
        bool storeUnsentMessages_ = false;
    public:
        using Base = BaseColumnData;

        static constexpr std::wstring_view FieldNames = L"[Id],[RowVersion],[AisTransceiver],[Timestamp],[UserName],[Password],[Latitude],[Longitude],[AisProviderLoginURL],[ComPort],[BaudRate],[FilterByArea],[UpperLeftCornerLatitude],[UpperLeftCornerLongitude],[BottomRightCornerLatitude],[BottomRightCornerLongitude],[AisProviderIPAddress],[AisProviderPort],[UseLogin],[AisProviderLoginPort],[CanSendAISMessage],[UdpPort],[ConnectionType],[EnableRefreshAidToNavigationIn30sec],[EnableAidToNavigationFromFile],[SendingMMSI],[SourceUpdateRate],[EnableRefreshStayingStillTargetIn30sec],[EnableSendBaseStationAlarms],[AisWebConfig],[StoreReceivedSentences],[StoreSentMessages],[StoreUnsentMessages],[TextMessageHeader],[Urls],[AidToNavigationHeader],[ExcludeSendAisBaseStation],[ExcludeSendAisA]";
        static constexpr std::wstring_view ViewName = L"AisTransceiverConfigurationView";

        static constexpr SQLUSMALLINT ID_FIELD_ID = 1;
        static constexpr SQLUSMALLINT ROWVERSION_FIELD_ID = 2;
        static constexpr SQLUSMALLINT AISTRANSCEIVER_FIELD_ID = 3;
        static constexpr SQLUSMALLINT TIMESTAMP_FIELD_ID = 4;
        static constexpr SQLUSMALLINT USERNAME_FIELD_ID = 5;
        static constexpr SQLUSMALLINT PASSWORD_FIELD_ID = 6;
        static constexpr SQLUSMALLINT LATITUDE_FIELD_ID = 7;
        static constexpr SQLUSMALLINT LONGITUDE_FIELD_ID = 8;
        static constexpr SQLUSMALLINT AISPROVIDERLOGINURL_FIELD_ID = 9;
        static constexpr SQLUSMALLINT COMPORT_FIELD_ID = 10;
        static constexpr SQLUSMALLINT BAUDRATE_FIELD_ID = 11;
        static constexpr SQLUSMALLINT FILTERBYAREA_FIELD_ID = 12;
        static constexpr SQLUSMALLINT UPPERLEFTCORNERLATITUDE_FIELD_ID = 13;
        static constexpr SQLUSMALLINT UPPERLEFTCORNERLONGITUDE_FIELD_ID = 14;
        static constexpr SQLUSMALLINT BOTTOMRIGHTCORNERLATITUDE_FIELD_ID = 15;
        static constexpr SQLUSMALLINT BOTTOMRIGHTCORNERLONGITUDE_FIELD_ID = 16;
        static constexpr SQLUSMALLINT AISPROVIDERIPADDRESS_FIELD_ID = 17;
        static constexpr SQLUSMALLINT AISPROVIDERPORT_FIELD_ID = 18;
        static constexpr SQLUSMALLINT USELOGIN_FIELD_ID = 19;
        static constexpr SQLUSMALLINT AISPROVIDERLOGINPORT_FIELD_ID = 20;
        static constexpr SQLUSMALLINT CANSENDAISMESSAGE_FIELD_ID = 21;
        static constexpr SQLUSMALLINT UDPPORT_FIELD_ID = 22;
        static constexpr SQLUSMALLINT CONNECTIONTYPE_FIELD_ID = 23;
        static constexpr SQLUSMALLINT ENABLEREFRESHAIDTONAVIGATIONIN30SEC_FIELD_ID = 24;
        static constexpr SQLUSMALLINT ENABLEAIDTONAVIGATIONFROMFILE_FIELD_ID = 25;
        static constexpr SQLUSMALLINT SENDINGMMSI_FIELD_ID = 26;
        static constexpr SQLUSMALLINT SOURCEUPDATERATE_FIELD_ID = 27;
        static constexpr SQLUSMALLINT ENABLEREFRESHSTAYINGSTILLTARGETIN30SEC_FIELD_ID = 28;
        static constexpr SQLUSMALLINT ENABLESENDBASESTATIONALARMS_FIELD_ID = 29;
        static constexpr SQLUSMALLINT AISWEBCONFIG_FIELD_ID = 30;
        static constexpr SQLUSMALLINT STORERECEIVEDSENTENCES_FIELD_ID = 31;
        static constexpr SQLUSMALLINT STORESENTMESSAGES_FIELD_ID = 32;
        static constexpr SQLUSMALLINT STOREUNSENTMESSAGES_FIELD_ID = 33;
        static constexpr SQLUSMALLINT TEXTMESSAGEHEADER_FIELD_ID = 34;
        static constexpr SQLUSMALLINT URLS_FIELD_ID = 35;
        static constexpr SQLUSMALLINT AIDTONAVIGATIONHEADER_FIELD_ID = 36;
        static constexpr SQLUSMALLINT EXCLUDESENDAISBASESTATION_FIELD_ID = 37;
        static constexpr SQLUSMALLINT EXCLUDESENDAISA_FIELD_ID = 38;

        AisTransceiverConfigurationColumnData( ) = default;

        virtual Kind GetKind() const override
        {
            return Kind::AisTransceiverConfiguration;
        }

        const Guid& Id( ) const
        {
            return id_;
        }
        void SetId( const Guid& id )
        {
            id_ = id;
        }
        Int64 RowVersion( ) const
        {
            return rowVersion_;
        }
        void SetRowVersion( const Int64& rowVersion )
        {
            rowVersion_ = rowVersion;
        }
        const Guid& AisTransceiver( ) const
        {
            return aisTransceiver_;
        }
        void SetAisTransceiver( const Guid& aisTransceiver )
        {
            aisTransceiver_ = aisTransceiver;
        }
        const DateTime& Timestamp( ) const
        {
            return timestamp_;
        }
        void SetTimestamp( const DateTime& timestamp )
        {
            timestamp_ = timestamp;
        }
        const FixedDBWideString<127>& UserName( ) const
        {
            return userName_;
        }
        void SetUserName( const WideString& userName )
        {
            userName_ = userName;
        }
        const FixedDBWideString<127>& Password( ) const
        {
            return password_;
        }
        void SetPassword( const WideString& password )
        {
            password_ = password;
        }
        double Latitude( ) const
        {
            return latitude_;
        }
        void SetLatitude( double latitude )
        {
            latitude_ = latitude;
        }
        double Longitude( ) const
        {
            return longitude_;
        }
        void SetLongitude( double longitude )
        {
            longitude_ = longitude;
        }
        const FixedDBWideString<127>& AisProviderLoginURL( ) const
        {
            return aisProviderLoginURL_;
        }
        void SetAisProviderLoginURL( const WideString& aisProviderLoginURL )
        {
            aisProviderLoginURL_ = aisProviderLoginURL;
        }
        const FixedDBWideString<32>& ComPort( ) const
        {
            return comPort_;
        }
        void SetComPort( const WideString& comPort )
        {
            comPort_ = comPort;
        }
        Int32 BaudRate( ) const
        {
            return baudRate_;
        }
        void SetBaudRate( Int32 baudRate )
        {
            baudRate_ = baudRate;
        }
        bool FilterByArea( ) const
        {
            return filterByArea_;
        }
        void SetFilterByArea( bool filterByArea )
        {
            filterByArea_ = filterByArea;
        }
        double UpperLeftCornerLatitude( ) const
        {
            return upperLeftCornerLatitude_;
        }
        void SetUpperLeftCornerLatitude( double upperLeftCornerLatitude )
        {
            upperLeftCornerLatitude_ = upperLeftCornerLatitude;
        }
        double UpperLeftCornerLongitude( ) const
        {
            return upperLeftCornerLongitude_;
        }
        void SetUpperLeftCornerLongitude( double upperLeftCornerLongitude )
        {
            upperLeftCornerLongitude_ = upperLeftCornerLongitude;
        }
        double BottomRightCornerLatitude( ) const
        {
            return bottomRightCornerLatitude_;
        }
        void SetBottomRightCornerLatitude( double bottomRightCornerLatitude )
        {
            bottomRightCornerLatitude_ = bottomRightCornerLatitude;
        }
        double BottomRightCornerLongitude( ) const
        {
            return bottomRightCornerLongitude_;
        }
        void SetBottomRightCornerLongitude( double bottomRightCornerLongitude )
        {
            bottomRightCornerLongitude_ = bottomRightCornerLongitude;
        }
        const FixedDBWideString<127>& AisProviderIPAddress( ) const
        {
            return aisProviderIPAddress_;
        }
        void SetAisProviderIPAddress( const WideString& aisProviderIPAddress )
        {
            aisProviderIPAddress_ = aisProviderIPAddress;
        }
        Int32 AisProviderPort( ) const
        {
            return aisProviderPort_;
        }
        void SetAisProviderPort( Int32 aisProviderPort )
        {
            aisProviderPort_ = aisProviderPort;
        }
        bool UseLogin( ) const
        {
            return useLogin_;
        }
        void SetUseLogin( bool useLogin )
        {
            useLogin_ = useLogin;
        }
        Int32 AisProviderLoginPort( ) const
        {
            return aisProviderLoginPort_;
        }
        void SetAisProviderLoginPort( Int32 aisProviderLoginPort )
        {
            aisProviderLoginPort_ = aisProviderLoginPort;
        }
        bool CanSendAISMessage( ) const
        {
            return canSendAISMessage_;
        }
        void SetCanSendAISMessage( bool canSendAISMessage )
        {
            canSendAISMessage_ = canSendAISMessage;
        }
        const WideString& TextMessageHeader( ) const
        {
            return textMessageHeader_;
        }
        void SetTextMessageHeader( const WideString& textMessageHeader )
        {
            textMessageHeader_ = textMessageHeader;
        }
        const WideString& Urls( ) const
        {
            return urls_;
        }
        void SetUrls( const WideString& urls )
        {
            urls_ = urls;
        }
        Int32 UdpPort( ) const
        {
            return udpPort_;
        }
        void SetUdpPort( Int32 udpPort )
        {
            udpPort_ = udpPort;
        }
        Data::AisTransceiverConnectionType ConnectionType( ) const
        {
            return connectionType_;
        }
        void SetConnectionType( Data::AisTransceiverConnectionType connectionType )
        {
            connectionType_ = connectionType;
        }
        bool EnableRefreshAidToNavigationIn30sec( ) const
        {
            return enableRefreshAidToNavigationIn30sec_;
        }
        void SetEnableRefreshAidToNavigationIn30sec( bool enableRefreshAidToNavigationIn30sec )
        {
            enableRefreshAidToNavigationIn30sec_ = enableRefreshAidToNavigationIn30sec;
        }
        bool EnableAidToNavigationFromFile( ) const
        {
            return enableAidToNavigationFromFile_;
        }
        void SetEnableAidToNavigationFromFile( bool enableAidToNavigationFromFile )
        {
            enableAidToNavigationFromFile_ = enableAidToNavigationFromFile;
        }
        const WideString& AidToNavigationHeader( ) const
        {
            return aidToNavigationHeader_;
        }
        void SetAidToNavigationHeader( const WideString& aidToNavigationHeader )
        {
            aidToNavigationHeader_ = aidToNavigationHeader;
        }
        bool SendingMMSI( ) const
        {
            return sendingMMSI_;
        }
        void SetSendingMMSI( bool sendingMMSI )
        {
            sendingMMSI_ = sendingMMSI;
        }
        Int32 SourceUpdateRate( ) const
        {
            return sourceUpdateRate_;
        }
        void SetSourceUpdateRate( Int32 sourceUpdateRate )
        {
            sourceUpdateRate_ = sourceUpdateRate;
        }
        bool EnableRefreshStayingStillTargetIn30sec( ) const
        {
            return enableRefreshStayingStillTargetIn30sec_;
        }
        void SetEnableRefreshStayingStillTargetIn30sec( bool enableRefreshStayingStillTargetIn30sec )
        {
            enableRefreshStayingStillTargetIn30sec_ = enableRefreshStayingStillTargetIn30sec;
        }
        const WideString& ExcludeSendAisBaseStation( ) const
        {
            return excludeSendAisBaseStation_;
        }
        void SetExcludeSendAisBaseStation( const WideString& excludeSendAisBaseStation )
        {
            excludeSendAisBaseStation_ = excludeSendAisBaseStation;
        }
        const WideString& ExcludeSendAisA( ) const
        {
            return excludeSendAisA_;
        }
        void SetExcludeSendAisA( const WideString& excludeSendAisA )
        {
            excludeSendAisA_ = excludeSendAisA;
        }
        bool EnableSendBaseStationAlarms( ) const
        {
            return enableSendBaseStationAlarms_;
        }
        void SetEnableSendBaseStationAlarms( bool enableSendBaseStationAlarms )
        {
            enableSendBaseStationAlarms_ = enableSendBaseStationAlarms;
        }
        const FixedDBWideString<127>& AisWebConfig( ) const
        {
            return aisWebConfig_;
        }
        void SetAisWebConfig( const WideString& aisWebConfig )
        {
            aisWebConfig_ = aisWebConfig;
        }
        bool StoreReceivedSentences( ) const
        {
            return storeReceivedSentences_;
        }
        void SetStoreReceivedSentences( bool storeReceivedSentences )
        {
            storeReceivedSentences_ = storeReceivedSentences;
        }
        bool StoreSentMessages( ) const
        {
            return storeSentMessages_;
        }
        void SetStoreSentMessages( bool storeSentMessages )
        {
            storeSentMessages_ = storeSentMessages;
        }
        bool StoreUnsentMessages( ) const
        {
            return storeUnsentMessages_;
        }
        void SetStoreUnsentMessages( bool storeUnsentMessages )
        {
            storeUnsentMessages_ = storeUnsentMessages;
        }
        void BindColumns( const ODBC::Statement& statement )
        {
            Bind(statement, ID_FIELD_ID, id_);
            Bind(statement, ROWVERSION_FIELD_ID, rowVersion_);
            Bind(statement, AISTRANSCEIVER_FIELD_ID, aisTransceiver_);
            Bind(statement, TIMESTAMP_FIELD_ID, timestamp_);
            Bind(statement, USERNAME_FIELD_ID, userName_);
            Bind(statement, PASSWORD_FIELD_ID, password_);
            Bind(statement, LATITUDE_FIELD_ID, latitude_);
            Bind(statement, LONGITUDE_FIELD_ID, longitude_);
            Bind(statement, AISPROVIDERLOGINURL_FIELD_ID, aisProviderLoginURL_);
            Bind(statement, COMPORT_FIELD_ID, comPort_);
            Bind(statement, BAUDRATE_FIELD_ID, baudRate_);
            Bind(statement, FILTERBYAREA_FIELD_ID, filterByArea_);
            Bind(statement, UPPERLEFTCORNERLATITUDE_FIELD_ID, upperLeftCornerLatitude_);
            Bind(statement, UPPERLEFTCORNERLONGITUDE_FIELD_ID, upperLeftCornerLongitude_);
            Bind(statement, BOTTOMRIGHTCORNERLATITUDE_FIELD_ID, bottomRightCornerLatitude_);
            Bind(statement, BOTTOMRIGHTCORNERLONGITUDE_FIELD_ID, bottomRightCornerLongitude_);
            Bind(statement, AISPROVIDERIPADDRESS_FIELD_ID, aisProviderIPAddress_);
            Bind(statement, AISPROVIDERPORT_FIELD_ID, aisProviderPort_);
            Bind(statement, USELOGIN_FIELD_ID, useLogin_);
            Bind(statement, AISPROVIDERLOGINPORT_FIELD_ID, aisProviderLoginPort_);
            Bind(statement, CANSENDAISMESSAGE_FIELD_ID, canSendAISMessage_);
            Bind(statement, UDPPORT_FIELD_ID, udpPort_);
            Bind(statement, CONNECTIONTYPE_FIELD_ID, connectionType_);
            Bind(statement, ENABLEREFRESHAIDTONAVIGATIONIN30SEC_FIELD_ID, enableRefreshAidToNavigationIn30sec_);
            Bind(statement, ENABLEAIDTONAVIGATIONFROMFILE_FIELD_ID, enableAidToNavigationFromFile_);
            Bind(statement, SENDINGMMSI_FIELD_ID, sendingMMSI_);
            Bind(statement, SOURCEUPDATERATE_FIELD_ID, sourceUpdateRate_);
            Bind(statement, ENABLEREFRESHSTAYINGSTILLTARGETIN30SEC_FIELD_ID, enableRefreshStayingStillTargetIn30sec_);
            Bind(statement, ENABLESENDBASESTATIONALARMS_FIELD_ID, enableSendBaseStationAlarms_);
            Bind(statement, AISWEBCONFIG_FIELD_ID, aisWebConfig_);
            Bind(statement, STORERECEIVEDSENTENCES_FIELD_ID, storeReceivedSentences_);
            Bind(statement, STORESENTMESSAGES_FIELD_ID, storeSentMessages_);
            Bind(statement, STOREUNSENTMESSAGES_FIELD_ID, storeUnsentMessages_);
        }

        void ReadUnboundData( const ODBC::Statement& statement )
        {
            Base::ReadUnboundData( statement );

            textMessageHeader_ = statement.GetWideString(TEXTMESSAGEHEADER_FIELD_ID);
            urls_ = statement.GetWideString(URLS_FIELD_ID);
            aidToNavigationHeader_ = statement.GetWideString(AIDTONAVIGATIONHEADER_FIELD_ID);
            excludeSendAisBaseStation_ = statement.GetWideString(EXCLUDESENDAISBASESTATION_FIELD_ID);
            excludeSendAisA_ = statement.GetWideString(EXCLUDESENDAISA_FIELD_ID);
        }
        template<IO::StreamWriter StreamT>
        void WriteColumns( IO::BinaryWriter<StreamT>& destination ) const
        {
            WriteColumnValue( destination, id_);
            WriteColumnValue( destination, rowVersion_);
            WriteColumnValue( destination, aisTransceiver_);
            WriteColumnValue( destination, timestamp_);
            WriteColumnValue( destination, userName_);
            WriteColumnValue( destination, password_);
            WriteColumnValue( destination, latitude_);
            WriteColumnValue( destination, longitude_);
            WriteColumnValue( destination, aisProviderLoginURL_);
            WriteColumnValue( destination, comPort_);
            WriteColumnValue( destination, baudRate_);
            WriteColumnValue( destination, filterByArea_);
            WriteColumnValue( destination, upperLeftCornerLatitude_);
            WriteColumnValue( destination, upperLeftCornerLongitude_);
            WriteColumnValue( destination, bottomRightCornerLatitude_);
            WriteColumnValue( destination, bottomRightCornerLongitude_);
            WriteColumnValue( destination, aisProviderIPAddress_);
            WriteColumnValue( destination, aisProviderPort_);
            WriteColumnValue( destination, useLogin_);
            WriteColumnValue( destination, aisProviderLoginPort_);
            WriteColumnValue( destination, canSendAISMessage_);
            WriteColumnValue( destination, textMessageHeader_);
            WriteColumnValue( destination, urls_);
            WriteColumnValue( destination, udpPort_);
            WriteColumnValue( destination, connectionType_);
            WriteColumnValue( destination, enableRefreshAidToNavigationIn30sec_);
            WriteColumnValue( destination, enableAidToNavigationFromFile_);
            WriteColumnValue( destination, aidToNavigationHeader_);
            WriteColumnValue( destination, sendingMMSI_);
            WriteColumnValue( destination, sourceUpdateRate_);
            WriteColumnValue( destination, enableRefreshStayingStillTargetIn30sec_);
            WriteColumnValue( destination, excludeSendAisBaseStation_);
            WriteColumnValue( destination, excludeSendAisA_);
            WriteColumnValue( destination, enableSendBaseStationAlarms_);
            WriteColumnValue( destination, aisWebConfig_);
            WriteColumnValue( destination, storeReceivedSentences_);
            WriteColumnValue( destination, storeSentMessages_);
            WriteColumnValue( destination, storeUnsentMessages_);
        }
    };

    using SimpleAisTransceiverConfigurationDataReader = SimpleColumnDataReader<AisTransceiverConfigurationColumnData>;

    class AisTransceiverRawMessageColumnData : public BaseColumnData
    {
        Guid id_;
        Int64 rowVersion_ = 0;
        Guid aisTransceiver_;
        DateTime timestamp_;
        bool isSent_ = false;
        FixedDBWideString<100> message_;
    public:
        using Base = BaseColumnData;

        static constexpr std::wstring_view FieldNames = L"[Id],[RowVersion],[AisTransceiver],[Timestamp],[IsSent],[Message]";
        static constexpr std::wstring_view ViewName = L"AisTransceiverRawMessageView";

        static constexpr SQLUSMALLINT ID_FIELD_ID = 1;
        static constexpr SQLUSMALLINT ROWVERSION_FIELD_ID = 2;
        static constexpr SQLUSMALLINT AISTRANSCEIVER_FIELD_ID = 3;
        static constexpr SQLUSMALLINT TIMESTAMP_FIELD_ID = 4;
        static constexpr SQLUSMALLINT ISSENT_FIELD_ID = 5;
        static constexpr SQLUSMALLINT MESSAGE_FIELD_ID = 6;

        AisTransceiverRawMessageColumnData( ) = default;

        virtual Kind GetKind() const override
        {
            return Kind::AisTransceiverRawMessage;
        }

        const Guid& Id( ) const
        {
            return id_;
        }
        void SetId( const Guid& id )
        {
            id_ = id;
        }
        Int64 RowVersion( ) const
        {
            return rowVersion_;
        }
        void SetRowVersion( const Int64& rowVersion )
        {
            rowVersion_ = rowVersion;
        }
        const Guid& AisTransceiver( ) const
        {
            return aisTransceiver_;
        }
        void SetAisTransceiver( const Guid& aisTransceiver )
        {
            aisTransceiver_ = aisTransceiver;
        }
        const DateTime& Timestamp( ) const
        {
            return timestamp_;
        }
        void SetTimestamp( const DateTime& timestamp )
        {
            timestamp_ = timestamp;
        }
        bool IsSent( ) const
        {
            return isSent_;
        }
        void SetIsSent( bool isSent )
        {
            isSent_ = isSent;
        }
        const FixedDBWideString<100>& Message( ) const
        {
            return message_;
        }
        void SetMessage( const WideString& message )
        {
            message_ = message;
        }
        void BindColumns( const ODBC::Statement& statement )
        {
            Bind(statement, ID_FIELD_ID, id_);
            Bind(statement, ROWVERSION_FIELD_ID, rowVersion_);
            Bind(statement, AISTRANSCEIVER_FIELD_ID, aisTransceiver_);
            Bind(statement, TIMESTAMP_FIELD_ID, timestamp_);
            Bind(statement, ISSENT_FIELD_ID, isSent_);
            Bind(statement, MESSAGE_FIELD_ID, message_);
        }

        template<IO::StreamWriter StreamT>
        void WriteColumns( IO::BinaryWriter<StreamT>& destination ) const
        {
            WriteColumnValue( destination, id_);
            WriteColumnValue( destination, rowVersion_);
            WriteColumnValue( destination, aisTransceiver_);
            WriteColumnValue( destination, timestamp_);
            WriteColumnValue( destination, isSent_);
            WriteColumnValue( destination, message_);
        }
    };

    using SimpleAisTransceiverRawMessageDataReader = SimpleColumnDataReader<AisTransceiverRawMessageColumnData>;

    class AisTransceiverRawSentenceColumnData : public BaseColumnData
    {
        Guid id_;
        Int64 rowVersion_ = 0;
        Guid aisTransceiver_;
        DateTime timestamp_;
        WideString sentence_;
        SQLLEN sentenceLength_ = SQL_NULL_DATA;
    public:
        using Base = BaseColumnData;

        static constexpr std::wstring_view FieldNames = L"[Id],[RowVersion],[AisTransceiver],[Timestamp],[Sentence]";
        static constexpr std::wstring_view ViewName = L"AisTransceiverRawSentenceView";

        static constexpr SQLUSMALLINT ID_FIELD_ID = 1;
        static constexpr SQLUSMALLINT ROWVERSION_FIELD_ID = 2;
        static constexpr SQLUSMALLINT AISTRANSCEIVER_FIELD_ID = 3;
        static constexpr SQLUSMALLINT TIMESTAMP_FIELD_ID = 4;
        static constexpr SQLUSMALLINT SENTENCE_FIELD_ID = 5;

        AisTransceiverRawSentenceColumnData( ) = default;

        virtual Kind GetKind() const override
        {
            return Kind::AisTransceiverRawSentence;
        }

        const Guid& Id( ) const
        {
            return id_;
        }
        void SetId( const Guid& id )
        {
            id_ = id;
        }
        Int64 RowVersion( ) const
        {
            return rowVersion_;
        }
        void SetRowVersion( const Int64& rowVersion )
        {
            rowVersion_ = rowVersion;
        }
        const Guid& AisTransceiver( ) const
        {
            return aisTransceiver_;
        }
        void SetAisTransceiver( const Guid& aisTransceiver )
        {
            aisTransceiver_ = aisTransceiver;
        }
        const DateTime& Timestamp( ) const
        {
            return timestamp_;
        }
        void SetTimestamp( const DateTime& timestamp )
        {
            timestamp_ = timestamp;
        }
        const WideString& Sentence( ) const
        {
            return sentence_;
        }
        void SetSentence( const WideString& sentence )
        {
            sentence_ = sentence;
        }
        void BindColumns( const ODBC::Statement& statement )
        {
            Bind(statement, ID_FIELD_ID, id_);
            Bind(statement, ROWVERSION_FIELD_ID, rowVersion_);
            Bind(statement, AISTRANSCEIVER_FIELD_ID, aisTransceiver_);
            Bind(statement, TIMESTAMP_FIELD_ID, timestamp_);
        }

        void ReadUnboundData( const ODBC::Statement& statement )
        {
            Base::ReadUnboundData( statement );

            sentence_ = statement.GetWideString(SENTENCE_FIELD_ID);
        }
        template<IO::StreamWriter StreamT>
        void WriteColumns( IO::BinaryWriter<StreamT>& destination ) const
        {
            WriteColumnValue( destination, id_);
            WriteColumnValue( destination, rowVersion_);
            WriteColumnValue( destination, aisTransceiver_);
            WriteColumnValue( destination, timestamp_);
            WriteColumnValue( destination, sentence_);
        }
    };

    using SimpleAisTransceiverRawSentenceDataReader = SimpleColumnDataReader<AisTransceiverRawSentenceColumnData>;

    class AlarmStateChangeColumnData : public BaseColumnData
    {
        Guid id_;
        Int64 rowVersion_ = 0;
        Guid alarm_;
        DateTime timestamp_;
        Data::AlarmState state_ = Data::AlarmState::Unknown;
    public:
        using Base = BaseColumnData;

        static constexpr std::wstring_view FieldNames = L"[Id],[RowVersion],[Alarm],[Timestamp],[State]";
        static constexpr std::wstring_view ViewName = L"AlarmStateChangeView";

        static constexpr SQLUSMALLINT ID_FIELD_ID = 1;
        static constexpr SQLUSMALLINT ROWVERSION_FIELD_ID = 2;
        static constexpr SQLUSMALLINT ALARM_FIELD_ID = 3;
        static constexpr SQLUSMALLINT TIMESTAMP_FIELD_ID = 4;
        static constexpr SQLUSMALLINT STATE_FIELD_ID = 5;

        AlarmStateChangeColumnData( ) = default;

        virtual Kind GetKind() const override
        {
            return Kind::AlarmStateChange;
        }

        const Guid& Id( ) const
        {
            return id_;
        }
        void SetId( const Guid& id )
        {
            id_ = id;
        }
        Int64 RowVersion( ) const
        {
            return rowVersion_;
        }
        void SetRowVersion( const Int64& rowVersion )
        {
            rowVersion_ = rowVersion;
        }
        const Guid& Alarm( ) const
        {
            return alarm_;
        }
        void SetAlarm( const Guid& alarm )
        {
            alarm_ = alarm;
        }
        const DateTime& Timestamp( ) const
        {
            return timestamp_;
        }
        void SetTimestamp( const DateTime& timestamp )
        {
            timestamp_ = timestamp;
        }
        Data::AlarmState State( ) const
        {
            return state_;
        }
        void SetState( Data::AlarmState state )
        {
            state_ = state;
        }
        void BindColumns( const ODBC::Statement& statement )
        {
            Bind(statement, ID_FIELD_ID, id_);
            Bind(statement, ROWVERSION_FIELD_ID, rowVersion_);
            Bind(statement, ALARM_FIELD_ID, alarm_);
            Bind(statement, TIMESTAMP_FIELD_ID, timestamp_);
            Bind(statement, STATE_FIELD_ID, state_);
        }

        template<IO::StreamWriter StreamT>
        void WriteColumns( IO::BinaryWriter<StreamT>& destination ) const
        {
            WriteColumnValue( destination, id_);
            WriteColumnValue( destination, rowVersion_);
            WriteColumnValue( destination, alarm_);
            WriteColumnValue( destination, timestamp_);
            WriteColumnValue( destination, state_);
        }
    };

    using SimpleAlarmStateChangeDataReader = SimpleColumnDataReader<AlarmStateChangeColumnData>;

    class BaseStationTypeColumnData : public BaseColumnData
    {
        Guid id_;
        Int64 rowVersion_ = 0;
        FixedDBWideString<127> name_;
    public:
        using Base = BaseColumnData;

        static constexpr std::wstring_view FieldNames = L"[Id],[RowVersion],[Name]";
        static constexpr std::wstring_view ViewName = L"BaseStationTypeView";

        static constexpr SQLUSMALLINT ID_FIELD_ID = 1;
        static constexpr SQLUSMALLINT ROWVERSION_FIELD_ID = 2;
        static constexpr SQLUSMALLINT NAME_FIELD_ID = 3;

        BaseStationTypeColumnData( ) = default;

        virtual Kind GetKind() const override
        {
            return Kind::BaseStationType;
        }

        const Guid& Id( ) const
        {
            return id_;
        }
        void SetId( const Guid& id )
        {
            id_ = id;
        }
        Int64 RowVersion( ) const
        {
            return rowVersion_;
        }
        void SetRowVersion( const Int64& rowVersion )
        {
            rowVersion_ = rowVersion;
        }
        const FixedDBWideString<127>& Name( ) const
        {
            return name_;
        }
        void SetName( const WideString& name )
        {
            name_ = name;
        }
        void BindColumns( const ODBC::Statement& statement )
        {
            Bind(statement, ID_FIELD_ID, id_);
            Bind(statement, ROWVERSION_FIELD_ID, rowVersion_);
            Bind(statement, NAME_FIELD_ID, name_);
        }

        template<IO::StreamWriter StreamT>
        void WriteColumns( IO::BinaryWriter<StreamT>& destination ) const
        {
            WriteColumnValue( destination, id_);
            WriteColumnValue( destination, rowVersion_);
            WriteColumnValue( destination, name_);
        }
    };

    using SimpleBaseStationTypeDataReader = SimpleColumnDataReader<BaseStationTypeColumnData>;

    class BinaryTimeseriesValueColumnData : public BaseColumnData
    {
        Guid id_;
        Int64 rowVersion_ = 0;
        Guid timeseries_;
        DateTime timestamp_;
        Binary value_;
        SQLLEN valueLength_ = SQL_NULL_DATA;
    public:
        using Base = BaseColumnData;

        static constexpr std::wstring_view FieldNames = L"[Id],[RowVersion],[Timeseries],[Timestamp],[Value]";
        static constexpr std::wstring_view ViewName = L"BinaryTimeseriesValueView";

        static constexpr SQLUSMALLINT ID_FIELD_ID = 1;
        static constexpr SQLUSMALLINT ROWVERSION_FIELD_ID = 2;
        static constexpr SQLUSMALLINT TIMESERIES_FIELD_ID = 3;
        static constexpr SQLUSMALLINT TIMESTAMP_FIELD_ID = 4;
        static constexpr SQLUSMALLINT VALUE_FIELD_ID = 5;

        BinaryTimeseriesValueColumnData( ) = default;

        virtual Kind GetKind() const override
        {
            return Kind::BinaryTimeseriesValue;
        }

        const Guid& Id( ) const
        {
            return id_;
        }
        void SetId( const Guid& id )
        {
            id_ = id;
        }
        Int64 RowVersion( ) const
        {
            return rowVersion_;
        }
        void SetRowVersion( const Int64& rowVersion )
        {
            rowVersion_ = rowVersion;
        }
        const Guid& Timeseries( ) const
        {
            return timeseries_;
        }
        void SetTimeseries( const Guid& timeseries )
        {
            timeseries_ = timeseries;
        }
        const DateTime& Timestamp( ) const
        {
            return timestamp_;
        }
        void SetTimestamp( const DateTime& timestamp )
        {
            timestamp_ = timestamp;
        }
        const Binary& Value( ) const
        {
            return value_;
        }
        void SetValue( const Binary& value )
        {
            value_ = value;
        }
        void BindColumns( const ODBC::Statement& statement )
        {
            Bind(statement, ID_FIELD_ID, id_);
            Bind(statement, ROWVERSION_FIELD_ID, rowVersion_);
            Bind(statement, TIMESERIES_FIELD_ID, timeseries_);
            Bind(statement, TIMESTAMP_FIELD_ID, timestamp_);
        }

        void ReadUnboundData( const ODBC::Statement& statement )
        {
            Base::ReadUnboundData( statement );

            value_ = statement.GetBinary(VALUE_FIELD_ID);
        }
        template<IO::StreamWriter StreamT>
        void WriteColumns( IO::BinaryWriter<StreamT>& destination ) const
        {
            WriteColumnValue( destination, id_);
            WriteColumnValue( destination, rowVersion_);
            WriteColumnValue( destination, timeseries_);
            WriteColumnValue( destination, timestamp_);
            WriteColumnValue( destination, value_);
        }
    };

    using SimpleBinaryTimeseriesValueDataReader = SimpleColumnDataReader<BinaryTimeseriesValueColumnData>;

    class BookmarkColumnData : public BaseColumnData
    {
        Guid id_;
        Int64 rowVersion_ = 0;
        Guid view_;
        FixedDBWideString<100> name_;
        DBDateTime timestamp_;
        double latitude_ = 0.0;
        double longitude_ = 0.0;
        double zoomLevel_ = 0.0;
    public:
        using Base = BaseColumnData;

        static constexpr std::wstring_view FieldNames = L"[Id],[RowVersion],[View],[Name],[Timestamp],[Latitude],[Longitude],[ZoomLevel]";
        static constexpr std::wstring_view ViewName = L"BookmarkView";

        static constexpr SQLUSMALLINT ID_FIELD_ID = 1;
        static constexpr SQLUSMALLINT ROWVERSION_FIELD_ID = 2;
        static constexpr SQLUSMALLINT VIEW_FIELD_ID = 3;
        static constexpr SQLUSMALLINT NAME_FIELD_ID = 4;
        static constexpr SQLUSMALLINT TIMESTAMP_FIELD_ID = 5;
        static constexpr SQLUSMALLINT LATITUDE_FIELD_ID = 6;
        static constexpr SQLUSMALLINT LONGITUDE_FIELD_ID = 7;
        static constexpr SQLUSMALLINT ZOOMLEVEL_FIELD_ID = 8;

        BookmarkColumnData( ) = default;

        virtual Kind GetKind() const override
        {
            return Kind::Bookmark;
        }

        const Guid& Id( ) const
        {
            return id_;
        }
        void SetId( const Guid& id )
        {
            id_ = id;
        }
        Int64 RowVersion( ) const
        {
            return rowVersion_;
        }
        void SetRowVersion( const Int64& rowVersion )
        {
            rowVersion_ = rowVersion;
        }
        const Guid& View( ) const
        {
            return view_;
        }
        void SetView( const Guid& view )
        {
            view_ = view;
        }
        const FixedDBWideString<100>& Name( ) const
        {
            return name_;
        }
        void SetName( const WideString& name )
        {
            name_ = name;
        }
        const DBDateTime& Timestamp( ) const
        {
            return timestamp_;
        }
        void SetTimestamp( const DBDateTime& timestamp )
        {
            timestamp_ = timestamp;
        }
        double Latitude( ) const
        {
            return latitude_;
        }
        void SetLatitude( double latitude )
        {
            latitude_ = latitude;
        }
        double Longitude( ) const
        {
            return longitude_;
        }
        void SetLongitude( double longitude )
        {
            longitude_ = longitude;
        }
        double ZoomLevel( ) const
        {
            return zoomLevel_;
        }
        void SetZoomLevel( double zoomLevel )
        {
            zoomLevel_ = zoomLevel;
        }
        void BindColumns( const ODBC::Statement& statement )
        {
            Bind(statement, ID_FIELD_ID, id_);
            Bind(statement, ROWVERSION_FIELD_ID, rowVersion_);
            Bind(statement, VIEW_FIELD_ID, view_);
            Bind(statement, NAME_FIELD_ID, name_);
            Bind(statement, TIMESTAMP_FIELD_ID, timestamp_);
            Bind(statement, LATITUDE_FIELD_ID, latitude_);
            Bind(statement, LONGITUDE_FIELD_ID, longitude_);
            Bind(statement, ZOOMLEVEL_FIELD_ID, zoomLevel_);
        }

        template<IO::StreamWriter StreamT>
        void WriteColumns( IO::BinaryWriter<StreamT>& destination ) const
        {
            WriteColumnValue( destination, id_);
            WriteColumnValue( destination, rowVersion_);
            WriteColumnValue( destination, view_);
            WriteColumnValue( destination, name_);
            WriteColumnValue( destination, timestamp_);
            WriteColumnValue( destination, latitude_);
            WriteColumnValue( destination, longitude_);
            WriteColumnValue( destination, zoomLevel_);
        }
    };

    using SimpleBookmarkDataReader = SimpleColumnDataReader<BookmarkColumnData>;

    class BooleanTimeseriesValueColumnData : public BaseColumnData
    {
        Guid id_;
        Int64 rowVersion_ = 0;
        Guid timeseries_;
        DateTime timestamp_;
        DBBoolean  value_;
    public:
        using Base = BaseColumnData;

        static constexpr std::wstring_view FieldNames = L"[Id],[RowVersion],[Timeseries],[Timestamp],[Value]";
        static constexpr std::wstring_view ViewName = L"BooleanTimeseriesValueView";

        static constexpr SQLUSMALLINT ID_FIELD_ID = 1;
        static constexpr SQLUSMALLINT ROWVERSION_FIELD_ID = 2;
        static constexpr SQLUSMALLINT TIMESERIES_FIELD_ID = 3;
        static constexpr SQLUSMALLINT TIMESTAMP_FIELD_ID = 4;
        static constexpr SQLUSMALLINT VALUE_FIELD_ID = 5;

        BooleanTimeseriesValueColumnData( ) = default;

        virtual Kind GetKind() const override
        {
            return Kind::BooleanTimeseriesValue;
        }

        const Guid& Id( ) const
        {
            return id_;
        }
        void SetId( const Guid& id )
        {
            id_ = id;
        }
        Int64 RowVersion( ) const
        {
            return rowVersion_;
        }
        void SetRowVersion( const Int64& rowVersion )
        {
            rowVersion_ = rowVersion;
        }
        const Guid& Timeseries( ) const
        {
            return timeseries_;
        }
        void SetTimeseries( const Guid& timeseries )
        {
            timeseries_ = timeseries;
        }
        const DateTime& Timestamp( ) const
        {
            return timestamp_;
        }
        void SetTimestamp( const DateTime& timestamp )
        {
            timestamp_ = timestamp;
        }
        const DBBoolean & Value( ) const
        {
            return value_;
        }
        void SetValue( const DBBoolean & value )
        {
            value_ = value;
        }
        void BindColumns( const ODBC::Statement& statement )
        {
            Bind(statement, ID_FIELD_ID, id_);
            Bind(statement, ROWVERSION_FIELD_ID, rowVersion_);
            Bind(statement, TIMESERIES_FIELD_ID, timeseries_);
            Bind(statement, TIMESTAMP_FIELD_ID, timestamp_);
            Bind(statement, VALUE_FIELD_ID, value_);
        }

        template<IO::StreamWriter StreamT>
        void WriteColumns( IO::BinaryWriter<StreamT>& destination ) const
        {
            WriteColumnValue( destination, id_);
            WriteColumnValue( destination, rowVersion_);
            WriteColumnValue( destination, timeseries_);
            WriteColumnValue( destination, timestamp_);
            WriteColumnValue( destination, value_);
        }
    };

    using SimpleBooleanTimeseriesValueDataReader = SimpleColumnDataReader<BooleanTimeseriesValueColumnData>;

    class ByteTimeseriesValueColumnData : public BaseColumnData
    {
        Guid id_;
        Int64 rowVersion_ = 0;
        Guid timeseries_;
        DateTime timestamp_;
        DBByte value_;
    public:
        using Base = BaseColumnData;

        static constexpr std::wstring_view FieldNames = L"[Id],[RowVersion],[Timeseries],[Timestamp],[Value]";
        static constexpr std::wstring_view ViewName = L"ByteTimeseriesValueView";

        static constexpr SQLUSMALLINT ID_FIELD_ID = 1;
        static constexpr SQLUSMALLINT ROWVERSION_FIELD_ID = 2;
        static constexpr SQLUSMALLINT TIMESERIES_FIELD_ID = 3;
        static constexpr SQLUSMALLINT TIMESTAMP_FIELD_ID = 4;
        static constexpr SQLUSMALLINT VALUE_FIELD_ID = 5;

        ByteTimeseriesValueColumnData( ) = default;

        virtual Kind GetKind() const override
        {
            return Kind::ByteTimeseriesValue;
        }

        const Guid& Id( ) const
        {
            return id_;
        }
        void SetId( const Guid& id )
        {
            id_ = id;
        }
        Int64 RowVersion( ) const
        {
            return rowVersion_;
        }
        void SetRowVersion( const Int64& rowVersion )
        {
            rowVersion_ = rowVersion;
        }
        const Guid& Timeseries( ) const
        {
            return timeseries_;
        }
        void SetTimeseries( const Guid& timeseries )
        {
            timeseries_ = timeseries;
        }
        const DateTime& Timestamp( ) const
        {
            return timestamp_;
        }
        void SetTimestamp( const DateTime& timestamp )
        {
            timestamp_ = timestamp;
        }
        const DBByte& Value( ) const
        {
            return value_;
        }
        void SetValue( const DBByte& value )
        {
            value_ = value;
        }
        void BindColumns( const ODBC::Statement& statement )
        {
            Bind(statement, ID_FIELD_ID, id_);
            Bind(statement, ROWVERSION_FIELD_ID, rowVersion_);
            Bind(statement, TIMESERIES_FIELD_ID, timeseries_);
            Bind(statement, TIMESTAMP_FIELD_ID, timestamp_);
            Bind(statement, VALUE_FIELD_ID, value_);
        }

        template<IO::StreamWriter StreamT>
        void WriteColumns( IO::BinaryWriter<StreamT>& destination ) const
        {
            WriteColumnValue( destination, id_);
            WriteColumnValue( destination, rowVersion_);
            WriteColumnValue( destination, timeseries_);
            WriteColumnValue( destination, timestamp_);
            WriteColumnValue( destination, value_);
        }
    };

    using SimpleByteTimeseriesValueDataReader = SimpleColumnDataReader<ByteTimeseriesValueColumnData>;

    class CameraCommandColumnData : public BaseColumnData
    {
        Guid id_;
        Int64 rowVersion_ = 0;
        Guid camera_;
        DateTime timestamp_;
        Data::DeviceCommandSourceType deviceCommandSourceType_ = Data::DeviceCommandSourceType::Unknown;
        Guid deviceCommandSourceId_;
        Guid reply_;
    public:
        using Base = BaseColumnData;

        static constexpr std::wstring_view FieldNames = L"[Id],[RowVersion],[Camera],[Timestamp],[DeviceCommandSourceType],[DeviceCommandSourceId],[Reply]";
        static constexpr std::wstring_view ViewName = L"CameraCommandView";

        static constexpr SQLUSMALLINT ID_FIELD_ID = 1;
        static constexpr SQLUSMALLINT ROWVERSION_FIELD_ID = 2;
        static constexpr SQLUSMALLINT CAMERA_FIELD_ID = 3;
        static constexpr SQLUSMALLINT TIMESTAMP_FIELD_ID = 4;
        static constexpr SQLUSMALLINT DEVICECOMMANDSOURCETYPE_FIELD_ID = 5;
        static constexpr SQLUSMALLINT DEVICECOMMANDSOURCEID_FIELD_ID = 6;
        static constexpr SQLUSMALLINT REPLY_FIELD_ID = 7;

        CameraCommandColumnData( ) = default;

        virtual Kind GetKind() const override
        {
            return Kind::CameraCommand;
        }

        const Guid& Id( ) const
        {
            return id_;
        }
        void SetId( const Guid& id )
        {
            id_ = id;
        }
        Int64 RowVersion( ) const
        {
            return rowVersion_;
        }
        void SetRowVersion( const Int64& rowVersion )
        {
            rowVersion_ = rowVersion;
        }
        const Guid& Camera( ) const
        {
            return camera_;
        }
        void SetCamera( const Guid& camera )
        {
            camera_ = camera;
        }
        const DateTime& Timestamp( ) const
        {
            return timestamp_;
        }
        void SetTimestamp( const DateTime& timestamp )
        {
            timestamp_ = timestamp;
        }
        Data::DeviceCommandSourceType DeviceCommandSourceType( ) const
        {
            return deviceCommandSourceType_;
        }
        void SetDeviceCommandSourceType( Data::DeviceCommandSourceType deviceCommandSourceType )
        {
            deviceCommandSourceType_ = deviceCommandSourceType;
        }
        const Guid& DeviceCommandSourceId( ) const
        {
            return deviceCommandSourceId_;
        }
        void SetDeviceCommandSourceId( const Guid& deviceCommandSourceId )
        {
            deviceCommandSourceId_ = deviceCommandSourceId;
        }
        const Guid& Reply( ) const
        {
            return reply_;
        }
        void SetReply( const Guid& reply )
        {
            reply_ = reply;
        }
        void BindColumns( const ODBC::Statement& statement )
        {
            Bind(statement, ID_FIELD_ID, id_);
            Bind(statement, ROWVERSION_FIELD_ID, rowVersion_);
            Bind(statement, CAMERA_FIELD_ID, camera_);
            Bind(statement, TIMESTAMP_FIELD_ID, timestamp_);
            Bind(statement, DEVICECOMMANDSOURCETYPE_FIELD_ID, deviceCommandSourceType_);
            Bind(statement, DEVICECOMMANDSOURCEID_FIELD_ID, deviceCommandSourceId_);
            Bind(statement, REPLY_FIELD_ID, reply_);
        }

        template<IO::StreamWriter StreamT>
        void WriteColumns( IO::BinaryWriter<StreamT>& destination ) const
        {
            WriteColumnValue( destination, id_);
            WriteColumnValue( destination, rowVersion_);
            WriteColumnValue( destination, camera_);
            WriteColumnValue( destination, timestamp_);
            WriteColumnValue( destination, deviceCommandSourceType_);
            WriteColumnValue( destination, deviceCommandSourceId_);
            WriteColumnValue( destination, reply_);
        }
    };

    using SimpleCameraCommandDataReader = SimpleColumnDataReader<CameraCommandColumnData>;

    class CameraCommandAbsoluteMoveColumnData : public CameraCommandColumnData
    {
        Data::CameraPanTiltMode positionPanTiltMode_ = Data::CameraPanTiltMode::Unknown;
        DBDouble panAngle_;
        DBDouble tiltAngle_;
        Data::CameraFocalLengthMode positionFocalLengthMode_ = Data::CameraFocalLengthMode::Unknown;
        DBDouble focalLength_;
        Data::CameraPanTiltMode speedPanTiltMode_ = Data::CameraPanTiltMode::Unknown;
        DBDouble panSpeed_;
        DBDouble tiltSpeed_;
        Data::CameraFocalLengthMode speedFocalLengthMode_ = Data::CameraFocalLengthMode::Unknown;
        DBDouble zoomSpeed_;
    public:
        using Base = CameraCommandColumnData;

        static constexpr std::wstring_view FieldNames = L"[Id],[RowVersion],[Camera],[Timestamp],[DeviceCommandSourceType],[DeviceCommandSourceId],[Reply],[PositionPanTiltMode],[PanAngle],[TiltAngle],[PositionFocalLengthMode],[FocalLength],[SpeedPanTiltMode],[PanSpeed],[TiltSpeed],[SpeedFocalLengthMode],[ZoomSpeed]";
        static constexpr std::wstring_view ViewName = L"CameraCommandAbsoluteMoveView";

        static constexpr SQLUSMALLINT POSITIONPANTILTMODE_FIELD_ID = 8;
        static constexpr SQLUSMALLINT PANANGLE_FIELD_ID = 9;
        static constexpr SQLUSMALLINT TILTANGLE_FIELD_ID = 10;
        static constexpr SQLUSMALLINT POSITIONFOCALLENGTHMODE_FIELD_ID = 11;
        static constexpr SQLUSMALLINT FOCALLENGTH_FIELD_ID = 12;
        static constexpr SQLUSMALLINT SPEEDPANTILTMODE_FIELD_ID = 13;
        static constexpr SQLUSMALLINT PANSPEED_FIELD_ID = 14;
        static constexpr SQLUSMALLINT TILTSPEED_FIELD_ID = 15;
        static constexpr SQLUSMALLINT SPEEDFOCALLENGTHMODE_FIELD_ID = 16;
        static constexpr SQLUSMALLINT ZOOMSPEED_FIELD_ID = 17;

        CameraCommandAbsoluteMoveColumnData( ) = default;

        virtual Kind GetKind() const override
        {
            return Kind::CameraCommandAbsoluteMove;
        }

        Data::CameraPanTiltMode PositionPanTiltMode( ) const
        {
            return positionPanTiltMode_;
        }
        void SetPositionPanTiltMode( Data::CameraPanTiltMode positionPanTiltMode )
        {
            positionPanTiltMode_ = positionPanTiltMode;
        }
        const DBDouble& PanAngle( ) const
        {
            return panAngle_;
        }
        void SetPanAngle( const DBDouble& panAngle )
        {
            panAngle_ = panAngle;
        }
        const DBDouble& TiltAngle( ) const
        {
            return tiltAngle_;
        }
        void SetTiltAngle( const DBDouble& tiltAngle )
        {
            tiltAngle_ = tiltAngle;
        }
        Data::CameraFocalLengthMode PositionFocalLengthMode( ) const
        {
            return positionFocalLengthMode_;
        }
        void SetPositionFocalLengthMode( Data::CameraFocalLengthMode positionFocalLengthMode )
        {
            positionFocalLengthMode_ = positionFocalLengthMode;
        }
        const DBDouble& FocalLength( ) const
        {
            return focalLength_;
        }
        void SetFocalLength( const DBDouble& focalLength )
        {
            focalLength_ = focalLength;
        }
        Data::CameraPanTiltMode SpeedPanTiltMode( ) const
        {
            return speedPanTiltMode_;
        }
        void SetSpeedPanTiltMode( Data::CameraPanTiltMode speedPanTiltMode )
        {
            speedPanTiltMode_ = speedPanTiltMode;
        }
        const DBDouble& PanSpeed( ) const
        {
            return panSpeed_;
        }
        void SetPanSpeed( const DBDouble& panSpeed )
        {
            panSpeed_ = panSpeed;
        }
        const DBDouble& TiltSpeed( ) const
        {
            return tiltSpeed_;
        }
        void SetTiltSpeed( const DBDouble& tiltSpeed )
        {
            tiltSpeed_ = tiltSpeed;
        }
        Data::CameraFocalLengthMode SpeedFocalLengthMode( ) const
        {
            return speedFocalLengthMode_;
        }
        void SetSpeedFocalLengthMode( Data::CameraFocalLengthMode speedFocalLengthMode )
        {
            speedFocalLengthMode_ = speedFocalLengthMode;
        }
        const DBDouble& ZoomSpeed( ) const
        {
            return zoomSpeed_;
        }
        void SetZoomSpeed( const DBDouble& zoomSpeed )
        {
            zoomSpeed_ = zoomSpeed;
        }
        void BindColumns( const ODBC::Statement& statement )
        {
            Base::BindColumns( statement );

            Bind(statement, POSITIONPANTILTMODE_FIELD_ID, positionPanTiltMode_);
            Bind(statement, PANANGLE_FIELD_ID, panAngle_);
            Bind(statement, TILTANGLE_FIELD_ID, tiltAngle_);
            Bind(statement, POSITIONFOCALLENGTHMODE_FIELD_ID, positionFocalLengthMode_);
            Bind(statement, FOCALLENGTH_FIELD_ID, focalLength_);
            Bind(statement, SPEEDPANTILTMODE_FIELD_ID, speedPanTiltMode_);
            Bind(statement, PANSPEED_FIELD_ID, panSpeed_);
            Bind(statement, TILTSPEED_FIELD_ID, tiltSpeed_);
            Bind(statement, SPEEDFOCALLENGTHMODE_FIELD_ID, speedFocalLengthMode_);
            Bind(statement, ZOOMSPEED_FIELD_ID, zoomSpeed_);
        }

        template<IO::StreamWriter StreamT>
        void WriteColumns( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteColumns( destination );
            WriteColumnValue( destination, positionPanTiltMode_);
            WriteColumnValue( destination, panAngle_);
            WriteColumnValue( destination, tiltAngle_);
            WriteColumnValue( destination, positionFocalLengthMode_);
            WriteColumnValue( destination, focalLength_);
            WriteColumnValue( destination, speedPanTiltMode_);
            WriteColumnValue( destination, panSpeed_);
            WriteColumnValue( destination, tiltSpeed_);
            WriteColumnValue( destination, speedFocalLengthMode_);
            WriteColumnValue( destination, zoomSpeed_);
        }
    };

    using SimpleCameraCommandAbsoluteMoveDataReader = SimpleColumnDataReader<CameraCommandAbsoluteMoveColumnData>;

    class CameraCommandAdjustPanTiltZoomColumnData : public CameraCommandColumnData
    {
        DBDouble x_;
        DBDouble y_;
        DBDouble z_;
    public:
        using Base = CameraCommandColumnData;

        static constexpr std::wstring_view FieldNames = L"[Id],[RowVersion],[Camera],[Timestamp],[DeviceCommandSourceType],[DeviceCommandSourceId],[Reply],[X],[Y],[Z]";
        static constexpr std::wstring_view ViewName = L"CameraCommandAdjustPanTiltZoomView";

        static constexpr SQLUSMALLINT X_FIELD_ID = 8;
        static constexpr SQLUSMALLINT Y_FIELD_ID = 9;
        static constexpr SQLUSMALLINT Z_FIELD_ID = 10;

        CameraCommandAdjustPanTiltZoomColumnData( ) = default;

        virtual Kind GetKind() const override
        {
            return Kind::CameraCommandAdjustPanTiltZoom;
        }

        const DBDouble& X( ) const
        {
            return x_;
        }
        void SetX( const DBDouble& x )
        {
            x_ = x;
        }
        const DBDouble& Y( ) const
        {
            return y_;
        }
        void SetY( const DBDouble& y )
        {
            y_ = y;
        }
        const DBDouble& Z( ) const
        {
            return z_;
        }
        void SetZ( const DBDouble& z )
        {
            z_ = z;
        }
        void BindColumns( const ODBC::Statement& statement )
        {
            Base::BindColumns( statement );

            Bind(statement, X_FIELD_ID, x_);
            Bind(statement, Y_FIELD_ID, y_);
            Bind(statement, Z_FIELD_ID, z_);
        }

        template<IO::StreamWriter StreamT>
        void WriteColumns( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteColumns( destination );
            WriteColumnValue( destination, x_);
            WriteColumnValue( destination, y_);
            WriteColumnValue( destination, z_);
        }
    };

    using SimpleCameraCommandAdjustPanTiltZoomDataReader = SimpleColumnDataReader<CameraCommandAdjustPanTiltZoomColumnData>;

    class CameraCommandContinuousMoveColumnData : public CameraCommandColumnData
    {
        bool normalized_ = false;
        DBDouble panVelocity_;
        DBDouble tiltVelocity_;
        DBDouble zoomVelocity_;
        DBTimeSpan duration_;
    public:
        using Base = CameraCommandColumnData;

        static constexpr std::wstring_view FieldNames = L"[Id],[RowVersion],[Camera],[Timestamp],[DeviceCommandSourceType],[DeviceCommandSourceId],[Reply],[Normalized],[PanVelocity],[TiltVelocity],[ZoomVelocity],[Duration]";
        static constexpr std::wstring_view ViewName = L"CameraCommandContinuousMoveView";

        static constexpr SQLUSMALLINT NORMALIZED_FIELD_ID = 8;
        static constexpr SQLUSMALLINT PANVELOCITY_FIELD_ID = 9;
        static constexpr SQLUSMALLINT TILTVELOCITY_FIELD_ID = 10;
        static constexpr SQLUSMALLINT ZOOMVELOCITY_FIELD_ID = 11;
        static constexpr SQLUSMALLINT DURATION_FIELD_ID = 12;

        CameraCommandContinuousMoveColumnData( ) = default;

        virtual Kind GetKind() const override
        {
            return Kind::CameraCommandContinuousMove;
        }

        bool Normalized( ) const
        {
            return normalized_;
        }
        void SetNormalized( bool normalized )
        {
            normalized_ = normalized;
        }
        const DBDouble& PanVelocity( ) const
        {
            return panVelocity_;
        }
        void SetPanVelocity( const DBDouble& panVelocity )
        {
            panVelocity_ = panVelocity;
        }
        const DBDouble& TiltVelocity( ) const
        {
            return tiltVelocity_;
        }
        void SetTiltVelocity( const DBDouble& tiltVelocity )
        {
            tiltVelocity_ = tiltVelocity;
        }
        const DBDouble& ZoomVelocity( ) const
        {
            return zoomVelocity_;
        }
        void SetZoomVelocity( const DBDouble& zoomVelocity )
        {
            zoomVelocity_ = zoomVelocity;
        }
        const DBTimeSpan& Duration( ) const
        {
            return duration_;
        }
        void SetDuration( const DBTimeSpan& duration )
        {
            duration_ = duration;
        }
        void BindColumns( const ODBC::Statement& statement )
        {
            Base::BindColumns( statement );

            Bind(statement, NORMALIZED_FIELD_ID, normalized_);
            Bind(statement, PANVELOCITY_FIELD_ID, panVelocity_);
            Bind(statement, TILTVELOCITY_FIELD_ID, tiltVelocity_);
            Bind(statement, ZOOMVELOCITY_FIELD_ID, zoomVelocity_);
            Bind(statement, DURATION_FIELD_ID, duration_);
        }

        template<IO::StreamWriter StreamT>
        void WriteColumns( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteColumns( destination );
            WriteColumnValue( destination, normalized_);
            WriteColumnValue( destination, panVelocity_);
            WriteColumnValue( destination, tiltVelocity_);
            WriteColumnValue( destination, zoomVelocity_);
            WriteColumnValue( destination, duration_);
        }
    };

    using SimpleCameraCommandContinuousMoveDataReader = SimpleColumnDataReader<CameraCommandContinuousMoveColumnData>;

    class CameraCommandGeoMoveColumnData : public CameraCommandColumnData
    {
        double latitude_ = 0.0;
        double longitude_ = 0.0;
        DBDouble altitude_;
        DBDouble viewportWidth_;
        DBDouble viewportHeight_;
    public:
        using Base = CameraCommandColumnData;

        static constexpr std::wstring_view FieldNames = L"[Id],[RowVersion],[Camera],[Timestamp],[DeviceCommandSourceType],[DeviceCommandSourceId],[Reply],[Latitude],[Longitude],[Altitude],[ViewportWidth],[ViewportHeight]";
        static constexpr std::wstring_view ViewName = L"CameraCommandGeoMoveView";

        static constexpr SQLUSMALLINT LATITUDE_FIELD_ID = 8;
        static constexpr SQLUSMALLINT LONGITUDE_FIELD_ID = 9;
        static constexpr SQLUSMALLINT ALTITUDE_FIELD_ID = 10;
        static constexpr SQLUSMALLINT VIEWPORTWIDTH_FIELD_ID = 11;
        static constexpr SQLUSMALLINT VIEWPORTHEIGHT_FIELD_ID = 12;

        CameraCommandGeoMoveColumnData( ) = default;

        virtual Kind GetKind() const override
        {
            return Kind::CameraCommandGeoMove;
        }

        double Latitude( ) const
        {
            return latitude_;
        }
        void SetLatitude( double latitude )
        {
            latitude_ = latitude;
        }
        double Longitude( ) const
        {
            return longitude_;
        }
        void SetLongitude( double longitude )
        {
            longitude_ = longitude;
        }
        const DBDouble& Altitude( ) const
        {
            return altitude_;
        }
        void SetAltitude( const DBDouble& altitude )
        {
            altitude_ = altitude;
        }
        const DBDouble& ViewportWidth( ) const
        {
            return viewportWidth_;
        }
        void SetViewportWidth( const DBDouble& viewportWidth )
        {
            viewportWidth_ = viewportWidth;
        }
        const DBDouble& ViewportHeight( ) const
        {
            return viewportHeight_;
        }
        void SetViewportHeight( const DBDouble& viewportHeight )
        {
            viewportHeight_ = viewportHeight;
        }
        void BindColumns( const ODBC::Statement& statement )
        {
            Base::BindColumns( statement );

            Bind(statement, LATITUDE_FIELD_ID, latitude_);
            Bind(statement, LONGITUDE_FIELD_ID, longitude_);
            Bind(statement, ALTITUDE_FIELD_ID, altitude_);
            Bind(statement, VIEWPORTWIDTH_FIELD_ID, viewportWidth_);
            Bind(statement, VIEWPORTHEIGHT_FIELD_ID, viewportHeight_);
        }

        template<IO::StreamWriter StreamT>
        void WriteColumns( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteColumns( destination );
            WriteColumnValue( destination, latitude_);
            WriteColumnValue( destination, longitude_);
            WriteColumnValue( destination, altitude_);
            WriteColumnValue( destination, viewportWidth_);
            WriteColumnValue( destination, viewportHeight_);
        }
    };

    using SimpleCameraCommandGeoMoveDataReader = SimpleColumnDataReader<CameraCommandGeoMoveColumnData>;

    class CameraCommandRelativeMoveColumnData : public CameraCommandColumnData
    {
        bool normalized_ = false;
        DBDouble panAngle_;
        DBDouble tiltAngle_;
        DBDouble focalLength_;
        DBDouble panSpeed_;
        DBDouble tiltSpeed_;
        DBDouble zoomSpeed_;
    public:
        using Base = CameraCommandColumnData;

        static constexpr std::wstring_view FieldNames = L"[Id],[RowVersion],[Camera],[Timestamp],[DeviceCommandSourceType],[DeviceCommandSourceId],[Reply],[Normalized],[PanAngle],[TiltAngle],[FocalLength],[PanSpeed],[TiltSpeed],[ZoomSpeed]";
        static constexpr std::wstring_view ViewName = L"CameraCommandRelativeMoveView";

        static constexpr SQLUSMALLINT NORMALIZED_FIELD_ID = 8;
        static constexpr SQLUSMALLINT PANANGLE_FIELD_ID = 9;
        static constexpr SQLUSMALLINT TILTANGLE_FIELD_ID = 10;
        static constexpr SQLUSMALLINT FOCALLENGTH_FIELD_ID = 11;
        static constexpr SQLUSMALLINT PANSPEED_FIELD_ID = 12;
        static constexpr SQLUSMALLINT TILTSPEED_FIELD_ID = 13;
        static constexpr SQLUSMALLINT ZOOMSPEED_FIELD_ID = 14;

        CameraCommandRelativeMoveColumnData( ) = default;

        virtual Kind GetKind() const override
        {
            return Kind::CameraCommandRelativeMove;
        }

        bool Normalized( ) const
        {
            return normalized_;
        }
        void SetNormalized( bool normalized )
        {
            normalized_ = normalized;
        }
        const DBDouble& PanAngle( ) const
        {
            return panAngle_;
        }
        void SetPanAngle( const DBDouble& panAngle )
        {
            panAngle_ = panAngle;
        }
        const DBDouble& TiltAngle( ) const
        {
            return tiltAngle_;
        }
        void SetTiltAngle( const DBDouble& tiltAngle )
        {
            tiltAngle_ = tiltAngle;
        }
        const DBDouble& FocalLength( ) const
        {
            return focalLength_;
        }
        void SetFocalLength( const DBDouble& focalLength )
        {
            focalLength_ = focalLength;
        }
        const DBDouble& PanSpeed( ) const
        {
            return panSpeed_;
        }
        void SetPanSpeed( const DBDouble& panSpeed )
        {
            panSpeed_ = panSpeed;
        }
        const DBDouble& TiltSpeed( ) const
        {
            return tiltSpeed_;
        }
        void SetTiltSpeed( const DBDouble& tiltSpeed )
        {
            tiltSpeed_ = tiltSpeed;
        }
        const DBDouble& ZoomSpeed( ) const
        {
            return zoomSpeed_;
        }
        void SetZoomSpeed( const DBDouble& zoomSpeed )
        {
            zoomSpeed_ = zoomSpeed;
        }
        void BindColumns( const ODBC::Statement& statement )
        {
            Base::BindColumns( statement );

            Bind(statement, NORMALIZED_FIELD_ID, normalized_);
            Bind(statement, PANANGLE_FIELD_ID, panAngle_);
            Bind(statement, TILTANGLE_FIELD_ID, tiltAngle_);
            Bind(statement, FOCALLENGTH_FIELD_ID, focalLength_);
            Bind(statement, PANSPEED_FIELD_ID, panSpeed_);
            Bind(statement, TILTSPEED_FIELD_ID, tiltSpeed_);
            Bind(statement, ZOOMSPEED_FIELD_ID, zoomSpeed_);
        }

        template<IO::StreamWriter StreamT>
        void WriteColumns( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteColumns( destination );
            WriteColumnValue( destination, normalized_);
            WriteColumnValue( destination, panAngle_);
            WriteColumnValue( destination, tiltAngle_);
            WriteColumnValue( destination, focalLength_);
            WriteColumnValue( destination, panSpeed_);
            WriteColumnValue( destination, tiltSpeed_);
            WriteColumnValue( destination, zoomSpeed_);
        }
    };

    using SimpleCameraCommandRelativeMoveDataReader = SimpleColumnDataReader<CameraCommandRelativeMoveColumnData>;

    class CameraCommandReleasePTZOwnershipColumnData : public CameraCommandColumnData
    {
    public:
        using Base = CameraCommandColumnData;

        static constexpr std::wstring_view FieldNames = L"[Id],[RowVersion],[Camera],[Timestamp],[DeviceCommandSourceType],[DeviceCommandSourceId],[Reply]";
        static constexpr std::wstring_view ViewName = L"CameraCommandReleasePTZOwnershipView";

        CameraCommandReleasePTZOwnershipColumnData( ) = default;

        virtual Kind GetKind() const override
        {
            return Kind::CameraCommandReleasePTZOwnership;
        }

        template<IO::StreamWriter StreamT>
        void WriteColumns( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteColumns( destination );
        }
    };

    using SimpleCameraCommandReleasePTZOwnershipDataReader = SimpleColumnDataReader<CameraCommandReleasePTZOwnershipColumnData>;

    class CameraCommandRequestPTZOwnershipColumnData : public CameraCommandColumnData
    {
    public:
        using Base = CameraCommandColumnData;

        static constexpr std::wstring_view FieldNames = L"[Id],[RowVersion],[Camera],[Timestamp],[DeviceCommandSourceType],[DeviceCommandSourceId],[Reply]";
        static constexpr std::wstring_view ViewName = L"CameraCommandRequestPTZOwnershipView";

        CameraCommandRequestPTZOwnershipColumnData( ) = default;

        virtual Kind GetKind() const override
        {
            return Kind::CameraCommandRequestPTZOwnership;
        }

        template<IO::StreamWriter StreamT>
        void WriteColumns( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteColumns( destination );
        }
    };

    using SimpleCameraCommandRequestPTZOwnershipDataReader = SimpleColumnDataReader<CameraCommandRequestPTZOwnershipColumnData>;

    class CameraCommandSetAutoFocusColumnData : public CameraCommandColumnData
    {
        bool enabled_ = false;
    public:
        using Base = CameraCommandColumnData;

        static constexpr std::wstring_view FieldNames = L"[Id],[RowVersion],[Camera],[Timestamp],[DeviceCommandSourceType],[DeviceCommandSourceId],[Reply],[Enabled]";
        static constexpr std::wstring_view ViewName = L"CameraCommandSetAutoFocusView";

        static constexpr SQLUSMALLINT ENABLED_FIELD_ID = 8;

        CameraCommandSetAutoFocusColumnData( ) = default;

        virtual Kind GetKind() const override
        {
            return Kind::CameraCommandSetAutoFocus;
        }

        bool Enabled( ) const
        {
            return enabled_;
        }
        void SetEnabled( bool enabled )
        {
            enabled_ = enabled;
        }
        void BindColumns( const ODBC::Statement& statement )
        {
            Base::BindColumns( statement );

            Bind(statement, ENABLED_FIELD_ID, enabled_);
        }

        template<IO::StreamWriter StreamT>
        void WriteColumns( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteColumns( destination );
            WriteColumnValue( destination, enabled_);
        }
    };

    using SimpleCameraCommandSetAutoFocusDataReader = SimpleColumnDataReader<CameraCommandSetAutoFocusColumnData>;

    class CameraCommandSetBlackAndWhiteColumnData : public CameraCommandColumnData
    {
        bool enabled_ = false;
    public:
        using Base = CameraCommandColumnData;

        static constexpr std::wstring_view FieldNames = L"[Id],[RowVersion],[Camera],[Timestamp],[DeviceCommandSourceType],[DeviceCommandSourceId],[Reply],[Enabled]";
        static constexpr std::wstring_view ViewName = L"CameraCommandSetBlackAndWhiteView";

        static constexpr SQLUSMALLINT ENABLED_FIELD_ID = 8;

        CameraCommandSetBlackAndWhiteColumnData( ) = default;

        virtual Kind GetKind() const override
        {
            return Kind::CameraCommandSetBlackAndWhite;
        }

        bool Enabled( ) const
        {
            return enabled_;
        }
        void SetEnabled( bool enabled )
        {
            enabled_ = enabled;
        }
        void BindColumns( const ODBC::Statement& statement )
        {
            Base::BindColumns( statement );

            Bind(statement, ENABLED_FIELD_ID, enabled_);
        }

        template<IO::StreamWriter StreamT>
        void WriteColumns( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteColumns( destination );
            WriteColumnValue( destination, enabled_);
        }
    };

    using SimpleCameraCommandSetBlackAndWhiteDataReader = SimpleColumnDataReader<CameraCommandSetBlackAndWhiteColumnData>;

    class CameraCommandSetFollowedColumnData : public CameraCommandColumnData
    {
        Guid trackId_;
        Data::CameraFollowReason reason_ = Data::CameraFollowReason::Alarm;
    public:
        using Base = CameraCommandColumnData;

        static constexpr std::wstring_view FieldNames = L"[Id],[RowVersion],[Camera],[Timestamp],[DeviceCommandSourceType],[DeviceCommandSourceId],[Reply],[TrackId],[Reason]";
        static constexpr std::wstring_view ViewName = L"CameraCommandSetFollowedView";

        static constexpr SQLUSMALLINT TRACKID_FIELD_ID = 8;
        static constexpr SQLUSMALLINT REASON_FIELD_ID = 9;

        CameraCommandSetFollowedColumnData( ) = default;

        virtual Kind GetKind() const override
        {
            return Kind::CameraCommandSetFollowed;
        }

        const Guid& TrackId( ) const
        {
            return trackId_;
        }
        void SetTrackId( const Guid& trackId )
        {
            trackId_ = trackId;
        }
        Data::CameraFollowReason Reason( ) const
        {
            return reason_;
        }
        void SetReason( Data::CameraFollowReason reason )
        {
            reason_ = reason;
        }
        void BindColumns( const ODBC::Statement& statement )
        {
            Base::BindColumns( statement );

            Bind(statement, TRACKID_FIELD_ID, trackId_);
            Bind(statement, REASON_FIELD_ID, reason_);
        }

        template<IO::StreamWriter StreamT>
        void WriteColumns( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteColumns( destination );
            WriteColumnValue( destination, trackId_);
            WriteColumnValue( destination, reason_);
        }
    };

    using SimpleCameraCommandSetFollowedDataReader = SimpleColumnDataReader<CameraCommandSetFollowedColumnData>;

    class CameraCommandSetInfraRedLampColumnData : public CameraCommandColumnData
    {
        bool enabled_ = false;
    public:
        using Base = CameraCommandColumnData;

        static constexpr std::wstring_view FieldNames = L"[Id],[RowVersion],[Camera],[Timestamp],[DeviceCommandSourceType],[DeviceCommandSourceId],[Reply],[Enabled]";
        static constexpr std::wstring_view ViewName = L"CameraCommandSetInfraRedLampView";

        static constexpr SQLUSMALLINT ENABLED_FIELD_ID = 8;

        CameraCommandSetInfraRedLampColumnData( ) = default;

        virtual Kind GetKind() const override
        {
            return Kind::CameraCommandSetInfraRedLamp;
        }

        bool Enabled( ) const
        {
            return enabled_;
        }
        void SetEnabled( bool enabled )
        {
            enabled_ = enabled;
        }
        void BindColumns( const ODBC::Statement& statement )
        {
            Base::BindColumns( statement );

            Bind(statement, ENABLED_FIELD_ID, enabled_);
        }

        template<IO::StreamWriter StreamT>
        void WriteColumns( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteColumns( destination );
            WriteColumnValue( destination, enabled_);
        }
    };

    using SimpleCameraCommandSetInfraRedLampDataReader = SimpleColumnDataReader<CameraCommandSetInfraRedLampColumnData>;

    class CameraCommandSetWasherColumnData : public CameraCommandColumnData
    {
        bool enabled_ = false;
    public:
        using Base = CameraCommandColumnData;

        static constexpr std::wstring_view FieldNames = L"[Id],[RowVersion],[Camera],[Timestamp],[DeviceCommandSourceType],[DeviceCommandSourceId],[Reply],[Enabled]";
        static constexpr std::wstring_view ViewName = L"CameraCommandSetWasherView";

        static constexpr SQLUSMALLINT ENABLED_FIELD_ID = 8;

        CameraCommandSetWasherColumnData( ) = default;

        virtual Kind GetKind() const override
        {
            return Kind::CameraCommandSetWasher;
        }

        bool Enabled( ) const
        {
            return enabled_;
        }
        void SetEnabled( bool enabled )
        {
            enabled_ = enabled;
        }
        void BindColumns( const ODBC::Statement& statement )
        {
            Base::BindColumns( statement );

            Bind(statement, ENABLED_FIELD_ID, enabled_);
        }

        template<IO::StreamWriter StreamT>
        void WriteColumns( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteColumns( destination );
            WriteColumnValue( destination, enabled_);
        }
    };

    using SimpleCameraCommandSetWasherDataReader = SimpleColumnDataReader<CameraCommandSetWasherColumnData>;

    class CameraCommandSetWiperColumnData : public CameraCommandColumnData
    {
        bool enabled_ = false;
    public:
        using Base = CameraCommandColumnData;

        static constexpr std::wstring_view FieldNames = L"[Id],[RowVersion],[Camera],[Timestamp],[DeviceCommandSourceType],[DeviceCommandSourceId],[Reply],[Enabled]";
        static constexpr std::wstring_view ViewName = L"CameraCommandSetWiperView";

        static constexpr SQLUSMALLINT ENABLED_FIELD_ID = 8;

        CameraCommandSetWiperColumnData( ) = default;

        virtual Kind GetKind() const override
        {
            return Kind::CameraCommandSetWiper;
        }

        bool Enabled( ) const
        {
            return enabled_;
        }
        void SetEnabled( bool enabled )
        {
            enabled_ = enabled;
        }
        void BindColumns( const ODBC::Statement& statement )
        {
            Base::BindColumns( statement );

            Bind(statement, ENABLED_FIELD_ID, enabled_);
        }

        template<IO::StreamWriter StreamT>
        void WriteColumns( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteColumns( destination );
            WriteColumnValue( destination, enabled_);
        }
    };

    using SimpleCameraCommandSetWiperDataReader = SimpleColumnDataReader<CameraCommandSetWiperColumnData>;

    class CameraCommandStopColumnData : public CameraCommandColumnData
    {
        bool panTilt_ = false;
        bool zoom_ = false;
    public:
        using Base = CameraCommandColumnData;

        static constexpr std::wstring_view FieldNames = L"[Id],[RowVersion],[Camera],[Timestamp],[DeviceCommandSourceType],[DeviceCommandSourceId],[Reply],[PanTilt],[Zoom]";
        static constexpr std::wstring_view ViewName = L"CameraCommandStopView";

        static constexpr SQLUSMALLINT PANTILT_FIELD_ID = 8;
        static constexpr SQLUSMALLINT ZOOM_FIELD_ID = 9;

        CameraCommandStopColumnData( ) = default;

        virtual Kind GetKind() const override
        {
            return Kind::CameraCommandStop;
        }

        bool PanTilt( ) const
        {
            return panTilt_;
        }
        void SetPanTilt( bool panTilt )
        {
            panTilt_ = panTilt;
        }
        bool Zoom( ) const
        {
            return zoom_;
        }
        void SetZoom( bool zoom )
        {
            zoom_ = zoom;
        }
        void BindColumns( const ODBC::Statement& statement )
        {
            Base::BindColumns( statement );

            Bind(statement, PANTILT_FIELD_ID, panTilt_);
            Bind(statement, ZOOM_FIELD_ID, zoom_);
        }

        template<IO::StreamWriter StreamT>
        void WriteColumns( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteColumns( destination );
            WriteColumnValue( destination, panTilt_);
            WriteColumnValue( destination, zoom_);
        }
    };

    using SimpleCameraCommandStopDataReader = SimpleColumnDataReader<CameraCommandStopColumnData>;

    class CameraCommandReplyColumnData : public BaseColumnData
    {
        Guid id_;
        Int64 rowVersion_ = 0;
        Guid camera_;
        DateTime timestamp_;
        Guid command_;
        Data::DeviceCommandReplyStatus status_ = Data::DeviceCommandReplyStatus::Unknown;
        WideString message_;
        SQLLEN messageLength_ = SQL_NULL_DATA;
        double panAngle_ = 0.0;
        double tiltAngle_ = 0.0;
        double focalLength_ = 0.0;
    public:
        using Base = BaseColumnData;

        static constexpr std::wstring_view FieldNames = L"[Id],[RowVersion],[Camera],[Timestamp],[Command],[Status],[PanAngle],[TiltAngle],[FocalLength],[Message]";
        static constexpr std::wstring_view ViewName = L"CameraCommandReplyView";

        static constexpr SQLUSMALLINT ID_FIELD_ID = 1;
        static constexpr SQLUSMALLINT ROWVERSION_FIELD_ID = 2;
        static constexpr SQLUSMALLINT CAMERA_FIELD_ID = 3;
        static constexpr SQLUSMALLINT TIMESTAMP_FIELD_ID = 4;
        static constexpr SQLUSMALLINT COMMAND_FIELD_ID = 5;
        static constexpr SQLUSMALLINT STATUS_FIELD_ID = 6;
        static constexpr SQLUSMALLINT PANANGLE_FIELD_ID = 7;
        static constexpr SQLUSMALLINT TILTANGLE_FIELD_ID = 8;
        static constexpr SQLUSMALLINT FOCALLENGTH_FIELD_ID = 9;
        static constexpr SQLUSMALLINT MESSAGE_FIELD_ID = 10;

        CameraCommandReplyColumnData( ) = default;

        virtual Kind GetKind() const override
        {
            return Kind::CameraCommandReply;
        }

        const Guid& Id( ) const
        {
            return id_;
        }
        void SetId( const Guid& id )
        {
            id_ = id;
        }
        Int64 RowVersion( ) const
        {
            return rowVersion_;
        }
        void SetRowVersion( const Int64& rowVersion )
        {
            rowVersion_ = rowVersion;
        }
        const Guid& Camera( ) const
        {
            return camera_;
        }
        void SetCamera( const Guid& camera )
        {
            camera_ = camera;
        }
        const DateTime& Timestamp( ) const
        {
            return timestamp_;
        }
        void SetTimestamp( const DateTime& timestamp )
        {
            timestamp_ = timestamp;
        }
        const Guid& Command( ) const
        {
            return command_;
        }
        void SetCommand( const Guid& command )
        {
            command_ = command;
        }
        Data::DeviceCommandReplyStatus Status( ) const
        {
            return status_;
        }
        void SetStatus( Data::DeviceCommandReplyStatus status )
        {
            status_ = status;
        }
        const WideString& Message( ) const
        {
            return message_;
        }
        void SetMessage( const WideString& message )
        {
            message_ = message;
        }
        double PanAngle( ) const
        {
            return panAngle_;
        }
        void SetPanAngle( double panAngle )
        {
            panAngle_ = panAngle;
        }
        double TiltAngle( ) const
        {
            return tiltAngle_;
        }
        void SetTiltAngle( double tiltAngle )
        {
            tiltAngle_ = tiltAngle;
        }
        double FocalLength( ) const
        {
            return focalLength_;
        }
        void SetFocalLength( double focalLength )
        {
            focalLength_ = focalLength;
        }
        void BindColumns( const ODBC::Statement& statement )
        {
            Bind(statement, ID_FIELD_ID, id_);
            Bind(statement, ROWVERSION_FIELD_ID, rowVersion_);
            Bind(statement, CAMERA_FIELD_ID, camera_);
            Bind(statement, TIMESTAMP_FIELD_ID, timestamp_);
            Bind(statement, COMMAND_FIELD_ID, command_);
            Bind(statement, STATUS_FIELD_ID, status_);
            Bind(statement, PANANGLE_FIELD_ID, panAngle_);
            Bind(statement, TILTANGLE_FIELD_ID, tiltAngle_);
            Bind(statement, FOCALLENGTH_FIELD_ID, focalLength_);
        }

        void ReadUnboundData( const ODBC::Statement& statement )
        {
            Base::ReadUnboundData( statement );

            message_ = statement.GetWideString(MESSAGE_FIELD_ID);
        }
        template<IO::StreamWriter StreamT>
        void WriteColumns( IO::BinaryWriter<StreamT>& destination ) const
        {
            WriteColumnValue( destination, id_);
            WriteColumnValue( destination, rowVersion_);
            WriteColumnValue( destination, camera_);
            WriteColumnValue( destination, timestamp_);
            WriteColumnValue( destination, command_);
            WriteColumnValue( destination, status_);
            WriteColumnValue( destination, message_);
            WriteColumnValue( destination, panAngle_);
            WriteColumnValue( destination, tiltAngle_);
            WriteColumnValue( destination, focalLength_);
        }
    };

    using SimpleCameraCommandReplyDataReader = SimpleColumnDataReader<CameraCommandReplyColumnData>;

    class CameraConfigurationColumnData : public BaseColumnData
    {
        Guid id_;
        Int64 rowVersion_ = 0;
        Guid camera_;
        DateTime timestamp_;
        Data::CameraControlProtocol cameraControlProtocol_ = Data::CameraControlProtocol::Unknown;
        FixedDBWideString<127> cameraAddress_;
        Int32 cameraPort_ = 0;
        FixedDBWideString<127> cameraControlAddress_;
        Int32 cameraControlPort_ = 0;
        FixedDBWideString<127> cameraUserName_;
        FixedDBWideString<127> cameraPassword_;
        bool useRtspUriOverride_ = false;
        FixedDBWideString<127> rtspUriOverride_;
        double latitude_ = 0.0;
        double longitude_ = 0.0;
        double altitude_ = 0.0;
        bool useRelativePosition_ = false;
        double azimuthFromGPS_ = 0.0;
        double distanceFromGPS_ = 0.0;
        Data::CameraPanTiltMode panTiltMode_ = Data::CameraPanTiltMode::Unknown;
        double minTiltAngle_ = 0.0;
        double maxTiltAngle_ = 0.0;
        double minTiltScaleAngle_ = 0.0;
        double maxTiltScaleAngle_ = 0.0;
        bool useReverseTiltAngle_ = false;
        bool useReverseNormalizedTiltAngle_ = false;
        double minTiltVelocity_ = 0.0;
        double maxTiltVelocity_ = 0.0;
        double minTiltSpeed_ = 0.0;
        double maxTiltSpeed_ = 0.0;
        double minPanAngle_ = 0.0;
        double maxPanAngle_ = 0.0;
        double minPanScaleAngle_ = 0.0;
        double maxPanScaleAngle_ = 0.0;
        bool useReversePanAngle_ = false;
        bool useReverseNormalizedPanAngle_ = false;
        double minPanVelocity_ = 0.0;
        double maxPanVelocity_ = 0.0;
        double minPanSpeed_ = 0.0;
        double maxPanSpeed_ = 0.0;
        Data::CameraFocalLengthMode focalLengthMode_ = Data::CameraFocalLengthMode::Unknown;
        double minFocalLength_ = 0.0;
        double maxFocalLength_ = 0.0;
        double minFocalLengthScale_ = 0.0;
        double maxFocalLengthScale_ = 0.0;
        double minZoomVelocity_ = 0.0;
        double maxZoomVelocity_ = 0.0;
        double minZoomSpeed_ = 0.0;
        double maxZoomSpeed_ = 0.0;
        double imageSensorWidth_ = 0.0;
        double imageSensorHeight_ = 0.0;
        double homePanAngle_ = 0.0;
        double homeTiltAngle_ = 0.0;
        double homeFocalLength_ = 0.0;
        double panOffset_ = 0.0;
        double tiltOffset_ = 0.0;
        double aimAltitude_ = 0.0;
        double minimumTargetWidth_ = 0.0;
        TimeSpan targetLockTimeout_;
        TimeSpan updateStatusInterval_;
        TimeSpan readTimeout_;
        TimeSpan moveCommandStatusDelay_;
        FixedDBWideString<127> ptzProfileName_;
        FixedDBWideString<127> ptzConfigurationToken_;
        FixedDBWideString<127> videoSourceToken_;
    public:
        using Base = BaseColumnData;

        static constexpr std::wstring_view FieldNames = L"[Id],[RowVersion],[Camera],[Timestamp],[CameraControlProtocol],[CameraAddress],[CameraPort],[CameraControlAddress],[CameraControlPort],[CameraUserName],[CameraPassword],[UseRtspUriOverride],[RtspUriOverride],[Latitude],[Longitude],[Altitude],[UseRelativePosition],[AzimuthFromGPS],[DistanceFromGPS],[PanTiltMode],[MinTiltAngle],[MaxTiltAngle],[MinTiltScaleAngle],[MaxTiltScaleAngle],[UseReverseTiltAngle],[UseReverseNormalizedTiltAngle],[MinTiltVelocity],[MaxTiltVelocity],[MinTiltSpeed],[MaxTiltSpeed],[MinPanAngle],[MaxPanAngle],[MinPanScaleAngle],[MaxPanScaleAngle],[UseReversePanAngle],[UseReverseNormalizedPanAngle],[MinPanVelocity],[MaxPanVelocity],[MinPanSpeed],[MaxPanSpeed],[FocalLengthMode],[MinFocalLength],[MaxFocalLength],[MinFocalLengthScale],[MaxFocalLengthScale],[MinZoomVelocity],[MaxZoomVelocity],[MinZoomSpeed],[MaxZoomSpeed],[ImageSensorWidth],[ImageSensorHeight],[HomePanAngle],[HomeTiltAngle],[HomeFocalLength],[PanOffset],[TiltOffset],[AimAltitude],[MinimumTargetWidth],[TargetLockTimeout],[UpdateStatusInterval],[ReadTimeout],[MoveCommandStatusDelay],[PtzProfileName],[PtzConfigurationToken],[VideoSourceToken]";
        static constexpr std::wstring_view ViewName = L"CameraConfigurationView";

        static constexpr SQLUSMALLINT ID_FIELD_ID = 1;
        static constexpr SQLUSMALLINT ROWVERSION_FIELD_ID = 2;
        static constexpr SQLUSMALLINT CAMERA_FIELD_ID = 3;
        static constexpr SQLUSMALLINT TIMESTAMP_FIELD_ID = 4;
        static constexpr SQLUSMALLINT CAMERACONTROLPROTOCOL_FIELD_ID = 5;
        static constexpr SQLUSMALLINT CAMERAADDRESS_FIELD_ID = 6;
        static constexpr SQLUSMALLINT CAMERAPORT_FIELD_ID = 7;
        static constexpr SQLUSMALLINT CAMERACONTROLADDRESS_FIELD_ID = 8;
        static constexpr SQLUSMALLINT CAMERACONTROLPORT_FIELD_ID = 9;
        static constexpr SQLUSMALLINT CAMERAUSERNAME_FIELD_ID = 10;
        static constexpr SQLUSMALLINT CAMERAPASSWORD_FIELD_ID = 11;
        static constexpr SQLUSMALLINT USERTSPURIOVERRIDE_FIELD_ID = 12;
        static constexpr SQLUSMALLINT RTSPURIOVERRIDE_FIELD_ID = 13;
        static constexpr SQLUSMALLINT LATITUDE_FIELD_ID = 14;
        static constexpr SQLUSMALLINT LONGITUDE_FIELD_ID = 15;
        static constexpr SQLUSMALLINT ALTITUDE_FIELD_ID = 16;
        static constexpr SQLUSMALLINT USERELATIVEPOSITION_FIELD_ID = 17;
        static constexpr SQLUSMALLINT AZIMUTHFROMGPS_FIELD_ID = 18;
        static constexpr SQLUSMALLINT DISTANCEFROMGPS_FIELD_ID = 19;
        static constexpr SQLUSMALLINT PANTILTMODE_FIELD_ID = 20;
        static constexpr SQLUSMALLINT MINTILTANGLE_FIELD_ID = 21;
        static constexpr SQLUSMALLINT MAXTILTANGLE_FIELD_ID = 22;
        static constexpr SQLUSMALLINT MINTILTSCALEANGLE_FIELD_ID = 23;
        static constexpr SQLUSMALLINT MAXTILTSCALEANGLE_FIELD_ID = 24;
        static constexpr SQLUSMALLINT USEREVERSETILTANGLE_FIELD_ID = 25;
        static constexpr SQLUSMALLINT USEREVERSENORMALIZEDTILTANGLE_FIELD_ID = 26;
        static constexpr SQLUSMALLINT MINTILTVELOCITY_FIELD_ID = 27;
        static constexpr SQLUSMALLINT MAXTILTVELOCITY_FIELD_ID = 28;
        static constexpr SQLUSMALLINT MINTILTSPEED_FIELD_ID = 29;
        static constexpr SQLUSMALLINT MAXTILTSPEED_FIELD_ID = 30;
        static constexpr SQLUSMALLINT MINPANANGLE_FIELD_ID = 31;
        static constexpr SQLUSMALLINT MAXPANANGLE_FIELD_ID = 32;
        static constexpr SQLUSMALLINT MINPANSCALEANGLE_FIELD_ID = 33;
        static constexpr SQLUSMALLINT MAXPANSCALEANGLE_FIELD_ID = 34;
        static constexpr SQLUSMALLINT USEREVERSEPANANGLE_FIELD_ID = 35;
        static constexpr SQLUSMALLINT USEREVERSENORMALIZEDPANANGLE_FIELD_ID = 36;
        static constexpr SQLUSMALLINT MINPANVELOCITY_FIELD_ID = 37;
        static constexpr SQLUSMALLINT MAXPANVELOCITY_FIELD_ID = 38;
        static constexpr SQLUSMALLINT MINPANSPEED_FIELD_ID = 39;
        static constexpr SQLUSMALLINT MAXPANSPEED_FIELD_ID = 40;
        static constexpr SQLUSMALLINT FOCALLENGTHMODE_FIELD_ID = 41;
        static constexpr SQLUSMALLINT MINFOCALLENGTH_FIELD_ID = 42;
        static constexpr SQLUSMALLINT MAXFOCALLENGTH_FIELD_ID = 43;
        static constexpr SQLUSMALLINT MINFOCALLENGTHSCALE_FIELD_ID = 44;
        static constexpr SQLUSMALLINT MAXFOCALLENGTHSCALE_FIELD_ID = 45;
        static constexpr SQLUSMALLINT MINZOOMVELOCITY_FIELD_ID = 46;
        static constexpr SQLUSMALLINT MAXZOOMVELOCITY_FIELD_ID = 47;
        static constexpr SQLUSMALLINT MINZOOMSPEED_FIELD_ID = 48;
        static constexpr SQLUSMALLINT MAXZOOMSPEED_FIELD_ID = 49;
        static constexpr SQLUSMALLINT IMAGESENSORWIDTH_FIELD_ID = 50;
        static constexpr SQLUSMALLINT IMAGESENSORHEIGHT_FIELD_ID = 51;
        static constexpr SQLUSMALLINT HOMEPANANGLE_FIELD_ID = 52;
        static constexpr SQLUSMALLINT HOMETILTANGLE_FIELD_ID = 53;
        static constexpr SQLUSMALLINT HOMEFOCALLENGTH_FIELD_ID = 54;
        static constexpr SQLUSMALLINT PANOFFSET_FIELD_ID = 55;
        static constexpr SQLUSMALLINT TILTOFFSET_FIELD_ID = 56;
        static constexpr SQLUSMALLINT AIMALTITUDE_FIELD_ID = 57;
        static constexpr SQLUSMALLINT MINIMUMTARGETWIDTH_FIELD_ID = 58;
        static constexpr SQLUSMALLINT TARGETLOCKTIMEOUT_FIELD_ID = 59;
        static constexpr SQLUSMALLINT UPDATESTATUSINTERVAL_FIELD_ID = 60;
        static constexpr SQLUSMALLINT READTIMEOUT_FIELD_ID = 61;
        static constexpr SQLUSMALLINT MOVECOMMANDSTATUSDELAY_FIELD_ID = 62;
        static constexpr SQLUSMALLINT PTZPROFILENAME_FIELD_ID = 63;
        static constexpr SQLUSMALLINT PTZCONFIGURATIONTOKEN_FIELD_ID = 64;
        static constexpr SQLUSMALLINT VIDEOSOURCETOKEN_FIELD_ID = 65;

        CameraConfigurationColumnData( ) = default;

        virtual Kind GetKind() const override
        {
            return Kind::CameraConfiguration;
        }

        const Guid& Id( ) const
        {
            return id_;
        }
        void SetId( const Guid& id )
        {
            id_ = id;
        }
        Int64 RowVersion( ) const
        {
            return rowVersion_;
        }
        void SetRowVersion( const Int64& rowVersion )
        {
            rowVersion_ = rowVersion;
        }
        const Guid& Camera( ) const
        {
            return camera_;
        }
        void SetCamera( const Guid& camera )
        {
            camera_ = camera;
        }
        const DateTime& Timestamp( ) const
        {
            return timestamp_;
        }
        void SetTimestamp( const DateTime& timestamp )
        {
            timestamp_ = timestamp;
        }
        Data::CameraControlProtocol CameraControlProtocol( ) const
        {
            return cameraControlProtocol_;
        }
        void SetCameraControlProtocol( Data::CameraControlProtocol cameraControlProtocol )
        {
            cameraControlProtocol_ = cameraControlProtocol;
        }
        const FixedDBWideString<127>& CameraAddress( ) const
        {
            return cameraAddress_;
        }
        void SetCameraAddress( const WideString& cameraAddress )
        {
            cameraAddress_ = cameraAddress;
        }
        Int32 CameraPort( ) const
        {
            return cameraPort_;
        }
        void SetCameraPort( Int32 cameraPort )
        {
            cameraPort_ = cameraPort;
        }
        const FixedDBWideString<127>& CameraControlAddress( ) const
        {
            return cameraControlAddress_;
        }
        void SetCameraControlAddress( const WideString& cameraControlAddress )
        {
            cameraControlAddress_ = cameraControlAddress;
        }
        Int32 CameraControlPort( ) const
        {
            return cameraControlPort_;
        }
        void SetCameraControlPort( Int32 cameraControlPort )
        {
            cameraControlPort_ = cameraControlPort;
        }
        const FixedDBWideString<127>& CameraUserName( ) const
        {
            return cameraUserName_;
        }
        void SetCameraUserName( const WideString& cameraUserName )
        {
            cameraUserName_ = cameraUserName;
        }
        const FixedDBWideString<127>& CameraPassword( ) const
        {
            return cameraPassword_;
        }
        void SetCameraPassword( const WideString& cameraPassword )
        {
            cameraPassword_ = cameraPassword;
        }
        bool UseRtspUriOverride( ) const
        {
            return useRtspUriOverride_;
        }
        void SetUseRtspUriOverride( bool useRtspUriOverride )
        {
            useRtspUriOverride_ = useRtspUriOverride;
        }
        const FixedDBWideString<127>& RtspUriOverride( ) const
        {
            return rtspUriOverride_;
        }
        void SetRtspUriOverride( const WideString& rtspUriOverride )
        {
            rtspUriOverride_ = rtspUriOverride;
        }
        double Latitude( ) const
        {
            return latitude_;
        }
        void SetLatitude( double latitude )
        {
            latitude_ = latitude;
        }
        double Longitude( ) const
        {
            return longitude_;
        }
        void SetLongitude( double longitude )
        {
            longitude_ = longitude;
        }
        double Altitude( ) const
        {
            return altitude_;
        }
        void SetAltitude( double altitude )
        {
            altitude_ = altitude;
        }
        bool UseRelativePosition( ) const
        {
            return useRelativePosition_;
        }
        void SetUseRelativePosition( bool useRelativePosition )
        {
            useRelativePosition_ = useRelativePosition;
        }
        double AzimuthFromGPS( ) const
        {
            return azimuthFromGPS_;
        }
        void SetAzimuthFromGPS( double azimuthFromGPS )
        {
            azimuthFromGPS_ = azimuthFromGPS;
        }
        double DistanceFromGPS( ) const
        {
            return distanceFromGPS_;
        }
        void SetDistanceFromGPS( double distanceFromGPS )
        {
            distanceFromGPS_ = distanceFromGPS;
        }
        Data::CameraPanTiltMode PanTiltMode( ) const
        {
            return panTiltMode_;
        }
        void SetPanTiltMode( Data::CameraPanTiltMode panTiltMode )
        {
            panTiltMode_ = panTiltMode;
        }
        double MinTiltAngle( ) const
        {
            return minTiltAngle_;
        }
        void SetMinTiltAngle( double minTiltAngle )
        {
            minTiltAngle_ = minTiltAngle;
        }
        double MaxTiltAngle( ) const
        {
            return maxTiltAngle_;
        }
        void SetMaxTiltAngle( double maxTiltAngle )
        {
            maxTiltAngle_ = maxTiltAngle;
        }
        double MinTiltScaleAngle( ) const
        {
            return minTiltScaleAngle_;
        }
        void SetMinTiltScaleAngle( double minTiltScaleAngle )
        {
            minTiltScaleAngle_ = minTiltScaleAngle;
        }
        double MaxTiltScaleAngle( ) const
        {
            return maxTiltScaleAngle_;
        }
        void SetMaxTiltScaleAngle( double maxTiltScaleAngle )
        {
            maxTiltScaleAngle_ = maxTiltScaleAngle;
        }
        bool UseReverseTiltAngle( ) const
        {
            return useReverseTiltAngle_;
        }
        void SetUseReverseTiltAngle( bool useReverseTiltAngle )
        {
            useReverseTiltAngle_ = useReverseTiltAngle;
        }
        bool UseReverseNormalizedTiltAngle( ) const
        {
            return useReverseNormalizedTiltAngle_;
        }
        void SetUseReverseNormalizedTiltAngle( bool useReverseNormalizedTiltAngle )
        {
            useReverseNormalizedTiltAngle_ = useReverseNormalizedTiltAngle;
        }
        double MinTiltVelocity( ) const
        {
            return minTiltVelocity_;
        }
        void SetMinTiltVelocity( double minTiltVelocity )
        {
            minTiltVelocity_ = minTiltVelocity;
        }
        double MaxTiltVelocity( ) const
        {
            return maxTiltVelocity_;
        }
        void SetMaxTiltVelocity( double maxTiltVelocity )
        {
            maxTiltVelocity_ = maxTiltVelocity;
        }
        double MinTiltSpeed( ) const
        {
            return minTiltSpeed_;
        }
        void SetMinTiltSpeed( double minTiltSpeed )
        {
            minTiltSpeed_ = minTiltSpeed;
        }
        double MaxTiltSpeed( ) const
        {
            return maxTiltSpeed_;
        }
        void SetMaxTiltSpeed( double maxTiltSpeed )
        {
            maxTiltSpeed_ = maxTiltSpeed;
        }
        double MinPanAngle( ) const
        {
            return minPanAngle_;
        }
        void SetMinPanAngle( double minPanAngle )
        {
            minPanAngle_ = minPanAngle;
        }
        double MaxPanAngle( ) const
        {
            return maxPanAngle_;
        }
        void SetMaxPanAngle( double maxPanAngle )
        {
            maxPanAngle_ = maxPanAngle;
        }
        double MinPanScaleAngle( ) const
        {
            return minPanScaleAngle_;
        }
        void SetMinPanScaleAngle( double minPanScaleAngle )
        {
            minPanScaleAngle_ = minPanScaleAngle;
        }
        double MaxPanScaleAngle( ) const
        {
            return maxPanScaleAngle_;
        }
        void SetMaxPanScaleAngle( double maxPanScaleAngle )
        {
            maxPanScaleAngle_ = maxPanScaleAngle;
        }
        bool UseReversePanAngle( ) const
        {
            return useReversePanAngle_;
        }
        void SetUseReversePanAngle( bool useReversePanAngle )
        {
            useReversePanAngle_ = useReversePanAngle;
        }
        bool UseReverseNormalizedPanAngle( ) const
        {
            return useReverseNormalizedPanAngle_;
        }
        void SetUseReverseNormalizedPanAngle( bool useReverseNormalizedPanAngle )
        {
            useReverseNormalizedPanAngle_ = useReverseNormalizedPanAngle;
        }
        double MinPanVelocity( ) const
        {
            return minPanVelocity_;
        }
        void SetMinPanVelocity( double minPanVelocity )
        {
            minPanVelocity_ = minPanVelocity;
        }
        double MaxPanVelocity( ) const
        {
            return maxPanVelocity_;
        }
        void SetMaxPanVelocity( double maxPanVelocity )
        {
            maxPanVelocity_ = maxPanVelocity;
        }
        double MinPanSpeed( ) const
        {
            return minPanSpeed_;
        }
        void SetMinPanSpeed( double minPanSpeed )
        {
            minPanSpeed_ = minPanSpeed;
        }
        double MaxPanSpeed( ) const
        {
            return maxPanSpeed_;
        }
        void SetMaxPanSpeed( double maxPanSpeed )
        {
            maxPanSpeed_ = maxPanSpeed;
        }
        Data::CameraFocalLengthMode FocalLengthMode( ) const
        {
            return focalLengthMode_;
        }
        void SetFocalLengthMode( Data::CameraFocalLengthMode focalLengthMode )
        {
            focalLengthMode_ = focalLengthMode;
        }
        double MinFocalLength( ) const
        {
            return minFocalLength_;
        }
        void SetMinFocalLength( double minFocalLength )
        {
            minFocalLength_ = minFocalLength;
        }
        double MaxFocalLength( ) const
        {
            return maxFocalLength_;
        }
        void SetMaxFocalLength( double maxFocalLength )
        {
            maxFocalLength_ = maxFocalLength;
        }
        double MinFocalLengthScale( ) const
        {
            return minFocalLengthScale_;
        }
        void SetMinFocalLengthScale( double minFocalLengthScale )
        {
            minFocalLengthScale_ = minFocalLengthScale;
        }
        double MaxFocalLengthScale( ) const
        {
            return maxFocalLengthScale_;
        }
        void SetMaxFocalLengthScale( double maxFocalLengthScale )
        {
            maxFocalLengthScale_ = maxFocalLengthScale;
        }
        double MinZoomVelocity( ) const
        {
            return minZoomVelocity_;
        }
        void SetMinZoomVelocity( double minZoomVelocity )
        {
            minZoomVelocity_ = minZoomVelocity;
        }
        double MaxZoomVelocity( ) const
        {
            return maxZoomVelocity_;
        }
        void SetMaxZoomVelocity( double maxZoomVelocity )
        {
            maxZoomVelocity_ = maxZoomVelocity;
        }
        double MinZoomSpeed( ) const
        {
            return minZoomSpeed_;
        }
        void SetMinZoomSpeed( double minZoomSpeed )
        {
            minZoomSpeed_ = minZoomSpeed;
        }
        double MaxZoomSpeed( ) const
        {
            return maxZoomSpeed_;
        }
        void SetMaxZoomSpeed( double maxZoomSpeed )
        {
            maxZoomSpeed_ = maxZoomSpeed;
        }
        double ImageSensorWidth( ) const
        {
            return imageSensorWidth_;
        }
        void SetImageSensorWidth( double imageSensorWidth )
        {
            imageSensorWidth_ = imageSensorWidth;
        }
        double ImageSensorHeight( ) const
        {
            return imageSensorHeight_;
        }
        void SetImageSensorHeight( double imageSensorHeight )
        {
            imageSensorHeight_ = imageSensorHeight;
        }
        double HomePanAngle( ) const
        {
            return homePanAngle_;
        }
        void SetHomePanAngle( double homePanAngle )
        {
            homePanAngle_ = homePanAngle;
        }
        double HomeTiltAngle( ) const
        {
            return homeTiltAngle_;
        }
        void SetHomeTiltAngle( double homeTiltAngle )
        {
            homeTiltAngle_ = homeTiltAngle;
        }
        double HomeFocalLength( ) const
        {
            return homeFocalLength_;
        }
        void SetHomeFocalLength( double homeFocalLength )
        {
            homeFocalLength_ = homeFocalLength;
        }
        double PanOffset( ) const
        {
            return panOffset_;
        }
        void SetPanOffset( double panOffset )
        {
            panOffset_ = panOffset;
        }
        double TiltOffset( ) const
        {
            return tiltOffset_;
        }
        void SetTiltOffset( double tiltOffset )
        {
            tiltOffset_ = tiltOffset;
        }
        double AimAltitude( ) const
        {
            return aimAltitude_;
        }
        void SetAimAltitude( double aimAltitude )
        {
            aimAltitude_ = aimAltitude;
        }
        double MinimumTargetWidth( ) const
        {
            return minimumTargetWidth_;
        }
        void SetMinimumTargetWidth( double minimumTargetWidth )
        {
            minimumTargetWidth_ = minimumTargetWidth;
        }
        const TimeSpan& TargetLockTimeout( ) const
        {
            return targetLockTimeout_;
        }
        void SetTargetLockTimeout( const TimeSpan& targetLockTimeout )
        {
            targetLockTimeout_ = targetLockTimeout;
        }
        const TimeSpan& UpdateStatusInterval( ) const
        {
            return updateStatusInterval_;
        }
        void SetUpdateStatusInterval( const TimeSpan& updateStatusInterval )
        {
            updateStatusInterval_ = updateStatusInterval;
        }
        const TimeSpan& ReadTimeout( ) const
        {
            return readTimeout_;
        }
        void SetReadTimeout( const TimeSpan& readTimeout )
        {
            readTimeout_ = readTimeout;
        }
        const TimeSpan& MoveCommandStatusDelay( ) const
        {
            return moveCommandStatusDelay_;
        }
        void SetMoveCommandStatusDelay( const TimeSpan& moveCommandStatusDelay )
        {
            moveCommandStatusDelay_ = moveCommandStatusDelay;
        }
        const FixedDBWideString<127>& PtzProfileName( ) const
        {
            return ptzProfileName_;
        }
        void SetPtzProfileName( const WideString& ptzProfileName )
        {
            ptzProfileName_ = ptzProfileName;
        }
        const FixedDBWideString<127>& PtzConfigurationToken( ) const
        {
            return ptzConfigurationToken_;
        }
        void SetPtzConfigurationToken( const WideString& ptzConfigurationToken )
        {
            ptzConfigurationToken_ = ptzConfigurationToken;
        }
        const FixedDBWideString<127>& VideoSourceToken( ) const
        {
            return videoSourceToken_;
        }
        void SetVideoSourceToken( const WideString& videoSourceToken )
        {
            videoSourceToken_ = videoSourceToken;
        }
        void BindColumns( const ODBC::Statement& statement )
        {
            Bind(statement, ID_FIELD_ID, id_);
            Bind(statement, ROWVERSION_FIELD_ID, rowVersion_);
            Bind(statement, CAMERA_FIELD_ID, camera_);
            Bind(statement, TIMESTAMP_FIELD_ID, timestamp_);
            Bind(statement, CAMERACONTROLPROTOCOL_FIELD_ID, cameraControlProtocol_);
            Bind(statement, CAMERAADDRESS_FIELD_ID, cameraAddress_);
            Bind(statement, CAMERAPORT_FIELD_ID, cameraPort_);
            Bind(statement, CAMERACONTROLADDRESS_FIELD_ID, cameraControlAddress_);
            Bind(statement, CAMERACONTROLPORT_FIELD_ID, cameraControlPort_);
            Bind(statement, CAMERAUSERNAME_FIELD_ID, cameraUserName_);
            Bind(statement, CAMERAPASSWORD_FIELD_ID, cameraPassword_);
            Bind(statement, USERTSPURIOVERRIDE_FIELD_ID, useRtspUriOverride_);
            Bind(statement, RTSPURIOVERRIDE_FIELD_ID, rtspUriOverride_);
            Bind(statement, LATITUDE_FIELD_ID, latitude_);
            Bind(statement, LONGITUDE_FIELD_ID, longitude_);
            Bind(statement, ALTITUDE_FIELD_ID, altitude_);
            Bind(statement, USERELATIVEPOSITION_FIELD_ID, useRelativePosition_);
            Bind(statement, AZIMUTHFROMGPS_FIELD_ID, azimuthFromGPS_);
            Bind(statement, DISTANCEFROMGPS_FIELD_ID, distanceFromGPS_);
            Bind(statement, PANTILTMODE_FIELD_ID, panTiltMode_);
            Bind(statement, MINTILTANGLE_FIELD_ID, minTiltAngle_);
            Bind(statement, MAXTILTANGLE_FIELD_ID, maxTiltAngle_);
            Bind(statement, MINTILTSCALEANGLE_FIELD_ID, minTiltScaleAngle_);
            Bind(statement, MAXTILTSCALEANGLE_FIELD_ID, maxTiltScaleAngle_);
            Bind(statement, USEREVERSETILTANGLE_FIELD_ID, useReverseTiltAngle_);
            Bind(statement, USEREVERSENORMALIZEDTILTANGLE_FIELD_ID, useReverseNormalizedTiltAngle_);
            Bind(statement, MINTILTVELOCITY_FIELD_ID, minTiltVelocity_);
            Bind(statement, MAXTILTVELOCITY_FIELD_ID, maxTiltVelocity_);
            Bind(statement, MINTILTSPEED_FIELD_ID, minTiltSpeed_);
            Bind(statement, MAXTILTSPEED_FIELD_ID, maxTiltSpeed_);
            Bind(statement, MINPANANGLE_FIELD_ID, minPanAngle_);
            Bind(statement, MAXPANANGLE_FIELD_ID, maxPanAngle_);
            Bind(statement, MINPANSCALEANGLE_FIELD_ID, minPanScaleAngle_);
            Bind(statement, MAXPANSCALEANGLE_FIELD_ID, maxPanScaleAngle_);
            Bind(statement, USEREVERSEPANANGLE_FIELD_ID, useReversePanAngle_);
            Bind(statement, USEREVERSENORMALIZEDPANANGLE_FIELD_ID, useReverseNormalizedPanAngle_);
            Bind(statement, MINPANVELOCITY_FIELD_ID, minPanVelocity_);
            Bind(statement, MAXPANVELOCITY_FIELD_ID, maxPanVelocity_);
            Bind(statement, MINPANSPEED_FIELD_ID, minPanSpeed_);
            Bind(statement, MAXPANSPEED_FIELD_ID, maxPanSpeed_);
            Bind(statement, FOCALLENGTHMODE_FIELD_ID, focalLengthMode_);
            Bind(statement, MINFOCALLENGTH_FIELD_ID, minFocalLength_);
            Bind(statement, MAXFOCALLENGTH_FIELD_ID, maxFocalLength_);
            Bind(statement, MINFOCALLENGTHSCALE_FIELD_ID, minFocalLengthScale_);
            Bind(statement, MAXFOCALLENGTHSCALE_FIELD_ID, maxFocalLengthScale_);
            Bind(statement, MINZOOMVELOCITY_FIELD_ID, minZoomVelocity_);
            Bind(statement, MAXZOOMVELOCITY_FIELD_ID, maxZoomVelocity_);
            Bind(statement, MINZOOMSPEED_FIELD_ID, minZoomSpeed_);
            Bind(statement, MAXZOOMSPEED_FIELD_ID, maxZoomSpeed_);
            Bind(statement, IMAGESENSORWIDTH_FIELD_ID, imageSensorWidth_);
            Bind(statement, IMAGESENSORHEIGHT_FIELD_ID, imageSensorHeight_);
            Bind(statement, HOMEPANANGLE_FIELD_ID, homePanAngle_);
            Bind(statement, HOMETILTANGLE_FIELD_ID, homeTiltAngle_);
            Bind(statement, HOMEFOCALLENGTH_FIELD_ID, homeFocalLength_);
            Bind(statement, PANOFFSET_FIELD_ID, panOffset_);
            Bind(statement, TILTOFFSET_FIELD_ID, tiltOffset_);
            Bind(statement, AIMALTITUDE_FIELD_ID, aimAltitude_);
            Bind(statement, MINIMUMTARGETWIDTH_FIELD_ID, minimumTargetWidth_);
            Bind(statement, TARGETLOCKTIMEOUT_FIELD_ID, targetLockTimeout_);
            Bind(statement, UPDATESTATUSINTERVAL_FIELD_ID, updateStatusInterval_);
            Bind(statement, READTIMEOUT_FIELD_ID, readTimeout_);
            Bind(statement, MOVECOMMANDSTATUSDELAY_FIELD_ID, moveCommandStatusDelay_);
            Bind(statement, PTZPROFILENAME_FIELD_ID, ptzProfileName_);
            Bind(statement, PTZCONFIGURATIONTOKEN_FIELD_ID, ptzConfigurationToken_);
            Bind(statement, VIDEOSOURCETOKEN_FIELD_ID, videoSourceToken_);
        }

        template<IO::StreamWriter StreamT>
        void WriteColumns( IO::BinaryWriter<StreamT>& destination ) const
        {
            WriteColumnValue( destination, id_);
            WriteColumnValue( destination, rowVersion_);
            WriteColumnValue( destination, camera_);
            WriteColumnValue( destination, timestamp_);
            WriteColumnValue( destination, cameraControlProtocol_);
            WriteColumnValue( destination, cameraAddress_);
            WriteColumnValue( destination, cameraPort_);
            WriteColumnValue( destination, cameraControlAddress_);
            WriteColumnValue( destination, cameraControlPort_);
            WriteColumnValue( destination, cameraUserName_);
            WriteColumnValue( destination, cameraPassword_);
            WriteColumnValue( destination, useRtspUriOverride_);
            WriteColumnValue( destination, rtspUriOverride_);
            WriteColumnValue( destination, latitude_);
            WriteColumnValue( destination, longitude_);
            WriteColumnValue( destination, altitude_);
            WriteColumnValue( destination, useRelativePosition_);
            WriteColumnValue( destination, azimuthFromGPS_);
            WriteColumnValue( destination, distanceFromGPS_);
            WriteColumnValue( destination, panTiltMode_);
            WriteColumnValue( destination, minTiltAngle_);
            WriteColumnValue( destination, maxTiltAngle_);
            WriteColumnValue( destination, minTiltScaleAngle_);
            WriteColumnValue( destination, maxTiltScaleAngle_);
            WriteColumnValue( destination, useReverseTiltAngle_);
            WriteColumnValue( destination, useReverseNormalizedTiltAngle_);
            WriteColumnValue( destination, minTiltVelocity_);
            WriteColumnValue( destination, maxTiltVelocity_);
            WriteColumnValue( destination, minTiltSpeed_);
            WriteColumnValue( destination, maxTiltSpeed_);
            WriteColumnValue( destination, minPanAngle_);
            WriteColumnValue( destination, maxPanAngle_);
            WriteColumnValue( destination, minPanScaleAngle_);
            WriteColumnValue( destination, maxPanScaleAngle_);
            WriteColumnValue( destination, useReversePanAngle_);
            WriteColumnValue( destination, useReverseNormalizedPanAngle_);
            WriteColumnValue( destination, minPanVelocity_);
            WriteColumnValue( destination, maxPanVelocity_);
            WriteColumnValue( destination, minPanSpeed_);
            WriteColumnValue( destination, maxPanSpeed_);
            WriteColumnValue( destination, focalLengthMode_);
            WriteColumnValue( destination, minFocalLength_);
            WriteColumnValue( destination, maxFocalLength_);
            WriteColumnValue( destination, minFocalLengthScale_);
            WriteColumnValue( destination, maxFocalLengthScale_);
            WriteColumnValue( destination, minZoomVelocity_);
            WriteColumnValue( destination, maxZoomVelocity_);
            WriteColumnValue( destination, minZoomSpeed_);
            WriteColumnValue( destination, maxZoomSpeed_);
            WriteColumnValue( destination, imageSensorWidth_);
            WriteColumnValue( destination, imageSensorHeight_);
            WriteColumnValue( destination, homePanAngle_);
            WriteColumnValue( destination, homeTiltAngle_);
            WriteColumnValue( destination, homeFocalLength_);
            WriteColumnValue( destination, panOffset_);
            WriteColumnValue( destination, tiltOffset_);
            WriteColumnValue( destination, aimAltitude_);
            WriteColumnValue( destination, minimumTargetWidth_);
            WriteColumnValue( destination, targetLockTimeout_);
            WriteColumnValue( destination, updateStatusInterval_);
            WriteColumnValue( destination, readTimeout_);
            WriteColumnValue( destination, moveCommandStatusDelay_);
            WriteColumnValue( destination, ptzProfileName_);
            WriteColumnValue( destination, ptzConfigurationToken_);
            WriteColumnValue( destination, videoSourceToken_);
        }
    };

    using SimpleCameraConfigurationDataReader = SimpleColumnDataReader<CameraConfigurationColumnData>;

    class CameraPanCalibrationColumnData : public BaseColumnData
    {
        Guid id_;
        Int64 rowVersion_ = 0;
        Guid camera_;
        DateTime timestamp_;
    public:
        using Base = BaseColumnData;

        static constexpr std::wstring_view FieldNames = L"[Id],[RowVersion],[Camera],[Timestamp]";
        static constexpr std::wstring_view ViewName = L"CameraPanCalibrationView";

        static constexpr SQLUSMALLINT ID_FIELD_ID = 1;
        static constexpr SQLUSMALLINT ROWVERSION_FIELD_ID = 2;
        static constexpr SQLUSMALLINT CAMERA_FIELD_ID = 3;
        static constexpr SQLUSMALLINT TIMESTAMP_FIELD_ID = 4;

        CameraPanCalibrationColumnData( ) = default;

        virtual Kind GetKind() const override
        {
            return Kind::CameraPanCalibration;
        }

        const Guid& Id( ) const
        {
            return id_;
        }
        void SetId( const Guid& id )
        {
            id_ = id;
        }
        Int64 RowVersion( ) const
        {
            return rowVersion_;
        }
        void SetRowVersion( const Int64& rowVersion )
        {
            rowVersion_ = rowVersion;
        }
        const Guid& Camera( ) const
        {
            return camera_;
        }
        void SetCamera( const Guid& camera )
        {
            camera_ = camera;
        }
        const DateTime& Timestamp( ) const
        {
            return timestamp_;
        }
        void SetTimestamp( const DateTime& timestamp )
        {
            timestamp_ = timestamp;
        }
        void BindColumns( const ODBC::Statement& statement )
        {
            Bind(statement, ID_FIELD_ID, id_);
            Bind(statement, ROWVERSION_FIELD_ID, rowVersion_);
            Bind(statement, CAMERA_FIELD_ID, camera_);
            Bind(statement, TIMESTAMP_FIELD_ID, timestamp_);
        }

        template<IO::StreamWriter StreamT>
        void WriteColumns( IO::BinaryWriter<StreamT>& destination ) const
        {
            WriteColumnValue( destination, id_);
            WriteColumnValue( destination, rowVersion_);
            WriteColumnValue( destination, camera_);
            WriteColumnValue( destination, timestamp_);
        }
    };

    using SimpleCameraPanCalibrationDataReader = SimpleColumnDataReader<CameraPanCalibrationColumnData>;

    class CameraPanCalibrationValueColumnData : public BaseColumnData
    {
        Guid id_;
        Int64 rowVersion_ = 0;
        Guid panCalibration_;
        double panAngle_ = 0.0;
        double panOffset_ = 0.0;
    public:
        using Base = BaseColumnData;

        static constexpr std::wstring_view FieldNames = L"[Id],[RowVersion],[PanCalibration],[PanAngle],[PanOffset]";
        static constexpr std::wstring_view ViewName = L"CameraPanCalibrationValueView";

        static constexpr SQLUSMALLINT ID_FIELD_ID = 1;
        static constexpr SQLUSMALLINT ROWVERSION_FIELD_ID = 2;
        static constexpr SQLUSMALLINT PANCALIBRATION_FIELD_ID = 3;
        static constexpr SQLUSMALLINT PANANGLE_FIELD_ID = 4;
        static constexpr SQLUSMALLINT PANOFFSET_FIELD_ID = 5;

        CameraPanCalibrationValueColumnData( ) = default;

        virtual Kind GetKind() const override
        {
            return Kind::CameraPanCalibrationValue;
        }

        const Guid& Id( ) const
        {
            return id_;
        }
        void SetId( const Guid& id )
        {
            id_ = id;
        }
        Int64 RowVersion( ) const
        {
            return rowVersion_;
        }
        void SetRowVersion( const Int64& rowVersion )
        {
            rowVersion_ = rowVersion;
        }
        const Guid& PanCalibration( ) const
        {
            return panCalibration_;
        }
        void SetPanCalibration( const Guid& panCalibration )
        {
            panCalibration_ = panCalibration;
        }
        double PanAngle( ) const
        {
            return panAngle_;
        }
        void SetPanAngle( double panAngle )
        {
            panAngle_ = panAngle;
        }
        double PanOffset( ) const
        {
            return panOffset_;
        }
        void SetPanOffset( double panOffset )
        {
            panOffset_ = panOffset;
        }
        void BindColumns( const ODBC::Statement& statement )
        {
            Bind(statement, ID_FIELD_ID, id_);
            Bind(statement, ROWVERSION_FIELD_ID, rowVersion_);
            Bind(statement, PANCALIBRATION_FIELD_ID, panCalibration_);
            Bind(statement, PANANGLE_FIELD_ID, panAngle_);
            Bind(statement, PANOFFSET_FIELD_ID, panOffset_);
        }

        template<IO::StreamWriter StreamT>
        void WriteColumns( IO::BinaryWriter<StreamT>& destination ) const
        {
            WriteColumnValue( destination, id_);
            WriteColumnValue( destination, rowVersion_);
            WriteColumnValue( destination, panCalibration_);
            WriteColumnValue( destination, panAngle_);
            WriteColumnValue( destination, panOffset_);
        }
    };

    using SimpleCameraPanCalibrationValueDataReader = SimpleColumnDataReader<CameraPanCalibrationValueColumnData>;

    class CameraStatusColumnData : public BaseColumnData
    {
        Guid id_;
        Int64 rowVersion_ = 0;
        Guid camera_;
        Guid track_;
        DateTime timestamp_;
        Data::CameraPanTiltMode positionPanTiltMode_ = Data::CameraPanTiltMode::Unknown;
        double panAngle_ = 0.0;
        double tiltAngle_ = 0.0;
        Data::CameraFocalLengthMode positionFocalLengthMode_ = Data::CameraFocalLengthMode::Unknown;
        double focalLength_ = 0.0;
        Data::CameraMoveStatus panTiltMoveStatus_ = Data::CameraMoveStatus::Unknown;
        Data::CameraMoveStatus zoomMoveStatus_ = Data::CameraMoveStatus::Unknown;
        Data::CameraPanTiltMode velocityPanTiltMode_ = Data::CameraPanTiltMode::Unknown;
        DBDouble panVelocity_;
        DBDouble tiltVelocity_;
        Data::CameraFocalLengthMode velocityFocalLengthMode_ = Data::CameraFocalLengthMode::Unknown;
        DBDouble zoomVelocity_;
        Data::CameraFeatures activeFeatures_ = Data::CameraFeatures::None;
        WideString error_;
        SQLLEN errorLength_ = SQL_NULL_DATA;
    public:
        using Base = BaseColumnData;

        static constexpr std::wstring_view FieldNames = L"[Id],[RowVersion],[Camera],[Track],[Timestamp],[PositionPanTiltMode],[PanAngle],[TiltAngle],[PositionFocalLengthMode],[FocalLength],[PanTiltMoveStatus],[ZoomMoveStatus],[VelocityPanTiltMode],[PanVelocity],[TiltVelocity],[VelocityFocalLengthMode],[ZoomVelocity],[ActiveFeatures],[Error]";
        static constexpr std::wstring_view ViewName = L"CameraStatusView";

        static constexpr SQLUSMALLINT ID_FIELD_ID = 1;
        static constexpr SQLUSMALLINT ROWVERSION_FIELD_ID = 2;
        static constexpr SQLUSMALLINT CAMERA_FIELD_ID = 3;
        static constexpr SQLUSMALLINT TRACK_FIELD_ID = 4;
        static constexpr SQLUSMALLINT TIMESTAMP_FIELD_ID = 5;
        static constexpr SQLUSMALLINT POSITIONPANTILTMODE_FIELD_ID = 6;
        static constexpr SQLUSMALLINT PANANGLE_FIELD_ID = 7;
        static constexpr SQLUSMALLINT TILTANGLE_FIELD_ID = 8;
        static constexpr SQLUSMALLINT POSITIONFOCALLENGTHMODE_FIELD_ID = 9;
        static constexpr SQLUSMALLINT FOCALLENGTH_FIELD_ID = 10;
        static constexpr SQLUSMALLINT PANTILTMOVESTATUS_FIELD_ID = 11;
        static constexpr SQLUSMALLINT ZOOMMOVESTATUS_FIELD_ID = 12;
        static constexpr SQLUSMALLINT VELOCITYPANTILTMODE_FIELD_ID = 13;
        static constexpr SQLUSMALLINT PANVELOCITY_FIELD_ID = 14;
        static constexpr SQLUSMALLINT TILTVELOCITY_FIELD_ID = 15;
        static constexpr SQLUSMALLINT VELOCITYFOCALLENGTHMODE_FIELD_ID = 16;
        static constexpr SQLUSMALLINT ZOOMVELOCITY_FIELD_ID = 17;
        static constexpr SQLUSMALLINT ACTIVEFEATURES_FIELD_ID = 18;
        static constexpr SQLUSMALLINT ERROR_FIELD_ID = 19;

        CameraStatusColumnData( ) = default;

        virtual Kind GetKind() const override
        {
            return Kind::CameraStatus;
        }

        const Guid& Id( ) const
        {
            return id_;
        }
        void SetId( const Guid& id )
        {
            id_ = id;
        }
        Int64 RowVersion( ) const
        {
            return rowVersion_;
        }
        void SetRowVersion( const Int64& rowVersion )
        {
            rowVersion_ = rowVersion;
        }
        const Guid& Camera( ) const
        {
            return camera_;
        }
        void SetCamera( const Guid& camera )
        {
            camera_ = camera;
        }
        const Guid& Track( ) const
        {
            return track_;
        }
        void SetTrack( const Guid& track )
        {
            track_ = track;
        }
        const DateTime& Timestamp( ) const
        {
            return timestamp_;
        }
        void SetTimestamp( const DateTime& timestamp )
        {
            timestamp_ = timestamp;
        }
        Data::CameraPanTiltMode PositionPanTiltMode( ) const
        {
            return positionPanTiltMode_;
        }
        void SetPositionPanTiltMode( Data::CameraPanTiltMode positionPanTiltMode )
        {
            positionPanTiltMode_ = positionPanTiltMode;
        }
        double PanAngle( ) const
        {
            return panAngle_;
        }
        void SetPanAngle( double panAngle )
        {
            panAngle_ = panAngle;
        }
        double TiltAngle( ) const
        {
            return tiltAngle_;
        }
        void SetTiltAngle( double tiltAngle )
        {
            tiltAngle_ = tiltAngle;
        }
        Data::CameraFocalLengthMode PositionFocalLengthMode( ) const
        {
            return positionFocalLengthMode_;
        }
        void SetPositionFocalLengthMode( Data::CameraFocalLengthMode positionFocalLengthMode )
        {
            positionFocalLengthMode_ = positionFocalLengthMode;
        }
        double FocalLength( ) const
        {
            return focalLength_;
        }
        void SetFocalLength( double focalLength )
        {
            focalLength_ = focalLength;
        }
        Data::CameraMoveStatus PanTiltMoveStatus( ) const
        {
            return panTiltMoveStatus_;
        }
        void SetPanTiltMoveStatus( Data::CameraMoveStatus panTiltMoveStatus )
        {
            panTiltMoveStatus_ = panTiltMoveStatus;
        }
        Data::CameraMoveStatus ZoomMoveStatus( ) const
        {
            return zoomMoveStatus_;
        }
        void SetZoomMoveStatus( Data::CameraMoveStatus zoomMoveStatus )
        {
            zoomMoveStatus_ = zoomMoveStatus;
        }
        Data::CameraPanTiltMode VelocityPanTiltMode( ) const
        {
            return velocityPanTiltMode_;
        }
        void SetVelocityPanTiltMode( Data::CameraPanTiltMode velocityPanTiltMode )
        {
            velocityPanTiltMode_ = velocityPanTiltMode;
        }
        const DBDouble& PanVelocity( ) const
        {
            return panVelocity_;
        }
        void SetPanVelocity( const DBDouble& panVelocity )
        {
            panVelocity_ = panVelocity;
        }
        const DBDouble& TiltVelocity( ) const
        {
            return tiltVelocity_;
        }
        void SetTiltVelocity( const DBDouble& tiltVelocity )
        {
            tiltVelocity_ = tiltVelocity;
        }
        Data::CameraFocalLengthMode VelocityFocalLengthMode( ) const
        {
            return velocityFocalLengthMode_;
        }
        void SetVelocityFocalLengthMode( Data::CameraFocalLengthMode velocityFocalLengthMode )
        {
            velocityFocalLengthMode_ = velocityFocalLengthMode;
        }
        const DBDouble& ZoomVelocity( ) const
        {
            return zoomVelocity_;
        }
        void SetZoomVelocity( const DBDouble& zoomVelocity )
        {
            zoomVelocity_ = zoomVelocity;
        }
        Data::CameraFeatures ActiveFeatures( ) const
        {
            return activeFeatures_;
        }
        void SetActiveFeatures( Data::CameraFeatures activeFeatures )
        {
            activeFeatures_ = activeFeatures;
        }
        const WideString& Error( ) const
        {
            return error_;
        }
        void SetError( const WideString& error )
        {
            error_ = error;
        }
        void BindColumns( const ODBC::Statement& statement )
        {
            Bind(statement, ID_FIELD_ID, id_);
            Bind(statement, ROWVERSION_FIELD_ID, rowVersion_);
            Bind(statement, CAMERA_FIELD_ID, camera_);
            Bind(statement, TRACK_FIELD_ID, track_);
            Bind(statement, TIMESTAMP_FIELD_ID, timestamp_);
            Bind(statement, POSITIONPANTILTMODE_FIELD_ID, positionPanTiltMode_);
            Bind(statement, PANANGLE_FIELD_ID, panAngle_);
            Bind(statement, TILTANGLE_FIELD_ID, tiltAngle_);
            Bind(statement, POSITIONFOCALLENGTHMODE_FIELD_ID, positionFocalLengthMode_);
            Bind(statement, FOCALLENGTH_FIELD_ID, focalLength_);
            Bind(statement, PANTILTMOVESTATUS_FIELD_ID, panTiltMoveStatus_);
            Bind(statement, ZOOMMOVESTATUS_FIELD_ID, zoomMoveStatus_);
            Bind(statement, VELOCITYPANTILTMODE_FIELD_ID, velocityPanTiltMode_);
            Bind(statement, PANVELOCITY_FIELD_ID, panVelocity_);
            Bind(statement, TILTVELOCITY_FIELD_ID, tiltVelocity_);
            Bind(statement, VELOCITYFOCALLENGTHMODE_FIELD_ID, velocityFocalLengthMode_);
            Bind(statement, ZOOMVELOCITY_FIELD_ID, zoomVelocity_);
            Bind(statement, ACTIVEFEATURES_FIELD_ID, activeFeatures_);
        }

        void ReadUnboundData( const ODBC::Statement& statement )
        {
            Base::ReadUnboundData( statement );

            error_ = statement.GetWideString(ERROR_FIELD_ID);
        }
        template<IO::StreamWriter StreamT>
        void WriteColumns( IO::BinaryWriter<StreamT>& destination ) const
        {
            WriteColumnValue( destination, id_);
            WriteColumnValue( destination, rowVersion_);
            WriteColumnValue( destination, camera_);
            WriteColumnValue( destination, track_);
            WriteColumnValue( destination, timestamp_);
            WriteColumnValue( destination, positionPanTiltMode_);
            WriteColumnValue( destination, panAngle_);
            WriteColumnValue( destination, tiltAngle_);
            WriteColumnValue( destination, positionFocalLengthMode_);
            WriteColumnValue( destination, focalLength_);
            WriteColumnValue( destination, panTiltMoveStatus_);
            WriteColumnValue( destination, zoomMoveStatus_);
            WriteColumnValue( destination, velocityPanTiltMode_);
            WriteColumnValue( destination, panVelocity_);
            WriteColumnValue( destination, tiltVelocity_);
            WriteColumnValue( destination, velocityFocalLengthMode_);
            WriteColumnValue( destination, zoomVelocity_);
            WriteColumnValue( destination, activeFeatures_);
            WriteColumnValue( destination, error_);
        }
    };

    using SimpleCameraStatusDataReader = SimpleColumnDataReader<CameraStatusColumnData>;

    class CameraTiltCalibrationColumnData : public BaseColumnData
    {
        Guid id_;
        Int64 rowVersion_ = 0;
        Guid camera_;
        DateTime timestamp_;
    public:
        using Base = BaseColumnData;

        static constexpr std::wstring_view FieldNames = L"[Id],[RowVersion],[Camera],[Timestamp]";
        static constexpr std::wstring_view ViewName = L"CameraTiltCalibrationView";

        static constexpr SQLUSMALLINT ID_FIELD_ID = 1;
        static constexpr SQLUSMALLINT ROWVERSION_FIELD_ID = 2;
        static constexpr SQLUSMALLINT CAMERA_FIELD_ID = 3;
        static constexpr SQLUSMALLINT TIMESTAMP_FIELD_ID = 4;

        CameraTiltCalibrationColumnData( ) = default;

        virtual Kind GetKind() const override
        {
            return Kind::CameraTiltCalibration;
        }

        const Guid& Id( ) const
        {
            return id_;
        }
        void SetId( const Guid& id )
        {
            id_ = id;
        }
        Int64 RowVersion( ) const
        {
            return rowVersion_;
        }
        void SetRowVersion( const Int64& rowVersion )
        {
            rowVersion_ = rowVersion;
        }
        const Guid& Camera( ) const
        {
            return camera_;
        }
        void SetCamera( const Guid& camera )
        {
            camera_ = camera;
        }
        const DateTime& Timestamp( ) const
        {
            return timestamp_;
        }
        void SetTimestamp( const DateTime& timestamp )
        {
            timestamp_ = timestamp;
        }
        void BindColumns( const ODBC::Statement& statement )
        {
            Bind(statement, ID_FIELD_ID, id_);
            Bind(statement, ROWVERSION_FIELD_ID, rowVersion_);
            Bind(statement, CAMERA_FIELD_ID, camera_);
            Bind(statement, TIMESTAMP_FIELD_ID, timestamp_);
        }

        template<IO::StreamWriter StreamT>
        void WriteColumns( IO::BinaryWriter<StreamT>& destination ) const
        {
            WriteColumnValue( destination, id_);
            WriteColumnValue( destination, rowVersion_);
            WriteColumnValue( destination, camera_);
            WriteColumnValue( destination, timestamp_);
        }
    };

    using SimpleCameraTiltCalibrationDataReader = SimpleColumnDataReader<CameraTiltCalibrationColumnData>;

    class CameraTiltCalibrationValueColumnData : public BaseColumnData
    {
        Guid id_;
        Int64 rowVersion_ = 0;
        Guid tiltCalibration_;
        double panAngle_ = 0.0;
        double tiltOffset_ = 0.0;
    public:
        using Base = BaseColumnData;

        static constexpr std::wstring_view FieldNames = L"[Id],[RowVersion],[TiltCalibration],[PanAngle],[TiltOffset]";
        static constexpr std::wstring_view ViewName = L"CameraTiltCalibrationValueView";

        static constexpr SQLUSMALLINT ID_FIELD_ID = 1;
        static constexpr SQLUSMALLINT ROWVERSION_FIELD_ID = 2;
        static constexpr SQLUSMALLINT TILTCALIBRATION_FIELD_ID = 3;
        static constexpr SQLUSMALLINT PANANGLE_FIELD_ID = 4;
        static constexpr SQLUSMALLINT TILTOFFSET_FIELD_ID = 5;

        CameraTiltCalibrationValueColumnData( ) = default;

        virtual Kind GetKind() const override
        {
            return Kind::CameraTiltCalibrationValue;
        }

        const Guid& Id( ) const
        {
            return id_;
        }
        void SetId( const Guid& id )
        {
            id_ = id;
        }
        Int64 RowVersion( ) const
        {
            return rowVersion_;
        }
        void SetRowVersion( const Int64& rowVersion )
        {
            rowVersion_ = rowVersion;
        }
        const Guid& TiltCalibration( ) const
        {
            return tiltCalibration_;
        }
        void SetTiltCalibration( const Guid& tiltCalibration )
        {
            tiltCalibration_ = tiltCalibration;
        }
        double PanAngle( ) const
        {
            return panAngle_;
        }
        void SetPanAngle( double panAngle )
        {
            panAngle_ = panAngle;
        }
        double TiltOffset( ) const
        {
            return tiltOffset_;
        }
        void SetTiltOffset( double tiltOffset )
        {
            tiltOffset_ = tiltOffset;
        }
        void BindColumns( const ODBC::Statement& statement )
        {
            Bind(statement, ID_FIELD_ID, id_);
            Bind(statement, ROWVERSION_FIELD_ID, rowVersion_);
            Bind(statement, TILTCALIBRATION_FIELD_ID, tiltCalibration_);
            Bind(statement, PANANGLE_FIELD_ID, panAngle_);
            Bind(statement, TILTOFFSET_FIELD_ID, tiltOffset_);
        }

        template<IO::StreamWriter StreamT>
        void WriteColumns( IO::BinaryWriter<StreamT>& destination ) const
        {
            WriteColumnValue( destination, id_);
            WriteColumnValue( destination, rowVersion_);
            WriteColumnValue( destination, tiltCalibration_);
            WriteColumnValue( destination, panAngle_);
            WriteColumnValue( destination, tiltOffset_);
        }
    };

    using SimpleCameraTiltCalibrationValueDataReader = SimpleColumnDataReader<CameraTiltCalibrationValueColumnData>;

    class CameraZoomCalibrationColumnData : public BaseColumnData
    {
        Guid id_;
        Int64 rowVersion_ = 0;
        Guid camera_;
        DateTime timestamp_;
    public:
        using Base = BaseColumnData;

        static constexpr std::wstring_view FieldNames = L"[Id],[RowVersion],[Camera],[Timestamp]";
        static constexpr std::wstring_view ViewName = L"CameraZoomCalibrationView";

        static constexpr SQLUSMALLINT ID_FIELD_ID = 1;
        static constexpr SQLUSMALLINT ROWVERSION_FIELD_ID = 2;
        static constexpr SQLUSMALLINT CAMERA_FIELD_ID = 3;
        static constexpr SQLUSMALLINT TIMESTAMP_FIELD_ID = 4;

        CameraZoomCalibrationColumnData( ) = default;

        virtual Kind GetKind() const override
        {
            return Kind::CameraZoomCalibration;
        }

        const Guid& Id( ) const
        {
            return id_;
        }
        void SetId( const Guid& id )
        {
            id_ = id;
        }
        Int64 RowVersion( ) const
        {
            return rowVersion_;
        }
        void SetRowVersion( const Int64& rowVersion )
        {
            rowVersion_ = rowVersion;
        }
        const Guid& Camera( ) const
        {
            return camera_;
        }
        void SetCamera( const Guid& camera )
        {
            camera_ = camera;
        }
        const DateTime& Timestamp( ) const
        {
            return timestamp_;
        }
        void SetTimestamp( const DateTime& timestamp )
        {
            timestamp_ = timestamp;
        }
        void BindColumns( const ODBC::Statement& statement )
        {
            Bind(statement, ID_FIELD_ID, id_);
            Bind(statement, ROWVERSION_FIELD_ID, rowVersion_);
            Bind(statement, CAMERA_FIELD_ID, camera_);
            Bind(statement, TIMESTAMP_FIELD_ID, timestamp_);
        }

        template<IO::StreamWriter StreamT>
        void WriteColumns( IO::BinaryWriter<StreamT>& destination ) const
        {
            WriteColumnValue( destination, id_);
            WriteColumnValue( destination, rowVersion_);
            WriteColumnValue( destination, camera_);
            WriteColumnValue( destination, timestamp_);
        }
    };

    using SimpleCameraZoomCalibrationDataReader = SimpleColumnDataReader<CameraZoomCalibrationColumnData>;

    class CameraZoomCalibrationValueColumnData : public BaseColumnData
    {
        Guid id_;
        Int64 rowVersion_ = 0;
        Guid zoomCalibration_;
        double focalLength_ = 0.0;
        double focalLengthOffset_ = 0.0;
    public:
        using Base = BaseColumnData;

        static constexpr std::wstring_view FieldNames = L"[Id],[RowVersion],[ZoomCalibration],[FocalLength],[FocalLengthOffset]";
        static constexpr std::wstring_view ViewName = L"CameraZoomCalibrationValueView";

        static constexpr SQLUSMALLINT ID_FIELD_ID = 1;
        static constexpr SQLUSMALLINT ROWVERSION_FIELD_ID = 2;
        static constexpr SQLUSMALLINT ZOOMCALIBRATION_FIELD_ID = 3;
        static constexpr SQLUSMALLINT FOCALLENGTH_FIELD_ID = 4;
        static constexpr SQLUSMALLINT FOCALLENGTHOFFSET_FIELD_ID = 5;

        CameraZoomCalibrationValueColumnData( ) = default;

        virtual Kind GetKind() const override
        {
            return Kind::CameraZoomCalibrationValue;
        }

        const Guid& Id( ) const
        {
            return id_;
        }
        void SetId( const Guid& id )
        {
            id_ = id;
        }
        Int64 RowVersion( ) const
        {
            return rowVersion_;
        }
        void SetRowVersion( const Int64& rowVersion )
        {
            rowVersion_ = rowVersion;
        }
        const Guid& ZoomCalibration( ) const
        {
            return zoomCalibration_;
        }
        void SetZoomCalibration( const Guid& zoomCalibration )
        {
            zoomCalibration_ = zoomCalibration;
        }
        double FocalLength( ) const
        {
            return focalLength_;
        }
        void SetFocalLength( double focalLength )
        {
            focalLength_ = focalLength;
        }
        double FocalLengthOffset( ) const
        {
            return focalLengthOffset_;
        }
        void SetFocalLengthOffset( double focalLengthOffset )
        {
            focalLengthOffset_ = focalLengthOffset;
        }
        void BindColumns( const ODBC::Statement& statement )
        {
            Bind(statement, ID_FIELD_ID, id_);
            Bind(statement, ROWVERSION_FIELD_ID, rowVersion_);
            Bind(statement, ZOOMCALIBRATION_FIELD_ID, zoomCalibration_);
            Bind(statement, FOCALLENGTH_FIELD_ID, focalLength_);
            Bind(statement, FOCALLENGTHOFFSET_FIELD_ID, focalLengthOffset_);
        }

        template<IO::StreamWriter StreamT>
        void WriteColumns( IO::BinaryWriter<StreamT>& destination ) const
        {
            WriteColumnValue( destination, id_);
            WriteColumnValue( destination, rowVersion_);
            WriteColumnValue( destination, zoomCalibration_);
            WriteColumnValue( destination, focalLength_);
            WriteColumnValue( destination, focalLengthOffset_);
        }
    };

    using SimpleCameraZoomCalibrationValueDataReader = SimpleColumnDataReader<CameraZoomCalibrationValueColumnData>;

    class CatalogElementColumnData : public BaseColumnData
    {
        Guid id_;
        Int64 rowVersion_ = 0;
        Guid catalog_;
        FixedDBWideString<127> name_;
    public:
        using Base = BaseColumnData;

        static constexpr std::wstring_view FieldNames = L"[Id],[RowVersion],[Catalog],[Name]";
        static constexpr std::wstring_view ViewName = L"CatalogElementView";

        static constexpr SQLUSMALLINT ID_FIELD_ID = 1;
        static constexpr SQLUSMALLINT ROWVERSION_FIELD_ID = 2;
        static constexpr SQLUSMALLINT CATALOG_FIELD_ID = 3;
        static constexpr SQLUSMALLINT NAME_FIELD_ID = 4;

        CatalogElementColumnData( ) = default;

        virtual Kind GetKind() const override
        {
            return Kind::CatalogElement;
        }

        const Guid& Id( ) const
        {
            return id_;
        }
        void SetId( const Guid& id )
        {
            id_ = id;
        }
        Int64 RowVersion( ) const
        {
            return rowVersion_;
        }
        void SetRowVersion( const Int64& rowVersion )
        {
            rowVersion_ = rowVersion;
        }
        const Guid& Catalog( ) const
        {
            return catalog_;
        }
        void SetCatalog( const Guid& catalog )
        {
            catalog_ = catalog;
        }
        const FixedDBWideString<127>& Name( ) const
        {
            return name_;
        }
        void SetName( const WideString& name )
        {
            name_ = name;
        }
        void BindColumns( const ODBC::Statement& statement )
        {
            Bind(statement, ID_FIELD_ID, id_);
            Bind(statement, ROWVERSION_FIELD_ID, rowVersion_);
            Bind(statement, CATALOG_FIELD_ID, catalog_);
            Bind(statement, NAME_FIELD_ID, name_);
        }

        template<IO::StreamWriter StreamT>
        void WriteColumns( IO::BinaryWriter<StreamT>& destination ) const
        {
            WriteColumnValue( destination, id_);
            WriteColumnValue( destination, rowVersion_);
            WriteColumnValue( destination, catalog_);
            WriteColumnValue( destination, name_);
        }
    };

    using SimpleCatalogElementDataReader = SimpleColumnDataReader<CatalogElementColumnData>;

    class CatalogColumnData : public CatalogElementColumnData
    {
    public:
        using Base = CatalogElementColumnData;

        static constexpr std::wstring_view FieldNames = L"[Id],[RowVersion],[Catalog],[Name]";
        static constexpr std::wstring_view ViewName = L"CatalogView";

        CatalogColumnData( ) = default;

        virtual Kind GetKind() const override
        {
            return Kind::Catalog;
        }

        template<IO::StreamWriter StreamT>
        void WriteColumns( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteColumns( destination );
        }
    };

    using SimpleCatalogDataReader = SimpleColumnDataReader<CatalogColumnData>;

    class ElementColumnData : public CatalogElementColumnData
    {
        Guid elementType_;
    public:
        using Base = CatalogElementColumnData;

        static constexpr std::wstring_view FieldNames = L"[Id],[RowVersion],[Catalog],[Name],[ElementType]";
        static constexpr std::wstring_view ViewName = L"ElementView";

        static constexpr SQLUSMALLINT ELEMENTTYPE_FIELD_ID = 5;

        ElementColumnData( ) = default;

        virtual Kind GetKind() const override
        {
            return Kind::Element;
        }

        const Guid& ElementType( ) const
        {
            return elementType_;
        }
        void SetElementType( const Guid& elementType )
        {
            elementType_ = elementType;
        }
        void BindColumns( const ODBC::Statement& statement )
        {
            Base::BindColumns( statement );

            Bind(statement, ELEMENTTYPE_FIELD_ID, elementType_);
        }

        template<IO::StreamWriter StreamT>
        void WriteColumns( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteColumns( destination );
            WriteColumnValue( destination, elementType_);
        }
    };

    using SimpleElementDataReader = SimpleColumnDataReader<ElementColumnData>;

    class CollectionInfoColumnData : public BaseColumnData
    {
        Guid id_;
        Int64 rowVersion_ = 0;
        Int64 count_ = 0;
    public:
        using Base = BaseColumnData;

        static constexpr std::wstring_view FieldNames = L"[Id],[RowVersion],[Count]";
        static constexpr std::wstring_view ViewName = L"CollectionInfoView";

        static constexpr SQLUSMALLINT ID_FIELD_ID = 1;
        static constexpr SQLUSMALLINT ROWVERSION_FIELD_ID = 2;
        static constexpr SQLUSMALLINT COUNT_FIELD_ID = 3;

        CollectionInfoColumnData( ) = default;

        virtual Kind GetKind() const override
        {
            return Kind::CollectionInfo;
        }

        const Guid& Id( ) const
        {
            return id_;
        }
        void SetId( const Guid& id )
        {
            id_ = id;
        }
        Int64 RowVersion( ) const
        {
            return rowVersion_;
        }
        void SetRowVersion( const Int64& rowVersion )
        {
            rowVersion_ = rowVersion;
        }
        Int64 Count( ) const
        {
            return count_;
        }
        void SetCount( Int64 count )
        {
            count_ = count;
        }
        void BindColumns( const ODBC::Statement& statement )
        {
            Bind(statement, ID_FIELD_ID, id_);
            Bind(statement, ROWVERSION_FIELD_ID, rowVersion_);
            Bind(statement, COUNT_FIELD_ID, count_);
        }

        template<IO::StreamWriter StreamT>
        void WriteColumns( IO::BinaryWriter<StreamT>& destination ) const
        {
            WriteColumnValue( destination, id_);
            WriteColumnValue( destination, rowVersion_);
            WriteColumnValue( destination, count_);
        }
    };

    using SimpleCollectionInfoDataReader = SimpleColumnDataReader<CollectionInfoColumnData>;

    class CountryColumnData : public BaseColumnData
    {
        Guid id_;
        Int64 rowVersion_ = 0;
        FixedDBWideString<127> name_;
        Int32 code_ = 0;
        FixedDBWideString<2> alpha2_;
        FixedDBWideString<3> alpha3_;
    public:
        using Base = BaseColumnData;

        static constexpr std::wstring_view FieldNames = L"[Id],[RowVersion],[Name],[Code],[Alpha2],[Alpha3]";
        static constexpr std::wstring_view ViewName = L"CountryView";

        static constexpr SQLUSMALLINT ID_FIELD_ID = 1;
        static constexpr SQLUSMALLINT ROWVERSION_FIELD_ID = 2;
        static constexpr SQLUSMALLINT NAME_FIELD_ID = 3;
        static constexpr SQLUSMALLINT CODE_FIELD_ID = 4;
        static constexpr SQLUSMALLINT ALPHA2_FIELD_ID = 5;
        static constexpr SQLUSMALLINT ALPHA3_FIELD_ID = 6;

        CountryColumnData( ) = default;

        virtual Kind GetKind() const override
        {
            return Kind::Country;
        }

        const Guid& Id( ) const
        {
            return id_;
        }
        void SetId( const Guid& id )
        {
            id_ = id;
        }
        Int64 RowVersion( ) const
        {
            return rowVersion_;
        }
        void SetRowVersion( const Int64& rowVersion )
        {
            rowVersion_ = rowVersion;
        }
        const FixedDBWideString<127>& Name( ) const
        {
            return name_;
        }
        void SetName( const WideString& name )
        {
            name_ = name;
        }
        Int32 Code( ) const
        {
            return code_;
        }
        void SetCode( Int32 code )
        {
            code_ = code;
        }
        const FixedDBWideString<2>& Alpha2( ) const
        {
            return alpha2_;
        }
        void SetAlpha2( const WideString& alpha2 )
        {
            alpha2_ = alpha2;
        }
        const FixedDBWideString<3>& Alpha3( ) const
        {
            return alpha3_;
        }
        void SetAlpha3( const WideString& alpha3 )
        {
            alpha3_ = alpha3;
        }
        void BindColumns( const ODBC::Statement& statement )
        {
            Bind(statement, ID_FIELD_ID, id_);
            Bind(statement, ROWVERSION_FIELD_ID, rowVersion_);
            Bind(statement, NAME_FIELD_ID, name_);
            Bind(statement, CODE_FIELD_ID, code_);
            Bind(statement, ALPHA2_FIELD_ID, alpha2_);
            Bind(statement, ALPHA3_FIELD_ID, alpha3_);
        }

        template<IO::StreamWriter StreamT>
        void WriteColumns( IO::BinaryWriter<StreamT>& destination ) const
        {
            WriteColumnValue( destination, id_);
            WriteColumnValue( destination, rowVersion_);
            WriteColumnValue( destination, name_);
            WriteColumnValue( destination, code_);
            WriteColumnValue( destination, alpha2_);
            WriteColumnValue( destination, alpha3_);
        }
    };

    using SimpleCountryDataReader = SimpleColumnDataReader<CountryColumnData>;

    class CursorInfoColumnData : public BaseColumnData
    {
        Guid id_;
        Int64 rowVersion_ = 0;
        Int32 typeCode_ = 0;
    public:
        using Base = BaseColumnData;

        static constexpr std::wstring_view FieldNames = L"[Id],[RowVersion],[TypeCode]";
        static constexpr std::wstring_view ViewName = L"CursorInfoView";

        static constexpr SQLUSMALLINT ID_FIELD_ID = 1;
        static constexpr SQLUSMALLINT ROWVERSION_FIELD_ID = 2;
        static constexpr SQLUSMALLINT TYPECODE_FIELD_ID = 3;

        CursorInfoColumnData( ) = default;

        virtual Kind GetKind() const override
        {
            return Kind::CursorInfo;
        }

        const Guid& Id( ) const
        {
            return id_;
        }
        void SetId( const Guid& id )
        {
            id_ = id;
        }
        Int64 RowVersion( ) const
        {
            return rowVersion_;
        }
        void SetRowVersion( const Int64& rowVersion )
        {
            rowVersion_ = rowVersion;
        }
        Int32 TypeCode( ) const
        {
            return typeCode_;
        }
        void SetTypeCode( Int32 typeCode )
        {
            typeCode_ = typeCode;
        }
        void BindColumns( const ODBC::Statement& statement )
        {
            Bind(statement, ID_FIELD_ID, id_);
            Bind(statement, ROWVERSION_FIELD_ID, rowVersion_);
            Bind(statement, TYPECODE_FIELD_ID, typeCode_);
        }

        template<IO::StreamWriter StreamT>
        void WriteColumns( IO::BinaryWriter<StreamT>& destination ) const
        {
            WriteColumnValue( destination, id_);
            WriteColumnValue( destination, rowVersion_);
            WriteColumnValue( destination, typeCode_);
        }
    };

    using SimpleCursorInfoDataReader = SimpleColumnDataReader<CursorInfoColumnData>;

    class DateTimeTimeseriesValueColumnData : public BaseColumnData
    {
        Guid id_;
        Int64 rowVersion_ = 0;
        Guid timeseries_;
        DateTime timestamp_;
        DBDateTime value_;
    public:
        using Base = BaseColumnData;

        static constexpr std::wstring_view FieldNames = L"[Id],[RowVersion],[Timeseries],[Timestamp],[Value]";
        static constexpr std::wstring_view ViewName = L"DateTimeTimeseriesValueView";

        static constexpr SQLUSMALLINT ID_FIELD_ID = 1;
        static constexpr SQLUSMALLINT ROWVERSION_FIELD_ID = 2;
        static constexpr SQLUSMALLINT TIMESERIES_FIELD_ID = 3;
        static constexpr SQLUSMALLINT TIMESTAMP_FIELD_ID = 4;
        static constexpr SQLUSMALLINT VALUE_FIELD_ID = 5;

        DateTimeTimeseriesValueColumnData( ) = default;

        virtual Kind GetKind() const override
        {
            return Kind::DateTimeTimeseriesValue;
        }

        const Guid& Id( ) const
        {
            return id_;
        }
        void SetId( const Guid& id )
        {
            id_ = id;
        }
        Int64 RowVersion( ) const
        {
            return rowVersion_;
        }
        void SetRowVersion( const Int64& rowVersion )
        {
            rowVersion_ = rowVersion;
        }
        const Guid& Timeseries( ) const
        {
            return timeseries_;
        }
        void SetTimeseries( const Guid& timeseries )
        {
            timeseries_ = timeseries;
        }
        const DateTime& Timestamp( ) const
        {
            return timestamp_;
        }
        void SetTimestamp( const DateTime& timestamp )
        {
            timestamp_ = timestamp;
        }
        const DBDateTime& Value( ) const
        {
            return value_;
        }
        void SetValue( const DBDateTime& value )
        {
            value_ = value;
        }
        void BindColumns( const ODBC::Statement& statement )
        {
            Bind(statement, ID_FIELD_ID, id_);
            Bind(statement, ROWVERSION_FIELD_ID, rowVersion_);
            Bind(statement, TIMESERIES_FIELD_ID, timeseries_);
            Bind(statement, TIMESTAMP_FIELD_ID, timestamp_);
            Bind(statement, VALUE_FIELD_ID, value_);
        }

        template<IO::StreamWriter StreamT>
        void WriteColumns( IO::BinaryWriter<StreamT>& destination ) const
        {
            WriteColumnValue( destination, id_);
            WriteColumnValue( destination, rowVersion_);
            WriteColumnValue( destination, timeseries_);
            WriteColumnValue( destination, timestamp_);
            WriteColumnValue( destination, value_);
        }
    };

    using SimpleDateTimeTimeseriesValueDataReader = SimpleColumnDataReader<DateTimeTimeseriesValueColumnData>;

    class DeviceHostColumnData : public BaseColumnData
    {
        Guid id_;
        Int64 rowVersion_ = 0;
        FixedDBWideString<127> name_;
    public:
        using Base = BaseColumnData;

        static constexpr std::wstring_view FieldNames = L"[Id],[RowVersion],[Name]";
        static constexpr std::wstring_view ViewName = L"DeviceHostView";

        static constexpr SQLUSMALLINT ID_FIELD_ID = 1;
        static constexpr SQLUSMALLINT ROWVERSION_FIELD_ID = 2;
        static constexpr SQLUSMALLINT NAME_FIELD_ID = 3;

        DeviceHostColumnData( ) = default;

        virtual Kind GetKind() const override
        {
            return Kind::DeviceHost;
        }

        const Guid& Id( ) const
        {
            return id_;
        }
        void SetId( const Guid& id )
        {
            id_ = id;
        }
        Int64 RowVersion( ) const
        {
            return rowVersion_;
        }
        void SetRowVersion( const Int64& rowVersion )
        {
            rowVersion_ = rowVersion;
        }
        const FixedDBWideString<127>& Name( ) const
        {
            return name_;
        }
        void SetName( const WideString& name )
        {
            name_ = name;
        }
        void BindColumns( const ODBC::Statement& statement )
        {
            Bind(statement, ID_FIELD_ID, id_);
            Bind(statement, ROWVERSION_FIELD_ID, rowVersion_);
            Bind(statement, NAME_FIELD_ID, name_);
        }

        template<IO::StreamWriter StreamT>
        void WriteColumns( IO::BinaryWriter<StreamT>& destination ) const
        {
            WriteColumnValue( destination, id_);
            WriteColumnValue( destination, rowVersion_);
            WriteColumnValue( destination, name_);
        }
    };

    using SimpleDeviceHostDataReader = SimpleColumnDataReader<DeviceHostColumnData>;

    class DeviceHostConfigurationColumnData : public BaseColumnData
    {
        Guid id_;
        Int64 rowVersion_ = 0;
        Guid host_;
        DateTime timestamp_;
        FixedDBWideString<127> hostname_;
        Int32 port_ = 0;
        FixedDBWideString<100> queueName_;
    public:
        using Base = BaseColumnData;

        static constexpr std::wstring_view FieldNames = L"[Id],[RowVersion],[Host],[Timestamp],[Hostname],[Port],[QueueName]";
        static constexpr std::wstring_view ViewName = L"DeviceHostConfigurationView";

        static constexpr SQLUSMALLINT ID_FIELD_ID = 1;
        static constexpr SQLUSMALLINT ROWVERSION_FIELD_ID = 2;
        static constexpr SQLUSMALLINT HOST_FIELD_ID = 3;
        static constexpr SQLUSMALLINT TIMESTAMP_FIELD_ID = 4;
        static constexpr SQLUSMALLINT HOSTNAME_FIELD_ID = 5;
        static constexpr SQLUSMALLINT PORT_FIELD_ID = 6;
        static constexpr SQLUSMALLINT QUEUENAME_FIELD_ID = 7;

        DeviceHostConfigurationColumnData( ) = default;

        virtual Kind GetKind() const override
        {
            return Kind::DeviceHostConfiguration;
        }

        const Guid& Id( ) const
        {
            return id_;
        }
        void SetId( const Guid& id )
        {
            id_ = id;
        }
        Int64 RowVersion( ) const
        {
            return rowVersion_;
        }
        void SetRowVersion( const Int64& rowVersion )
        {
            rowVersion_ = rowVersion;
        }
        const Guid& Host( ) const
        {
            return host_;
        }
        void SetHost( const Guid& host )
        {
            host_ = host;
        }
        const DateTime& Timestamp( ) const
        {
            return timestamp_;
        }
        void SetTimestamp( const DateTime& timestamp )
        {
            timestamp_ = timestamp;
        }
        const FixedDBWideString<127>& Hostname( ) const
        {
            return hostname_;
        }
        void SetHostname( const WideString& hostname )
        {
            hostname_ = hostname;
        }
        Int32 Port( ) const
        {
            return port_;
        }
        void SetPort( Int32 port )
        {
            port_ = port;
        }
        const FixedDBWideString<100>& QueueName( ) const
        {
            return queueName_;
        }
        void SetQueueName( const WideString& queueName )
        {
            queueName_ = queueName;
        }
        void BindColumns( const ODBC::Statement& statement )
        {
            Bind(statement, ID_FIELD_ID, id_);
            Bind(statement, ROWVERSION_FIELD_ID, rowVersion_);
            Bind(statement, HOST_FIELD_ID, host_);
            Bind(statement, TIMESTAMP_FIELD_ID, timestamp_);
            Bind(statement, HOSTNAME_FIELD_ID, hostname_);
            Bind(statement, PORT_FIELD_ID, port_);
            Bind(statement, QUEUENAME_FIELD_ID, queueName_);
        }

        template<IO::StreamWriter StreamT>
        void WriteColumns( IO::BinaryWriter<StreamT>& destination ) const
        {
            WriteColumnValue( destination, id_);
            WriteColumnValue( destination, rowVersion_);
            WriteColumnValue( destination, host_);
            WriteColumnValue( destination, timestamp_);
            WriteColumnValue( destination, hostname_);
            WriteColumnValue( destination, port_);
            WriteColumnValue( destination, queueName_);
        }
    };

    using SimpleDeviceHostConfigurationDataReader = SimpleColumnDataReader<DeviceHostConfigurationColumnData>;

    class DeviceTypeColumnData : public BaseColumnData
    {
        Guid id_;
        Int64 rowVersion_ = 0;
        FixedDBWideString<100> assemblyName_;
        FixedDBWideString<100> className_;
        FixedDBWideString<100> proxyAssemblyName_;
        FixedDBWideString<100> proxyClassName_;
    public:
        using Base = BaseColumnData;

        static constexpr std::wstring_view FieldNames = L"[Id],[RowVersion],[AssemblyName],[ClassName],[ProxyAssemblyName],[ProxyClassName]";
        static constexpr std::wstring_view ViewName = L"DeviceTypeView";

        static constexpr SQLUSMALLINT ID_FIELD_ID = 1;
        static constexpr SQLUSMALLINT ROWVERSION_FIELD_ID = 2;
        static constexpr SQLUSMALLINT ASSEMBLYNAME_FIELD_ID = 3;
        static constexpr SQLUSMALLINT CLASSNAME_FIELD_ID = 4;
        static constexpr SQLUSMALLINT PROXYASSEMBLYNAME_FIELD_ID = 5;
        static constexpr SQLUSMALLINT PROXYCLASSNAME_FIELD_ID = 6;

        DeviceTypeColumnData( ) = default;

        virtual Kind GetKind() const override
        {
            return Kind::DeviceType;
        }

        const Guid& Id( ) const
        {
            return id_;
        }
        void SetId( const Guid& id )
        {
            id_ = id;
        }
        Int64 RowVersion( ) const
        {
            return rowVersion_;
        }
        void SetRowVersion( const Int64& rowVersion )
        {
            rowVersion_ = rowVersion;
        }
        const FixedDBWideString<100>& AssemblyName( ) const
        {
            return assemblyName_;
        }
        void SetAssemblyName( const WideString& assemblyName )
        {
            assemblyName_ = assemblyName;
        }
        const FixedDBWideString<100>& ClassName( ) const
        {
            return className_;
        }
        void SetClassName( const WideString& className )
        {
            className_ = className;
        }
        const FixedDBWideString<100>& ProxyAssemblyName( ) const
        {
            return proxyAssemblyName_;
        }
        void SetProxyAssemblyName( const WideString& proxyAssemblyName )
        {
            proxyAssemblyName_ = proxyAssemblyName;
        }
        const FixedDBWideString<100>& ProxyClassName( ) const
        {
            return proxyClassName_;
        }
        void SetProxyClassName( const WideString& proxyClassName )
        {
            proxyClassName_ = proxyClassName;
        }
        void BindColumns( const ODBC::Statement& statement )
        {
            Bind(statement, ID_FIELD_ID, id_);
            Bind(statement, ROWVERSION_FIELD_ID, rowVersion_);
            Bind(statement, ASSEMBLYNAME_FIELD_ID, assemblyName_);
            Bind(statement, CLASSNAME_FIELD_ID, className_);
            Bind(statement, PROXYASSEMBLYNAME_FIELD_ID, proxyAssemblyName_);
            Bind(statement, PROXYCLASSNAME_FIELD_ID, proxyClassName_);
        }

        template<IO::StreamWriter StreamT>
        void WriteColumns( IO::BinaryWriter<StreamT>& destination ) const
        {
            WriteColumnValue( destination, id_);
            WriteColumnValue( destination, rowVersion_);
            WriteColumnValue( destination, assemblyName_);
            WriteColumnValue( destination, className_);
            WriteColumnValue( destination, proxyAssemblyName_);
            WriteColumnValue( destination, proxyClassName_);
        }
    };

    using SimpleDeviceTypeDataReader = SimpleColumnDataReader<DeviceTypeColumnData>;

    class AisTransceiverTypeColumnData : public DeviceTypeColumnData
    {
        FixedDBWideString<127> name_;
    public:
        using Base = DeviceTypeColumnData;

        static constexpr std::wstring_view FieldNames = L"[Id],[RowVersion],[AssemblyName],[ClassName],[ProxyAssemblyName],[ProxyClassName],[Name]";
        static constexpr std::wstring_view ViewName = L"AisTransceiverTypeView";

        static constexpr SQLUSMALLINT NAME_FIELD_ID = 7;

        AisTransceiverTypeColumnData( ) = default;

        virtual Kind GetKind() const override
        {
            return Kind::AisTransceiverType;
        }

        const FixedDBWideString<127>& Name( ) const
        {
            return name_;
        }
        void SetName( const WideString& name )
        {
            name_ = name;
        }
        void BindColumns( const ODBC::Statement& statement )
        {
            Base::BindColumns( statement );

            Bind(statement, NAME_FIELD_ID, name_);
        }

        template<IO::StreamWriter StreamT>
        void WriteColumns( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteColumns( destination );
            WriteColumnValue( destination, name_);
        }
    };

    using SimpleAisTransceiverTypeDataReader = SimpleColumnDataReader<AisTransceiverTypeColumnData>;

    class CameraTypeColumnData : public DeviceTypeColumnData
    {
        FixedDBWideString<127> name_;
        Data::CameraFeatures cameraFeatures_ = Data::CameraFeatures::None;
    public:
        using Base = DeviceTypeColumnData;

        static constexpr std::wstring_view FieldNames = L"[Id],[RowVersion],[AssemblyName],[ClassName],[ProxyAssemblyName],[ProxyClassName],[Name],[CameraFeatures]";
        static constexpr std::wstring_view ViewName = L"CameraTypeView";

        static constexpr SQLUSMALLINT NAME_FIELD_ID = 7;
        static constexpr SQLUSMALLINT CAMERAFEATURES_FIELD_ID = 8;

        CameraTypeColumnData( ) = default;

        virtual Kind GetKind() const override
        {
            return Kind::CameraType;
        }

        const FixedDBWideString<127>& Name( ) const
        {
            return name_;
        }
        void SetName( const WideString& name )
        {
            name_ = name;
        }
        Data::CameraFeatures CameraFeatures( ) const
        {
            return cameraFeatures_;
        }
        void SetCameraFeatures( Data::CameraFeatures cameraFeatures )
        {
            cameraFeatures_ = cameraFeatures;
        }
        void BindColumns( const ODBC::Statement& statement )
        {
            Base::BindColumns( statement );

            Bind(statement, NAME_FIELD_ID, name_);
            Bind(statement, CAMERAFEATURES_FIELD_ID, cameraFeatures_);
        }

        template<IO::StreamWriter StreamT>
        void WriteColumns( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteColumns( destination );
            WriteColumnValue( destination, name_);
            WriteColumnValue( destination, cameraFeatures_);
        }
    };

    using SimpleCameraTypeDataReader = SimpleColumnDataReader<CameraTypeColumnData>;

    class GNSSDeviceTypeColumnData : public DeviceTypeColumnData
    {
        FixedDBWideString<127> name_;
    public:
        using Base = DeviceTypeColumnData;

        static constexpr std::wstring_view FieldNames = L"[Id],[RowVersion],[AssemblyName],[ClassName],[ProxyAssemblyName],[ProxyClassName],[Name]";
        static constexpr std::wstring_view ViewName = L"GNSSDeviceTypeView";

        static constexpr SQLUSMALLINT NAME_FIELD_ID = 7;

        GNSSDeviceTypeColumnData( ) = default;

        virtual Kind GetKind() const override
        {
            return Kind::GNSSDeviceType;
        }

        const FixedDBWideString<127>& Name( ) const
        {
            return name_;
        }
        void SetName( const WideString& name )
        {
            name_ = name;
        }
        void BindColumns( const ODBC::Statement& statement )
        {
            Base::BindColumns( statement );

            Bind(statement, NAME_FIELD_ID, name_);
        }

        template<IO::StreamWriter StreamT>
        void WriteColumns( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteColumns( destination );
            WriteColumnValue( destination, name_);
        }
    };

    using SimpleGNSSDeviceTypeDataReader = SimpleColumnDataReader<GNSSDeviceTypeColumnData>;

    class GyroDeviceTypeColumnData : public DeviceTypeColumnData
    {
        FixedDBWideString<127> name_;
    public:
        using Base = DeviceTypeColumnData;

        static constexpr std::wstring_view FieldNames = L"[Id],[RowVersion],[AssemblyName],[ClassName],[ProxyAssemblyName],[ProxyClassName],[Name]";
        static constexpr std::wstring_view ViewName = L"GyroDeviceTypeView";

        static constexpr SQLUSMALLINT NAME_FIELD_ID = 7;

        GyroDeviceTypeColumnData( ) = default;

        virtual Kind GetKind() const override
        {
            return Kind::GyroDeviceType;
        }

        const FixedDBWideString<127>& Name( ) const
        {
            return name_;
        }
        void SetName( const WideString& name )
        {
            name_ = name;
        }
        void BindColumns( const ODBC::Statement& statement )
        {
            Base::BindColumns( statement );

            Bind(statement, NAME_FIELD_ID, name_);
        }

        template<IO::StreamWriter StreamT>
        void WriteColumns( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteColumns( destination );
            WriteColumnValue( destination, name_);
        }
    };

    using SimpleGyroDeviceTypeDataReader = SimpleColumnDataReader<GyroDeviceTypeColumnData>;

    class LineInputDeviceTypeColumnData : public DeviceTypeColumnData
    {
        FixedDBWideString<127> name_;
    public:
        using Base = DeviceTypeColumnData;

        static constexpr std::wstring_view FieldNames = L"[Id],[RowVersion],[AssemblyName],[ClassName],[ProxyAssemblyName],[ProxyClassName],[Name]";
        static constexpr std::wstring_view ViewName = L"LineInputDeviceTypeView";

        static constexpr SQLUSMALLINT NAME_FIELD_ID = 7;

        LineInputDeviceTypeColumnData( ) = default;

        virtual Kind GetKind() const override
        {
            return Kind::LineInputDeviceType;
        }

        const FixedDBWideString<127>& Name( ) const
        {
            return name_;
        }
        void SetName( const WideString& name )
        {
            name_ = name;
        }
        void BindColumns( const ODBC::Statement& statement )
        {
            Base::BindColumns( statement );

            Bind(statement, NAME_FIELD_ID, name_);
        }

        template<IO::StreamWriter StreamT>
        void WriteColumns( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteColumns( destination );
            WriteColumnValue( destination, name_);
        }
    };

    using SimpleLineInputDeviceTypeDataReader = SimpleColumnDataReader<LineInputDeviceTypeColumnData>;

    class OilspillDetectorTypeColumnData : public DeviceTypeColumnData
    {
        FixedDBWideString<127> name_;
    public:
        using Base = DeviceTypeColumnData;

        static constexpr std::wstring_view FieldNames = L"[Id],[RowVersion],[AssemblyName],[ClassName],[ProxyAssemblyName],[ProxyClassName],[Name]";
        static constexpr std::wstring_view ViewName = L"OilspillDetectorTypeView";

        static constexpr SQLUSMALLINT NAME_FIELD_ID = 7;

        OilspillDetectorTypeColumnData( ) = default;

        virtual Kind GetKind() const override
        {
            return Kind::OilspillDetectorType;
        }

        const FixedDBWideString<127>& Name( ) const
        {
            return name_;
        }
        void SetName( const WideString& name )
        {
            name_ = name;
        }
        void BindColumns( const ODBC::Statement& statement )
        {
            Base::BindColumns( statement );

            Bind(statement, NAME_FIELD_ID, name_);
        }

        template<IO::StreamWriter StreamT>
        void WriteColumns( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteColumns( destination );
            WriteColumnValue( destination, name_);
        }
    };

    using SimpleOilspillDetectorTypeDataReader = SimpleColumnDataReader<OilspillDetectorTypeColumnData>;

    class RadarTypeColumnData : public DeviceTypeColumnData
    {
        FixedDBWideString<127> name_;
        DBInt32 pulseShortMinusValue_;
        FixedDBWideString<50> pulseShortMinusDisplayText_;
        DBInt32 pulseShortValue_;
        FixedDBWideString<50> pulseShortDisplayText_;
        DBInt32 pulseShortPlusValue_;
        FixedDBWideString<50> pulseShortPlusDisplayText_;
        DBInt32 pulseMediumMinusValue_;
        FixedDBWideString<50> pulseMediumMinusDisplayText_;
        DBInt32 pulseMediumValue_;
        FixedDBWideString<50> pulseMediumDisplayText_;
        DBInt32 pulseMediumPlusValue_;
        FixedDBWideString<50> pulseMediumPlusDisplayText_;
        DBInt32 pulseLongMinusValue_;
        FixedDBWideString<50> pulseLongMinusDisplayText_;
        DBInt32 pulseLongValue_;
        FixedDBWideString<50> pulseLongDisplayText_;
        DBInt32 pulseLongPlusValue_;
        FixedDBWideString<50> pulseLongPlusDisplayText_;
    public:
        using Base = DeviceTypeColumnData;

        static constexpr std::wstring_view FieldNames = L"[Id],[RowVersion],[AssemblyName],[ClassName],[ProxyAssemblyName],[ProxyClassName],[Name],[PulseShortMinusValue],[PulseShortMinusDisplayText],[PulseShortValue],[PulseShortDisplayText],[PulseShortPlusValue],[PulseShortPlusDisplayText],[PulseMediumMinusValue],[PulseMediumMinusDisplayText],[PulseMediumValue],[PulseMediumDisplayText],[PulseMediumPlusValue],[PulseMediumPlusDisplayText],[PulseLongMinusValue],[PulseLongMinusDisplayText],[PulseLongValue],[PulseLongDisplayText],[PulseLongPlusValue],[PulseLongPlusDisplayText]";
        static constexpr std::wstring_view ViewName = L"RadarTypeView";

        static constexpr SQLUSMALLINT NAME_FIELD_ID = 7;
        static constexpr SQLUSMALLINT PULSESHORTMINUSVALUE_FIELD_ID = 8;
        static constexpr SQLUSMALLINT PULSESHORTMINUSDISPLAYTEXT_FIELD_ID = 9;
        static constexpr SQLUSMALLINT PULSESHORTVALUE_FIELD_ID = 10;
        static constexpr SQLUSMALLINT PULSESHORTDISPLAYTEXT_FIELD_ID = 11;
        static constexpr SQLUSMALLINT PULSESHORTPLUSVALUE_FIELD_ID = 12;
        static constexpr SQLUSMALLINT PULSESHORTPLUSDISPLAYTEXT_FIELD_ID = 13;
        static constexpr SQLUSMALLINT PULSEMEDIUMMINUSVALUE_FIELD_ID = 14;
        static constexpr SQLUSMALLINT PULSEMEDIUMMINUSDISPLAYTEXT_FIELD_ID = 15;
        static constexpr SQLUSMALLINT PULSEMEDIUMVALUE_FIELD_ID = 16;
        static constexpr SQLUSMALLINT PULSEMEDIUMDISPLAYTEXT_FIELD_ID = 17;
        static constexpr SQLUSMALLINT PULSEMEDIUMPLUSVALUE_FIELD_ID = 18;
        static constexpr SQLUSMALLINT PULSEMEDIUMPLUSDISPLAYTEXT_FIELD_ID = 19;
        static constexpr SQLUSMALLINT PULSELONGMINUSVALUE_FIELD_ID = 20;
        static constexpr SQLUSMALLINT PULSELONGMINUSDISPLAYTEXT_FIELD_ID = 21;
        static constexpr SQLUSMALLINT PULSELONGVALUE_FIELD_ID = 22;
        static constexpr SQLUSMALLINT PULSELONGDISPLAYTEXT_FIELD_ID = 23;
        static constexpr SQLUSMALLINT PULSELONGPLUSVALUE_FIELD_ID = 24;
        static constexpr SQLUSMALLINT PULSELONGPLUSDISPLAYTEXT_FIELD_ID = 25;

        RadarTypeColumnData( ) = default;

        virtual Kind GetKind() const override
        {
            return Kind::RadarType;
        }

        const FixedDBWideString<127>& Name( ) const
        {
            return name_;
        }
        void SetName( const WideString& name )
        {
            name_ = name;
        }
        const DBInt32& PulseShortMinusValue( ) const
        {
            return pulseShortMinusValue_;
        }
        void SetPulseShortMinusValue( const DBInt32& pulseShortMinusValue )
        {
            pulseShortMinusValue_ = pulseShortMinusValue;
        }
        const FixedDBWideString<50>& PulseShortMinusDisplayText( ) const
        {
            return pulseShortMinusDisplayText_;
        }
        void SetPulseShortMinusDisplayText( const WideString& pulseShortMinusDisplayText )
        {
            pulseShortMinusDisplayText_ = pulseShortMinusDisplayText;
        }
        const DBInt32& PulseShortValue( ) const
        {
            return pulseShortValue_;
        }
        void SetPulseShortValue( const DBInt32& pulseShortValue )
        {
            pulseShortValue_ = pulseShortValue;
        }
        const FixedDBWideString<50>& PulseShortDisplayText( ) const
        {
            return pulseShortDisplayText_;
        }
        void SetPulseShortDisplayText( const WideString& pulseShortDisplayText )
        {
            pulseShortDisplayText_ = pulseShortDisplayText;
        }
        const DBInt32& PulseShortPlusValue( ) const
        {
            return pulseShortPlusValue_;
        }
        void SetPulseShortPlusValue( const DBInt32& pulseShortPlusValue )
        {
            pulseShortPlusValue_ = pulseShortPlusValue;
        }
        const FixedDBWideString<50>& PulseShortPlusDisplayText( ) const
        {
            return pulseShortPlusDisplayText_;
        }
        void SetPulseShortPlusDisplayText( const WideString& pulseShortPlusDisplayText )
        {
            pulseShortPlusDisplayText_ = pulseShortPlusDisplayText;
        }
        const DBInt32& PulseMediumMinusValue( ) const
        {
            return pulseMediumMinusValue_;
        }
        void SetPulseMediumMinusValue( const DBInt32& pulseMediumMinusValue )
        {
            pulseMediumMinusValue_ = pulseMediumMinusValue;
        }
        const FixedDBWideString<50>& PulseMediumMinusDisplayText( ) const
        {
            return pulseMediumMinusDisplayText_;
        }
        void SetPulseMediumMinusDisplayText( const WideString& pulseMediumMinusDisplayText )
        {
            pulseMediumMinusDisplayText_ = pulseMediumMinusDisplayText;
        }
        const DBInt32& PulseMediumValue( ) const
        {
            return pulseMediumValue_;
        }
        void SetPulseMediumValue( const DBInt32& pulseMediumValue )
        {
            pulseMediumValue_ = pulseMediumValue;
        }
        const FixedDBWideString<50>& PulseMediumDisplayText( ) const
        {
            return pulseMediumDisplayText_;
        }
        void SetPulseMediumDisplayText( const WideString& pulseMediumDisplayText )
        {
            pulseMediumDisplayText_ = pulseMediumDisplayText;
        }
        const DBInt32& PulseMediumPlusValue( ) const
        {
            return pulseMediumPlusValue_;
        }
        void SetPulseMediumPlusValue( const DBInt32& pulseMediumPlusValue )
        {
            pulseMediumPlusValue_ = pulseMediumPlusValue;
        }
        const FixedDBWideString<50>& PulseMediumPlusDisplayText( ) const
        {
            return pulseMediumPlusDisplayText_;
        }
        void SetPulseMediumPlusDisplayText( const WideString& pulseMediumPlusDisplayText )
        {
            pulseMediumPlusDisplayText_ = pulseMediumPlusDisplayText;
        }
        const DBInt32& PulseLongMinusValue( ) const
        {
            return pulseLongMinusValue_;
        }
        void SetPulseLongMinusValue( const DBInt32& pulseLongMinusValue )
        {
            pulseLongMinusValue_ = pulseLongMinusValue;
        }
        const FixedDBWideString<50>& PulseLongMinusDisplayText( ) const
        {
            return pulseLongMinusDisplayText_;
        }
        void SetPulseLongMinusDisplayText( const WideString& pulseLongMinusDisplayText )
        {
            pulseLongMinusDisplayText_ = pulseLongMinusDisplayText;
        }
        const DBInt32& PulseLongValue( ) const
        {
            return pulseLongValue_;
        }
        void SetPulseLongValue( const DBInt32& pulseLongValue )
        {
            pulseLongValue_ = pulseLongValue;
        }
        const FixedDBWideString<50>& PulseLongDisplayText( ) const
        {
            return pulseLongDisplayText_;
        }
        void SetPulseLongDisplayText( const WideString& pulseLongDisplayText )
        {
            pulseLongDisplayText_ = pulseLongDisplayText;
        }
        const DBInt32& PulseLongPlusValue( ) const
        {
            return pulseLongPlusValue_;
        }
        void SetPulseLongPlusValue( const DBInt32& pulseLongPlusValue )
        {
            pulseLongPlusValue_ = pulseLongPlusValue;
        }
        const FixedDBWideString<50>& PulseLongPlusDisplayText( ) const
        {
            return pulseLongPlusDisplayText_;
        }
        void SetPulseLongPlusDisplayText( const WideString& pulseLongPlusDisplayText )
        {
            pulseLongPlusDisplayText_ = pulseLongPlusDisplayText;
        }
        void BindColumns( const ODBC::Statement& statement )
        {
            Base::BindColumns( statement );

            Bind(statement, NAME_FIELD_ID, name_);
            Bind(statement, PULSESHORTMINUSVALUE_FIELD_ID, pulseShortMinusValue_);
            Bind(statement, PULSESHORTMINUSDISPLAYTEXT_FIELD_ID, pulseShortMinusDisplayText_);
            Bind(statement, PULSESHORTVALUE_FIELD_ID, pulseShortValue_);
            Bind(statement, PULSESHORTDISPLAYTEXT_FIELD_ID, pulseShortDisplayText_);
            Bind(statement, PULSESHORTPLUSVALUE_FIELD_ID, pulseShortPlusValue_);
            Bind(statement, PULSESHORTPLUSDISPLAYTEXT_FIELD_ID, pulseShortPlusDisplayText_);
            Bind(statement, PULSEMEDIUMMINUSVALUE_FIELD_ID, pulseMediumMinusValue_);
            Bind(statement, PULSEMEDIUMMINUSDISPLAYTEXT_FIELD_ID, pulseMediumMinusDisplayText_);
            Bind(statement, PULSEMEDIUMVALUE_FIELD_ID, pulseMediumValue_);
            Bind(statement, PULSEMEDIUMDISPLAYTEXT_FIELD_ID, pulseMediumDisplayText_);
            Bind(statement, PULSEMEDIUMPLUSVALUE_FIELD_ID, pulseMediumPlusValue_);
            Bind(statement, PULSEMEDIUMPLUSDISPLAYTEXT_FIELD_ID, pulseMediumPlusDisplayText_);
            Bind(statement, PULSELONGMINUSVALUE_FIELD_ID, pulseLongMinusValue_);
            Bind(statement, PULSELONGMINUSDISPLAYTEXT_FIELD_ID, pulseLongMinusDisplayText_);
            Bind(statement, PULSELONGVALUE_FIELD_ID, pulseLongValue_);
            Bind(statement, PULSELONGDISPLAYTEXT_FIELD_ID, pulseLongDisplayText_);
            Bind(statement, PULSELONGPLUSVALUE_FIELD_ID, pulseLongPlusValue_);
            Bind(statement, PULSELONGPLUSDISPLAYTEXT_FIELD_ID, pulseLongPlusDisplayText_);
        }

        template<IO::StreamWriter StreamT>
        void WriteColumns( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteColumns( destination );
            WriteColumnValue( destination, name_);
            WriteColumnValue( destination, pulseShortMinusValue_);
            WriteColumnValue( destination, pulseShortMinusDisplayText_);
            WriteColumnValue( destination, pulseShortValue_);
            WriteColumnValue( destination, pulseShortDisplayText_);
            WriteColumnValue( destination, pulseShortPlusValue_);
            WriteColumnValue( destination, pulseShortPlusDisplayText_);
            WriteColumnValue( destination, pulseMediumMinusValue_);
            WriteColumnValue( destination, pulseMediumMinusDisplayText_);
            WriteColumnValue( destination, pulseMediumValue_);
            WriteColumnValue( destination, pulseMediumDisplayText_);
            WriteColumnValue( destination, pulseMediumPlusValue_);
            WriteColumnValue( destination, pulseMediumPlusDisplayText_);
            WriteColumnValue( destination, pulseLongMinusValue_);
            WriteColumnValue( destination, pulseLongMinusDisplayText_);
            WriteColumnValue( destination, pulseLongValue_);
            WriteColumnValue( destination, pulseLongDisplayText_);
            WriteColumnValue( destination, pulseLongPlusValue_);
            WriteColumnValue( destination, pulseLongPlusDisplayText_);
        }
    };

    using SimpleRadarTypeDataReader = SimpleColumnDataReader<RadarTypeColumnData>;

    class RadioTypeColumnData : public DeviceTypeColumnData
    {
        FixedDBWideString<127> name_;
    public:
        using Base = DeviceTypeColumnData;

        static constexpr std::wstring_view FieldNames = L"[Id],[RowVersion],[AssemblyName],[ClassName],[ProxyAssemblyName],[ProxyClassName],[Name]";
        static constexpr std::wstring_view ViewName = L"RadioTypeView";

        static constexpr SQLUSMALLINT NAME_FIELD_ID = 7;

        RadioTypeColumnData( ) = default;

        virtual Kind GetKind() const override
        {
            return Kind::RadioType;
        }

        const FixedDBWideString<127>& Name( ) const
        {
            return name_;
        }
        void SetName( const WideString& name )
        {
            name_ = name;
        }
        void BindColumns( const ODBC::Statement& statement )
        {
            Base::BindColumns( statement );

            Bind(statement, NAME_FIELD_ID, name_);
        }

        template<IO::StreamWriter StreamT>
        void WriteColumns( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteColumns( destination );
            WriteColumnValue( destination, name_);
        }
    };

    using SimpleRadioTypeDataReader = SimpleColumnDataReader<RadioTypeColumnData>;

    class RadomeTypeColumnData : public DeviceTypeColumnData
    {
        FixedDBWideString<127> name_;
    public:
        using Base = DeviceTypeColumnData;

        static constexpr std::wstring_view FieldNames = L"[Id],[RowVersion],[AssemblyName],[ClassName],[ProxyAssemblyName],[ProxyClassName],[Name]";
        static constexpr std::wstring_view ViewName = L"RadomeTypeView";

        static constexpr SQLUSMALLINT NAME_FIELD_ID = 7;

        RadomeTypeColumnData( ) = default;

        virtual Kind GetKind() const override
        {
            return Kind::RadomeType;
        }

        const FixedDBWideString<127>& Name( ) const
        {
            return name_;
        }
        void SetName( const WideString& name )
        {
            name_ = name;
        }
        void BindColumns( const ODBC::Statement& statement )
        {
            Base::BindColumns( statement );

            Bind(statement, NAME_FIELD_ID, name_);
        }

        template<IO::StreamWriter StreamT>
        void WriteColumns( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteColumns( destination );
            WriteColumnValue( destination, name_);
        }
    };

    using SimpleRadomeTypeDataReader = SimpleColumnDataReader<RadomeTypeColumnData>;

    class WeatherStationTypeColumnData : public DeviceTypeColumnData
    {
        FixedDBWideString<127> name_;
    public:
        using Base = DeviceTypeColumnData;

        static constexpr std::wstring_view FieldNames = L"[Id],[RowVersion],[AssemblyName],[ClassName],[ProxyAssemblyName],[ProxyClassName],[Name]";
        static constexpr std::wstring_view ViewName = L"WeatherStationTypeView";

        static constexpr SQLUSMALLINT NAME_FIELD_ID = 7;

        WeatherStationTypeColumnData( ) = default;

        virtual Kind GetKind() const override
        {
            return Kind::WeatherStationType;
        }

        const FixedDBWideString<127>& Name( ) const
        {
            return name_;
        }
        void SetName( const WideString& name )
        {
            name_ = name;
        }
        void BindColumns( const ODBC::Statement& statement )
        {
            Base::BindColumns( statement );

            Bind(statement, NAME_FIELD_ID, name_);
        }

        template<IO::StreamWriter StreamT>
        void WriteColumns( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteColumns( destination );
            WriteColumnValue( destination, name_);
        }
    };

    using SimpleWeatherStationTypeDataReader = SimpleColumnDataReader<WeatherStationTypeColumnData>;

    class DoubleTimeseriesValueColumnData : public BaseColumnData
    {
        Guid id_;
        Int64 rowVersion_ = 0;
        Guid timeseries_;
        DateTime timestamp_;
        DBDouble value_;
    public:
        using Base = BaseColumnData;

        static constexpr std::wstring_view FieldNames = L"[Id],[RowVersion],[Timeseries],[Timestamp],[Value]";
        static constexpr std::wstring_view ViewName = L"DoubleTimeseriesValueView";

        static constexpr SQLUSMALLINT ID_FIELD_ID = 1;
        static constexpr SQLUSMALLINT ROWVERSION_FIELD_ID = 2;
        static constexpr SQLUSMALLINT TIMESERIES_FIELD_ID = 3;
        static constexpr SQLUSMALLINT TIMESTAMP_FIELD_ID = 4;
        static constexpr SQLUSMALLINT VALUE_FIELD_ID = 5;

        DoubleTimeseriesValueColumnData( ) = default;

        virtual Kind GetKind() const override
        {
            return Kind::DoubleTimeseriesValue;
        }

        const Guid& Id( ) const
        {
            return id_;
        }
        void SetId( const Guid& id )
        {
            id_ = id;
        }
        Int64 RowVersion( ) const
        {
            return rowVersion_;
        }
        void SetRowVersion( const Int64& rowVersion )
        {
            rowVersion_ = rowVersion;
        }
        const Guid& Timeseries( ) const
        {
            return timeseries_;
        }
        void SetTimeseries( const Guid& timeseries )
        {
            timeseries_ = timeseries;
        }
        const DateTime& Timestamp( ) const
        {
            return timestamp_;
        }
        void SetTimestamp( const DateTime& timestamp )
        {
            timestamp_ = timestamp;
        }
        const DBDouble& Value( ) const
        {
            return value_;
        }
        void SetValue( const DBDouble& value )
        {
            value_ = value;
        }
        void BindColumns( const ODBC::Statement& statement )
        {
            Bind(statement, ID_FIELD_ID, id_);
            Bind(statement, ROWVERSION_FIELD_ID, rowVersion_);
            Bind(statement, TIMESERIES_FIELD_ID, timeseries_);
            Bind(statement, TIMESTAMP_FIELD_ID, timestamp_);
            Bind(statement, VALUE_FIELD_ID, value_);
        }

        template<IO::StreamWriter StreamT>
        void WriteColumns( IO::BinaryWriter<StreamT>& destination ) const
        {
            WriteColumnValue( destination, id_);
            WriteColumnValue( destination, rowVersion_);
            WriteColumnValue( destination, timeseries_);
            WriteColumnValue( destination, timestamp_);
            WriteColumnValue( destination, value_);
        }
    };

    using SimpleDoubleTimeseriesValueDataReader = SimpleColumnDataReader<DoubleTimeseriesValueColumnData>;

    class FacilityTypeColumnData : public BaseColumnData
    {
        Guid id_;
        Int64 rowVersion_ = 0;
        FixedDBWideString<127> name_;
    public:
        using Base = BaseColumnData;

        static constexpr std::wstring_view FieldNames = L"[Id],[RowVersion],[Name]";
        static constexpr std::wstring_view ViewName = L"FacilityTypeView";

        static constexpr SQLUSMALLINT ID_FIELD_ID = 1;
        static constexpr SQLUSMALLINT ROWVERSION_FIELD_ID = 2;
        static constexpr SQLUSMALLINT NAME_FIELD_ID = 3;

        FacilityTypeColumnData( ) = default;

        virtual Kind GetKind() const override
        {
            return Kind::FacilityType;
        }

        const Guid& Id( ) const
        {
            return id_;
        }
        void SetId( const Guid& id )
        {
            id_ = id;
        }
        Int64 RowVersion( ) const
        {
            return rowVersion_;
        }
        void SetRowVersion( const Int64& rowVersion )
        {
            rowVersion_ = rowVersion;
        }
        const FixedDBWideString<127>& Name( ) const
        {
            return name_;
        }
        void SetName( const WideString& name )
        {
            name_ = name;
        }
        void BindColumns( const ODBC::Statement& statement )
        {
            Bind(statement, ID_FIELD_ID, id_);
            Bind(statement, ROWVERSION_FIELD_ID, rowVersion_);
            Bind(statement, NAME_FIELD_ID, name_);
        }

        template<IO::StreamWriter StreamT>
        void WriteColumns( IO::BinaryWriter<StreamT>& destination ) const
        {
            WriteColumnValue( destination, id_);
            WriteColumnValue( destination, rowVersion_);
            WriteColumnValue( destination, name_);
        }
    };

    using SimpleFacilityTypeDataReader = SimpleColumnDataReader<FacilityTypeColumnData>;

    class GeoPosition2DTimeseriesValueColumnData : public BaseColumnData
    {
        Guid id_;
        Int64 rowVersion_ = 0;
        Guid timeseries_;
        DateTime timestamp_;
        DBDouble latitude_;
        DBDouble longitude_;
    public:
        using Base = BaseColumnData;

        static constexpr std::wstring_view FieldNames = L"[Id],[RowVersion],[Timeseries],[Timestamp],[Latitude],[Longitude]";
        static constexpr std::wstring_view ViewName = L"GeoPosition2DTimeseriesValueView";

        static constexpr SQLUSMALLINT ID_FIELD_ID = 1;
        static constexpr SQLUSMALLINT ROWVERSION_FIELD_ID = 2;
        static constexpr SQLUSMALLINT TIMESERIES_FIELD_ID = 3;
        static constexpr SQLUSMALLINT TIMESTAMP_FIELD_ID = 4;
        static constexpr SQLUSMALLINT LATITUDE_FIELD_ID = 5;
        static constexpr SQLUSMALLINT LONGITUDE_FIELD_ID = 6;

        GeoPosition2DTimeseriesValueColumnData( ) = default;

        virtual Kind GetKind() const override
        {
            return Kind::GeoPosition2DTimeseriesValue;
        }

        const Guid& Id( ) const
        {
            return id_;
        }
        void SetId( const Guid& id )
        {
            id_ = id;
        }
        Int64 RowVersion( ) const
        {
            return rowVersion_;
        }
        void SetRowVersion( const Int64& rowVersion )
        {
            rowVersion_ = rowVersion;
        }
        const Guid& Timeseries( ) const
        {
            return timeseries_;
        }
        void SetTimeseries( const Guid& timeseries )
        {
            timeseries_ = timeseries;
        }
        const DateTime& Timestamp( ) const
        {
            return timestamp_;
        }
        void SetTimestamp( const DateTime& timestamp )
        {
            timestamp_ = timestamp;
        }
        const DBDouble& Latitude( ) const
        {
            return latitude_;
        }
        void SetLatitude( const DBDouble& latitude )
        {
            latitude_ = latitude;
        }
        const DBDouble& Longitude( ) const
        {
            return longitude_;
        }
        void SetLongitude( const DBDouble& longitude )
        {
            longitude_ = longitude;
        }
        void BindColumns( const ODBC::Statement& statement )
        {
            Bind(statement, ID_FIELD_ID, id_);
            Bind(statement, ROWVERSION_FIELD_ID, rowVersion_);
            Bind(statement, TIMESERIES_FIELD_ID, timeseries_);
            Bind(statement, TIMESTAMP_FIELD_ID, timestamp_);
            Bind(statement, LATITUDE_FIELD_ID, latitude_);
            Bind(statement, LONGITUDE_FIELD_ID, longitude_);
        }

        template<IO::StreamWriter StreamT>
        void WriteColumns( IO::BinaryWriter<StreamT>& destination ) const
        {
            WriteColumnValue( destination, id_);
            WriteColumnValue( destination, rowVersion_);
            WriteColumnValue( destination, timeseries_);
            WriteColumnValue( destination, timestamp_);
            WriteColumnValue( destination, latitude_);
            WriteColumnValue( destination, longitude_);
        }
    };

    using SimpleGeoPosition2DTimeseriesValueDataReader = SimpleColumnDataReader<GeoPosition2DTimeseriesValueColumnData>;

    class GeoPosition3DTimeseriesValueColumnData : public BaseColumnData
    {
        Guid id_;
        Int64 rowVersion_ = 0;
        Guid timeseries_;
        DateTime timestamp_;
        DBDouble latitude_;
        DBDouble longitude_;
        DBDouble altitude_;
    public:
        using Base = BaseColumnData;

        static constexpr std::wstring_view FieldNames = L"[Id],[RowVersion],[Timeseries],[Timestamp],[Latitude],[Longitude],[Altitude]";
        static constexpr std::wstring_view ViewName = L"GeoPosition3DTimeseriesValueView";

        static constexpr SQLUSMALLINT ID_FIELD_ID = 1;
        static constexpr SQLUSMALLINT ROWVERSION_FIELD_ID = 2;
        static constexpr SQLUSMALLINT TIMESERIES_FIELD_ID = 3;
        static constexpr SQLUSMALLINT TIMESTAMP_FIELD_ID = 4;
        static constexpr SQLUSMALLINT LATITUDE_FIELD_ID = 5;
        static constexpr SQLUSMALLINT LONGITUDE_FIELD_ID = 6;
        static constexpr SQLUSMALLINT ALTITUDE_FIELD_ID = 7;

        GeoPosition3DTimeseriesValueColumnData( ) = default;

        virtual Kind GetKind() const override
        {
            return Kind::GeoPosition3DTimeseriesValue;
        }

        const Guid& Id( ) const
        {
            return id_;
        }
        void SetId( const Guid& id )
        {
            id_ = id;
        }
        Int64 RowVersion( ) const
        {
            return rowVersion_;
        }
        void SetRowVersion( const Int64& rowVersion )
        {
            rowVersion_ = rowVersion;
        }
        const Guid& Timeseries( ) const
        {
            return timeseries_;
        }
        void SetTimeseries( const Guid& timeseries )
        {
            timeseries_ = timeseries;
        }
        const DateTime& Timestamp( ) const
        {
            return timestamp_;
        }
        void SetTimestamp( const DateTime& timestamp )
        {
            timestamp_ = timestamp;
        }
        const DBDouble& Latitude( ) const
        {
            return latitude_;
        }
        void SetLatitude( const DBDouble& latitude )
        {
            latitude_ = latitude;
        }
        const DBDouble& Longitude( ) const
        {
            return longitude_;
        }
        void SetLongitude( const DBDouble& longitude )
        {
            longitude_ = longitude;
        }
        const DBDouble& Altitude( ) const
        {
            return altitude_;
        }
        void SetAltitude( const DBDouble& altitude )
        {
            altitude_ = altitude;
        }
        void BindColumns( const ODBC::Statement& statement )
        {
            Bind(statement, ID_FIELD_ID, id_);
            Bind(statement, ROWVERSION_FIELD_ID, rowVersion_);
            Bind(statement, TIMESERIES_FIELD_ID, timeseries_);
            Bind(statement, TIMESTAMP_FIELD_ID, timestamp_);
            Bind(statement, LATITUDE_FIELD_ID, latitude_);
            Bind(statement, LONGITUDE_FIELD_ID, longitude_);
            Bind(statement, ALTITUDE_FIELD_ID, altitude_);
        }

        template<IO::StreamWriter StreamT>
        void WriteColumns( IO::BinaryWriter<StreamT>& destination ) const
        {
            WriteColumnValue( destination, id_);
            WriteColumnValue( destination, rowVersion_);
            WriteColumnValue( destination, timeseries_);
            WriteColumnValue( destination, timestamp_);
            WriteColumnValue( destination, latitude_);
            WriteColumnValue( destination, longitude_);
            WriteColumnValue( destination, altitude_);
        }
    };

    using SimpleGeoPosition3DTimeseriesValueDataReader = SimpleColumnDataReader<GeoPosition3DTimeseriesValueColumnData>;

    class GNSSDeviceCommandColumnData : public BaseColumnData
    {
        Guid id_;
        Int64 rowVersion_ = 0;
        Guid gNSSDevice_;
        DateTime timestamp_;
        Data::DeviceCommandSourceType deviceCommandSourceType_ = Data::DeviceCommandSourceType::Unknown;
        Guid deviceCommandSourceId_;
        Guid reply_;
    public:
        using Base = BaseColumnData;

        static constexpr std::wstring_view FieldNames = L"[Id],[RowVersion],[GNSSDevice],[Timestamp],[DeviceCommandSourceType],[DeviceCommandSourceId],[Reply]";
        static constexpr std::wstring_view ViewName = L"GNSSDeviceCommandView";

        static constexpr SQLUSMALLINT ID_FIELD_ID = 1;
        static constexpr SQLUSMALLINT ROWVERSION_FIELD_ID = 2;
        static constexpr SQLUSMALLINT GNSSDEVICE_FIELD_ID = 3;
        static constexpr SQLUSMALLINT TIMESTAMP_FIELD_ID = 4;
        static constexpr SQLUSMALLINT DEVICECOMMANDSOURCETYPE_FIELD_ID = 5;
        static constexpr SQLUSMALLINT DEVICECOMMANDSOURCEID_FIELD_ID = 6;
        static constexpr SQLUSMALLINT REPLY_FIELD_ID = 7;

        GNSSDeviceCommandColumnData( ) = default;

        virtual Kind GetKind() const override
        {
            return Kind::GNSSDeviceCommand;
        }

        const Guid& Id( ) const
        {
            return id_;
        }
        void SetId( const Guid& id )
        {
            id_ = id;
        }
        Int64 RowVersion( ) const
        {
            return rowVersion_;
        }
        void SetRowVersion( const Int64& rowVersion )
        {
            rowVersion_ = rowVersion;
        }
        const Guid& GNSSDevice( ) const
        {
            return gNSSDevice_;
        }
        void SetGNSSDevice( const Guid& gNSSDevice )
        {
            gNSSDevice_ = gNSSDevice;
        }
        const DateTime& Timestamp( ) const
        {
            return timestamp_;
        }
        void SetTimestamp( const DateTime& timestamp )
        {
            timestamp_ = timestamp;
        }
        Data::DeviceCommandSourceType DeviceCommandSourceType( ) const
        {
            return deviceCommandSourceType_;
        }
        void SetDeviceCommandSourceType( Data::DeviceCommandSourceType deviceCommandSourceType )
        {
            deviceCommandSourceType_ = deviceCommandSourceType;
        }
        const Guid& DeviceCommandSourceId( ) const
        {
            return deviceCommandSourceId_;
        }
        void SetDeviceCommandSourceId( const Guid& deviceCommandSourceId )
        {
            deviceCommandSourceId_ = deviceCommandSourceId;
        }
        const Guid& Reply( ) const
        {
            return reply_;
        }
        void SetReply( const Guid& reply )
        {
            reply_ = reply;
        }
        void BindColumns( const ODBC::Statement& statement )
        {
            Bind(statement, ID_FIELD_ID, id_);
            Bind(statement, ROWVERSION_FIELD_ID, rowVersion_);
            Bind(statement, GNSSDEVICE_FIELD_ID, gNSSDevice_);
            Bind(statement, TIMESTAMP_FIELD_ID, timestamp_);
            Bind(statement, DEVICECOMMANDSOURCETYPE_FIELD_ID, deviceCommandSourceType_);
            Bind(statement, DEVICECOMMANDSOURCEID_FIELD_ID, deviceCommandSourceId_);
            Bind(statement, REPLY_FIELD_ID, reply_);
        }

        template<IO::StreamWriter StreamT>
        void WriteColumns( IO::BinaryWriter<StreamT>& destination ) const
        {
            WriteColumnValue( destination, id_);
            WriteColumnValue( destination, rowVersion_);
            WriteColumnValue( destination, gNSSDevice_);
            WriteColumnValue( destination, timestamp_);
            WriteColumnValue( destination, deviceCommandSourceType_);
            WriteColumnValue( destination, deviceCommandSourceId_);
            WriteColumnValue( destination, reply_);
        }
    };

    using SimpleGNSSDeviceCommandDataReader = SimpleColumnDataReader<GNSSDeviceCommandColumnData>;

    class GNSSDeviceCommandReplyColumnData : public BaseColumnData
    {
        Guid id_;
        Int64 rowVersion_ = 0;
        Guid gNSSDevice_;
        DateTime timestamp_;
        Guid command_;
        Data::DeviceCommandReplyStatus status_ = Data::DeviceCommandReplyStatus::Unknown;
        WideString message_;
        SQLLEN messageLength_ = SQL_NULL_DATA;
    public:
        using Base = BaseColumnData;

        static constexpr std::wstring_view FieldNames = L"[Id],[RowVersion],[GNSSDevice],[Timestamp],[Command],[Status],[Message]";
        static constexpr std::wstring_view ViewName = L"GNSSDeviceCommandReplyView";

        static constexpr SQLUSMALLINT ID_FIELD_ID = 1;
        static constexpr SQLUSMALLINT ROWVERSION_FIELD_ID = 2;
        static constexpr SQLUSMALLINT GNSSDEVICE_FIELD_ID = 3;
        static constexpr SQLUSMALLINT TIMESTAMP_FIELD_ID = 4;
        static constexpr SQLUSMALLINT COMMAND_FIELD_ID = 5;
        static constexpr SQLUSMALLINT STATUS_FIELD_ID = 6;
        static constexpr SQLUSMALLINT MESSAGE_FIELD_ID = 7;

        GNSSDeviceCommandReplyColumnData( ) = default;

        virtual Kind GetKind() const override
        {
            return Kind::GNSSDeviceCommandReply;
        }

        const Guid& Id( ) const
        {
            return id_;
        }
        void SetId( const Guid& id )
        {
            id_ = id;
        }
        Int64 RowVersion( ) const
        {
            return rowVersion_;
        }
        void SetRowVersion( const Int64& rowVersion )
        {
            rowVersion_ = rowVersion;
        }
        const Guid& GNSSDevice( ) const
        {
            return gNSSDevice_;
        }
        void SetGNSSDevice( const Guid& gNSSDevice )
        {
            gNSSDevice_ = gNSSDevice;
        }
        const DateTime& Timestamp( ) const
        {
            return timestamp_;
        }
        void SetTimestamp( const DateTime& timestamp )
        {
            timestamp_ = timestamp;
        }
        const Guid& Command( ) const
        {
            return command_;
        }
        void SetCommand( const Guid& command )
        {
            command_ = command;
        }
        Data::DeviceCommandReplyStatus Status( ) const
        {
            return status_;
        }
        void SetStatus( Data::DeviceCommandReplyStatus status )
        {
            status_ = status;
        }
        const WideString& Message( ) const
        {
            return message_;
        }
        void SetMessage( const WideString& message )
        {
            message_ = message;
        }
        void BindColumns( const ODBC::Statement& statement )
        {
            Bind(statement, ID_FIELD_ID, id_);
            Bind(statement, ROWVERSION_FIELD_ID, rowVersion_);
            Bind(statement, GNSSDEVICE_FIELD_ID, gNSSDevice_);
            Bind(statement, TIMESTAMP_FIELD_ID, timestamp_);
            Bind(statement, COMMAND_FIELD_ID, command_);
            Bind(statement, STATUS_FIELD_ID, status_);
        }

        void ReadUnboundData( const ODBC::Statement& statement )
        {
            Base::ReadUnboundData( statement );

            message_ = statement.GetWideString(MESSAGE_FIELD_ID);
        }
        template<IO::StreamWriter StreamT>
        void WriteColumns( IO::BinaryWriter<StreamT>& destination ) const
        {
            WriteColumnValue( destination, id_);
            WriteColumnValue( destination, rowVersion_);
            WriteColumnValue( destination, gNSSDevice_);
            WriteColumnValue( destination, timestamp_);
            WriteColumnValue( destination, command_);
            WriteColumnValue( destination, status_);
            WriteColumnValue( destination, message_);
        }
    };

    using SimpleGNSSDeviceCommandReplyDataReader = SimpleColumnDataReader<GNSSDeviceCommandReplyColumnData>;

    class GNSSDeviceConfigurationColumnData : public BaseColumnData
    {
        Guid id_;
        Int64 rowVersion_ = 0;
        Guid gNSSDevice_;
        DateTime timestamp_;
        double defaultLatitude_ = 0.0;
        double defaultLongitude_ = 0.0;
        double defaultAltitude_ = 0.0;
        double latitudeOffset_ = 0.0;
        double longitudeOffset_ = 0.0;
        double altitudeOffset_ = 0.0;
    public:
        using Base = BaseColumnData;

        static constexpr std::wstring_view FieldNames = L"[Id],[RowVersion],[GNSSDevice],[Timestamp],[DefaultLatitude],[DefaultLongitude],[DefaultAltitude],[LatitudeOffset],[LongitudeOffset],[AltitudeOffset]";
        static constexpr std::wstring_view ViewName = L"GNSSDeviceConfigurationView";

        static constexpr SQLUSMALLINT ID_FIELD_ID = 1;
        static constexpr SQLUSMALLINT ROWVERSION_FIELD_ID = 2;
        static constexpr SQLUSMALLINT GNSSDEVICE_FIELD_ID = 3;
        static constexpr SQLUSMALLINT TIMESTAMP_FIELD_ID = 4;
        static constexpr SQLUSMALLINT DEFAULTLATITUDE_FIELD_ID = 5;
        static constexpr SQLUSMALLINT DEFAULTLONGITUDE_FIELD_ID = 6;
        static constexpr SQLUSMALLINT DEFAULTALTITUDE_FIELD_ID = 7;
        static constexpr SQLUSMALLINT LATITUDEOFFSET_FIELD_ID = 8;
        static constexpr SQLUSMALLINT LONGITUDEOFFSET_FIELD_ID = 9;
        static constexpr SQLUSMALLINT ALTITUDEOFFSET_FIELD_ID = 10;

        GNSSDeviceConfigurationColumnData( ) = default;

        virtual Kind GetKind() const override
        {
            return Kind::GNSSDeviceConfiguration;
        }

        const Guid& Id( ) const
        {
            return id_;
        }
        void SetId( const Guid& id )
        {
            id_ = id;
        }
        Int64 RowVersion( ) const
        {
            return rowVersion_;
        }
        void SetRowVersion( const Int64& rowVersion )
        {
            rowVersion_ = rowVersion;
        }
        const Guid& GNSSDevice( ) const
        {
            return gNSSDevice_;
        }
        void SetGNSSDevice( const Guid& gNSSDevice )
        {
            gNSSDevice_ = gNSSDevice;
        }
        const DateTime& Timestamp( ) const
        {
            return timestamp_;
        }
        void SetTimestamp( const DateTime& timestamp )
        {
            timestamp_ = timestamp;
        }
        double DefaultLatitude( ) const
        {
            return defaultLatitude_;
        }
        void SetDefaultLatitude( double defaultLatitude )
        {
            defaultLatitude_ = defaultLatitude;
        }
        double DefaultLongitude( ) const
        {
            return defaultLongitude_;
        }
        void SetDefaultLongitude( double defaultLongitude )
        {
            defaultLongitude_ = defaultLongitude;
        }
        double DefaultAltitude( ) const
        {
            return defaultAltitude_;
        }
        void SetDefaultAltitude( double defaultAltitude )
        {
            defaultAltitude_ = defaultAltitude;
        }
        double LatitudeOffset( ) const
        {
            return latitudeOffset_;
        }
        void SetLatitudeOffset( double latitudeOffset )
        {
            latitudeOffset_ = latitudeOffset;
        }
        double LongitudeOffset( ) const
        {
            return longitudeOffset_;
        }
        void SetLongitudeOffset( double longitudeOffset )
        {
            longitudeOffset_ = longitudeOffset;
        }
        double AltitudeOffset( ) const
        {
            return altitudeOffset_;
        }
        void SetAltitudeOffset( double altitudeOffset )
        {
            altitudeOffset_ = altitudeOffset;
        }
        void BindColumns( const ODBC::Statement& statement )
        {
            Bind(statement, ID_FIELD_ID, id_);
            Bind(statement, ROWVERSION_FIELD_ID, rowVersion_);
            Bind(statement, GNSSDEVICE_FIELD_ID, gNSSDevice_);
            Bind(statement, TIMESTAMP_FIELD_ID, timestamp_);
            Bind(statement, DEFAULTLATITUDE_FIELD_ID, defaultLatitude_);
            Bind(statement, DEFAULTLONGITUDE_FIELD_ID, defaultLongitude_);
            Bind(statement, DEFAULTALTITUDE_FIELD_ID, defaultAltitude_);
            Bind(statement, LATITUDEOFFSET_FIELD_ID, latitudeOffset_);
            Bind(statement, LONGITUDEOFFSET_FIELD_ID, longitudeOffset_);
            Bind(statement, ALTITUDEOFFSET_FIELD_ID, altitudeOffset_);
        }

        template<IO::StreamWriter StreamT>
        void WriteColumns( IO::BinaryWriter<StreamT>& destination ) const
        {
            WriteColumnValue( destination, id_);
            WriteColumnValue( destination, rowVersion_);
            WriteColumnValue( destination, gNSSDevice_);
            WriteColumnValue( destination, timestamp_);
            WriteColumnValue( destination, defaultLatitude_);
            WriteColumnValue( destination, defaultLongitude_);
            WriteColumnValue( destination, defaultAltitude_);
            WriteColumnValue( destination, latitudeOffset_);
            WriteColumnValue( destination, longitudeOffset_);
            WriteColumnValue( destination, altitudeOffset_);
        }
    };

    using SimpleGNSSDeviceConfigurationDataReader = SimpleColumnDataReader<GNSSDeviceConfigurationColumnData>;

    class GuidTimeseriesValueColumnData : public BaseColumnData
    {
        Guid id_;
        Int64 rowVersion_ = 0;
        Guid timeseries_;
        DateTime timestamp_;
        DBGuid value_;
    public:
        using Base = BaseColumnData;

        static constexpr std::wstring_view FieldNames = L"[Id],[RowVersion],[Timeseries],[Timestamp],[Value]";
        static constexpr std::wstring_view ViewName = L"GuidTimeseriesValueView";

        static constexpr SQLUSMALLINT ID_FIELD_ID = 1;
        static constexpr SQLUSMALLINT ROWVERSION_FIELD_ID = 2;
        static constexpr SQLUSMALLINT TIMESERIES_FIELD_ID = 3;
        static constexpr SQLUSMALLINT TIMESTAMP_FIELD_ID = 4;
        static constexpr SQLUSMALLINT VALUE_FIELD_ID = 5;

        GuidTimeseriesValueColumnData( ) = default;

        virtual Kind GetKind() const override
        {
            return Kind::GuidTimeseriesValue;
        }

        const Guid& Id( ) const
        {
            return id_;
        }
        void SetId( const Guid& id )
        {
            id_ = id;
        }
        Int64 RowVersion( ) const
        {
            return rowVersion_;
        }
        void SetRowVersion( const Int64& rowVersion )
        {
            rowVersion_ = rowVersion;
        }
        const Guid& Timeseries( ) const
        {
            return timeseries_;
        }
        void SetTimeseries( const Guid& timeseries )
        {
            timeseries_ = timeseries;
        }
        const DateTime& Timestamp( ) const
        {
            return timestamp_;
        }
        void SetTimestamp( const DateTime& timestamp )
        {
            timestamp_ = timestamp;
        }
        const DBGuid& Value( ) const
        {
            return value_;
        }
        void SetValue( const DBGuid& value )
        {
            value_ = value;
        }
        void BindColumns( const ODBC::Statement& statement )
        {
            Bind(statement, ID_FIELD_ID, id_);
            Bind(statement, ROWVERSION_FIELD_ID, rowVersion_);
            Bind(statement, TIMESERIES_FIELD_ID, timeseries_);
            Bind(statement, TIMESTAMP_FIELD_ID, timestamp_);
            Bind(statement, VALUE_FIELD_ID, value_);
        }

        template<IO::StreamWriter StreamT>
        void WriteColumns( IO::BinaryWriter<StreamT>& destination ) const
        {
            WriteColumnValue( destination, id_);
            WriteColumnValue( destination, rowVersion_);
            WriteColumnValue( destination, timeseries_);
            WriteColumnValue( destination, timestamp_);
            WriteColumnValue( destination, value_);
        }
    };

    using SimpleGuidTimeseriesValueDataReader = SimpleColumnDataReader<GuidTimeseriesValueColumnData>;

    class GyroDeviceCommandColumnData : public BaseColumnData
    {
        Guid id_;
        Int64 rowVersion_ = 0;
        Guid gyroDevice_;
        DateTime timestamp_;
        Data::DeviceCommandSourceType deviceCommandSourceType_ = Data::DeviceCommandSourceType::Unknown;
        Guid deviceCommandSourceId_;
        Guid reply_;
    public:
        using Base = BaseColumnData;

        static constexpr std::wstring_view FieldNames = L"[Id],[RowVersion],[GyroDevice],[Timestamp],[DeviceCommandSourceType],[DeviceCommandSourceId],[Reply]";
        static constexpr std::wstring_view ViewName = L"GyroDeviceCommandView";

        static constexpr SQLUSMALLINT ID_FIELD_ID = 1;
        static constexpr SQLUSMALLINT ROWVERSION_FIELD_ID = 2;
        static constexpr SQLUSMALLINT GYRODEVICE_FIELD_ID = 3;
        static constexpr SQLUSMALLINT TIMESTAMP_FIELD_ID = 4;
        static constexpr SQLUSMALLINT DEVICECOMMANDSOURCETYPE_FIELD_ID = 5;
        static constexpr SQLUSMALLINT DEVICECOMMANDSOURCEID_FIELD_ID = 6;
        static constexpr SQLUSMALLINT REPLY_FIELD_ID = 7;

        GyroDeviceCommandColumnData( ) = default;

        virtual Kind GetKind() const override
        {
            return Kind::GyroDeviceCommand;
        }

        const Guid& Id( ) const
        {
            return id_;
        }
        void SetId( const Guid& id )
        {
            id_ = id;
        }
        Int64 RowVersion( ) const
        {
            return rowVersion_;
        }
        void SetRowVersion( const Int64& rowVersion )
        {
            rowVersion_ = rowVersion;
        }
        const Guid& GyroDevice( ) const
        {
            return gyroDevice_;
        }
        void SetGyroDevice( const Guid& gyroDevice )
        {
            gyroDevice_ = gyroDevice;
        }
        const DateTime& Timestamp( ) const
        {
            return timestamp_;
        }
        void SetTimestamp( const DateTime& timestamp )
        {
            timestamp_ = timestamp;
        }
        Data::DeviceCommandSourceType DeviceCommandSourceType( ) const
        {
            return deviceCommandSourceType_;
        }
        void SetDeviceCommandSourceType( Data::DeviceCommandSourceType deviceCommandSourceType )
        {
            deviceCommandSourceType_ = deviceCommandSourceType;
        }
        const Guid& DeviceCommandSourceId( ) const
        {
            return deviceCommandSourceId_;
        }
        void SetDeviceCommandSourceId( const Guid& deviceCommandSourceId )
        {
            deviceCommandSourceId_ = deviceCommandSourceId;
        }
        const Guid& Reply( ) const
        {
            return reply_;
        }
        void SetReply( const Guid& reply )
        {
            reply_ = reply;
        }
        void BindColumns( const ODBC::Statement& statement )
        {
            Bind(statement, ID_FIELD_ID, id_);
            Bind(statement, ROWVERSION_FIELD_ID, rowVersion_);
            Bind(statement, GYRODEVICE_FIELD_ID, gyroDevice_);
            Bind(statement, TIMESTAMP_FIELD_ID, timestamp_);
            Bind(statement, DEVICECOMMANDSOURCETYPE_FIELD_ID, deviceCommandSourceType_);
            Bind(statement, DEVICECOMMANDSOURCEID_FIELD_ID, deviceCommandSourceId_);
            Bind(statement, REPLY_FIELD_ID, reply_);
        }

        template<IO::StreamWriter StreamT>
        void WriteColumns( IO::BinaryWriter<StreamT>& destination ) const
        {
            WriteColumnValue( destination, id_);
            WriteColumnValue( destination, rowVersion_);
            WriteColumnValue( destination, gyroDevice_);
            WriteColumnValue( destination, timestamp_);
            WriteColumnValue( destination, deviceCommandSourceType_);
            WriteColumnValue( destination, deviceCommandSourceId_);
            WriteColumnValue( destination, reply_);
        }
    };

    using SimpleGyroDeviceCommandDataReader = SimpleColumnDataReader<GyroDeviceCommandColumnData>;

    class GyroDeviceCommandReplyColumnData : public BaseColumnData
    {
        Guid id_;
        Int64 rowVersion_ = 0;
        Guid gyroDevice_;
        DateTime timestamp_;
        Guid command_;
        Data::DeviceCommandReplyStatus status_ = Data::DeviceCommandReplyStatus::Unknown;
        WideString message_;
        SQLLEN messageLength_ = SQL_NULL_DATA;
    public:
        using Base = BaseColumnData;

        static constexpr std::wstring_view FieldNames = L"[Id],[RowVersion],[GyroDevice],[Timestamp],[Command],[Status],[Message]";
        static constexpr std::wstring_view ViewName = L"GyroDeviceCommandReplyView";

        static constexpr SQLUSMALLINT ID_FIELD_ID = 1;
        static constexpr SQLUSMALLINT ROWVERSION_FIELD_ID = 2;
        static constexpr SQLUSMALLINT GYRODEVICE_FIELD_ID = 3;
        static constexpr SQLUSMALLINT TIMESTAMP_FIELD_ID = 4;
        static constexpr SQLUSMALLINT COMMAND_FIELD_ID = 5;
        static constexpr SQLUSMALLINT STATUS_FIELD_ID = 6;
        static constexpr SQLUSMALLINT MESSAGE_FIELD_ID = 7;

        GyroDeviceCommandReplyColumnData( ) = default;

        virtual Kind GetKind() const override
        {
            return Kind::GyroDeviceCommandReply;
        }

        const Guid& Id( ) const
        {
            return id_;
        }
        void SetId( const Guid& id )
        {
            id_ = id;
        }
        Int64 RowVersion( ) const
        {
            return rowVersion_;
        }
        void SetRowVersion( const Int64& rowVersion )
        {
            rowVersion_ = rowVersion;
        }
        const Guid& GyroDevice( ) const
        {
            return gyroDevice_;
        }
        void SetGyroDevice( const Guid& gyroDevice )
        {
            gyroDevice_ = gyroDevice;
        }
        const DateTime& Timestamp( ) const
        {
            return timestamp_;
        }
        void SetTimestamp( const DateTime& timestamp )
        {
            timestamp_ = timestamp;
        }
        const Guid& Command( ) const
        {
            return command_;
        }
        void SetCommand( const Guid& command )
        {
            command_ = command;
        }
        Data::DeviceCommandReplyStatus Status( ) const
        {
            return status_;
        }
        void SetStatus( Data::DeviceCommandReplyStatus status )
        {
            status_ = status;
        }
        const WideString& Message( ) const
        {
            return message_;
        }
        void SetMessage( const WideString& message )
        {
            message_ = message;
        }
        void BindColumns( const ODBC::Statement& statement )
        {
            Bind(statement, ID_FIELD_ID, id_);
            Bind(statement, ROWVERSION_FIELD_ID, rowVersion_);
            Bind(statement, GYRODEVICE_FIELD_ID, gyroDevice_);
            Bind(statement, TIMESTAMP_FIELD_ID, timestamp_);
            Bind(statement, COMMAND_FIELD_ID, command_);
            Bind(statement, STATUS_FIELD_ID, status_);
        }

        void ReadUnboundData( const ODBC::Statement& statement )
        {
            Base::ReadUnboundData( statement );

            message_ = statement.GetWideString(MESSAGE_FIELD_ID);
        }
        template<IO::StreamWriter StreamT>
        void WriteColumns( IO::BinaryWriter<StreamT>& destination ) const
        {
            WriteColumnValue( destination, id_);
            WriteColumnValue( destination, rowVersion_);
            WriteColumnValue( destination, gyroDevice_);
            WriteColumnValue( destination, timestamp_);
            WriteColumnValue( destination, command_);
            WriteColumnValue( destination, status_);
            WriteColumnValue( destination, message_);
        }
    };

    using SimpleGyroDeviceCommandReplyDataReader = SimpleColumnDataReader<GyroDeviceCommandReplyColumnData>;

    class GyroDeviceConfigurationColumnData : public BaseColumnData
    {
        Guid id_;
        Int64 rowVersion_ = 0;
        Guid gyroDevice_;
        DateTime timestamp_;
        double defaultHeadingTrueNorth_ = 0.0;
        double defaultMagneticTrueNorth_ = 0.0;
        double headingTrueNorthOffset_ = 0.0;
        double headingMagneticNorthOffset_ = 0.0;
        FixedDBWideString<64> pitchTransducerName_;
        FixedDBWideString<64> rollTransducerName_;
    public:
        using Base = BaseColumnData;

        static constexpr std::wstring_view FieldNames = L"[Id],[RowVersion],[GyroDevice],[Timestamp],[DefaultHeadingTrueNorth],[DefaultMagneticTrueNorth],[HeadingTrueNorthOffset],[HeadingMagneticNorthOffset],[PitchTransducerName],[RollTransducerName]";
        static constexpr std::wstring_view ViewName = L"GyroDeviceConfigurationView";

        static constexpr SQLUSMALLINT ID_FIELD_ID = 1;
        static constexpr SQLUSMALLINT ROWVERSION_FIELD_ID = 2;
        static constexpr SQLUSMALLINT GYRODEVICE_FIELD_ID = 3;
        static constexpr SQLUSMALLINT TIMESTAMP_FIELD_ID = 4;
        static constexpr SQLUSMALLINT DEFAULTHEADINGTRUENORTH_FIELD_ID = 5;
        static constexpr SQLUSMALLINT DEFAULTMAGNETICTRUENORTH_FIELD_ID = 6;
        static constexpr SQLUSMALLINT HEADINGTRUENORTHOFFSET_FIELD_ID = 7;
        static constexpr SQLUSMALLINT HEADINGMAGNETICNORTHOFFSET_FIELD_ID = 8;
        static constexpr SQLUSMALLINT PITCHTRANSDUCERNAME_FIELD_ID = 9;
        static constexpr SQLUSMALLINT ROLLTRANSDUCERNAME_FIELD_ID = 10;

        GyroDeviceConfigurationColumnData( ) = default;

        virtual Kind GetKind() const override
        {
            return Kind::GyroDeviceConfiguration;
        }

        const Guid& Id( ) const
        {
            return id_;
        }
        void SetId( const Guid& id )
        {
            id_ = id;
        }
        Int64 RowVersion( ) const
        {
            return rowVersion_;
        }
        void SetRowVersion( const Int64& rowVersion )
        {
            rowVersion_ = rowVersion;
        }
        const Guid& GyroDevice( ) const
        {
            return gyroDevice_;
        }
        void SetGyroDevice( const Guid& gyroDevice )
        {
            gyroDevice_ = gyroDevice;
        }
        const DateTime& Timestamp( ) const
        {
            return timestamp_;
        }
        void SetTimestamp( const DateTime& timestamp )
        {
            timestamp_ = timestamp;
        }
        double DefaultHeadingTrueNorth( ) const
        {
            return defaultHeadingTrueNorth_;
        }
        void SetDefaultHeadingTrueNorth( double defaultHeadingTrueNorth )
        {
            defaultHeadingTrueNorth_ = defaultHeadingTrueNorth;
        }
        double DefaultMagneticTrueNorth( ) const
        {
            return defaultMagneticTrueNorth_;
        }
        void SetDefaultMagneticTrueNorth( double defaultMagneticTrueNorth )
        {
            defaultMagneticTrueNorth_ = defaultMagneticTrueNorth;
        }
        double HeadingTrueNorthOffset( ) const
        {
            return headingTrueNorthOffset_;
        }
        void SetHeadingTrueNorthOffset( double headingTrueNorthOffset )
        {
            headingTrueNorthOffset_ = headingTrueNorthOffset;
        }
        double HeadingMagneticNorthOffset( ) const
        {
            return headingMagneticNorthOffset_;
        }
        void SetHeadingMagneticNorthOffset( double headingMagneticNorthOffset )
        {
            headingMagneticNorthOffset_ = headingMagneticNorthOffset;
        }
        const FixedDBWideString<64>& PitchTransducerName( ) const
        {
            return pitchTransducerName_;
        }
        void SetPitchTransducerName( const WideString& pitchTransducerName )
        {
            pitchTransducerName_ = pitchTransducerName;
        }
        const FixedDBWideString<64>& RollTransducerName( ) const
        {
            return rollTransducerName_;
        }
        void SetRollTransducerName( const WideString& rollTransducerName )
        {
            rollTransducerName_ = rollTransducerName;
        }
        void BindColumns( const ODBC::Statement& statement )
        {
            Bind(statement, ID_FIELD_ID, id_);
            Bind(statement, ROWVERSION_FIELD_ID, rowVersion_);
            Bind(statement, GYRODEVICE_FIELD_ID, gyroDevice_);
            Bind(statement, TIMESTAMP_FIELD_ID, timestamp_);
            Bind(statement, DEFAULTHEADINGTRUENORTH_FIELD_ID, defaultHeadingTrueNorth_);
            Bind(statement, DEFAULTMAGNETICTRUENORTH_FIELD_ID, defaultMagneticTrueNorth_);
            Bind(statement, HEADINGTRUENORTHOFFSET_FIELD_ID, headingTrueNorthOffset_);
            Bind(statement, HEADINGMAGNETICNORTHOFFSET_FIELD_ID, headingMagneticNorthOffset_);
            Bind(statement, PITCHTRANSDUCERNAME_FIELD_ID, pitchTransducerName_);
            Bind(statement, ROLLTRANSDUCERNAME_FIELD_ID, rollTransducerName_);
        }

        template<IO::StreamWriter StreamT>
        void WriteColumns( IO::BinaryWriter<StreamT>& destination ) const
        {
            WriteColumnValue( destination, id_);
            WriteColumnValue( destination, rowVersion_);
            WriteColumnValue( destination, gyroDevice_);
            WriteColumnValue( destination, timestamp_);
            WriteColumnValue( destination, defaultHeadingTrueNorth_);
            WriteColumnValue( destination, defaultMagneticTrueNorth_);
            WriteColumnValue( destination, headingTrueNorthOffset_);
            WriteColumnValue( destination, headingMagneticNorthOffset_);
            WriteColumnValue( destination, pitchTransducerName_);
            WriteColumnValue( destination, rollTransducerName_);
        }
    };

    using SimpleGyroDeviceConfigurationDataReader = SimpleColumnDataReader<GyroDeviceConfigurationColumnData>;

    class IdentityColumnData : public BaseColumnData
    {
        Guid id_;
        Int64 rowVersion_ = 0;
    public:
        using Base = BaseColumnData;

        static constexpr std::wstring_view FieldNames = L"[Id],[RowVersion]";
        static constexpr std::wstring_view ViewName = L"IdentityView";

        static constexpr SQLUSMALLINT ID_FIELD_ID = 1;
        static constexpr SQLUSMALLINT ROWVERSION_FIELD_ID = 2;

        IdentityColumnData( ) = default;

        virtual Kind GetKind() const override
        {
            return Kind::Identity;
        }

        const Guid& Id( ) const
        {
            return id_;
        }
        void SetId( const Guid& id )
        {
            id_ = id;
        }
        Int64 RowVersion( ) const
        {
            return rowVersion_;
        }
        void SetRowVersion( const Int64& rowVersion )
        {
            rowVersion_ = rowVersion;
        }
        void BindColumns( const ODBC::Statement& statement )
        {
            Bind(statement, ID_FIELD_ID, id_);
            Bind(statement, ROWVERSION_FIELD_ID, rowVersion_);
        }

        template<IO::StreamWriter StreamT>
        void WriteColumns( IO::BinaryWriter<StreamT>& destination ) const
        {
            WriteColumnValue( destination, id_);
            WriteColumnValue( destination, rowVersion_);
        }
    };

    using SimpleIdentityDataReader = SimpleColumnDataReader<IdentityColumnData>;

    class CallsignColumnData : public IdentityColumnData
    {
        FixedDBWideString<127> identifier_;
    public:
        using Base = IdentityColumnData;

        static constexpr std::wstring_view FieldNames = L"[Id],[RowVersion],[Identifier]";
        static constexpr std::wstring_view ViewName = L"CallsignView";

        static constexpr SQLUSMALLINT IDENTIFIER_FIELD_ID = 3;

        CallsignColumnData( ) = default;

        virtual Kind GetKind() const override
        {
            return Kind::Callsign;
        }

        const FixedDBWideString<127>& Identifier( ) const
        {
            return identifier_;
        }
        void SetIdentifier( const WideString& identifier )
        {
            identifier_ = identifier;
        }
        void BindColumns( const ODBC::Statement& statement )
        {
            Base::BindColumns( statement );

            Bind(statement, IDENTIFIER_FIELD_ID, identifier_);
        }

        template<IO::StreamWriter StreamT>
        void WriteColumns( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteColumns( destination );
            WriteColumnValue( destination, identifier_);
        }
    };

    using SimpleCallsignDataReader = SimpleColumnDataReader<CallsignColumnData>;

    class InternationalMaritimeOrganizationNumberColumnData : public IdentityColumnData
    {
        Int64 identifier_ = 0;
    public:
        using Base = IdentityColumnData;

        static constexpr std::wstring_view FieldNames = L"[Id],[RowVersion],[Identifier]";
        static constexpr std::wstring_view ViewName = L"InternationalMaritimeOrganizationNumberView";

        static constexpr SQLUSMALLINT IDENTIFIER_FIELD_ID = 3;

        InternationalMaritimeOrganizationNumberColumnData( ) = default;

        virtual Kind GetKind() const override
        {
            return Kind::InternationalMaritimeOrganizationNumber;
        }

        Int64 Identifier( ) const
        {
            return identifier_;
        }
        void SetIdentifier( Int64 identifier )
        {
            identifier_ = identifier;
        }
        void BindColumns( const ODBC::Statement& statement )
        {
            Base::BindColumns( statement );

            Bind(statement, IDENTIFIER_FIELD_ID, identifier_);
        }

        template<IO::StreamWriter StreamT>
        void WriteColumns( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteColumns( destination );
            WriteColumnValue( destination, identifier_);
        }
    };

    using SimpleInternationalMaritimeOrganizationNumberDataReader = SimpleColumnDataReader<InternationalMaritimeOrganizationNumberColumnData>;

    class MaritimeMobileServiceIdentityColumnData : public IdentityColumnData
    {
        Int64 identifier_ = 0;
    public:
        using Base = IdentityColumnData;

        static constexpr std::wstring_view FieldNames = L"[Id],[RowVersion],[Identifier]";
        static constexpr std::wstring_view ViewName = L"MaritimeMobileServiceIdentityView";

        static constexpr SQLUSMALLINT IDENTIFIER_FIELD_ID = 3;

        MaritimeMobileServiceIdentityColumnData( ) = default;

        virtual Kind GetKind() const override
        {
            return Kind::MaritimeMobileServiceIdentity;
        }

        Int64 Identifier( ) const
        {
            return identifier_;
        }
        void SetIdentifier( Int64 identifier )
        {
            identifier_ = identifier;
        }
        void BindColumns( const ODBC::Statement& statement )
        {
            Base::BindColumns( statement );

            Bind(statement, IDENTIFIER_FIELD_ID, identifier_);
        }

        template<IO::StreamWriter StreamT>
        void WriteColumns( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteColumns( destination );
            WriteColumnValue( destination, identifier_);
        }
    };

    using SimpleMaritimeMobileServiceIdentityDataReader = SimpleColumnDataReader<MaritimeMobileServiceIdentityColumnData>;

    class NameColumnData : public IdentityColumnData
    {
        FixedDBWideString<100> text_;
    public:
        using Base = IdentityColumnData;

        static constexpr std::wstring_view FieldNames = L"[Id],[RowVersion],[Text]";
        static constexpr std::wstring_view ViewName = L"NameView";

        static constexpr SQLUSMALLINT TEXT_FIELD_ID = 3;

        NameColumnData( ) = default;

        virtual Kind GetKind() const override
        {
            return Kind::Name;
        }

        const FixedDBWideString<100>& Text( ) const
        {
            return text_;
        }
        void SetText( const WideString& text )
        {
            text_ = text;
        }
        void BindColumns( const ODBC::Statement& statement )
        {
            Base::BindColumns( statement );

            Bind(statement, TEXT_FIELD_ID, text_);
        }

        template<IO::StreamWriter StreamT>
        void WriteColumns( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteColumns( destination );
            WriteColumnValue( destination, text_);
        }
    };

    using SimpleNameDataReader = SimpleColumnDataReader<NameColumnData>;

    class Int16TimeseriesValueColumnData : public BaseColumnData
    {
        Guid id_;
        Int64 rowVersion_ = 0;
        Guid timeseries_;
        DateTime timestamp_;
        DBInt16 value_;
    public:
        using Base = BaseColumnData;

        static constexpr std::wstring_view FieldNames = L"[Id],[RowVersion],[Timeseries],[Timestamp],[Value]";
        static constexpr std::wstring_view ViewName = L"Int16TimeseriesValueView";

        static constexpr SQLUSMALLINT ID_FIELD_ID = 1;
        static constexpr SQLUSMALLINT ROWVERSION_FIELD_ID = 2;
        static constexpr SQLUSMALLINT TIMESERIES_FIELD_ID = 3;
        static constexpr SQLUSMALLINT TIMESTAMP_FIELD_ID = 4;
        static constexpr SQLUSMALLINT VALUE_FIELD_ID = 5;

        Int16TimeseriesValueColumnData( ) = default;

        virtual Kind GetKind() const override
        {
            return Kind::Int16TimeseriesValue;
        }

        const Guid& Id( ) const
        {
            return id_;
        }
        void SetId( const Guid& id )
        {
            id_ = id;
        }
        Int64 RowVersion( ) const
        {
            return rowVersion_;
        }
        void SetRowVersion( const Int64& rowVersion )
        {
            rowVersion_ = rowVersion;
        }
        const Guid& Timeseries( ) const
        {
            return timeseries_;
        }
        void SetTimeseries( const Guid& timeseries )
        {
            timeseries_ = timeseries;
        }
        const DateTime& Timestamp( ) const
        {
            return timestamp_;
        }
        void SetTimestamp( const DateTime& timestamp )
        {
            timestamp_ = timestamp;
        }
        const DBInt16& Value( ) const
        {
            return value_;
        }
        void SetValue( const DBInt16& value )
        {
            value_ = value;
        }
        void BindColumns( const ODBC::Statement& statement )
        {
            Bind(statement, ID_FIELD_ID, id_);
            Bind(statement, ROWVERSION_FIELD_ID, rowVersion_);
            Bind(statement, TIMESERIES_FIELD_ID, timeseries_);
            Bind(statement, TIMESTAMP_FIELD_ID, timestamp_);
            Bind(statement, VALUE_FIELD_ID, value_);
        }

        template<IO::StreamWriter StreamT>
        void WriteColumns( IO::BinaryWriter<StreamT>& destination ) const
        {
            WriteColumnValue( destination, id_);
            WriteColumnValue( destination, rowVersion_);
            WriteColumnValue( destination, timeseries_);
            WriteColumnValue( destination, timestamp_);
            WriteColumnValue( destination, value_);
        }
    };

    using SimpleInt16TimeseriesValueDataReader = SimpleColumnDataReader<Int16TimeseriesValueColumnData>;

    class Int32TimeseriesValueColumnData : public BaseColumnData
    {
        Guid id_;
        Int64 rowVersion_ = 0;
        Guid timeseries_;
        DateTime timestamp_;
        DBInt32 value_;
    public:
        using Base = BaseColumnData;

        static constexpr std::wstring_view FieldNames = L"[Id],[RowVersion],[Timeseries],[Timestamp],[Value]";
        static constexpr std::wstring_view ViewName = L"Int32TimeseriesValueView";

        static constexpr SQLUSMALLINT ID_FIELD_ID = 1;
        static constexpr SQLUSMALLINT ROWVERSION_FIELD_ID = 2;
        static constexpr SQLUSMALLINT TIMESERIES_FIELD_ID = 3;
        static constexpr SQLUSMALLINT TIMESTAMP_FIELD_ID = 4;
        static constexpr SQLUSMALLINT VALUE_FIELD_ID = 5;

        Int32TimeseriesValueColumnData( ) = default;

        virtual Kind GetKind() const override
        {
            return Kind::Int32TimeseriesValue;
        }

        const Guid& Id( ) const
        {
            return id_;
        }
        void SetId( const Guid& id )
        {
            id_ = id;
        }
        Int64 RowVersion( ) const
        {
            return rowVersion_;
        }
        void SetRowVersion( const Int64& rowVersion )
        {
            rowVersion_ = rowVersion;
        }
        const Guid& Timeseries( ) const
        {
            return timeseries_;
        }
        void SetTimeseries( const Guid& timeseries )
        {
            timeseries_ = timeseries;
        }
        const DateTime& Timestamp( ) const
        {
            return timestamp_;
        }
        void SetTimestamp( const DateTime& timestamp )
        {
            timestamp_ = timestamp;
        }
        const DBInt32& Value( ) const
        {
            return value_;
        }
        void SetValue( const DBInt32& value )
        {
            value_ = value;
        }
        void BindColumns( const ODBC::Statement& statement )
        {
            Bind(statement, ID_FIELD_ID, id_);
            Bind(statement, ROWVERSION_FIELD_ID, rowVersion_);
            Bind(statement, TIMESERIES_FIELD_ID, timeseries_);
            Bind(statement, TIMESTAMP_FIELD_ID, timestamp_);
            Bind(statement, VALUE_FIELD_ID, value_);
        }

        template<IO::StreamWriter StreamT>
        void WriteColumns( IO::BinaryWriter<StreamT>& destination ) const
        {
            WriteColumnValue( destination, id_);
            WriteColumnValue( destination, rowVersion_);
            WriteColumnValue( destination, timeseries_);
            WriteColumnValue( destination, timestamp_);
            WriteColumnValue( destination, value_);
        }
    };

    using SimpleInt32TimeseriesValueDataReader = SimpleColumnDataReader<Int32TimeseriesValueColumnData>;

    class Int64TimeseriesValueColumnData : public BaseColumnData
    {
        Guid id_;
        Int64 rowVersion_ = 0;
        Guid timeseries_;
        DateTime timestamp_;
        DBInt64 value_;
    public:
        using Base = BaseColumnData;

        static constexpr std::wstring_view FieldNames = L"[Id],[RowVersion],[Timeseries],[Timestamp],[Value]";
        static constexpr std::wstring_view ViewName = L"Int64TimeseriesValueView";

        static constexpr SQLUSMALLINT ID_FIELD_ID = 1;
        static constexpr SQLUSMALLINT ROWVERSION_FIELD_ID = 2;
        static constexpr SQLUSMALLINT TIMESERIES_FIELD_ID = 3;
        static constexpr SQLUSMALLINT TIMESTAMP_FIELD_ID = 4;
        static constexpr SQLUSMALLINT VALUE_FIELD_ID = 5;

        Int64TimeseriesValueColumnData( ) = default;

        virtual Kind GetKind() const override
        {
            return Kind::Int64TimeseriesValue;
        }

        const Guid& Id( ) const
        {
            return id_;
        }
        void SetId( const Guid& id )
        {
            id_ = id;
        }
        Int64 RowVersion( ) const
        {
            return rowVersion_;
        }
        void SetRowVersion( const Int64& rowVersion )
        {
            rowVersion_ = rowVersion;
        }
        const Guid& Timeseries( ) const
        {
            return timeseries_;
        }
        void SetTimeseries( const Guid& timeseries )
        {
            timeseries_ = timeseries;
        }
        const DateTime& Timestamp( ) const
        {
            return timestamp_;
        }
        void SetTimestamp( const DateTime& timestamp )
        {
            timestamp_ = timestamp;
        }
        const DBInt64& Value( ) const
        {
            return value_;
        }
        void SetValue( const DBInt64& value )
        {
            value_ = value;
        }
        void BindColumns( const ODBC::Statement& statement )
        {
            Bind(statement, ID_FIELD_ID, id_);
            Bind(statement, ROWVERSION_FIELD_ID, rowVersion_);
            Bind(statement, TIMESERIES_FIELD_ID, timeseries_);
            Bind(statement, TIMESTAMP_FIELD_ID, timestamp_);
            Bind(statement, VALUE_FIELD_ID, value_);
        }

        template<IO::StreamWriter StreamT>
        void WriteColumns( IO::BinaryWriter<StreamT>& destination ) const
        {
            WriteColumnValue( destination, id_);
            WriteColumnValue( destination, rowVersion_);
            WriteColumnValue( destination, timeseries_);
            WriteColumnValue( destination, timestamp_);
            WriteColumnValue( destination, value_);
        }
    };

    using SimpleInt64TimeseriesValueDataReader = SimpleColumnDataReader<Int64TimeseriesValueColumnData>;

    class ItemColumnData : public BaseColumnData
    {
        Guid id_;
        Int64 rowVersion_ = 0;
    public:
        using Base = BaseColumnData;

        static constexpr std::wstring_view FieldNames = L"[Id],[RowVersion]";
        static constexpr std::wstring_view ViewName = L"ItemView";

        static constexpr SQLUSMALLINT ID_FIELD_ID = 1;
        static constexpr SQLUSMALLINT ROWVERSION_FIELD_ID = 2;

        ItemColumnData( ) = default;

        virtual Kind GetKind() const override
        {
            return Kind::Item;
        }

        const Guid& Id( ) const
        {
            return id_;
        }
        void SetId( const Guid& id )
        {
            id_ = id;
        }
        Int64 RowVersion( ) const
        {
            return rowVersion_;
        }
        void SetRowVersion( const Int64& rowVersion )
        {
            rowVersion_ = rowVersion;
        }
        void BindColumns( const ODBC::Statement& statement )
        {
            Bind(statement, ID_FIELD_ID, id_);
            Bind(statement, ROWVERSION_FIELD_ID, rowVersion_);
        }

        template<IO::StreamWriter StreamT>
        void WriteColumns( IO::BinaryWriter<StreamT>& destination ) const
        {
            WriteColumnValue( destination, id_);
            WriteColumnValue( destination, rowVersion_);
        }
    };

    using SimpleItemDataReader = SimpleColumnDataReader<ItemColumnData>;

    class BaseStationColumnData : public ItemColumnData
    {
        FixedDBWideString<127> name_;
        Guid type_;
    public:
        using Base = ItemColumnData;

        static constexpr std::wstring_view FieldNames = L"[Id],[RowVersion],[Name],[Type]";
        static constexpr std::wstring_view ViewName = L"BaseStationView";

        static constexpr SQLUSMALLINT NAME_FIELD_ID = 3;
        static constexpr SQLUSMALLINT TYPE_FIELD_ID = 4;

        BaseStationColumnData( ) = default;

        virtual Kind GetKind() const override
        {
            return Kind::BaseStation;
        }

        const FixedDBWideString<127>& Name( ) const
        {
            return name_;
        }
        void SetName( const WideString& name )
        {
            name_ = name;
        }
        const Guid& Type( ) const
        {
            return type_;
        }
        void SetType( const Guid& type )
        {
            type_ = type;
        }
        void BindColumns( const ODBC::Statement& statement )
        {
            Base::BindColumns( statement );

            Bind(statement, NAME_FIELD_ID, name_);
            Bind(statement, TYPE_FIELD_ID, type_);
        }

        template<IO::StreamWriter StreamT>
        void WriteColumns( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteColumns( destination );
            WriteColumnValue( destination, name_);
            WriteColumnValue( destination, type_);
        }
    };

    using SimpleBaseStationDataReader = SimpleColumnDataReader<BaseStationColumnData>;

    class DeviceColumnData : public ItemColumnData
    {
        Guid host_;
        FixedDBWideString<127> name_;
        WideString description_;
        SQLLEN descriptionLength_ = SQL_NULL_DATA;
        Guid enabledTimeseries_;
    public:
        using Base = ItemColumnData;

        static constexpr std::wstring_view FieldNames = L"[Id],[RowVersion],[Host],[Name],[EnabledTimeseries],[Description]";
        static constexpr std::wstring_view ViewName = L"DeviceView";

        static constexpr SQLUSMALLINT HOST_FIELD_ID = 3;
        static constexpr SQLUSMALLINT NAME_FIELD_ID = 4;
        static constexpr SQLUSMALLINT ENABLEDTIMESERIES_FIELD_ID = 5;
        static constexpr SQLUSMALLINT DESCRIPTION_FIELD_ID = 6;

        DeviceColumnData( ) = default;

        virtual Kind GetKind() const override
        {
            return Kind::Device;
        }

        const Guid& Host( ) const
        {
            return host_;
        }
        void SetHost( const Guid& host )
        {
            host_ = host;
        }
        const FixedDBWideString<127>& Name( ) const
        {
            return name_;
        }
        void SetName( const WideString& name )
        {
            name_ = name;
        }
        const WideString& Description( ) const
        {
            return description_;
        }
        void SetDescription( const WideString& description )
        {
            description_ = description;
        }
        const Guid& EnabledTimeseries( ) const
        {
            return enabledTimeseries_;
        }
        void SetEnabledTimeseries( const Guid& enabledTimeseries )
        {
            enabledTimeseries_ = enabledTimeseries;
        }
        void BindColumns( const ODBC::Statement& statement )
        {
            Base::BindColumns( statement );

            Bind(statement, HOST_FIELD_ID, host_);
            Bind(statement, NAME_FIELD_ID, name_);
            Bind(statement, ENABLEDTIMESERIES_FIELD_ID, enabledTimeseries_);
        }

        void ReadUnboundData( const ODBC::Statement& statement )
        {
            Base::ReadUnboundData( statement );

            description_ = statement.GetWideString(DESCRIPTION_FIELD_ID);
        }
        template<IO::StreamWriter StreamT>
        void WriteColumns( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteColumns( destination );
            WriteColumnValue( destination, host_);
            WriteColumnValue( destination, name_);
            WriteColumnValue( destination, description_);
            WriteColumnValue( destination, enabledTimeseries_);
        }
    };

    using SimpleDeviceDataReader = SimpleColumnDataReader<DeviceColumnData>;

    class CameraColumnData : public DeviceColumnData
    {
        Guid type_;
    public:
        using Base = DeviceColumnData;

        static constexpr std::wstring_view FieldNames = L"[Id],[RowVersion],[Host],[Name],[EnabledTimeseries],[Type],[Description]";
        static constexpr std::wstring_view ViewName = L"CameraView";

        static constexpr SQLUSMALLINT TYPE_FIELD_ID = 7;

        CameraColumnData( ) = default;

        virtual Kind GetKind() const override
        {
            return Kind::Camera;
        }

        const Guid& Type( ) const
        {
            return type_;
        }
        void SetType( const Guid& type )
        {
            type_ = type;
        }
        void BindColumns( const ODBC::Statement& statement )
        {
            Base::BindColumns( statement );

            Bind(statement, TYPE_FIELD_ID, type_);
        }

        template<IO::StreamWriter StreamT>
        void WriteColumns( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteColumns( destination );
            WriteColumnValue( destination, type_);
        }
    };

    using SimpleCameraDataReader = SimpleColumnDataReader<CameraColumnData>;

    class GNSSDeviceColumnData : public DeviceColumnData
    {
        Guid type_;
        Guid latitudeTimeseries_;
        Guid longitudeTimeseries_;
        Guid altitudeTimeseries_;
    public:
        using Base = DeviceColumnData;

        static constexpr std::wstring_view FieldNames = L"[Id],[RowVersion],[Host],[Name],[EnabledTimeseries],[Type],[LatitudeTimeseries],[LongitudeTimeseries],[AltitudeTimeseries],[Description]";
        static constexpr std::wstring_view ViewName = L"GNSSDeviceView";

        static constexpr SQLUSMALLINT TYPE_FIELD_ID = 7;
        static constexpr SQLUSMALLINT LATITUDETIMESERIES_FIELD_ID = 8;
        static constexpr SQLUSMALLINT LONGITUDETIMESERIES_FIELD_ID = 9;
        static constexpr SQLUSMALLINT ALTITUDETIMESERIES_FIELD_ID = 10;

        GNSSDeviceColumnData( ) = default;

        virtual Kind GetKind() const override
        {
            return Kind::GNSSDevice;
        }

        const Guid& Type( ) const
        {
            return type_;
        }
        void SetType( const Guid& type )
        {
            type_ = type;
        }
        const Guid& LatitudeTimeseries( ) const
        {
            return latitudeTimeseries_;
        }
        void SetLatitudeTimeseries( const Guid& latitudeTimeseries )
        {
            latitudeTimeseries_ = latitudeTimeseries;
        }
        const Guid& LongitudeTimeseries( ) const
        {
            return longitudeTimeseries_;
        }
        void SetLongitudeTimeseries( const Guid& longitudeTimeseries )
        {
            longitudeTimeseries_ = longitudeTimeseries;
        }
        const Guid& AltitudeTimeseries( ) const
        {
            return altitudeTimeseries_;
        }
        void SetAltitudeTimeseries( const Guid& altitudeTimeseries )
        {
            altitudeTimeseries_ = altitudeTimeseries;
        }
        void BindColumns( const ODBC::Statement& statement )
        {
            Base::BindColumns( statement );

            Bind(statement, TYPE_FIELD_ID, type_);
            Bind(statement, LATITUDETIMESERIES_FIELD_ID, latitudeTimeseries_);
            Bind(statement, LONGITUDETIMESERIES_FIELD_ID, longitudeTimeseries_);
            Bind(statement, ALTITUDETIMESERIES_FIELD_ID, altitudeTimeseries_);
        }

        template<IO::StreamWriter StreamT>
        void WriteColumns( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteColumns( destination );
            WriteColumnValue( destination, type_);
            WriteColumnValue( destination, latitudeTimeseries_);
            WriteColumnValue( destination, longitudeTimeseries_);
            WriteColumnValue( destination, altitudeTimeseries_);
        }
    };

    using SimpleGNSSDeviceDataReader = SimpleColumnDataReader<GNSSDeviceColumnData>;

    class GyroDeviceColumnData : public DeviceColumnData
    {
        Guid type_;
        Guid headingTrueNorthTimeseries_;
        Guid headingMagneticNorthTimeseries_;
        Guid pitchTimeseries_;
        Guid rateOfTurnTimeseries_;
        Guid rollTimeseries_;
        Guid courseTimeseries_;
        Guid speedTimeseries_;
        Guid gNSSDevice_;
    public:
        using Base = DeviceColumnData;

        static constexpr std::wstring_view FieldNames = L"[Id],[RowVersion],[Host],[Name],[EnabledTimeseries],[Type],[HeadingTrueNorthTimeseries],[HeadingMagneticNorthTimeseries],[PitchTimeseries],[RateOfTurnTimeseries],[RollTimeseries],[CourseTimeseries],[SpeedTimeseries],[GNSSDevice],[Description]";
        static constexpr std::wstring_view ViewName = L"GyroDeviceView";

        static constexpr SQLUSMALLINT TYPE_FIELD_ID = 7;
        static constexpr SQLUSMALLINT HEADINGTRUENORTHTIMESERIES_FIELD_ID = 8;
        static constexpr SQLUSMALLINT HEADINGMAGNETICNORTHTIMESERIES_FIELD_ID = 9;
        static constexpr SQLUSMALLINT PITCHTIMESERIES_FIELD_ID = 10;
        static constexpr SQLUSMALLINT RATEOFTURNTIMESERIES_FIELD_ID = 11;
        static constexpr SQLUSMALLINT ROLLTIMESERIES_FIELD_ID = 12;
        static constexpr SQLUSMALLINT COURSETIMESERIES_FIELD_ID = 13;
        static constexpr SQLUSMALLINT SPEEDTIMESERIES_FIELD_ID = 14;
        static constexpr SQLUSMALLINT GNSSDEVICE_FIELD_ID = 15;

        GyroDeviceColumnData( ) = default;

        virtual Kind GetKind() const override
        {
            return Kind::GyroDevice;
        }

        const Guid& Type( ) const
        {
            return type_;
        }
        void SetType( const Guid& type )
        {
            type_ = type;
        }
        const Guid& HeadingTrueNorthTimeseries( ) const
        {
            return headingTrueNorthTimeseries_;
        }
        void SetHeadingTrueNorthTimeseries( const Guid& headingTrueNorthTimeseries )
        {
            headingTrueNorthTimeseries_ = headingTrueNorthTimeseries;
        }
        const Guid& HeadingMagneticNorthTimeseries( ) const
        {
            return headingMagneticNorthTimeseries_;
        }
        void SetHeadingMagneticNorthTimeseries( const Guid& headingMagneticNorthTimeseries )
        {
            headingMagneticNorthTimeseries_ = headingMagneticNorthTimeseries;
        }
        const Guid& PitchTimeseries( ) const
        {
            return pitchTimeseries_;
        }
        void SetPitchTimeseries( const Guid& pitchTimeseries )
        {
            pitchTimeseries_ = pitchTimeseries;
        }
        const Guid& RateOfTurnTimeseries( ) const
        {
            return rateOfTurnTimeseries_;
        }
        void SetRateOfTurnTimeseries( const Guid& rateOfTurnTimeseries )
        {
            rateOfTurnTimeseries_ = rateOfTurnTimeseries;
        }
        const Guid& RollTimeseries( ) const
        {
            return rollTimeseries_;
        }
        void SetRollTimeseries( const Guid& rollTimeseries )
        {
            rollTimeseries_ = rollTimeseries;
        }
        const Guid& CourseTimeseries( ) const
        {
            return courseTimeseries_;
        }
        void SetCourseTimeseries( const Guid& courseTimeseries )
        {
            courseTimeseries_ = courseTimeseries;
        }
        const Guid& SpeedTimeseries( ) const
        {
            return speedTimeseries_;
        }
        void SetSpeedTimeseries( const Guid& speedTimeseries )
        {
            speedTimeseries_ = speedTimeseries;
        }
        const Guid& GNSSDevice( ) const
        {
            return gNSSDevice_;
        }
        void SetGNSSDevice( const Guid& gNSSDevice )
        {
            gNSSDevice_ = gNSSDevice;
        }
        void BindColumns( const ODBC::Statement& statement )
        {
            Base::BindColumns( statement );

            Bind(statement, TYPE_FIELD_ID, type_);
            Bind(statement, HEADINGTRUENORTHTIMESERIES_FIELD_ID, headingTrueNorthTimeseries_);
            Bind(statement, HEADINGMAGNETICNORTHTIMESERIES_FIELD_ID, headingMagneticNorthTimeseries_);
            Bind(statement, PITCHTIMESERIES_FIELD_ID, pitchTimeseries_);
            Bind(statement, RATEOFTURNTIMESERIES_FIELD_ID, rateOfTurnTimeseries_);
            Bind(statement, ROLLTIMESERIES_FIELD_ID, rollTimeseries_);
            Bind(statement, COURSETIMESERIES_FIELD_ID, courseTimeseries_);
            Bind(statement, SPEEDTIMESERIES_FIELD_ID, speedTimeseries_);
            Bind(statement, GNSSDEVICE_FIELD_ID, gNSSDevice_);
        }

        template<IO::StreamWriter StreamT>
        void WriteColumns( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteColumns( destination );
            WriteColumnValue( destination, type_);
            WriteColumnValue( destination, headingTrueNorthTimeseries_);
            WriteColumnValue( destination, headingMagneticNorthTimeseries_);
            WriteColumnValue( destination, pitchTimeseries_);
            WriteColumnValue( destination, rateOfTurnTimeseries_);
            WriteColumnValue( destination, rollTimeseries_);
            WriteColumnValue( destination, courseTimeseries_);
            WriteColumnValue( destination, speedTimeseries_);
            WriteColumnValue( destination, gNSSDevice_);
        }
    };

    using SimpleGyroDeviceDataReader = SimpleColumnDataReader<GyroDeviceColumnData>;

    class LineInputDeviceColumnData : public DeviceColumnData
    {
        Guid type_;
    public:
        using Base = DeviceColumnData;

        static constexpr std::wstring_view FieldNames = L"[Id],[RowVersion],[Host],[Name],[EnabledTimeseries],[Type],[Description]";
        static constexpr std::wstring_view ViewName = L"LineInputDeviceView";

        static constexpr SQLUSMALLINT TYPE_FIELD_ID = 7;

        LineInputDeviceColumnData( ) = default;

        virtual Kind GetKind() const override
        {
            return Kind::LineInputDevice;
        }

        const Guid& Type( ) const
        {
            return type_;
        }
        void SetType( const Guid& type )
        {
            type_ = type;
        }
        void BindColumns( const ODBC::Statement& statement )
        {
            Base::BindColumns( statement );

            Bind(statement, TYPE_FIELD_ID, type_);
        }

        template<IO::StreamWriter StreamT>
        void WriteColumns( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteColumns( destination );
            WriteColumnValue( destination, type_);
        }
    };

    using SimpleLineInputDeviceDataReader = SimpleColumnDataReader<LineInputDeviceColumnData>;

    class OilspillDetectorColumnData : public DeviceColumnData
    {
        Guid type_;
    public:
        using Base = DeviceColumnData;

        static constexpr std::wstring_view FieldNames = L"[Id],[RowVersion],[Host],[Name],[EnabledTimeseries],[Type],[Description]";
        static constexpr std::wstring_view ViewName = L"OilspillDetectorView";

        static constexpr SQLUSMALLINT TYPE_FIELD_ID = 7;

        OilspillDetectorColumnData( ) = default;

        virtual Kind GetKind() const override
        {
            return Kind::OilspillDetector;
        }

        const Guid& Type( ) const
        {
            return type_;
        }
        void SetType( const Guid& type )
        {
            type_ = type;
        }
        void BindColumns( const ODBC::Statement& statement )
        {
            Base::BindColumns( statement );

            Bind(statement, TYPE_FIELD_ID, type_);
        }

        template<IO::StreamWriter StreamT>
        void WriteColumns( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteColumns( destination );
            WriteColumnValue( destination, type_);
        }
    };

    using SimpleOilspillDetectorDataReader = SimpleColumnDataReader<OilspillDetectorColumnData>;

    class RadioColumnData : public DeviceColumnData
    {
        Guid type_;
    public:
        using Base = DeviceColumnData;

        static constexpr std::wstring_view FieldNames = L"[Id],[RowVersion],[Host],[Name],[EnabledTimeseries],[Type],[Description]";
        static constexpr std::wstring_view ViewName = L"RadioView";

        static constexpr SQLUSMALLINT TYPE_FIELD_ID = 7;

        RadioColumnData( ) = default;

        virtual Kind GetKind() const override
        {
            return Kind::Radio;
        }

        const Guid& Type( ) const
        {
            return type_;
        }
        void SetType( const Guid& type )
        {
            type_ = type;
        }
        void BindColumns( const ODBC::Statement& statement )
        {
            Base::BindColumns( statement );

            Bind(statement, TYPE_FIELD_ID, type_);
        }

        template<IO::StreamWriter StreamT>
        void WriteColumns( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteColumns( destination );
            WriteColumnValue( destination, type_);
        }
    };

    using SimpleRadioDataReader = SimpleColumnDataReader<RadioColumnData>;

    class RadomeColumnData : public DeviceColumnData
    {
        Guid type_;
        Guid radar_;
        Guid pressureTimeseries_;
        Guid temperatureTimeseries_;
        Guid dewPointTimeseries_;
        Guid statusTimeseries_;
    public:
        using Base = DeviceColumnData;

        static constexpr std::wstring_view FieldNames = L"[Id],[RowVersion],[Host],[Name],[EnabledTimeseries],[Type],[Radar],[PressureTimeseries],[TemperatureTimeseries],[DewPointTimeseries],[StatusTimeseries],[Description]";
        static constexpr std::wstring_view ViewName = L"RadomeView";

        static constexpr SQLUSMALLINT TYPE_FIELD_ID = 7;
        static constexpr SQLUSMALLINT RADAR_FIELD_ID = 8;
        static constexpr SQLUSMALLINT PRESSURETIMESERIES_FIELD_ID = 9;
        static constexpr SQLUSMALLINT TEMPERATURETIMESERIES_FIELD_ID = 10;
        static constexpr SQLUSMALLINT DEWPOINTTIMESERIES_FIELD_ID = 11;
        static constexpr SQLUSMALLINT STATUSTIMESERIES_FIELD_ID = 12;

        RadomeColumnData( ) = default;

        virtual Kind GetKind() const override
        {
            return Kind::Radome;
        }

        const Guid& Type( ) const
        {
            return type_;
        }
        void SetType( const Guid& type )
        {
            type_ = type;
        }
        const Guid& Radar( ) const
        {
            return radar_;
        }
        void SetRadar( const Guid& radar )
        {
            radar_ = radar;
        }
        const Guid& PressureTimeseries( ) const
        {
            return pressureTimeseries_;
        }
        void SetPressureTimeseries( const Guid& pressureTimeseries )
        {
            pressureTimeseries_ = pressureTimeseries;
        }
        const Guid& TemperatureTimeseries( ) const
        {
            return temperatureTimeseries_;
        }
        void SetTemperatureTimeseries( const Guid& temperatureTimeseries )
        {
            temperatureTimeseries_ = temperatureTimeseries;
        }
        const Guid& DewPointTimeseries( ) const
        {
            return dewPointTimeseries_;
        }
        void SetDewPointTimeseries( const Guid& dewPointTimeseries )
        {
            dewPointTimeseries_ = dewPointTimeseries;
        }
        const Guid& StatusTimeseries( ) const
        {
            return statusTimeseries_;
        }
        void SetStatusTimeseries( const Guid& statusTimeseries )
        {
            statusTimeseries_ = statusTimeseries;
        }
        void BindColumns( const ODBC::Statement& statement )
        {
            Base::BindColumns( statement );

            Bind(statement, TYPE_FIELD_ID, type_);
            Bind(statement, RADAR_FIELD_ID, radar_);
            Bind(statement, PRESSURETIMESERIES_FIELD_ID, pressureTimeseries_);
            Bind(statement, TEMPERATURETIMESERIES_FIELD_ID, temperatureTimeseries_);
            Bind(statement, DEWPOINTTIMESERIES_FIELD_ID, dewPointTimeseries_);
            Bind(statement, STATUSTIMESERIES_FIELD_ID, statusTimeseries_);
        }

        template<IO::StreamWriter StreamT>
        void WriteColumns( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteColumns( destination );
            WriteColumnValue( destination, type_);
            WriteColumnValue( destination, radar_);
            WriteColumnValue( destination, pressureTimeseries_);
            WriteColumnValue( destination, temperatureTimeseries_);
            WriteColumnValue( destination, dewPointTimeseries_);
            WriteColumnValue( destination, statusTimeseries_);
        }
    };

    using SimpleRadomeDataReader = SimpleColumnDataReader<RadomeColumnData>;

    class TrackerColumnData : public DeviceColumnData
    {
    public:
        using Base = DeviceColumnData;

        static constexpr std::wstring_view FieldNames = L"[Id],[RowVersion],[Host],[Name],[EnabledTimeseries],[Description]";
        static constexpr std::wstring_view ViewName = L"TrackerView";

        TrackerColumnData( ) = default;

        virtual Kind GetKind() const override
        {
            return Kind::Tracker;
        }

        template<IO::StreamWriter StreamT>
        void WriteColumns( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteColumns( destination );
        }
    };

    using SimpleTrackerDataReader = SimpleColumnDataReader<TrackerColumnData>;

    class AisTransceiverColumnData : public TrackerColumnData
    {
        Guid type_;
    public:
        using Base = TrackerColumnData;

        static constexpr std::wstring_view FieldNames = L"[Id],[RowVersion],[Host],[Name],[EnabledTimeseries],[Type],[Description]";
        static constexpr std::wstring_view ViewName = L"AisTransceiverView";

        static constexpr SQLUSMALLINT TYPE_FIELD_ID = 7;

        AisTransceiverColumnData( ) = default;

        virtual Kind GetKind() const override
        {
            return Kind::AisTransceiver;
        }

        const Guid& Type( ) const
        {
            return type_;
        }
        void SetType( const Guid& type )
        {
            type_ = type;
        }
        void BindColumns( const ODBC::Statement& statement )
        {
            Base::BindColumns( statement );

            Bind(statement, TYPE_FIELD_ID, type_);
        }

        template<IO::StreamWriter StreamT>
        void WriteColumns( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteColumns( destination );
            WriteColumnValue( destination, type_);
        }
    };

    using SimpleAisTransceiverDataReader = SimpleColumnDataReader<AisTransceiverColumnData>;

    class RadarColumnData : public TrackerColumnData
    {
        Guid type_;
        Guid saveSettingsTimeseries_;
        Guid powerOnTimeseries_;
        Guid trackingOnTimeseries_;
        Guid radarPulseTimeseries_;
        Guid tuningTimeseries_;
        Guid blankSector1Timeseries_;
        Guid sector1StartTimeseries_;
        Guid sector1EndTimeseries_;
        Guid blankSector2Timeseries_;
        Guid sector2StartTimeseries_;
        Guid sector2EndTimeseries_;
        Guid enableAutomaticFrequencyControlTimeseries_;
        Guid azimuthOffsetTimeseries_;
        Guid enableSensitivityTimeControlTimeseries_;
        Guid automaticSensitivityTimeControlTimeseries_;
        Guid sensitivityTimeControlLevelTimeseries_;
        Guid enableFastTimeConstantTimeseries_;
        Guid fastTimeConstantLevelTimeseries_;
        Guid fastTimeConstantModeTimeseries_;
        Guid latitudeTimeseries_;
        Guid longitudeTimeseries_;
        Guid radome_;
        Guid gNSSDevice_;
    public:
        using Base = TrackerColumnData;

        static constexpr std::wstring_view FieldNames = L"[Id],[RowVersion],[Host],[Name],[EnabledTimeseries],[Type],[SaveSettingsTimeseries],[PowerOnTimeseries],[TrackingOnTimeseries],[RadarPulseTimeseries],[TuningTimeseries],[BlankSector1Timeseries],[Sector1StartTimeseries],[Sector1EndTimeseries],[BlankSector2Timeseries],[Sector2StartTimeseries],[Sector2EndTimeseries],[EnableAutomaticFrequencyControlTimeseries],[AzimuthOffsetTimeseries],[EnableSensitivityTimeControlTimeseries],[AutomaticSensitivityTimeControlTimeseries],[SensitivityTimeControlLevelTimeseries],[EnableFastTimeConstantTimeseries],[FastTimeConstantLevelTimeseries],[FastTimeConstantModeTimeseries],[LatitudeTimeseries],[LongitudeTimeseries],[Radome],[GNSSDevice],[Description]";
        static constexpr std::wstring_view ViewName = L"RadarView";

        static constexpr SQLUSMALLINT TYPE_FIELD_ID = 7;
        static constexpr SQLUSMALLINT SAVESETTINGSTIMESERIES_FIELD_ID = 8;
        static constexpr SQLUSMALLINT POWERONTIMESERIES_FIELD_ID = 9;
        static constexpr SQLUSMALLINT TRACKINGONTIMESERIES_FIELD_ID = 10;
        static constexpr SQLUSMALLINT RADARPULSETIMESERIES_FIELD_ID = 11;
        static constexpr SQLUSMALLINT TUNINGTIMESERIES_FIELD_ID = 12;
        static constexpr SQLUSMALLINT BLANKSECTOR1TIMESERIES_FIELD_ID = 13;
        static constexpr SQLUSMALLINT SECTOR1STARTTIMESERIES_FIELD_ID = 14;
        static constexpr SQLUSMALLINT SECTOR1ENDTIMESERIES_FIELD_ID = 15;
        static constexpr SQLUSMALLINT BLANKSECTOR2TIMESERIES_FIELD_ID = 16;
        static constexpr SQLUSMALLINT SECTOR2STARTTIMESERIES_FIELD_ID = 17;
        static constexpr SQLUSMALLINT SECTOR2ENDTIMESERIES_FIELD_ID = 18;
        static constexpr SQLUSMALLINT ENABLEAUTOMATICFREQUENCYCONTROLTIMESERIES_FIELD_ID = 19;
        static constexpr SQLUSMALLINT AZIMUTHOFFSETTIMESERIES_FIELD_ID = 20;
        static constexpr SQLUSMALLINT ENABLESENSITIVITYTIMECONTROLTIMESERIES_FIELD_ID = 21;
        static constexpr SQLUSMALLINT AUTOMATICSENSITIVITYTIMECONTROLTIMESERIES_FIELD_ID = 22;
        static constexpr SQLUSMALLINT SENSITIVITYTIMECONTROLLEVELTIMESERIES_FIELD_ID = 23;
        static constexpr SQLUSMALLINT ENABLEFASTTIMECONSTANTTIMESERIES_FIELD_ID = 24;
        static constexpr SQLUSMALLINT FASTTIMECONSTANTLEVELTIMESERIES_FIELD_ID = 25;
        static constexpr SQLUSMALLINT FASTTIMECONSTANTMODETIMESERIES_FIELD_ID = 26;
        static constexpr SQLUSMALLINT LATITUDETIMESERIES_FIELD_ID = 27;
        static constexpr SQLUSMALLINT LONGITUDETIMESERIES_FIELD_ID = 28;
        static constexpr SQLUSMALLINT RADOME_FIELD_ID = 29;
        static constexpr SQLUSMALLINT GNSSDEVICE_FIELD_ID = 30;

        RadarColumnData( ) = default;

        virtual Kind GetKind() const override
        {
            return Kind::Radar;
        }

        const Guid& Type( ) const
        {
            return type_;
        }
        void SetType( const Guid& type )
        {
            type_ = type;
        }
        const Guid& SaveSettingsTimeseries( ) const
        {
            return saveSettingsTimeseries_;
        }
        void SetSaveSettingsTimeseries( const Guid& saveSettingsTimeseries )
        {
            saveSettingsTimeseries_ = saveSettingsTimeseries;
        }
        const Guid& PowerOnTimeseries( ) const
        {
            return powerOnTimeseries_;
        }
        void SetPowerOnTimeseries( const Guid& powerOnTimeseries )
        {
            powerOnTimeseries_ = powerOnTimeseries;
        }
        const Guid& TrackingOnTimeseries( ) const
        {
            return trackingOnTimeseries_;
        }
        void SetTrackingOnTimeseries( const Guid& trackingOnTimeseries )
        {
            trackingOnTimeseries_ = trackingOnTimeseries;
        }
        const Guid& RadarPulseTimeseries( ) const
        {
            return radarPulseTimeseries_;
        }
        void SetRadarPulseTimeseries( const Guid& radarPulseTimeseries )
        {
            radarPulseTimeseries_ = radarPulseTimeseries;
        }
        const Guid& TuningTimeseries( ) const
        {
            return tuningTimeseries_;
        }
        void SetTuningTimeseries( const Guid& tuningTimeseries )
        {
            tuningTimeseries_ = tuningTimeseries;
        }
        const Guid& BlankSector1Timeseries( ) const
        {
            return blankSector1Timeseries_;
        }
        void SetBlankSector1Timeseries( const Guid& blankSector1Timeseries )
        {
            blankSector1Timeseries_ = blankSector1Timeseries;
        }
        const Guid& Sector1StartTimeseries( ) const
        {
            return sector1StartTimeseries_;
        }
        void SetSector1StartTimeseries( const Guid& sector1StartTimeseries )
        {
            sector1StartTimeseries_ = sector1StartTimeseries;
        }
        const Guid& Sector1EndTimeseries( ) const
        {
            return sector1EndTimeseries_;
        }
        void SetSector1EndTimeseries( const Guid& sector1EndTimeseries )
        {
            sector1EndTimeseries_ = sector1EndTimeseries;
        }
        const Guid& BlankSector2Timeseries( ) const
        {
            return blankSector2Timeseries_;
        }
        void SetBlankSector2Timeseries( const Guid& blankSector2Timeseries )
        {
            blankSector2Timeseries_ = blankSector2Timeseries;
        }
        const Guid& Sector2StartTimeseries( ) const
        {
            return sector2StartTimeseries_;
        }
        void SetSector2StartTimeseries( const Guid& sector2StartTimeseries )
        {
            sector2StartTimeseries_ = sector2StartTimeseries;
        }
        const Guid& Sector2EndTimeseries( ) const
        {
            return sector2EndTimeseries_;
        }
        void SetSector2EndTimeseries( const Guid& sector2EndTimeseries )
        {
            sector2EndTimeseries_ = sector2EndTimeseries;
        }
        const Guid& EnableAutomaticFrequencyControlTimeseries( ) const
        {
            return enableAutomaticFrequencyControlTimeseries_;
        }
        void SetEnableAutomaticFrequencyControlTimeseries( const Guid& enableAutomaticFrequencyControlTimeseries )
        {
            enableAutomaticFrequencyControlTimeseries_ = enableAutomaticFrequencyControlTimeseries;
        }
        const Guid& AzimuthOffsetTimeseries( ) const
        {
            return azimuthOffsetTimeseries_;
        }
        void SetAzimuthOffsetTimeseries( const Guid& azimuthOffsetTimeseries )
        {
            azimuthOffsetTimeseries_ = azimuthOffsetTimeseries;
        }
        const Guid& EnableSensitivityTimeControlTimeseries( ) const
        {
            return enableSensitivityTimeControlTimeseries_;
        }
        void SetEnableSensitivityTimeControlTimeseries( const Guid& enableSensitivityTimeControlTimeseries )
        {
            enableSensitivityTimeControlTimeseries_ = enableSensitivityTimeControlTimeseries;
        }
        const Guid& AutomaticSensitivityTimeControlTimeseries( ) const
        {
            return automaticSensitivityTimeControlTimeseries_;
        }
        void SetAutomaticSensitivityTimeControlTimeseries( const Guid& automaticSensitivityTimeControlTimeseries )
        {
            automaticSensitivityTimeControlTimeseries_ = automaticSensitivityTimeControlTimeseries;
        }
        const Guid& SensitivityTimeControlLevelTimeseries( ) const
        {
            return sensitivityTimeControlLevelTimeseries_;
        }
        void SetSensitivityTimeControlLevelTimeseries( const Guid& sensitivityTimeControlLevelTimeseries )
        {
            sensitivityTimeControlLevelTimeseries_ = sensitivityTimeControlLevelTimeseries;
        }
        const Guid& EnableFastTimeConstantTimeseries( ) const
        {
            return enableFastTimeConstantTimeseries_;
        }
        void SetEnableFastTimeConstantTimeseries( const Guid& enableFastTimeConstantTimeseries )
        {
            enableFastTimeConstantTimeseries_ = enableFastTimeConstantTimeseries;
        }
        const Guid& FastTimeConstantLevelTimeseries( ) const
        {
            return fastTimeConstantLevelTimeseries_;
        }
        void SetFastTimeConstantLevelTimeseries( const Guid& fastTimeConstantLevelTimeseries )
        {
            fastTimeConstantLevelTimeseries_ = fastTimeConstantLevelTimeseries;
        }
        const Guid& FastTimeConstantModeTimeseries( ) const
        {
            return fastTimeConstantModeTimeseries_;
        }
        void SetFastTimeConstantModeTimeseries( const Guid& fastTimeConstantModeTimeseries )
        {
            fastTimeConstantModeTimeseries_ = fastTimeConstantModeTimeseries;
        }
        const Guid& LatitudeTimeseries( ) const
        {
            return latitudeTimeseries_;
        }
        void SetLatitudeTimeseries( const Guid& latitudeTimeseries )
        {
            latitudeTimeseries_ = latitudeTimeseries;
        }
        const Guid& LongitudeTimeseries( ) const
        {
            return longitudeTimeseries_;
        }
        void SetLongitudeTimeseries( const Guid& longitudeTimeseries )
        {
            longitudeTimeseries_ = longitudeTimeseries;
        }
        const Guid& Radome( ) const
        {
            return radome_;
        }
        void SetRadome( const Guid& radome )
        {
            radome_ = radome;
        }
        const Guid& GNSSDevice( ) const
        {
            return gNSSDevice_;
        }
        void SetGNSSDevice( const Guid& gNSSDevice )
        {
            gNSSDevice_ = gNSSDevice;
        }
        void BindColumns( const ODBC::Statement& statement )
        {
            Base::BindColumns( statement );

            Bind(statement, TYPE_FIELD_ID, type_);
            Bind(statement, SAVESETTINGSTIMESERIES_FIELD_ID, saveSettingsTimeseries_);
            Bind(statement, POWERONTIMESERIES_FIELD_ID, powerOnTimeseries_);
            Bind(statement, TRACKINGONTIMESERIES_FIELD_ID, trackingOnTimeseries_);
            Bind(statement, RADARPULSETIMESERIES_FIELD_ID, radarPulseTimeseries_);
            Bind(statement, TUNINGTIMESERIES_FIELD_ID, tuningTimeseries_);
            Bind(statement, BLANKSECTOR1TIMESERIES_FIELD_ID, blankSector1Timeseries_);
            Bind(statement, SECTOR1STARTTIMESERIES_FIELD_ID, sector1StartTimeseries_);
            Bind(statement, SECTOR1ENDTIMESERIES_FIELD_ID, sector1EndTimeseries_);
            Bind(statement, BLANKSECTOR2TIMESERIES_FIELD_ID, blankSector2Timeseries_);
            Bind(statement, SECTOR2STARTTIMESERIES_FIELD_ID, sector2StartTimeseries_);
            Bind(statement, SECTOR2ENDTIMESERIES_FIELD_ID, sector2EndTimeseries_);
            Bind(statement, ENABLEAUTOMATICFREQUENCYCONTROLTIMESERIES_FIELD_ID, enableAutomaticFrequencyControlTimeseries_);
            Bind(statement, AZIMUTHOFFSETTIMESERIES_FIELD_ID, azimuthOffsetTimeseries_);
            Bind(statement, ENABLESENSITIVITYTIMECONTROLTIMESERIES_FIELD_ID, enableSensitivityTimeControlTimeseries_);
            Bind(statement, AUTOMATICSENSITIVITYTIMECONTROLTIMESERIES_FIELD_ID, automaticSensitivityTimeControlTimeseries_);
            Bind(statement, SENSITIVITYTIMECONTROLLEVELTIMESERIES_FIELD_ID, sensitivityTimeControlLevelTimeseries_);
            Bind(statement, ENABLEFASTTIMECONSTANTTIMESERIES_FIELD_ID, enableFastTimeConstantTimeseries_);
            Bind(statement, FASTTIMECONSTANTLEVELTIMESERIES_FIELD_ID, fastTimeConstantLevelTimeseries_);
            Bind(statement, FASTTIMECONSTANTMODETIMESERIES_FIELD_ID, fastTimeConstantModeTimeseries_);
            Bind(statement, LATITUDETIMESERIES_FIELD_ID, latitudeTimeseries_);
            Bind(statement, LONGITUDETIMESERIES_FIELD_ID, longitudeTimeseries_);
            Bind(statement, RADOME_FIELD_ID, radome_);
            Bind(statement, GNSSDEVICE_FIELD_ID, gNSSDevice_);
        }

        template<IO::StreamWriter StreamT>
        void WriteColumns( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteColumns( destination );
            WriteColumnValue( destination, type_);
            WriteColumnValue( destination, saveSettingsTimeseries_);
            WriteColumnValue( destination, powerOnTimeseries_);
            WriteColumnValue( destination, trackingOnTimeseries_);
            WriteColumnValue( destination, radarPulseTimeseries_);
            WriteColumnValue( destination, tuningTimeseries_);
            WriteColumnValue( destination, blankSector1Timeseries_);
            WriteColumnValue( destination, sector1StartTimeseries_);
            WriteColumnValue( destination, sector1EndTimeseries_);
            WriteColumnValue( destination, blankSector2Timeseries_);
            WriteColumnValue( destination, sector2StartTimeseries_);
            WriteColumnValue( destination, sector2EndTimeseries_);
            WriteColumnValue( destination, enableAutomaticFrequencyControlTimeseries_);
            WriteColumnValue( destination, azimuthOffsetTimeseries_);
            WriteColumnValue( destination, enableSensitivityTimeControlTimeseries_);
            WriteColumnValue( destination, automaticSensitivityTimeControlTimeseries_);
            WriteColumnValue( destination, sensitivityTimeControlLevelTimeseries_);
            WriteColumnValue( destination, enableFastTimeConstantTimeseries_);
            WriteColumnValue( destination, fastTimeConstantLevelTimeseries_);
            WriteColumnValue( destination, fastTimeConstantModeTimeseries_);
            WriteColumnValue( destination, latitudeTimeseries_);
            WriteColumnValue( destination, longitudeTimeseries_);
            WriteColumnValue( destination, radome_);
            WriteColumnValue( destination, gNSSDevice_);
        }
    };

    using SimpleRadarDataReader = SimpleColumnDataReader<RadarColumnData>;

    class WeatherStationColumnData : public DeviceColumnData
    {
        Guid type_;
        Guid barometricPressureTimeseries_;
        Guid airTemperatureTimeseries_;
        Guid waterTemperatureTimeseries_;
        Guid relativeHumidityTimeseries_;
        Guid absoluteHumidityTimeseries_;
        Guid dewPointTimeseries_;
        Guid windDirectionTimeseries_;
        Guid windSpeedTimeseries_;
        Guid gyro_;
    public:
        using Base = DeviceColumnData;

        static constexpr std::wstring_view FieldNames = L"[Id],[RowVersion],[Host],[Name],[EnabledTimeseries],[Type],[BarometricPressureTimeseries],[AirTemperatureTimeseries],[WaterTemperatureTimeseries],[RelativeHumidityTimeseries],[AbsoluteHumidityTimeseries],[DewPointTimeseries],[WindDirectionTimeseries],[WindSpeedTimeseries],[Gyro],[Description]";
        static constexpr std::wstring_view ViewName = L"WeatherStationView";

        static constexpr SQLUSMALLINT TYPE_FIELD_ID = 7;
        static constexpr SQLUSMALLINT BAROMETRICPRESSURETIMESERIES_FIELD_ID = 8;
        static constexpr SQLUSMALLINT AIRTEMPERATURETIMESERIES_FIELD_ID = 9;
        static constexpr SQLUSMALLINT WATERTEMPERATURETIMESERIES_FIELD_ID = 10;
        static constexpr SQLUSMALLINT RELATIVEHUMIDITYTIMESERIES_FIELD_ID = 11;
        static constexpr SQLUSMALLINT ABSOLUTEHUMIDITYTIMESERIES_FIELD_ID = 12;
        static constexpr SQLUSMALLINT DEWPOINTTIMESERIES_FIELD_ID = 13;
        static constexpr SQLUSMALLINT WINDDIRECTIONTIMESERIES_FIELD_ID = 14;
        static constexpr SQLUSMALLINT WINDSPEEDTIMESERIES_FIELD_ID = 15;
        static constexpr SQLUSMALLINT GYRO_FIELD_ID = 16;

        WeatherStationColumnData( ) = default;

        virtual Kind GetKind() const override
        {
            return Kind::WeatherStation;
        }

        const Guid& Type( ) const
        {
            return type_;
        }
        void SetType( const Guid& type )
        {
            type_ = type;
        }
        const Guid& BarometricPressureTimeseries( ) const
        {
            return barometricPressureTimeseries_;
        }
        void SetBarometricPressureTimeseries( const Guid& barometricPressureTimeseries )
        {
            barometricPressureTimeseries_ = barometricPressureTimeseries;
        }
        const Guid& AirTemperatureTimeseries( ) const
        {
            return airTemperatureTimeseries_;
        }
        void SetAirTemperatureTimeseries( const Guid& airTemperatureTimeseries )
        {
            airTemperatureTimeseries_ = airTemperatureTimeseries;
        }
        const Guid& WaterTemperatureTimeseries( ) const
        {
            return waterTemperatureTimeseries_;
        }
        void SetWaterTemperatureTimeseries( const Guid& waterTemperatureTimeseries )
        {
            waterTemperatureTimeseries_ = waterTemperatureTimeseries;
        }
        const Guid& RelativeHumidityTimeseries( ) const
        {
            return relativeHumidityTimeseries_;
        }
        void SetRelativeHumidityTimeseries( const Guid& relativeHumidityTimeseries )
        {
            relativeHumidityTimeseries_ = relativeHumidityTimeseries;
        }
        const Guid& AbsoluteHumidityTimeseries( ) const
        {
            return absoluteHumidityTimeseries_;
        }
        void SetAbsoluteHumidityTimeseries( const Guid& absoluteHumidityTimeseries )
        {
            absoluteHumidityTimeseries_ = absoluteHumidityTimeseries;
        }
        const Guid& DewPointTimeseries( ) const
        {
            return dewPointTimeseries_;
        }
        void SetDewPointTimeseries( const Guid& dewPointTimeseries )
        {
            dewPointTimeseries_ = dewPointTimeseries;
        }
        const Guid& WindDirectionTimeseries( ) const
        {
            return windDirectionTimeseries_;
        }
        void SetWindDirectionTimeseries( const Guid& windDirectionTimeseries )
        {
            windDirectionTimeseries_ = windDirectionTimeseries;
        }
        const Guid& WindSpeedTimeseries( ) const
        {
            return windSpeedTimeseries_;
        }
        void SetWindSpeedTimeseries( const Guid& windSpeedTimeseries )
        {
            windSpeedTimeseries_ = windSpeedTimeseries;
        }
        const Guid& Gyro( ) const
        {
            return gyro_;
        }
        void SetGyro( const Guid& gyro )
        {
            gyro_ = gyro;
        }
        void BindColumns( const ODBC::Statement& statement )
        {
            Base::BindColumns( statement );

            Bind(statement, TYPE_FIELD_ID, type_);
            Bind(statement, BAROMETRICPRESSURETIMESERIES_FIELD_ID, barometricPressureTimeseries_);
            Bind(statement, AIRTEMPERATURETIMESERIES_FIELD_ID, airTemperatureTimeseries_);
            Bind(statement, WATERTEMPERATURETIMESERIES_FIELD_ID, waterTemperatureTimeseries_);
            Bind(statement, RELATIVEHUMIDITYTIMESERIES_FIELD_ID, relativeHumidityTimeseries_);
            Bind(statement, ABSOLUTEHUMIDITYTIMESERIES_FIELD_ID, absoluteHumidityTimeseries_);
            Bind(statement, DEWPOINTTIMESERIES_FIELD_ID, dewPointTimeseries_);
            Bind(statement, WINDDIRECTIONTIMESERIES_FIELD_ID, windDirectionTimeseries_);
            Bind(statement, WINDSPEEDTIMESERIES_FIELD_ID, windSpeedTimeseries_);
            Bind(statement, GYRO_FIELD_ID, gyro_);
        }

        template<IO::StreamWriter StreamT>
        void WriteColumns( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteColumns( destination );
            WriteColumnValue( destination, type_);
            WriteColumnValue( destination, barometricPressureTimeseries_);
            WriteColumnValue( destination, airTemperatureTimeseries_);
            WriteColumnValue( destination, waterTemperatureTimeseries_);
            WriteColumnValue( destination, relativeHumidityTimeseries_);
            WriteColumnValue( destination, absoluteHumidityTimeseries_);
            WriteColumnValue( destination, dewPointTimeseries_);
            WriteColumnValue( destination, windDirectionTimeseries_);
            WriteColumnValue( destination, windSpeedTimeseries_);
            WriteColumnValue( destination, gyro_);
        }
    };

    using SimpleWeatherStationDataReader = SimpleColumnDataReader<WeatherStationColumnData>;

    class FacilityColumnData : public ItemColumnData
    {
        FixedDBWideString<127> name_;
        Guid type_;
        double longitude_ = 0.0;
        double latitude_ = 0.0;
        double altitude_ = 0.0;
    public:
        using Base = ItemColumnData;

        static constexpr std::wstring_view FieldNames = L"[Id],[RowVersion],[Name],[Type],[Longitude],[Latitude],[Altitude]";
        static constexpr std::wstring_view ViewName = L"FacilityView";

        static constexpr SQLUSMALLINT NAME_FIELD_ID = 3;
        static constexpr SQLUSMALLINT TYPE_FIELD_ID = 4;
        static constexpr SQLUSMALLINT LONGITUDE_FIELD_ID = 5;
        static constexpr SQLUSMALLINT LATITUDE_FIELD_ID = 6;
        static constexpr SQLUSMALLINT ALTITUDE_FIELD_ID = 7;

        FacilityColumnData( ) = default;

        virtual Kind GetKind() const override
        {
            return Kind::Facility;
        }

        const FixedDBWideString<127>& Name( ) const
        {
            return name_;
        }
        void SetName( const WideString& name )
        {
            name_ = name;
        }
        const Guid& Type( ) const
        {
            return type_;
        }
        void SetType( const Guid& type )
        {
            type_ = type;
        }
        double Longitude( ) const
        {
            return longitude_;
        }
        void SetLongitude( double longitude )
        {
            longitude_ = longitude;
        }
        double Latitude( ) const
        {
            return latitude_;
        }
        void SetLatitude( double latitude )
        {
            latitude_ = latitude;
        }
        double Altitude( ) const
        {
            return altitude_;
        }
        void SetAltitude( double altitude )
        {
            altitude_ = altitude;
        }
        void BindColumns( const ODBC::Statement& statement )
        {
            Base::BindColumns( statement );

            Bind(statement, NAME_FIELD_ID, name_);
            Bind(statement, TYPE_FIELD_ID, type_);
            Bind(statement, LONGITUDE_FIELD_ID, longitude_);
            Bind(statement, LATITUDE_FIELD_ID, latitude_);
            Bind(statement, ALTITUDE_FIELD_ID, altitude_);
        }

        template<IO::StreamWriter StreamT>
        void WriteColumns( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteColumns( destination );
            WriteColumnValue( destination, name_);
            WriteColumnValue( destination, type_);
            WriteColumnValue( destination, longitude_);
            WriteColumnValue( destination, latitude_);
            WriteColumnValue( destination, altitude_);
        }
    };

    using SimpleFacilityDataReader = SimpleColumnDataReader<FacilityColumnData>;

    class TrackableItemColumnData : public ItemColumnData
    {
    public:
        using Base = ItemColumnData;

        static constexpr std::wstring_view FieldNames = L"[Id],[RowVersion]";
        static constexpr std::wstring_view ViewName = L"TrackableItemView";

        TrackableItemColumnData( ) = default;

        virtual Kind GetKind() const override
        {
            return Kind::TrackableItem;
        }

        template<IO::StreamWriter StreamT>
        void WriteColumns( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteColumns( destination );
        }
    };

    using SimpleTrackableItemDataReader = SimpleColumnDataReader<TrackableItemColumnData>;

    class AircraftColumnData : public TrackableItemColumnData
    {
        FixedDBWideString<127> name_;
        Guid type_;
    public:
        using Base = TrackableItemColumnData;

        static constexpr std::wstring_view FieldNames = L"[Id],[RowVersion],[Name],[Type]";
        static constexpr std::wstring_view ViewName = L"AircraftView";

        static constexpr SQLUSMALLINT NAME_FIELD_ID = 3;
        static constexpr SQLUSMALLINT TYPE_FIELD_ID = 4;

        AircraftColumnData( ) = default;

        virtual Kind GetKind() const override
        {
            return Kind::Aircraft;
        }

        const FixedDBWideString<127>& Name( ) const
        {
            return name_;
        }
        void SetName( const WideString& name )
        {
            name_ = name;
        }
        const Guid& Type( ) const
        {
            return type_;
        }
        void SetType( const Guid& type )
        {
            type_ = type;
        }
        void BindColumns( const ODBC::Statement& statement )
        {
            Base::BindColumns( statement );

            Bind(statement, NAME_FIELD_ID, name_);
            Bind(statement, TYPE_FIELD_ID, type_);
        }

        template<IO::StreamWriter StreamT>
        void WriteColumns( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteColumns( destination );
            WriteColumnValue( destination, name_);
            WriteColumnValue( destination, type_);
        }
    };

    using SimpleAircraftDataReader = SimpleColumnDataReader<AircraftColumnData>;

    class AisAidToNavigationColumnData : public TrackableItemColumnData
    {
        FixedDBWideString<127> name_;
        Guid mMSI_;
        Data::NavigationalAidType navigationalAidType_ = Data::NavigationalAidType::NotSpecified;
        Guid position_;
        bool isVirtual_ = false;
        Int32 toBow_ = 0;
        Int32 toStern_ = 0;
        Int32 toPort_ = 0;
        Int32 toStarboard_ = 0;
        Guid offPositionTimeseries_;
    public:
        using Base = TrackableItemColumnData;

        static constexpr std::wstring_view FieldNames = L"[Id],[RowVersion],[Name],[MMSI],[NavigationalAidType],[Position],[IsVirtual],[ToBow],[ToStern],[ToPort],[ToStarboard],[OffPositionTimeseries]";
        static constexpr std::wstring_view ViewName = L"AisAidToNavigationView";

        static constexpr SQLUSMALLINT NAME_FIELD_ID = 3;
        static constexpr SQLUSMALLINT MMSI_FIELD_ID = 4;
        static constexpr SQLUSMALLINT NAVIGATIONALAIDTYPE_FIELD_ID = 5;
        static constexpr SQLUSMALLINT POSITION_FIELD_ID = 6;
        static constexpr SQLUSMALLINT ISVIRTUAL_FIELD_ID = 7;
        static constexpr SQLUSMALLINT TOBOW_FIELD_ID = 8;
        static constexpr SQLUSMALLINT TOSTERN_FIELD_ID = 9;
        static constexpr SQLUSMALLINT TOPORT_FIELD_ID = 10;
        static constexpr SQLUSMALLINT TOSTARBOARD_FIELD_ID = 11;
        static constexpr SQLUSMALLINT OFFPOSITIONTIMESERIES_FIELD_ID = 12;

        AisAidToNavigationColumnData( ) = default;

        virtual Kind GetKind() const override
        {
            return Kind::AisAidToNavigation;
        }

        const FixedDBWideString<127>& Name( ) const
        {
            return name_;
        }
        void SetName( const WideString& name )
        {
            name_ = name;
        }
        const Guid& MMSI( ) const
        {
            return mMSI_;
        }
        void SetMMSI( const Guid& mMSI )
        {
            mMSI_ = mMSI;
        }
        Data::NavigationalAidType NavigationalAidType( ) const
        {
            return navigationalAidType_;
        }
        void SetNavigationalAidType( Data::NavigationalAidType navigationalAidType )
        {
            navigationalAidType_ = navigationalAidType;
        }
        const Guid& Position( ) const
        {
            return position_;
        }
        void SetPosition( const Guid& position )
        {
            position_ = position;
        }
        bool IsVirtual( ) const
        {
            return isVirtual_;
        }
        void SetIsVirtual( bool isVirtual )
        {
            isVirtual_ = isVirtual;
        }
        Int32 ToBow( ) const
        {
            return toBow_;
        }
        void SetToBow( Int32 toBow )
        {
            toBow_ = toBow;
        }
        Int32 ToStern( ) const
        {
            return toStern_;
        }
        void SetToStern( Int32 toStern )
        {
            toStern_ = toStern;
        }
        Int32 ToPort( ) const
        {
            return toPort_;
        }
        void SetToPort( Int32 toPort )
        {
            toPort_ = toPort;
        }
        Int32 ToStarboard( ) const
        {
            return toStarboard_;
        }
        void SetToStarboard( Int32 toStarboard )
        {
            toStarboard_ = toStarboard;
        }
        const Guid& OffPositionTimeseries( ) const
        {
            return offPositionTimeseries_;
        }
        void SetOffPositionTimeseries( const Guid& offPositionTimeseries )
        {
            offPositionTimeseries_ = offPositionTimeseries;
        }
        void BindColumns( const ODBC::Statement& statement )
        {
            Base::BindColumns( statement );

            Bind(statement, NAME_FIELD_ID, name_);
            Bind(statement, MMSI_FIELD_ID, mMSI_);
            Bind(statement, NAVIGATIONALAIDTYPE_FIELD_ID, navigationalAidType_);
            Bind(statement, POSITION_FIELD_ID, position_);
            Bind(statement, ISVIRTUAL_FIELD_ID, isVirtual_);
            Bind(statement, TOBOW_FIELD_ID, toBow_);
            Bind(statement, TOSTERN_FIELD_ID, toStern_);
            Bind(statement, TOPORT_FIELD_ID, toPort_);
            Bind(statement, TOSTARBOARD_FIELD_ID, toStarboard_);
            Bind(statement, OFFPOSITIONTIMESERIES_FIELD_ID, offPositionTimeseries_);
        }

        template<IO::StreamWriter StreamT>
        void WriteColumns( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteColumns( destination );
            WriteColumnValue( destination, name_);
            WriteColumnValue( destination, mMSI_);
            WriteColumnValue( destination, navigationalAidType_);
            WriteColumnValue( destination, position_);
            WriteColumnValue( destination, isVirtual_);
            WriteColumnValue( destination, toBow_);
            WriteColumnValue( destination, toStern_);
            WriteColumnValue( destination, toPort_);
            WriteColumnValue( destination, toStarboard_);
            WriteColumnValue( destination, offPositionTimeseries_);
        }
    };

    using SimpleAisAidToNavigationDataReader = SimpleColumnDataReader<AisAidToNavigationColumnData>;

    class VehicleColumnData : public TrackableItemColumnData
    {
        FixedDBWideString<127> name_;
        Guid type_;
    public:
        using Base = TrackableItemColumnData;

        static constexpr std::wstring_view FieldNames = L"[Id],[RowVersion],[Name],[Type]";
        static constexpr std::wstring_view ViewName = L"VehicleView";

        static constexpr SQLUSMALLINT NAME_FIELD_ID = 3;
        static constexpr SQLUSMALLINT TYPE_FIELD_ID = 4;

        VehicleColumnData( ) = default;

        virtual Kind GetKind() const override
        {
            return Kind::Vehicle;
        }

        const FixedDBWideString<127>& Name( ) const
        {
            return name_;
        }
        void SetName( const WideString& name )
        {
            name_ = name;
        }
        const Guid& Type( ) const
        {
            return type_;
        }
        void SetType( const Guid& type )
        {
            type_ = type;
        }
        void BindColumns( const ODBC::Statement& statement )
        {
            Base::BindColumns( statement );

            Bind(statement, NAME_FIELD_ID, name_);
            Bind(statement, TYPE_FIELD_ID, type_);
        }

        template<IO::StreamWriter StreamT>
        void WriteColumns( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteColumns( destination );
            WriteColumnValue( destination, name_);
            WriteColumnValue( destination, type_);
        }
    };

    using SimpleVehicleDataReader = SimpleColumnDataReader<VehicleColumnData>;

    class VesselColumnData : public TrackableItemColumnData
    {
        FixedDBWideString<127> name_;
        Guid type_;
        Int32 toBow_ = 0;
        Int32 toStern_ = 0;
        Int32 toPort_ = 0;
        Int32 toStarboard_ = 0;
        Guid draughtTimeseries_;
        Guid personsOnBoardTimeseries_;
    public:
        using Base = TrackableItemColumnData;

        static constexpr std::wstring_view FieldNames = L"[Id],[RowVersion],[Name],[Type],[ToBow],[ToStern],[ToPort],[ToStarboard],[DraughtTimeseries],[PersonsOnBoardTimeseries]";
        static constexpr std::wstring_view ViewName = L"VesselView";

        static constexpr SQLUSMALLINT NAME_FIELD_ID = 3;
        static constexpr SQLUSMALLINT TYPE_FIELD_ID = 4;
        static constexpr SQLUSMALLINT TOBOW_FIELD_ID = 5;
        static constexpr SQLUSMALLINT TOSTERN_FIELD_ID = 6;
        static constexpr SQLUSMALLINT TOPORT_FIELD_ID = 7;
        static constexpr SQLUSMALLINT TOSTARBOARD_FIELD_ID = 8;
        static constexpr SQLUSMALLINT DRAUGHTTIMESERIES_FIELD_ID = 9;
        static constexpr SQLUSMALLINT PERSONSONBOARDTIMESERIES_FIELD_ID = 10;

        VesselColumnData( ) = default;

        virtual Kind GetKind() const override
        {
            return Kind::Vessel;
        }

        const FixedDBWideString<127>& Name( ) const
        {
            return name_;
        }
        void SetName( const WideString& name )
        {
            name_ = name;
        }
        const Guid& Type( ) const
        {
            return type_;
        }
        void SetType( const Guid& type )
        {
            type_ = type;
        }
        Int32 ToBow( ) const
        {
            return toBow_;
        }
        void SetToBow( Int32 toBow )
        {
            toBow_ = toBow;
        }
        Int32 ToStern( ) const
        {
            return toStern_;
        }
        void SetToStern( Int32 toStern )
        {
            toStern_ = toStern;
        }
        Int32 ToPort( ) const
        {
            return toPort_;
        }
        void SetToPort( Int32 toPort )
        {
            toPort_ = toPort;
        }
        Int32 ToStarboard( ) const
        {
            return toStarboard_;
        }
        void SetToStarboard( Int32 toStarboard )
        {
            toStarboard_ = toStarboard;
        }
        const Guid& DraughtTimeseries( ) const
        {
            return draughtTimeseries_;
        }
        void SetDraughtTimeseries( const Guid& draughtTimeseries )
        {
            draughtTimeseries_ = draughtTimeseries;
        }
        const Guid& PersonsOnBoardTimeseries( ) const
        {
            return personsOnBoardTimeseries_;
        }
        void SetPersonsOnBoardTimeseries( const Guid& personsOnBoardTimeseries )
        {
            personsOnBoardTimeseries_ = personsOnBoardTimeseries;
        }
        void BindColumns( const ODBC::Statement& statement )
        {
            Base::BindColumns( statement );

            Bind(statement, NAME_FIELD_ID, name_);
            Bind(statement, TYPE_FIELD_ID, type_);
            Bind(statement, TOBOW_FIELD_ID, toBow_);
            Bind(statement, TOSTERN_FIELD_ID, toStern_);
            Bind(statement, TOPORT_FIELD_ID, toPort_);
            Bind(statement, TOSTARBOARD_FIELD_ID, toStarboard_);
            Bind(statement, DRAUGHTTIMESERIES_FIELD_ID, draughtTimeseries_);
            Bind(statement, PERSONSONBOARDTIMESERIES_FIELD_ID, personsOnBoardTimeseries_);
        }

        template<IO::StreamWriter StreamT>
        void WriteColumns( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteColumns( destination );
            WriteColumnValue( destination, name_);
            WriteColumnValue( destination, type_);
            WriteColumnValue( destination, toBow_);
            WriteColumnValue( destination, toStern_);
            WriteColumnValue( destination, toPort_);
            WriteColumnValue( destination, toStarboard_);
            WriteColumnValue( destination, draughtTimeseries_);
            WriteColumnValue( destination, personsOnBoardTimeseries_);
        }
    };

    using SimpleVesselDataReader = SimpleColumnDataReader<VesselColumnData>;

    class ItemIdentityLinkColumnData : public BaseColumnData
    {
        Guid id_;
        Int64 rowVersion_ = 0;
        Guid item_;
        Guid identity_;
        DateTime start_;
        DBDateTime end_;
    public:
        using Base = BaseColumnData;

        static constexpr std::wstring_view FieldNames = L"[Id],[RowVersion],[Item],[Identity],[Start],[End]";
        static constexpr std::wstring_view ViewName = L"ItemIdentityLinkView";

        static constexpr SQLUSMALLINT ID_FIELD_ID = 1;
        static constexpr SQLUSMALLINT ROWVERSION_FIELD_ID = 2;
        static constexpr SQLUSMALLINT ITEM_FIELD_ID = 3;
        static constexpr SQLUSMALLINT IDENTITY_FIELD_ID = 4;
        static constexpr SQLUSMALLINT START_FIELD_ID = 5;
        static constexpr SQLUSMALLINT END_FIELD_ID = 6;

        ItemIdentityLinkColumnData( ) = default;

        virtual Kind GetKind() const override
        {
            return Kind::ItemIdentityLink;
        }

        const Guid& Id( ) const
        {
            return id_;
        }
        void SetId( const Guid& id )
        {
            id_ = id;
        }
        Int64 RowVersion( ) const
        {
            return rowVersion_;
        }
        void SetRowVersion( const Int64& rowVersion )
        {
            rowVersion_ = rowVersion;
        }
        const Guid& Item( ) const
        {
            return item_;
        }
        void SetItem( const Guid& item )
        {
            item_ = item;
        }
        const Guid& Identity( ) const
        {
            return identity_;
        }
        void SetIdentity( const Guid& identity )
        {
            identity_ = identity;
        }
        const DateTime& Start( ) const
        {
            return start_;
        }
        void SetStart( const DateTime& start )
        {
            start_ = start;
        }
        const DBDateTime& End( ) const
        {
            return end_;
        }
        void SetEnd( const DBDateTime& end )
        {
            end_ = end;
        }
        void BindColumns( const ODBC::Statement& statement )
        {
            Bind(statement, ID_FIELD_ID, id_);
            Bind(statement, ROWVERSION_FIELD_ID, rowVersion_);
            Bind(statement, ITEM_FIELD_ID, item_);
            Bind(statement, IDENTITY_FIELD_ID, identity_);
            Bind(statement, START_FIELD_ID, start_);
            Bind(statement, END_FIELD_ID, end_);
        }

        template<IO::StreamWriter StreamT>
        void WriteColumns( IO::BinaryWriter<StreamT>& destination ) const
        {
            WriteColumnValue( destination, id_);
            WriteColumnValue( destination, rowVersion_);
            WriteColumnValue( destination, item_);
            WriteColumnValue( destination, identity_);
            WriteColumnValue( destination, start_);
            WriteColumnValue( destination, end_);
        }
    };

    using SimpleItemIdentityLinkDataReader = SimpleColumnDataReader<ItemIdentityLinkColumnData>;

    class ItemParentChildLinkColumnData : public BaseColumnData
    {
        Guid id_;
        Int64 rowVersion_ = 0;
        Guid parent_;
        Guid child_;
        DateTime timestamp_;
    public:
        using Base = BaseColumnData;

        static constexpr std::wstring_view FieldNames = L"[Id],[RowVersion],[Parent],[Child],[Timestamp]";
        static constexpr std::wstring_view ViewName = L"ItemParentChildLinkView";

        static constexpr SQLUSMALLINT ID_FIELD_ID = 1;
        static constexpr SQLUSMALLINT ROWVERSION_FIELD_ID = 2;
        static constexpr SQLUSMALLINT PARENT_FIELD_ID = 3;
        static constexpr SQLUSMALLINT CHILD_FIELD_ID = 4;
        static constexpr SQLUSMALLINT TIMESTAMP_FIELD_ID = 5;

        ItemParentChildLinkColumnData( ) = default;

        virtual Kind GetKind() const override
        {
            return Kind::ItemParentChildLink;
        }

        const Guid& Id( ) const
        {
            return id_;
        }
        void SetId( const Guid& id )
        {
            id_ = id;
        }
        Int64 RowVersion( ) const
        {
            return rowVersion_;
        }
        void SetRowVersion( const Int64& rowVersion )
        {
            rowVersion_ = rowVersion;
        }
        const Guid& Parent( ) const
        {
            return parent_;
        }
        void SetParent( const Guid& parent )
        {
            parent_ = parent;
        }
        const Guid& Child( ) const
        {
            return child_;
        }
        void SetChild( const Guid& child )
        {
            child_ = child;
        }
        const DateTime& Timestamp( ) const
        {
            return timestamp_;
        }
        void SetTimestamp( const DateTime& timestamp )
        {
            timestamp_ = timestamp;
        }
        void BindColumns( const ODBC::Statement& statement )
        {
            Bind(statement, ID_FIELD_ID, id_);
            Bind(statement, ROWVERSION_FIELD_ID, rowVersion_);
            Bind(statement, PARENT_FIELD_ID, parent_);
            Bind(statement, CHILD_FIELD_ID, child_);
            Bind(statement, TIMESTAMP_FIELD_ID, timestamp_);
        }

        template<IO::StreamWriter StreamT>
        void WriteColumns( IO::BinaryWriter<StreamT>& destination ) const
        {
            WriteColumnValue( destination, id_);
            WriteColumnValue( destination, rowVersion_);
            WriteColumnValue( destination, parent_);
            WriteColumnValue( destination, child_);
            WriteColumnValue( destination, timestamp_);
        }
    };

    using SimpleItemParentChildLinkDataReader = SimpleColumnDataReader<ItemParentChildLinkColumnData>;

    class LineInputDeviceCommandColumnData : public BaseColumnData
    {
        Guid id_;
        Int64 rowVersion_ = 0;
        Guid lineInputDevice_;
        DateTime timestamp_;
        Data::DeviceCommandSourceType deviceCommandSourceType_ = Data::DeviceCommandSourceType::Unknown;
        Guid deviceCommandSourceId_;
        Guid reply_;
    public:
        using Base = BaseColumnData;

        static constexpr std::wstring_view FieldNames = L"[Id],[RowVersion],[LineInputDevice],[Timestamp],[DeviceCommandSourceType],[DeviceCommandSourceId],[Reply]";
        static constexpr std::wstring_view ViewName = L"LineInputDeviceCommandView";

        static constexpr SQLUSMALLINT ID_FIELD_ID = 1;
        static constexpr SQLUSMALLINT ROWVERSION_FIELD_ID = 2;
        static constexpr SQLUSMALLINT LINEINPUTDEVICE_FIELD_ID = 3;
        static constexpr SQLUSMALLINT TIMESTAMP_FIELD_ID = 4;
        static constexpr SQLUSMALLINT DEVICECOMMANDSOURCETYPE_FIELD_ID = 5;
        static constexpr SQLUSMALLINT DEVICECOMMANDSOURCEID_FIELD_ID = 6;
        static constexpr SQLUSMALLINT REPLY_FIELD_ID = 7;

        LineInputDeviceCommandColumnData( ) = default;

        virtual Kind GetKind() const override
        {
            return Kind::LineInputDeviceCommand;
        }

        const Guid& Id( ) const
        {
            return id_;
        }
        void SetId( const Guid& id )
        {
            id_ = id;
        }
        Int64 RowVersion( ) const
        {
            return rowVersion_;
        }
        void SetRowVersion( const Int64& rowVersion )
        {
            rowVersion_ = rowVersion;
        }
        const Guid& LineInputDevice( ) const
        {
            return lineInputDevice_;
        }
        void SetLineInputDevice( const Guid& lineInputDevice )
        {
            lineInputDevice_ = lineInputDevice;
        }
        const DateTime& Timestamp( ) const
        {
            return timestamp_;
        }
        void SetTimestamp( const DateTime& timestamp )
        {
            timestamp_ = timestamp;
        }
        Data::DeviceCommandSourceType DeviceCommandSourceType( ) const
        {
            return deviceCommandSourceType_;
        }
        void SetDeviceCommandSourceType( Data::DeviceCommandSourceType deviceCommandSourceType )
        {
            deviceCommandSourceType_ = deviceCommandSourceType;
        }
        const Guid& DeviceCommandSourceId( ) const
        {
            return deviceCommandSourceId_;
        }
        void SetDeviceCommandSourceId( const Guid& deviceCommandSourceId )
        {
            deviceCommandSourceId_ = deviceCommandSourceId;
        }
        const Guid& Reply( ) const
        {
            return reply_;
        }
        void SetReply( const Guid& reply )
        {
            reply_ = reply;
        }
        void BindColumns( const ODBC::Statement& statement )
        {
            Bind(statement, ID_FIELD_ID, id_);
            Bind(statement, ROWVERSION_FIELD_ID, rowVersion_);
            Bind(statement, LINEINPUTDEVICE_FIELD_ID, lineInputDevice_);
            Bind(statement, TIMESTAMP_FIELD_ID, timestamp_);
            Bind(statement, DEVICECOMMANDSOURCETYPE_FIELD_ID, deviceCommandSourceType_);
            Bind(statement, DEVICECOMMANDSOURCEID_FIELD_ID, deviceCommandSourceId_);
            Bind(statement, REPLY_FIELD_ID, reply_);
        }

        template<IO::StreamWriter StreamT>
        void WriteColumns( IO::BinaryWriter<StreamT>& destination ) const
        {
            WriteColumnValue( destination, id_);
            WriteColumnValue( destination, rowVersion_);
            WriteColumnValue( destination, lineInputDevice_);
            WriteColumnValue( destination, timestamp_);
            WriteColumnValue( destination, deviceCommandSourceType_);
            WriteColumnValue( destination, deviceCommandSourceId_);
            WriteColumnValue( destination, reply_);
        }
    };

    using SimpleLineInputDeviceCommandDataReader = SimpleColumnDataReader<LineInputDeviceCommandColumnData>;

    class LineInputDeviceCommandReplyColumnData : public BaseColumnData
    {
        Guid id_;
        Int64 rowVersion_ = 0;
        Guid lineInputDevice_;
        DateTime timestamp_;
        Guid command_;
        Data::DeviceCommandReplyStatus status_ = Data::DeviceCommandReplyStatus::Unknown;
        WideString message_;
        SQLLEN messageLength_ = SQL_NULL_DATA;
    public:
        using Base = BaseColumnData;

        static constexpr std::wstring_view FieldNames = L"[Id],[RowVersion],[LineInputDevice],[Timestamp],[Command],[Status],[Message]";
        static constexpr std::wstring_view ViewName = L"LineInputDeviceCommandReplyView";

        static constexpr SQLUSMALLINT ID_FIELD_ID = 1;
        static constexpr SQLUSMALLINT ROWVERSION_FIELD_ID = 2;
        static constexpr SQLUSMALLINT LINEINPUTDEVICE_FIELD_ID = 3;
        static constexpr SQLUSMALLINT TIMESTAMP_FIELD_ID = 4;
        static constexpr SQLUSMALLINT COMMAND_FIELD_ID = 5;
        static constexpr SQLUSMALLINT STATUS_FIELD_ID = 6;
        static constexpr SQLUSMALLINT MESSAGE_FIELD_ID = 7;

        LineInputDeviceCommandReplyColumnData( ) = default;

        virtual Kind GetKind() const override
        {
            return Kind::LineInputDeviceCommandReply;
        }

        const Guid& Id( ) const
        {
            return id_;
        }
        void SetId( const Guid& id )
        {
            id_ = id;
        }
        Int64 RowVersion( ) const
        {
            return rowVersion_;
        }
        void SetRowVersion( const Int64& rowVersion )
        {
            rowVersion_ = rowVersion;
        }
        const Guid& LineInputDevice( ) const
        {
            return lineInputDevice_;
        }
        void SetLineInputDevice( const Guid& lineInputDevice )
        {
            lineInputDevice_ = lineInputDevice;
        }
        const DateTime& Timestamp( ) const
        {
            return timestamp_;
        }
        void SetTimestamp( const DateTime& timestamp )
        {
            timestamp_ = timestamp;
        }
        const Guid& Command( ) const
        {
            return command_;
        }
        void SetCommand( const Guid& command )
        {
            command_ = command;
        }
        Data::DeviceCommandReplyStatus Status( ) const
        {
            return status_;
        }
        void SetStatus( Data::DeviceCommandReplyStatus status )
        {
            status_ = status;
        }
        const WideString& Message( ) const
        {
            return message_;
        }
        void SetMessage( const WideString& message )
        {
            message_ = message;
        }
        void BindColumns( const ODBC::Statement& statement )
        {
            Bind(statement, ID_FIELD_ID, id_);
            Bind(statement, ROWVERSION_FIELD_ID, rowVersion_);
            Bind(statement, LINEINPUTDEVICE_FIELD_ID, lineInputDevice_);
            Bind(statement, TIMESTAMP_FIELD_ID, timestamp_);
            Bind(statement, COMMAND_FIELD_ID, command_);
            Bind(statement, STATUS_FIELD_ID, status_);
        }

        void ReadUnboundData( const ODBC::Statement& statement )
        {
            Base::ReadUnboundData( statement );

            message_ = statement.GetWideString(MESSAGE_FIELD_ID);
        }
        template<IO::StreamWriter StreamT>
        void WriteColumns( IO::BinaryWriter<StreamT>& destination ) const
        {
            WriteColumnValue( destination, id_);
            WriteColumnValue( destination, rowVersion_);
            WriteColumnValue( destination, lineInputDevice_);
            WriteColumnValue( destination, timestamp_);
            WriteColumnValue( destination, command_);
            WriteColumnValue( destination, status_);
            WriteColumnValue( destination, message_);
        }
    };

    using SimpleLineInputDeviceCommandReplyDataReader = SimpleColumnDataReader<LineInputDeviceCommandReplyColumnData>;

    class LineInputDeviceConfigurationColumnData : public BaseColumnData
    {
        Guid id_;
        Int64 rowVersion_ = 0;
        Guid lineInputDevice_;
        DateTime timestamp_;
        bool storeReceivedSentences_ = false;
        bool storeSentMessages_ = false;
        bool storeUnsentMessages_ = false;
        bool nMEA_ = false;
        bool strictNMEA_ = false;
        Data::LineInputDeviceConnectionType connectionType_ = Data::LineInputDeviceConnectionType::Unknown;
        Int32 udpReceivePort_ = 0;
        FixedDBWideString<100> udpSendHostname_;
        Int32 udpSendPort_ = 0;
        FixedDBWideString<100> tcpHostname_;
        Int32 tcpPort_ = 0;
        bool useHttpLogin_ = false;
        FixedDBWideString<100> loginHostname_;
        Int32 loginPort_ = 0;
        FixedDBWideString<100> userName_;
        FixedDBWideString<100> password_;
        FixedDBWideString<100> comPort_;
        Int32 baudRate_ = 0;
        Int32 dataBits_ = 0;
        bool discardNull_ = false;
        bool dtrEnable_ = false;
        Data::Handshake handshake_ = Data::Handshake::None;
        FixedDBWideString<100> newLine_;
        Data::Parity parity_ = Data::Parity::None;
        Byte parityReplace_ = 0;
        Int32 readBufferSize_ = 0;
        TimeSpan readTimeout_;
        Int32 receivedBytesThreshold_ = 0;
        bool rtsEnable_ = false;
        Data::StopBits stopBits_ = Data::StopBits::None;
        Int32 writeBufferSize_ = 0;
        TimeSpan writeTimeout_;
        FixedDBWideString<100> pairedComPort_;
    public:
        using Base = BaseColumnData;

        static constexpr std::wstring_view FieldNames = L"[Id],[RowVersion],[LineInputDevice],[Timestamp],[StoreReceivedSentences],[StoreSentMessages],[StoreUnsentMessages],[NMEA],[StrictNMEA],[ConnectionType],[UdpReceivePort],[UdpSendHostname],[UdpSendPort],[TcpHostname],[TcpPort],[UseHttpLogin],[LoginHostname],[LoginPort],[UserName],[Password],[ComPort],[BaudRate],[DataBits],[DiscardNull],[DtrEnable],[Handshake],[NewLine],[Parity],[ParityReplace],[ReadBufferSize],[ReadTimeout],[ReceivedBytesThreshold],[RtsEnable],[StopBits],[WriteBufferSize],[WriteTimeout],[PairedComPort]";
        static constexpr std::wstring_view ViewName = L"LineInputDeviceConfigurationView";

        static constexpr SQLUSMALLINT ID_FIELD_ID = 1;
        static constexpr SQLUSMALLINT ROWVERSION_FIELD_ID = 2;
        static constexpr SQLUSMALLINT LINEINPUTDEVICE_FIELD_ID = 3;
        static constexpr SQLUSMALLINT TIMESTAMP_FIELD_ID = 4;
        static constexpr SQLUSMALLINT STORERECEIVEDSENTENCES_FIELD_ID = 5;
        static constexpr SQLUSMALLINT STORESENTMESSAGES_FIELD_ID = 6;
        static constexpr SQLUSMALLINT STOREUNSENTMESSAGES_FIELD_ID = 7;
        static constexpr SQLUSMALLINT NMEA_FIELD_ID = 8;
        static constexpr SQLUSMALLINT STRICTNMEA_FIELD_ID = 9;
        static constexpr SQLUSMALLINT CONNECTIONTYPE_FIELD_ID = 10;
        static constexpr SQLUSMALLINT UDPRECEIVEPORT_FIELD_ID = 11;
        static constexpr SQLUSMALLINT UDPSENDHOSTNAME_FIELD_ID = 12;
        static constexpr SQLUSMALLINT UDPSENDPORT_FIELD_ID = 13;
        static constexpr SQLUSMALLINT TCPHOSTNAME_FIELD_ID = 14;
        static constexpr SQLUSMALLINT TCPPORT_FIELD_ID = 15;
        static constexpr SQLUSMALLINT USEHTTPLOGIN_FIELD_ID = 16;
        static constexpr SQLUSMALLINT LOGINHOSTNAME_FIELD_ID = 17;
        static constexpr SQLUSMALLINT LOGINPORT_FIELD_ID = 18;
        static constexpr SQLUSMALLINT USERNAME_FIELD_ID = 19;
        static constexpr SQLUSMALLINT PASSWORD_FIELD_ID = 20;
        static constexpr SQLUSMALLINT COMPORT_FIELD_ID = 21;
        static constexpr SQLUSMALLINT BAUDRATE_FIELD_ID = 22;
        static constexpr SQLUSMALLINT DATABITS_FIELD_ID = 23;
        static constexpr SQLUSMALLINT DISCARDNULL_FIELD_ID = 24;
        static constexpr SQLUSMALLINT DTRENABLE_FIELD_ID = 25;
        static constexpr SQLUSMALLINT HANDSHAKE_FIELD_ID = 26;
        static constexpr SQLUSMALLINT NEWLINE_FIELD_ID = 27;
        static constexpr SQLUSMALLINT PARITY_FIELD_ID = 28;
        static constexpr SQLUSMALLINT PARITYREPLACE_FIELD_ID = 29;
        static constexpr SQLUSMALLINT READBUFFERSIZE_FIELD_ID = 30;
        static constexpr SQLUSMALLINT READTIMEOUT_FIELD_ID = 31;
        static constexpr SQLUSMALLINT RECEIVEDBYTESTHRESHOLD_FIELD_ID = 32;
        static constexpr SQLUSMALLINT RTSENABLE_FIELD_ID = 33;
        static constexpr SQLUSMALLINT STOPBITS_FIELD_ID = 34;
        static constexpr SQLUSMALLINT WRITEBUFFERSIZE_FIELD_ID = 35;
        static constexpr SQLUSMALLINT WRITETIMEOUT_FIELD_ID = 36;
        static constexpr SQLUSMALLINT PAIREDCOMPORT_FIELD_ID = 37;

        LineInputDeviceConfigurationColumnData( ) = default;

        virtual Kind GetKind() const override
        {
            return Kind::LineInputDeviceConfiguration;
        }

        const Guid& Id( ) const
        {
            return id_;
        }
        void SetId( const Guid& id )
        {
            id_ = id;
        }
        Int64 RowVersion( ) const
        {
            return rowVersion_;
        }
        void SetRowVersion( const Int64& rowVersion )
        {
            rowVersion_ = rowVersion;
        }
        const Guid& LineInputDevice( ) const
        {
            return lineInputDevice_;
        }
        void SetLineInputDevice( const Guid& lineInputDevice )
        {
            lineInputDevice_ = lineInputDevice;
        }
        const DateTime& Timestamp( ) const
        {
            return timestamp_;
        }
        void SetTimestamp( const DateTime& timestamp )
        {
            timestamp_ = timestamp;
        }
        bool StoreReceivedSentences( ) const
        {
            return storeReceivedSentences_;
        }
        void SetStoreReceivedSentences( bool storeReceivedSentences )
        {
            storeReceivedSentences_ = storeReceivedSentences;
        }
        bool StoreSentMessages( ) const
        {
            return storeSentMessages_;
        }
        void SetStoreSentMessages( bool storeSentMessages )
        {
            storeSentMessages_ = storeSentMessages;
        }
        bool StoreUnsentMessages( ) const
        {
            return storeUnsentMessages_;
        }
        void SetStoreUnsentMessages( bool storeUnsentMessages )
        {
            storeUnsentMessages_ = storeUnsentMessages;
        }
        bool NMEA( ) const
        {
            return nMEA_;
        }
        void SetNMEA( bool nMEA )
        {
            nMEA_ = nMEA;
        }
        bool StrictNMEA( ) const
        {
            return strictNMEA_;
        }
        void SetStrictNMEA( bool strictNMEA )
        {
            strictNMEA_ = strictNMEA;
        }
        Data::LineInputDeviceConnectionType ConnectionType( ) const
        {
            return connectionType_;
        }
        void SetConnectionType( Data::LineInputDeviceConnectionType connectionType )
        {
            connectionType_ = connectionType;
        }
        Int32 UdpReceivePort( ) const
        {
            return udpReceivePort_;
        }
        void SetUdpReceivePort( Int32 udpReceivePort )
        {
            udpReceivePort_ = udpReceivePort;
        }
        const FixedDBWideString<100>& UdpSendHostname( ) const
        {
            return udpSendHostname_;
        }
        void SetUdpSendHostname( const WideString& udpSendHostname )
        {
            udpSendHostname_ = udpSendHostname;
        }
        Int32 UdpSendPort( ) const
        {
            return udpSendPort_;
        }
        void SetUdpSendPort( Int32 udpSendPort )
        {
            udpSendPort_ = udpSendPort;
        }
        const FixedDBWideString<100>& TcpHostname( ) const
        {
            return tcpHostname_;
        }
        void SetTcpHostname( const WideString& tcpHostname )
        {
            tcpHostname_ = tcpHostname;
        }
        Int32 TcpPort( ) const
        {
            return tcpPort_;
        }
        void SetTcpPort( Int32 tcpPort )
        {
            tcpPort_ = tcpPort;
        }
        bool UseHttpLogin( ) const
        {
            return useHttpLogin_;
        }
        void SetUseHttpLogin( bool useHttpLogin )
        {
            useHttpLogin_ = useHttpLogin;
        }
        const FixedDBWideString<100>& LoginHostname( ) const
        {
            return loginHostname_;
        }
        void SetLoginHostname( const WideString& loginHostname )
        {
            loginHostname_ = loginHostname;
        }
        Int32 LoginPort( ) const
        {
            return loginPort_;
        }
        void SetLoginPort( Int32 loginPort )
        {
            loginPort_ = loginPort;
        }
        const FixedDBWideString<100>& UserName( ) const
        {
            return userName_;
        }
        void SetUserName( const WideString& userName )
        {
            userName_ = userName;
        }
        const FixedDBWideString<100>& Password( ) const
        {
            return password_;
        }
        void SetPassword( const WideString& password )
        {
            password_ = password;
        }
        const FixedDBWideString<100>& ComPort( ) const
        {
            return comPort_;
        }
        void SetComPort( const WideString& comPort )
        {
            comPort_ = comPort;
        }
        Int32 BaudRate( ) const
        {
            return baudRate_;
        }
        void SetBaudRate( Int32 baudRate )
        {
            baudRate_ = baudRate;
        }
        Int32 DataBits( ) const
        {
            return dataBits_;
        }
        void SetDataBits( Int32 dataBits )
        {
            dataBits_ = dataBits;
        }
        bool DiscardNull( ) const
        {
            return discardNull_;
        }
        void SetDiscardNull( bool discardNull )
        {
            discardNull_ = discardNull;
        }
        bool DtrEnable( ) const
        {
            return dtrEnable_;
        }
        void SetDtrEnable( bool dtrEnable )
        {
            dtrEnable_ = dtrEnable;
        }
        Data::Handshake Handshake( ) const
        {
            return handshake_;
        }
        void SetHandshake( Data::Handshake handshake )
        {
            handshake_ = handshake;
        }
        const FixedDBWideString<100>& NewLine( ) const
        {
            return newLine_;
        }
        void SetNewLine( const WideString& newLine )
        {
            newLine_ = newLine;
        }
        Data::Parity Parity( ) const
        {
            return parity_;
        }
        void SetParity( Data::Parity parity )
        {
            parity_ = parity;
        }
        Byte ParityReplace( ) const
        {
            return parityReplace_;
        }
        void SetParityReplace( Byte parityReplace )
        {
            parityReplace_ = parityReplace;
        }
        Int32 ReadBufferSize( ) const
        {
            return readBufferSize_;
        }
        void SetReadBufferSize( Int32 readBufferSize )
        {
            readBufferSize_ = readBufferSize;
        }
        const TimeSpan& ReadTimeout( ) const
        {
            return readTimeout_;
        }
        void SetReadTimeout( const TimeSpan& readTimeout )
        {
            readTimeout_ = readTimeout;
        }
        Int32 ReceivedBytesThreshold( ) const
        {
            return receivedBytesThreshold_;
        }
        void SetReceivedBytesThreshold( Int32 receivedBytesThreshold )
        {
            receivedBytesThreshold_ = receivedBytesThreshold;
        }
        bool RtsEnable( ) const
        {
            return rtsEnable_;
        }
        void SetRtsEnable( bool rtsEnable )
        {
            rtsEnable_ = rtsEnable;
        }
        Data::StopBits StopBits( ) const
        {
            return stopBits_;
        }
        void SetStopBits( Data::StopBits stopBits )
        {
            stopBits_ = stopBits;
        }
        Int32 WriteBufferSize( ) const
        {
            return writeBufferSize_;
        }
        void SetWriteBufferSize( Int32 writeBufferSize )
        {
            writeBufferSize_ = writeBufferSize;
        }
        const TimeSpan& WriteTimeout( ) const
        {
            return writeTimeout_;
        }
        void SetWriteTimeout( const TimeSpan& writeTimeout )
        {
            writeTimeout_ = writeTimeout;
        }
        const FixedDBWideString<100>& PairedComPort( ) const
        {
            return pairedComPort_;
        }
        void SetPairedComPort( const WideString& pairedComPort )
        {
            pairedComPort_ = pairedComPort;
        }
        void BindColumns( const ODBC::Statement& statement )
        {
            Bind(statement, ID_FIELD_ID, id_);
            Bind(statement, ROWVERSION_FIELD_ID, rowVersion_);
            Bind(statement, LINEINPUTDEVICE_FIELD_ID, lineInputDevice_);
            Bind(statement, TIMESTAMP_FIELD_ID, timestamp_);
            Bind(statement, STORERECEIVEDSENTENCES_FIELD_ID, storeReceivedSentences_);
            Bind(statement, STORESENTMESSAGES_FIELD_ID, storeSentMessages_);
            Bind(statement, STOREUNSENTMESSAGES_FIELD_ID, storeUnsentMessages_);
            Bind(statement, NMEA_FIELD_ID, nMEA_);
            Bind(statement, STRICTNMEA_FIELD_ID, strictNMEA_);
            Bind(statement, CONNECTIONTYPE_FIELD_ID, connectionType_);
            Bind(statement, UDPRECEIVEPORT_FIELD_ID, udpReceivePort_);
            Bind(statement, UDPSENDHOSTNAME_FIELD_ID, udpSendHostname_);
            Bind(statement, UDPSENDPORT_FIELD_ID, udpSendPort_);
            Bind(statement, TCPHOSTNAME_FIELD_ID, tcpHostname_);
            Bind(statement, TCPPORT_FIELD_ID, tcpPort_);
            Bind(statement, USEHTTPLOGIN_FIELD_ID, useHttpLogin_);
            Bind(statement, LOGINHOSTNAME_FIELD_ID, loginHostname_);
            Bind(statement, LOGINPORT_FIELD_ID, loginPort_);
            Bind(statement, USERNAME_FIELD_ID, userName_);
            Bind(statement, PASSWORD_FIELD_ID, password_);
            Bind(statement, COMPORT_FIELD_ID, comPort_);
            Bind(statement, BAUDRATE_FIELD_ID, baudRate_);
            Bind(statement, DATABITS_FIELD_ID, dataBits_);
            Bind(statement, DISCARDNULL_FIELD_ID, discardNull_);
            Bind(statement, DTRENABLE_FIELD_ID, dtrEnable_);
            Bind(statement, HANDSHAKE_FIELD_ID, handshake_);
            Bind(statement, NEWLINE_FIELD_ID, newLine_);
            Bind(statement, PARITY_FIELD_ID, parity_);
            Bind(statement, PARITYREPLACE_FIELD_ID, parityReplace_);
            Bind(statement, READBUFFERSIZE_FIELD_ID, readBufferSize_);
            Bind(statement, READTIMEOUT_FIELD_ID, readTimeout_);
            Bind(statement, RECEIVEDBYTESTHRESHOLD_FIELD_ID, receivedBytesThreshold_);
            Bind(statement, RTSENABLE_FIELD_ID, rtsEnable_);
            Bind(statement, STOPBITS_FIELD_ID, stopBits_);
            Bind(statement, WRITEBUFFERSIZE_FIELD_ID, writeBufferSize_);
            Bind(statement, WRITETIMEOUT_FIELD_ID, writeTimeout_);
            Bind(statement, PAIREDCOMPORT_FIELD_ID, pairedComPort_);
        }

        template<IO::StreamWriter StreamT>
        void WriteColumns( IO::BinaryWriter<StreamT>& destination ) const
        {
            WriteColumnValue( destination, id_);
            WriteColumnValue( destination, rowVersion_);
            WriteColumnValue( destination, lineInputDevice_);
            WriteColumnValue( destination, timestamp_);
            WriteColumnValue( destination, storeReceivedSentences_);
            WriteColumnValue( destination, storeSentMessages_);
            WriteColumnValue( destination, storeUnsentMessages_);
            WriteColumnValue( destination, nMEA_);
            WriteColumnValue( destination, strictNMEA_);
            WriteColumnValue( destination, connectionType_);
            WriteColumnValue( destination, udpReceivePort_);
            WriteColumnValue( destination, udpSendHostname_);
            WriteColumnValue( destination, udpSendPort_);
            WriteColumnValue( destination, tcpHostname_);
            WriteColumnValue( destination, tcpPort_);
            WriteColumnValue( destination, useHttpLogin_);
            WriteColumnValue( destination, loginHostname_);
            WriteColumnValue( destination, loginPort_);
            WriteColumnValue( destination, userName_);
            WriteColumnValue( destination, password_);
            WriteColumnValue( destination, comPort_);
            WriteColumnValue( destination, baudRate_);
            WriteColumnValue( destination, dataBits_);
            WriteColumnValue( destination, discardNull_);
            WriteColumnValue( destination, dtrEnable_);
            WriteColumnValue( destination, handshake_);
            WriteColumnValue( destination, newLine_);
            WriteColumnValue( destination, parity_);
            WriteColumnValue( destination, parityReplace_);
            WriteColumnValue( destination, readBufferSize_);
            WriteColumnValue( destination, readTimeout_);
            WriteColumnValue( destination, receivedBytesThreshold_);
            WriteColumnValue( destination, rtsEnable_);
            WriteColumnValue( destination, stopBits_);
            WriteColumnValue( destination, writeBufferSize_);
            WriteColumnValue( destination, writeTimeout_);
            WriteColumnValue( destination, pairedComPort_);
        }
    };

    using SimpleLineInputDeviceConfigurationDataReader = SimpleColumnDataReader<LineInputDeviceConfigurationColumnData>;

    class LineInputMessageRoutingColumnData : public BaseColumnData
    {
        Guid id_;
        Int64 rowVersion_ = 0;
        Guid lineInputDevice_;
        FixedDBWideString<100> type_;
    public:
        using Base = BaseColumnData;

        static constexpr std::wstring_view FieldNames = L"[Id],[RowVersion],[LineInputDevice],[Type]";
        static constexpr std::wstring_view ViewName = L"LineInputMessageRoutingView";

        static constexpr SQLUSMALLINT ID_FIELD_ID = 1;
        static constexpr SQLUSMALLINT ROWVERSION_FIELD_ID = 2;
        static constexpr SQLUSMALLINT LINEINPUTDEVICE_FIELD_ID = 3;
        static constexpr SQLUSMALLINT TYPE_FIELD_ID = 4;

        LineInputMessageRoutingColumnData( ) = default;

        virtual Kind GetKind() const override
        {
            return Kind::LineInputMessageRouting;
        }

        const Guid& Id( ) const
        {
            return id_;
        }
        void SetId( const Guid& id )
        {
            id_ = id;
        }
        Int64 RowVersion( ) const
        {
            return rowVersion_;
        }
        void SetRowVersion( const Int64& rowVersion )
        {
            rowVersion_ = rowVersion;
        }
        const Guid& LineInputDevice( ) const
        {
            return lineInputDevice_;
        }
        void SetLineInputDevice( const Guid& lineInputDevice )
        {
            lineInputDevice_ = lineInputDevice;
        }
        const FixedDBWideString<100>& Type( ) const
        {
            return type_;
        }
        void SetType( const WideString& type )
        {
            type_ = type;
        }
        void BindColumns( const ODBC::Statement& statement )
        {
            Bind(statement, ID_FIELD_ID, id_);
            Bind(statement, ROWVERSION_FIELD_ID, rowVersion_);
            Bind(statement, LINEINPUTDEVICE_FIELD_ID, lineInputDevice_);
            Bind(statement, TYPE_FIELD_ID, type_);
        }

        template<IO::StreamWriter StreamT>
        void WriteColumns( IO::BinaryWriter<StreamT>& destination ) const
        {
            WriteColumnValue( destination, id_);
            WriteColumnValue( destination, rowVersion_);
            WriteColumnValue( destination, lineInputDevice_);
            WriteColumnValue( destination, type_);
        }
    };

    using SimpleLineInputMessageRoutingDataReader = SimpleColumnDataReader<LineInputMessageRoutingColumnData>;

    class LineInputMessageRoutingDestinationColumnData : public BaseColumnData
    {
        Guid id_;
        Int64 rowVersion_ = 0;
        Guid routing_;
        Guid listener_;
    public:
        using Base = BaseColumnData;

        static constexpr std::wstring_view FieldNames = L"[Id],[RowVersion],[Routing],[Listener]";
        static constexpr std::wstring_view ViewName = L"LineInputMessageRoutingDestinationView";

        static constexpr SQLUSMALLINT ID_FIELD_ID = 1;
        static constexpr SQLUSMALLINT ROWVERSION_FIELD_ID = 2;
        static constexpr SQLUSMALLINT ROUTING_FIELD_ID = 3;
        static constexpr SQLUSMALLINT LISTENER_FIELD_ID = 4;

        LineInputMessageRoutingDestinationColumnData( ) = default;

        virtual Kind GetKind() const override
        {
            return Kind::LineInputMessageRoutingDestination;
        }

        const Guid& Id( ) const
        {
            return id_;
        }
        void SetId( const Guid& id )
        {
            id_ = id;
        }
        Int64 RowVersion( ) const
        {
            return rowVersion_;
        }
        void SetRowVersion( const Int64& rowVersion )
        {
            rowVersion_ = rowVersion;
        }
        const Guid& Routing( ) const
        {
            return routing_;
        }
        void SetRouting( const Guid& routing )
        {
            routing_ = routing;
        }
        const Guid& Listener( ) const
        {
            return listener_;
        }
        void SetListener( const Guid& listener )
        {
            listener_ = listener;
        }
        void BindColumns( const ODBC::Statement& statement )
        {
            Bind(statement, ID_FIELD_ID, id_);
            Bind(statement, ROWVERSION_FIELD_ID, rowVersion_);
            Bind(statement, ROUTING_FIELD_ID, routing_);
            Bind(statement, LISTENER_FIELD_ID, listener_);
        }

        template<IO::StreamWriter StreamT>
        void WriteColumns( IO::BinaryWriter<StreamT>& destination ) const
        {
            WriteColumnValue( destination, id_);
            WriteColumnValue( destination, rowVersion_);
            WriteColumnValue( destination, routing_);
            WriteColumnValue( destination, listener_);
        }
    };

    using SimpleLineInputMessageRoutingDestinationDataReader = SimpleColumnDataReader<LineInputMessageRoutingDestinationColumnData>;

    class LineInputWhiteListEntryColumnData : public BaseColumnData
    {
        Guid id_;
        Int64 rowVersion_ = 0;
        Guid lineInputDevice_;
        FixedDBWideString<128> hostName_;
        Int32 port_ = 0;
    public:
        using Base = BaseColumnData;

        static constexpr std::wstring_view FieldNames = L"[Id],[RowVersion],[LineInputDevice],[HostName],[Port]";
        static constexpr std::wstring_view ViewName = L"LineInputWhiteListEntryView";

        static constexpr SQLUSMALLINT ID_FIELD_ID = 1;
        static constexpr SQLUSMALLINT ROWVERSION_FIELD_ID = 2;
        static constexpr SQLUSMALLINT LINEINPUTDEVICE_FIELD_ID = 3;
        static constexpr SQLUSMALLINT HOSTNAME_FIELD_ID = 4;
        static constexpr SQLUSMALLINT PORT_FIELD_ID = 5;

        LineInputWhiteListEntryColumnData( ) = default;

        virtual Kind GetKind() const override
        {
            return Kind::LineInputWhiteListEntry;
        }

        const Guid& Id( ) const
        {
            return id_;
        }
        void SetId( const Guid& id )
        {
            id_ = id;
        }
        Int64 RowVersion( ) const
        {
            return rowVersion_;
        }
        void SetRowVersion( const Int64& rowVersion )
        {
            rowVersion_ = rowVersion;
        }
        const Guid& LineInputDevice( ) const
        {
            return lineInputDevice_;
        }
        void SetLineInputDevice( const Guid& lineInputDevice )
        {
            lineInputDevice_ = lineInputDevice;
        }
        const FixedDBWideString<128>& HostName( ) const
        {
            return hostName_;
        }
        void SetHostName( const WideString& hostName )
        {
            hostName_ = hostName;
        }
        Int32 Port( ) const
        {
            return port_;
        }
        void SetPort( Int32 port )
        {
            port_ = port;
        }
        void BindColumns( const ODBC::Statement& statement )
        {
            Bind(statement, ID_FIELD_ID, id_);
            Bind(statement, ROWVERSION_FIELD_ID, rowVersion_);
            Bind(statement, LINEINPUTDEVICE_FIELD_ID, lineInputDevice_);
            Bind(statement, HOSTNAME_FIELD_ID, hostName_);
            Bind(statement, PORT_FIELD_ID, port_);
        }

        template<IO::StreamWriter StreamT>
        void WriteColumns( IO::BinaryWriter<StreamT>& destination ) const
        {
            WriteColumnValue( destination, id_);
            WriteColumnValue( destination, rowVersion_);
            WriteColumnValue( destination, lineInputDevice_);
            WriteColumnValue( destination, hostName_);
            WriteColumnValue( destination, port_);
        }
    };

    using SimpleLineInputWhiteListEntryDataReader = SimpleColumnDataReader<LineInputWhiteListEntryColumnData>;

    class LogApplicationColumnData : public BaseColumnData
    {
        Guid id_;
        Int64 rowVersion_ = 0;
        FixedDBWideString<127> name_;
        WideString description_;
        SQLLEN descriptionLength_ = SQL_NULL_DATA;
    public:
        using Base = BaseColumnData;

        static constexpr std::wstring_view FieldNames = L"[Id],[RowVersion],[Name],[Description]";
        static constexpr std::wstring_view ViewName = L"LogApplicationView";

        static constexpr SQLUSMALLINT ID_FIELD_ID = 1;
        static constexpr SQLUSMALLINT ROWVERSION_FIELD_ID = 2;
        static constexpr SQLUSMALLINT NAME_FIELD_ID = 3;
        static constexpr SQLUSMALLINT DESCRIPTION_FIELD_ID = 4;

        LogApplicationColumnData( ) = default;

        virtual Kind GetKind() const override
        {
            return Kind::LogApplication;
        }

        const Guid& Id( ) const
        {
            return id_;
        }
        void SetId( const Guid& id )
        {
            id_ = id;
        }
        Int64 RowVersion( ) const
        {
            return rowVersion_;
        }
        void SetRowVersion( const Int64& rowVersion )
        {
            rowVersion_ = rowVersion;
        }
        const FixedDBWideString<127>& Name( ) const
        {
            return name_;
        }
        void SetName( const WideString& name )
        {
            name_ = name;
        }
        const WideString& Description( ) const
        {
            return description_;
        }
        void SetDescription( const WideString& description )
        {
            description_ = description;
        }
        void BindColumns( const ODBC::Statement& statement )
        {
            Bind(statement, ID_FIELD_ID, id_);
            Bind(statement, ROWVERSION_FIELD_ID, rowVersion_);
            Bind(statement, NAME_FIELD_ID, name_);
        }

        void ReadUnboundData( const ODBC::Statement& statement )
        {
            Base::ReadUnboundData( statement );

            description_ = statement.GetWideString(DESCRIPTION_FIELD_ID);
        }
        template<IO::StreamWriter StreamT>
        void WriteColumns( IO::BinaryWriter<StreamT>& destination ) const
        {
            WriteColumnValue( destination, id_);
            WriteColumnValue( destination, rowVersion_);
            WriteColumnValue( destination, name_);
            WriteColumnValue( destination, description_);
        }
    };

    using SimpleLogApplicationDataReader = SimpleColumnDataReader<LogApplicationColumnData>;

    class LogApplicationConfigurationColumnData : public BaseColumnData
    {
        Guid id_;
        Int64 rowVersion_ = 0;
        Guid application_;
        DateTime timestamp_;
        bool finest_ = false;
        bool finer_ = false;
        bool fine_ = false;
        bool info_ = false;
        bool notice_ = false;
        bool warn_ = false;
        bool error_ = false;
        bool severe_ = false;
        bool critical_ = false;
        bool alert_ = false;
        bool fatal_ = false;
        bool emergency_ = false;
    public:
        using Base = BaseColumnData;

        static constexpr std::wstring_view FieldNames = L"[Id],[RowVersion],[Application],[Timestamp],[Finest],[Finer],[Fine],[Info],[Notice],[Warn],[Error],[Severe],[Critical],[Alert],[Fatal],[Emergency]";
        static constexpr std::wstring_view ViewName = L"LogApplicationConfigurationView";

        static constexpr SQLUSMALLINT ID_FIELD_ID = 1;
        static constexpr SQLUSMALLINT ROWVERSION_FIELD_ID = 2;
        static constexpr SQLUSMALLINT APPLICATION_FIELD_ID = 3;
        static constexpr SQLUSMALLINT TIMESTAMP_FIELD_ID = 4;
        static constexpr SQLUSMALLINT FINEST_FIELD_ID = 5;
        static constexpr SQLUSMALLINT FINER_FIELD_ID = 6;
        static constexpr SQLUSMALLINT FINE_FIELD_ID = 7;
        static constexpr SQLUSMALLINT INFO_FIELD_ID = 8;
        static constexpr SQLUSMALLINT NOTICE_FIELD_ID = 9;
        static constexpr SQLUSMALLINT WARN_FIELD_ID = 10;
        static constexpr SQLUSMALLINT ERROR_FIELD_ID = 11;
        static constexpr SQLUSMALLINT SEVERE_FIELD_ID = 12;
        static constexpr SQLUSMALLINT CRITICAL_FIELD_ID = 13;
        static constexpr SQLUSMALLINT ALERT_FIELD_ID = 14;
        static constexpr SQLUSMALLINT FATAL_FIELD_ID = 15;
        static constexpr SQLUSMALLINT EMERGENCY_FIELD_ID = 16;

        LogApplicationConfigurationColumnData( ) = default;

        virtual Kind GetKind() const override
        {
            return Kind::LogApplicationConfiguration;
        }

        const Guid& Id( ) const
        {
            return id_;
        }
        void SetId( const Guid& id )
        {
            id_ = id;
        }
        Int64 RowVersion( ) const
        {
            return rowVersion_;
        }
        void SetRowVersion( const Int64& rowVersion )
        {
            rowVersion_ = rowVersion;
        }
        const Guid& Application( ) const
        {
            return application_;
        }
        void SetApplication( const Guid& application )
        {
            application_ = application;
        }
        const DateTime& Timestamp( ) const
        {
            return timestamp_;
        }
        void SetTimestamp( const DateTime& timestamp )
        {
            timestamp_ = timestamp;
        }
        bool Finest( ) const
        {
            return finest_;
        }
        void SetFinest( bool finest )
        {
            finest_ = finest;
        }
        bool Finer( ) const
        {
            return finer_;
        }
        void SetFiner( bool finer )
        {
            finer_ = finer;
        }
        bool Fine( ) const
        {
            return fine_;
        }
        void SetFine( bool fine )
        {
            fine_ = fine;
        }
        bool Info( ) const
        {
            return info_;
        }
        void SetInfo( bool info )
        {
            info_ = info;
        }
        bool Notice( ) const
        {
            return notice_;
        }
        void SetNotice( bool notice )
        {
            notice_ = notice;
        }
        bool Warn( ) const
        {
            return warn_;
        }
        void SetWarn( bool warn )
        {
            warn_ = warn;
        }
        bool Error( ) const
        {
            return error_;
        }
        void SetError( bool error )
        {
            error_ = error;
        }
        bool Severe( ) const
        {
            return severe_;
        }
        void SetSevere( bool severe )
        {
            severe_ = severe;
        }
        bool Critical( ) const
        {
            return critical_;
        }
        void SetCritical( bool critical )
        {
            critical_ = critical;
        }
        bool Alert( ) const
        {
            return alert_;
        }
        void SetAlert( bool alert )
        {
            alert_ = alert;
        }
        bool Fatal( ) const
        {
            return fatal_;
        }
        void SetFatal( bool fatal )
        {
            fatal_ = fatal;
        }
        bool Emergency( ) const
        {
            return emergency_;
        }
        void SetEmergency( bool emergency )
        {
            emergency_ = emergency;
        }
        void BindColumns( const ODBC::Statement& statement )
        {
            Bind(statement, ID_FIELD_ID, id_);
            Bind(statement, ROWVERSION_FIELD_ID, rowVersion_);
            Bind(statement, APPLICATION_FIELD_ID, application_);
            Bind(statement, TIMESTAMP_FIELD_ID, timestamp_);
            Bind(statement, FINEST_FIELD_ID, finest_);
            Bind(statement, FINER_FIELD_ID, finer_);
            Bind(statement, FINE_FIELD_ID, fine_);
            Bind(statement, INFO_FIELD_ID, info_);
            Bind(statement, NOTICE_FIELD_ID, notice_);
            Bind(statement, WARN_FIELD_ID, warn_);
            Bind(statement, ERROR_FIELD_ID, error_);
            Bind(statement, SEVERE_FIELD_ID, severe_);
            Bind(statement, CRITICAL_FIELD_ID, critical_);
            Bind(statement, ALERT_FIELD_ID, alert_);
            Bind(statement, FATAL_FIELD_ID, fatal_);
            Bind(statement, EMERGENCY_FIELD_ID, emergency_);
        }

        template<IO::StreamWriter StreamT>
        void WriteColumns( IO::BinaryWriter<StreamT>& destination ) const
        {
            WriteColumnValue( destination, id_);
            WriteColumnValue( destination, rowVersion_);
            WriteColumnValue( destination, application_);
            WriteColumnValue( destination, timestamp_);
            WriteColumnValue( destination, finest_);
            WriteColumnValue( destination, finer_);
            WriteColumnValue( destination, fine_);
            WriteColumnValue( destination, info_);
            WriteColumnValue( destination, notice_);
            WriteColumnValue( destination, warn_);
            WriteColumnValue( destination, error_);
            WriteColumnValue( destination, severe_);
            WriteColumnValue( destination, critical_);
            WriteColumnValue( destination, alert_);
            WriteColumnValue( destination, fatal_);
            WriteColumnValue( destination, emergency_);
        }
    };

    using SimpleLogApplicationConfigurationDataReader = SimpleColumnDataReader<LogApplicationConfigurationColumnData>;

    class LogHostColumnData : public BaseColumnData
    {
        Guid id_;
        Int64 rowVersion_ = 0;
        FixedDBWideString<127> computerName_;
        WideString description_;
        SQLLEN descriptionLength_ = SQL_NULL_DATA;
    public:
        using Base = BaseColumnData;

        static constexpr std::wstring_view FieldNames = L"[Id],[RowVersion],[ComputerName],[Description]";
        static constexpr std::wstring_view ViewName = L"LogHostView";

        static constexpr SQLUSMALLINT ID_FIELD_ID = 1;
        static constexpr SQLUSMALLINT ROWVERSION_FIELD_ID = 2;
        static constexpr SQLUSMALLINT COMPUTERNAME_FIELD_ID = 3;
        static constexpr SQLUSMALLINT DESCRIPTION_FIELD_ID = 4;

        LogHostColumnData( ) = default;

        virtual Kind GetKind() const override
        {
            return Kind::LogHost;
        }

        const Guid& Id( ) const
        {
            return id_;
        }
        void SetId( const Guid& id )
        {
            id_ = id;
        }
        Int64 RowVersion( ) const
        {
            return rowVersion_;
        }
        void SetRowVersion( const Int64& rowVersion )
        {
            rowVersion_ = rowVersion;
        }
        const FixedDBWideString<127>& ComputerName( ) const
        {
            return computerName_;
        }
        void SetComputerName( const WideString& computerName )
        {
            computerName_ = computerName;
        }
        const WideString& Description( ) const
        {
            return description_;
        }
        void SetDescription( const WideString& description )
        {
            description_ = description;
        }
        void BindColumns( const ODBC::Statement& statement )
        {
            Bind(statement, ID_FIELD_ID, id_);
            Bind(statement, ROWVERSION_FIELD_ID, rowVersion_);
            Bind(statement, COMPUTERNAME_FIELD_ID, computerName_);
        }

        void ReadUnboundData( const ODBC::Statement& statement )
        {
            Base::ReadUnboundData( statement );

            description_ = statement.GetWideString(DESCRIPTION_FIELD_ID);
        }
        template<IO::StreamWriter StreamT>
        void WriteColumns( IO::BinaryWriter<StreamT>& destination ) const
        {
            WriteColumnValue( destination, id_);
            WriteColumnValue( destination, rowVersion_);
            WriteColumnValue( destination, computerName_);
            WriteColumnValue( destination, description_);
        }
    };

    using SimpleLogHostDataReader = SimpleColumnDataReader<LogHostColumnData>;

    class LogHostConfigurationColumnData : public BaseColumnData
    {
        Guid id_;
        Int64 rowVersion_ = 0;
        Guid host_;
        DateTime timestamp_;
        bool finest_ = false;
        bool finer_ = false;
        bool fine_ = false;
        bool info_ = false;
        bool notice_ = false;
        bool warn_ = false;
        bool error_ = false;
        bool severe_ = false;
        bool critical_ = false;
        bool alert_ = false;
        bool fatal_ = false;
        bool emergency_ = false;
    public:
        using Base = BaseColumnData;

        static constexpr std::wstring_view FieldNames = L"[Id],[RowVersion],[Host],[Timestamp],[Finest],[Finer],[Fine],[Info],[Notice],[Warn],[Error],[Severe],[Critical],[Alert],[Fatal],[Emergency]";
        static constexpr std::wstring_view ViewName = L"LogHostConfigurationView";

        static constexpr SQLUSMALLINT ID_FIELD_ID = 1;
        static constexpr SQLUSMALLINT ROWVERSION_FIELD_ID = 2;
        static constexpr SQLUSMALLINT HOST_FIELD_ID = 3;
        static constexpr SQLUSMALLINT TIMESTAMP_FIELD_ID = 4;
        static constexpr SQLUSMALLINT FINEST_FIELD_ID = 5;
        static constexpr SQLUSMALLINT FINER_FIELD_ID = 6;
        static constexpr SQLUSMALLINT FINE_FIELD_ID = 7;
        static constexpr SQLUSMALLINT INFO_FIELD_ID = 8;
        static constexpr SQLUSMALLINT NOTICE_FIELD_ID = 9;
        static constexpr SQLUSMALLINT WARN_FIELD_ID = 10;
        static constexpr SQLUSMALLINT ERROR_FIELD_ID = 11;
        static constexpr SQLUSMALLINT SEVERE_FIELD_ID = 12;
        static constexpr SQLUSMALLINT CRITICAL_FIELD_ID = 13;
        static constexpr SQLUSMALLINT ALERT_FIELD_ID = 14;
        static constexpr SQLUSMALLINT FATAL_FIELD_ID = 15;
        static constexpr SQLUSMALLINT EMERGENCY_FIELD_ID = 16;

        LogHostConfigurationColumnData( ) = default;

        virtual Kind GetKind() const override
        {
            return Kind::LogHostConfiguration;
        }

        const Guid& Id( ) const
        {
            return id_;
        }
        void SetId( const Guid& id )
        {
            id_ = id;
        }
        Int64 RowVersion( ) const
        {
            return rowVersion_;
        }
        void SetRowVersion( const Int64& rowVersion )
        {
            rowVersion_ = rowVersion;
        }
        const Guid& Host( ) const
        {
            return host_;
        }
        void SetHost( const Guid& host )
        {
            host_ = host;
        }
        const DateTime& Timestamp( ) const
        {
            return timestamp_;
        }
        void SetTimestamp( const DateTime& timestamp )
        {
            timestamp_ = timestamp;
        }
        bool Finest( ) const
        {
            return finest_;
        }
        void SetFinest( bool finest )
        {
            finest_ = finest;
        }
        bool Finer( ) const
        {
            return finer_;
        }
        void SetFiner( bool finer )
        {
            finer_ = finer;
        }
        bool Fine( ) const
        {
            return fine_;
        }
        void SetFine( bool fine )
        {
            fine_ = fine;
        }
        bool Info( ) const
        {
            return info_;
        }
        void SetInfo( bool info )
        {
            info_ = info;
        }
        bool Notice( ) const
        {
            return notice_;
        }
        void SetNotice( bool notice )
        {
            notice_ = notice;
        }
        bool Warn( ) const
        {
            return warn_;
        }
        void SetWarn( bool warn )
        {
            warn_ = warn;
        }
        bool Error( ) const
        {
            return error_;
        }
        void SetError( bool error )
        {
            error_ = error;
        }
        bool Severe( ) const
        {
            return severe_;
        }
        void SetSevere( bool severe )
        {
            severe_ = severe;
        }
        bool Critical( ) const
        {
            return critical_;
        }
        void SetCritical( bool critical )
        {
            critical_ = critical;
        }
        bool Alert( ) const
        {
            return alert_;
        }
        void SetAlert( bool alert )
        {
            alert_ = alert;
        }
        bool Fatal( ) const
        {
            return fatal_;
        }
        void SetFatal( bool fatal )
        {
            fatal_ = fatal;
        }
        bool Emergency( ) const
        {
            return emergency_;
        }
        void SetEmergency( bool emergency )
        {
            emergency_ = emergency;
        }
        void BindColumns( const ODBC::Statement& statement )
        {
            Bind(statement, ID_FIELD_ID, id_);
            Bind(statement, ROWVERSION_FIELD_ID, rowVersion_);
            Bind(statement, HOST_FIELD_ID, host_);
            Bind(statement, TIMESTAMP_FIELD_ID, timestamp_);
            Bind(statement, FINEST_FIELD_ID, finest_);
            Bind(statement, FINER_FIELD_ID, finer_);
            Bind(statement, FINE_FIELD_ID, fine_);
            Bind(statement, INFO_FIELD_ID, info_);
            Bind(statement, NOTICE_FIELD_ID, notice_);
            Bind(statement, WARN_FIELD_ID, warn_);
            Bind(statement, ERROR_FIELD_ID, error_);
            Bind(statement, SEVERE_FIELD_ID, severe_);
            Bind(statement, CRITICAL_FIELD_ID, critical_);
            Bind(statement, ALERT_FIELD_ID, alert_);
            Bind(statement, FATAL_FIELD_ID, fatal_);
            Bind(statement, EMERGENCY_FIELD_ID, emergency_);
        }

        template<IO::StreamWriter StreamT>
        void WriteColumns( IO::BinaryWriter<StreamT>& destination ) const
        {
            WriteColumnValue( destination, id_);
            WriteColumnValue( destination, rowVersion_);
            WriteColumnValue( destination, host_);
            WriteColumnValue( destination, timestamp_);
            WriteColumnValue( destination, finest_);
            WriteColumnValue( destination, finer_);
            WriteColumnValue( destination, fine_);
            WriteColumnValue( destination, info_);
            WriteColumnValue( destination, notice_);
            WriteColumnValue( destination, warn_);
            WriteColumnValue( destination, error_);
            WriteColumnValue( destination, severe_);
            WriteColumnValue( destination, critical_);
            WriteColumnValue( destination, alert_);
            WriteColumnValue( destination, fatal_);
            WriteColumnValue( destination, emergency_);
        }
    };

    using SimpleLogHostConfigurationDataReader = SimpleColumnDataReader<LogHostConfigurationColumnData>;

    class LogLocationColumnData : public BaseColumnData
    {
        Guid id_;
        Int64 rowVersion_ = 0;
        FixedDBWideString<260> fileName_;
        Int32 lineNumber_ = 0;
        WideString namespace_;
        SQLLEN namespaceLength_ = SQL_NULL_DATA;
        WideString className_;
        SQLLEN classNameLength_ = SQL_NULL_DATA;
        FixedDBWideString<255> methodName_;
    public:
        using Base = BaseColumnData;

        static constexpr std::wstring_view FieldNames = L"[Id],[RowVersion],[FileName],[LineNumber],[MethodName],[Namespace],[ClassName]";
        static constexpr std::wstring_view ViewName = L"LogLocationView";

        static constexpr SQLUSMALLINT ID_FIELD_ID = 1;
        static constexpr SQLUSMALLINT ROWVERSION_FIELD_ID = 2;
        static constexpr SQLUSMALLINT FILENAME_FIELD_ID = 3;
        static constexpr SQLUSMALLINT LINENUMBER_FIELD_ID = 4;
        static constexpr SQLUSMALLINT METHODNAME_FIELD_ID = 5;
        static constexpr SQLUSMALLINT NAMESPACE_FIELD_ID = 6;
        static constexpr SQLUSMALLINT CLASSNAME_FIELD_ID = 7;

        LogLocationColumnData( ) = default;

        virtual Kind GetKind() const override
        {
            return Kind::LogLocation;
        }

        const Guid& Id( ) const
        {
            return id_;
        }
        void SetId( const Guid& id )
        {
            id_ = id;
        }
        Int64 RowVersion( ) const
        {
            return rowVersion_;
        }
        void SetRowVersion( const Int64& rowVersion )
        {
            rowVersion_ = rowVersion;
        }
        const FixedDBWideString<260>& FileName( ) const
        {
            return fileName_;
        }
        void SetFileName( const WideString& fileName )
        {
            fileName_ = fileName;
        }
        Int32 LineNumber( ) const
        {
            return lineNumber_;
        }
        void SetLineNumber( Int32 lineNumber )
        {
            lineNumber_ = lineNumber;
        }
        const WideString& Namespace( ) const
        {
            return namespace_;
        }
        void SetNamespace( const WideString& namespace__ )
        {
            namespace_ = namespace__;
        }
        const WideString& ClassName( ) const
        {
            return className_;
        }
        void SetClassName( const WideString& className )
        {
            className_ = className;
        }
        const FixedDBWideString<255>& MethodName( ) const
        {
            return methodName_;
        }
        void SetMethodName( const WideString& methodName )
        {
            methodName_ = methodName;
        }
        void BindColumns( const ODBC::Statement& statement )
        {
            Bind(statement, ID_FIELD_ID, id_);
            Bind(statement, ROWVERSION_FIELD_ID, rowVersion_);
            Bind(statement, FILENAME_FIELD_ID, fileName_);
            Bind(statement, LINENUMBER_FIELD_ID, lineNumber_);
            Bind(statement, METHODNAME_FIELD_ID, methodName_);
        }

        void ReadUnboundData( const ODBC::Statement& statement )
        {
            Base::ReadUnboundData( statement );

            namespace_ = statement.GetWideString(NAMESPACE_FIELD_ID);
            className_ = statement.GetWideString(CLASSNAME_FIELD_ID);
        }
        template<IO::StreamWriter StreamT>
        void WriteColumns( IO::BinaryWriter<StreamT>& destination ) const
        {
            WriteColumnValue( destination, id_);
            WriteColumnValue( destination, rowVersion_);
            WriteColumnValue( destination, fileName_);
            WriteColumnValue( destination, lineNumber_);
            WriteColumnValue( destination, namespace_);
            WriteColumnValue( destination, className_);
            WriteColumnValue( destination, methodName_);
        }
    };

    using SimpleLogLocationDataReader = SimpleColumnDataReader<LogLocationColumnData>;

    class LogProcessColumnData : public BaseColumnData
    {
        Guid id_;
        Int64 rowVersion_ = 0;
        Guid application_;
        Guid host_;
        DateTime started_;
        DBDateTime stopped_;
        Int64 processId_ = 0;
        WideString path_;
        SQLLEN pathLength_ = SQL_NULL_DATA;
        FixedDBWideString<127> identity_;
    public:
        using Base = BaseColumnData;

        static constexpr std::wstring_view FieldNames = L"[Id],[RowVersion],[Application],[Host],[Started],[Stopped],[ProcessId],[Identity],[Path]";
        static constexpr std::wstring_view ViewName = L"LogProcessView";

        static constexpr SQLUSMALLINT ID_FIELD_ID = 1;
        static constexpr SQLUSMALLINT ROWVERSION_FIELD_ID = 2;
        static constexpr SQLUSMALLINT APPLICATION_FIELD_ID = 3;
        static constexpr SQLUSMALLINT HOST_FIELD_ID = 4;
        static constexpr SQLUSMALLINT STARTED_FIELD_ID = 5;
        static constexpr SQLUSMALLINT STOPPED_FIELD_ID = 6;
        static constexpr SQLUSMALLINT PROCESSID_FIELD_ID = 7;
        static constexpr SQLUSMALLINT IDENTITY_FIELD_ID = 8;
        static constexpr SQLUSMALLINT PATH_FIELD_ID = 9;

        LogProcessColumnData( ) = default;

        virtual Kind GetKind() const override
        {
            return Kind::LogProcess;
        }

        const Guid& Id( ) const
        {
            return id_;
        }
        void SetId( const Guid& id )
        {
            id_ = id;
        }
        Int64 RowVersion( ) const
        {
            return rowVersion_;
        }
        void SetRowVersion( const Int64& rowVersion )
        {
            rowVersion_ = rowVersion;
        }
        const Guid& Application( ) const
        {
            return application_;
        }
        void SetApplication( const Guid& application )
        {
            application_ = application;
        }
        const Guid& Host( ) const
        {
            return host_;
        }
        void SetHost( const Guid& host )
        {
            host_ = host;
        }
        const DateTime& Started( ) const
        {
            return started_;
        }
        void SetStarted( const DateTime& started )
        {
            started_ = started;
        }
        const DBDateTime& Stopped( ) const
        {
            return stopped_;
        }
        void SetStopped( const DBDateTime& stopped )
        {
            stopped_ = stopped;
        }
        Int64 ProcessId( ) const
        {
            return processId_;
        }
        void SetProcessId( Int64 processId )
        {
            processId_ = processId;
        }
        const WideString& Path( ) const
        {
            return path_;
        }
        void SetPath( const WideString& path )
        {
            path_ = path;
        }
        const FixedDBWideString<127>& Identity( ) const
        {
            return identity_;
        }
        void SetIdentity( const WideString& identity )
        {
            identity_ = identity;
        }
        void BindColumns( const ODBC::Statement& statement )
        {
            Bind(statement, ID_FIELD_ID, id_);
            Bind(statement, ROWVERSION_FIELD_ID, rowVersion_);
            Bind(statement, APPLICATION_FIELD_ID, application_);
            Bind(statement, HOST_FIELD_ID, host_);
            Bind(statement, STARTED_FIELD_ID, started_);
            Bind(statement, STOPPED_FIELD_ID, stopped_);
            Bind(statement, PROCESSID_FIELD_ID, processId_);
            Bind(statement, IDENTITY_FIELD_ID, identity_);
        }

        void ReadUnboundData( const ODBC::Statement& statement )
        {
            Base::ReadUnboundData( statement );

            path_ = statement.GetWideString(PATH_FIELD_ID);
        }
        template<IO::StreamWriter StreamT>
        void WriteColumns( IO::BinaryWriter<StreamT>& destination ) const
        {
            WriteColumnValue( destination, id_);
            WriteColumnValue( destination, rowVersion_);
            WriteColumnValue( destination, application_);
            WriteColumnValue( destination, host_);
            WriteColumnValue( destination, started_);
            WriteColumnValue( destination, stopped_);
            WriteColumnValue( destination, processId_);
            WriteColumnValue( destination, path_);
            WriteColumnValue( destination, identity_);
        }
    };

    using SimpleLogProcessDataReader = SimpleColumnDataReader<LogProcessColumnData>;

    class LogRecordColumnData : public BaseColumnData
    {
        Guid id_;
        Int64 rowVersion_ = 0;
        Guid thread_;
        Int64 sequenceNumber_ = 0;
        Data::LogLevel level_ = Data::LogLevel::Unknown;
        DateTime timestamp_;
        Int32 depth_ = 0;
        Guid location_;
        WideString message_;
        SQLLEN messageLength_ = SQL_NULL_DATA;
        WideString exceptionString_;
        SQLLEN exceptionStringLength_ = SQL_NULL_DATA;
        Binary propertiesData_;
        SQLLEN propertiesDataLength_ = SQL_NULL_DATA;
    public:
        using Base = BaseColumnData;

        static constexpr std::wstring_view FieldNames = L"[Id],[RowVersion],[Thread],[SequenceNumber],[Level],[Timestamp],[Depth],[Location],[Message],[ExceptionString],[PropertiesData]";
        static constexpr std::wstring_view ViewName = L"LogRecordView";

        static constexpr SQLUSMALLINT ID_FIELD_ID = 1;
        static constexpr SQLUSMALLINT ROWVERSION_FIELD_ID = 2;
        static constexpr SQLUSMALLINT THREAD_FIELD_ID = 3;
        static constexpr SQLUSMALLINT SEQUENCENUMBER_FIELD_ID = 4;
        static constexpr SQLUSMALLINT LEVEL_FIELD_ID = 5;
        static constexpr SQLUSMALLINT TIMESTAMP_FIELD_ID = 6;
        static constexpr SQLUSMALLINT DEPTH_FIELD_ID = 7;
        static constexpr SQLUSMALLINT LOCATION_FIELD_ID = 8;
        static constexpr SQLUSMALLINT MESSAGE_FIELD_ID = 9;
        static constexpr SQLUSMALLINT EXCEPTIONSTRING_FIELD_ID = 10;
        static constexpr SQLUSMALLINT PROPERTIESDATA_FIELD_ID = 11;

        LogRecordColumnData( ) = default;

        virtual Kind GetKind() const override
        {
            return Kind::LogRecord;
        }

        const Guid& Id( ) const
        {
            return id_;
        }
        void SetId( const Guid& id )
        {
            id_ = id;
        }
        Int64 RowVersion( ) const
        {
            return rowVersion_;
        }
        void SetRowVersion( const Int64& rowVersion )
        {
            rowVersion_ = rowVersion;
        }
        const Guid& Thread( ) const
        {
            return thread_;
        }
        void SetThread( const Guid& thread )
        {
            thread_ = thread;
        }
        Int64 SequenceNumber( ) const
        {
            return sequenceNumber_;
        }
        void SetSequenceNumber( Int64 sequenceNumber )
        {
            sequenceNumber_ = sequenceNumber;
        }
        Data::LogLevel Level( ) const
        {
            return level_;
        }
        void SetLevel( Data::LogLevel level )
        {
            level_ = level;
        }
        const DateTime& Timestamp( ) const
        {
            return timestamp_;
        }
        void SetTimestamp( const DateTime& timestamp )
        {
            timestamp_ = timestamp;
        }
        Int32 Depth( ) const
        {
            return depth_;
        }
        void SetDepth( Int32 depth )
        {
            depth_ = depth;
        }
        const Guid& Location( ) const
        {
            return location_;
        }
        void SetLocation( const Guid& location )
        {
            location_ = location;
        }
        const WideString& Message( ) const
        {
            return message_;
        }
        void SetMessage( const WideString& message )
        {
            message_ = message;
        }
        const WideString& ExceptionString( ) const
        {
            return exceptionString_;
        }
        void SetExceptionString( const WideString& exceptionString )
        {
            exceptionString_ = exceptionString;
        }
        const Binary& PropertiesData( ) const
        {
            return propertiesData_;
        }
        void SetPropertiesData( const Binary& propertiesData )
        {
            propertiesData_ = propertiesData;
        }
        void BindColumns( const ODBC::Statement& statement )
        {
            Bind(statement, ID_FIELD_ID, id_);
            Bind(statement, ROWVERSION_FIELD_ID, rowVersion_);
            Bind(statement, THREAD_FIELD_ID, thread_);
            Bind(statement, SEQUENCENUMBER_FIELD_ID, sequenceNumber_);
            Bind(statement, LEVEL_FIELD_ID, level_);
            Bind(statement, TIMESTAMP_FIELD_ID, timestamp_);
            Bind(statement, DEPTH_FIELD_ID, depth_);
            Bind(statement, LOCATION_FIELD_ID, location_);
        }

        void ReadUnboundData( const ODBC::Statement& statement )
        {
            Base::ReadUnboundData( statement );

            message_ = statement.GetWideString(MESSAGE_FIELD_ID);
            exceptionString_ = statement.GetWideString(EXCEPTIONSTRING_FIELD_ID);
            propertiesData_ = statement.GetBinary(PROPERTIESDATA_FIELD_ID);
        }
        template<IO::StreamWriter StreamT>
        void WriteColumns( IO::BinaryWriter<StreamT>& destination ) const
        {
            WriteColumnValue( destination, id_);
            WriteColumnValue( destination, rowVersion_);
            WriteColumnValue( destination, thread_);
            WriteColumnValue( destination, sequenceNumber_);
            WriteColumnValue( destination, level_);
            WriteColumnValue( destination, timestamp_);
            WriteColumnValue( destination, depth_);
            WriteColumnValue( destination, location_);
            WriteColumnValue( destination, message_);
            WriteColumnValue( destination, exceptionString_);
            WriteColumnValue( destination, propertiesData_);
        }
    };

    using SimpleLogRecordDataReader = SimpleColumnDataReader<LogRecordColumnData>;

    class LogThreadColumnData : public BaseColumnData
    {
        Guid id_;
        Int64 rowVersion_ = 0;
        Guid process_;
        DateTime started_;
        DBDateTime stopped_;
        Int64 threadId_ = 0;
        FixedDBWideString<127> name_;
    public:
        using Base = BaseColumnData;

        static constexpr std::wstring_view FieldNames = L"[Id],[RowVersion],[Process],[Started],[Stopped],[ThreadId],[Name]";
        static constexpr std::wstring_view ViewName = L"LogThreadView";

        static constexpr SQLUSMALLINT ID_FIELD_ID = 1;
        static constexpr SQLUSMALLINT ROWVERSION_FIELD_ID = 2;
        static constexpr SQLUSMALLINT PROCESS_FIELD_ID = 3;
        static constexpr SQLUSMALLINT STARTED_FIELD_ID = 4;
        static constexpr SQLUSMALLINT STOPPED_FIELD_ID = 5;
        static constexpr SQLUSMALLINT THREADID_FIELD_ID = 6;
        static constexpr SQLUSMALLINT NAME_FIELD_ID = 7;

        LogThreadColumnData( ) = default;

        virtual Kind GetKind() const override
        {
            return Kind::LogThread;
        }

        const Guid& Id( ) const
        {
            return id_;
        }
        void SetId( const Guid& id )
        {
            id_ = id;
        }
        Int64 RowVersion( ) const
        {
            return rowVersion_;
        }
        void SetRowVersion( const Int64& rowVersion )
        {
            rowVersion_ = rowVersion;
        }
        const Guid& Process( ) const
        {
            return process_;
        }
        void SetProcess( const Guid& process )
        {
            process_ = process;
        }
        const DateTime& Started( ) const
        {
            return started_;
        }
        void SetStarted( const DateTime& started )
        {
            started_ = started;
        }
        const DBDateTime& Stopped( ) const
        {
            return stopped_;
        }
        void SetStopped( const DBDateTime& stopped )
        {
            stopped_ = stopped;
        }
        Int64 ThreadId( ) const
        {
            return threadId_;
        }
        void SetThreadId( Int64 threadId )
        {
            threadId_ = threadId;
        }
        const FixedDBWideString<127>& Name( ) const
        {
            return name_;
        }
        void SetName( const WideString& name )
        {
            name_ = name;
        }
        void BindColumns( const ODBC::Statement& statement )
        {
            Bind(statement, ID_FIELD_ID, id_);
            Bind(statement, ROWVERSION_FIELD_ID, rowVersion_);
            Bind(statement, PROCESS_FIELD_ID, process_);
            Bind(statement, STARTED_FIELD_ID, started_);
            Bind(statement, STOPPED_FIELD_ID, stopped_);
            Bind(statement, THREADID_FIELD_ID, threadId_);
            Bind(statement, NAME_FIELD_ID, name_);
        }

        template<IO::StreamWriter StreamT>
        void WriteColumns( IO::BinaryWriter<StreamT>& destination ) const
        {
            WriteColumnValue( destination, id_);
            WriteColumnValue( destination, rowVersion_);
            WriteColumnValue( destination, process_);
            WriteColumnValue( destination, started_);
            WriteColumnValue( destination, stopped_);
            WriteColumnValue( destination, threadId_);
            WriteColumnValue( destination, name_);
        }
    };

    using SimpleLogThreadDataReader = SimpleColumnDataReader<LogThreadColumnData>;

    class LogTraceEntryColumnData : public BaseColumnData
    {
        Guid id_;
        Int64 rowVersion_ = 0;
        Guid thread_;
        Int64 sequenceNumber_ = 0;
        Guid location_;
        Int32 depth_ = 0;
        DateTime entered_;
        DBDateTime ended_;
    public:
        using Base = BaseColumnData;

        static constexpr std::wstring_view FieldNames = L"[Id],[RowVersion],[Thread],[SequenceNumber],[Location],[Depth],[Entered],[Ended]";
        static constexpr std::wstring_view ViewName = L"LogTraceEntryView";

        static constexpr SQLUSMALLINT ID_FIELD_ID = 1;
        static constexpr SQLUSMALLINT ROWVERSION_FIELD_ID = 2;
        static constexpr SQLUSMALLINT THREAD_FIELD_ID = 3;
        static constexpr SQLUSMALLINT SEQUENCENUMBER_FIELD_ID = 4;
        static constexpr SQLUSMALLINT LOCATION_FIELD_ID = 5;
        static constexpr SQLUSMALLINT DEPTH_FIELD_ID = 6;
        static constexpr SQLUSMALLINT ENTERED_FIELD_ID = 7;
        static constexpr SQLUSMALLINT ENDED_FIELD_ID = 8;

        LogTraceEntryColumnData( ) = default;

        virtual Kind GetKind() const override
        {
            return Kind::LogTraceEntry;
        }

        const Guid& Id( ) const
        {
            return id_;
        }
        void SetId( const Guid& id )
        {
            id_ = id;
        }
        Int64 RowVersion( ) const
        {
            return rowVersion_;
        }
        void SetRowVersion( const Int64& rowVersion )
        {
            rowVersion_ = rowVersion;
        }
        const Guid& Thread( ) const
        {
            return thread_;
        }
        void SetThread( const Guid& thread )
        {
            thread_ = thread;
        }
        Int64 SequenceNumber( ) const
        {
            return sequenceNumber_;
        }
        void SetSequenceNumber( Int64 sequenceNumber )
        {
            sequenceNumber_ = sequenceNumber;
        }
        const Guid& Location( ) const
        {
            return location_;
        }
        void SetLocation( const Guid& location )
        {
            location_ = location;
        }
        Int32 Depth( ) const
        {
            return depth_;
        }
        void SetDepth( Int32 depth )
        {
            depth_ = depth;
        }
        const DateTime& Entered( ) const
        {
            return entered_;
        }
        void SetEntered( const DateTime& entered )
        {
            entered_ = entered;
        }
        const DBDateTime& Ended( ) const
        {
            return ended_;
        }
        void SetEnded( const DBDateTime& ended )
        {
            ended_ = ended;
        }
        void BindColumns( const ODBC::Statement& statement )
        {
            Bind(statement, ID_FIELD_ID, id_);
            Bind(statement, ROWVERSION_FIELD_ID, rowVersion_);
            Bind(statement, THREAD_FIELD_ID, thread_);
            Bind(statement, SEQUENCENUMBER_FIELD_ID, sequenceNumber_);
            Bind(statement, LOCATION_FIELD_ID, location_);
            Bind(statement, DEPTH_FIELD_ID, depth_);
            Bind(statement, ENTERED_FIELD_ID, entered_);
            Bind(statement, ENDED_FIELD_ID, ended_);
        }

        template<IO::StreamWriter StreamT>
        void WriteColumns( IO::BinaryWriter<StreamT>& destination ) const
        {
            WriteColumnValue( destination, id_);
            WriteColumnValue( destination, rowVersion_);
            WriteColumnValue( destination, thread_);
            WriteColumnValue( destination, sequenceNumber_);
            WriteColumnValue( destination, location_);
            WriteColumnValue( destination, depth_);
            WriteColumnValue( destination, entered_);
            WriteColumnValue( destination, ended_);
        }
    };

    using SimpleLogTraceEntryDataReader = SimpleColumnDataReader<LogTraceEntryColumnData>;

    class MapElementColumnData : public BaseColumnData
    {
        Guid id_;
        Int64 rowVersion_ = 0;
        Guid item_;
        Data::MapElementType elementType_ = Data::MapElementType::Unknown;
        double latitude_ = 0.0;
        double longitude_ = 0.0;
        double angle_ = 0.0;
        double left_ = 0.0;
        double top_ = 0.0;
        double width_ = 0.0;
        double height_ = 0.0;
        FixedDBWideString<100> label_;
        Binary data_;
        SQLLEN dataLength_ = SQL_NULL_DATA;
    public:
        using Base = BaseColumnData;

        static constexpr std::wstring_view FieldNames = L"[Id],[RowVersion],[Item],[ElementType],[Latitude],[Longitude],[Angle],[Left],[Top],[Width],[Height],[Label],[Data]";
        static constexpr std::wstring_view ViewName = L"MapElementView";

        static constexpr SQLUSMALLINT ID_FIELD_ID = 1;
        static constexpr SQLUSMALLINT ROWVERSION_FIELD_ID = 2;
        static constexpr SQLUSMALLINT ITEM_FIELD_ID = 3;
        static constexpr SQLUSMALLINT ELEMENTTYPE_FIELD_ID = 4;
        static constexpr SQLUSMALLINT LATITUDE_FIELD_ID = 5;
        static constexpr SQLUSMALLINT LONGITUDE_FIELD_ID = 6;
        static constexpr SQLUSMALLINT ANGLE_FIELD_ID = 7;
        static constexpr SQLUSMALLINT LEFT_FIELD_ID = 8;
        static constexpr SQLUSMALLINT TOP_FIELD_ID = 9;
        static constexpr SQLUSMALLINT WIDTH_FIELD_ID = 10;
        static constexpr SQLUSMALLINT HEIGHT_FIELD_ID = 11;
        static constexpr SQLUSMALLINT LABEL_FIELD_ID = 12;
        static constexpr SQLUSMALLINT DATA_FIELD_ID = 13;

        MapElementColumnData( ) = default;

        virtual Kind GetKind() const override
        {
            return Kind::MapElement;
        }

        const Guid& Id( ) const
        {
            return id_;
        }
        void SetId( const Guid& id )
        {
            id_ = id;
        }
        Int64 RowVersion( ) const
        {
            return rowVersion_;
        }
        void SetRowVersion( const Int64& rowVersion )
        {
            rowVersion_ = rowVersion;
        }
        const Guid& Item( ) const
        {
            return item_;
        }
        void SetItem( const Guid& item )
        {
            item_ = item;
        }
        Data::MapElementType ElementType( ) const
        {
            return elementType_;
        }
        void SetElementType( Data::MapElementType elementType )
        {
            elementType_ = elementType;
        }
        double Latitude( ) const
        {
            return latitude_;
        }
        void SetLatitude( double latitude )
        {
            latitude_ = latitude;
        }
        double Longitude( ) const
        {
            return longitude_;
        }
        void SetLongitude( double longitude )
        {
            longitude_ = longitude;
        }
        double Angle( ) const
        {
            return angle_;
        }
        void SetAngle( double angle )
        {
            angle_ = angle;
        }
        double Left( ) const
        {
            return left_;
        }
        void SetLeft( double left )
        {
            left_ = left;
        }
        double Top( ) const
        {
            return top_;
        }
        void SetTop( double top )
        {
            top_ = top;
        }
        double Width( ) const
        {
            return width_;
        }
        void SetWidth( double width )
        {
            width_ = width;
        }
        double Height( ) const
        {
            return height_;
        }
        void SetHeight( double height )
        {
            height_ = height;
        }
        const FixedDBWideString<100>& Label( ) const
        {
            return label_;
        }
        void SetLabel( const WideString& label )
        {
            label_ = label;
        }
        const Binary& Data( ) const
        {
            return data_;
        }
        void SetData( const Binary& data )
        {
            data_ = data;
        }
        void BindColumns( const ODBC::Statement& statement )
        {
            Bind(statement, ID_FIELD_ID, id_);
            Bind(statement, ROWVERSION_FIELD_ID, rowVersion_);
            Bind(statement, ITEM_FIELD_ID, item_);
            Bind(statement, ELEMENTTYPE_FIELD_ID, elementType_);
            Bind(statement, LATITUDE_FIELD_ID, latitude_);
            Bind(statement, LONGITUDE_FIELD_ID, longitude_);
            Bind(statement, ANGLE_FIELD_ID, angle_);
            Bind(statement, LEFT_FIELD_ID, left_);
            Bind(statement, TOP_FIELD_ID, top_);
            Bind(statement, WIDTH_FIELD_ID, width_);
            Bind(statement, HEIGHT_FIELD_ID, height_);
            Bind(statement, LABEL_FIELD_ID, label_);
        }

        void ReadUnboundData( const ODBC::Statement& statement )
        {
            Base::ReadUnboundData( statement );

            data_ = statement.GetBinary(DATA_FIELD_ID);
        }
        template<IO::StreamWriter StreamT>
        void WriteColumns( IO::BinaryWriter<StreamT>& destination ) const
        {
            WriteColumnValue( destination, id_);
            WriteColumnValue( destination, rowVersion_);
            WriteColumnValue( destination, item_);
            WriteColumnValue( destination, elementType_);
            WriteColumnValue( destination, latitude_);
            WriteColumnValue( destination, longitude_);
            WriteColumnValue( destination, angle_);
            WriteColumnValue( destination, left_);
            WriteColumnValue( destination, top_);
            WriteColumnValue( destination, width_);
            WriteColumnValue( destination, height_);
            WriteColumnValue( destination, label_);
            WriteColumnValue( destination, data_);
        }
    };

    using SimpleMapElementDataReader = SimpleColumnDataReader<MapElementColumnData>;

    class MapInfoColumnData : public BaseColumnData
    {
        Guid id_;
        Int64 rowVersion_ = 0;
        Int32 scale_ = 0;
        double latitude_ = 0.0;
        double longitude_ = 0.0;
        double northWestLatitude_ = 0.0;
        double northWestLongitude_ = 0.0;
        double southEastLatitude_ = 0.0;
        double southEastLongitude_ = 0.0;
        Binary image_;
        SQLLEN imageLength_ = SQL_NULL_DATA;
    public:
        using Base = BaseColumnData;

        static constexpr std::wstring_view FieldNames = L"[Id],[RowVersion],[Scale],[Latitude],[Longitude],[NorthWestLatitude],[NorthWestLongitude],[SouthEastLatitude],[SouthEastLongitude],[Image]";
        static constexpr std::wstring_view ViewName = L"MapInfoView";

        static constexpr SQLUSMALLINT ID_FIELD_ID = 1;
        static constexpr SQLUSMALLINT ROWVERSION_FIELD_ID = 2;
        static constexpr SQLUSMALLINT SCALE_FIELD_ID = 3;
        static constexpr SQLUSMALLINT LATITUDE_FIELD_ID = 4;
        static constexpr SQLUSMALLINT LONGITUDE_FIELD_ID = 5;
        static constexpr SQLUSMALLINT NORTHWESTLATITUDE_FIELD_ID = 6;
        static constexpr SQLUSMALLINT NORTHWESTLONGITUDE_FIELD_ID = 7;
        static constexpr SQLUSMALLINT SOUTHEASTLATITUDE_FIELD_ID = 8;
        static constexpr SQLUSMALLINT SOUTHEASTLONGITUDE_FIELD_ID = 9;
        static constexpr SQLUSMALLINT IMAGE_FIELD_ID = 10;

        MapInfoColumnData( ) = default;

        virtual Kind GetKind() const override
        {
            return Kind::MapInfo;
        }

        const Guid& Id( ) const
        {
            return id_;
        }
        void SetId( const Guid& id )
        {
            id_ = id;
        }
        Int64 RowVersion( ) const
        {
            return rowVersion_;
        }
        void SetRowVersion( const Int64& rowVersion )
        {
            rowVersion_ = rowVersion;
        }
        Int32 Scale( ) const
        {
            return scale_;
        }
        void SetScale( Int32 scale )
        {
            scale_ = scale;
        }
        double Latitude( ) const
        {
            return latitude_;
        }
        void SetLatitude( double latitude )
        {
            latitude_ = latitude;
        }
        double Longitude( ) const
        {
            return longitude_;
        }
        void SetLongitude( double longitude )
        {
            longitude_ = longitude;
        }
        double NorthWestLatitude( ) const
        {
            return northWestLatitude_;
        }
        void SetNorthWestLatitude( double northWestLatitude )
        {
            northWestLatitude_ = northWestLatitude;
        }
        double NorthWestLongitude( ) const
        {
            return northWestLongitude_;
        }
        void SetNorthWestLongitude( double northWestLongitude )
        {
            northWestLongitude_ = northWestLongitude;
        }
        double SouthEastLatitude( ) const
        {
            return southEastLatitude_;
        }
        void SetSouthEastLatitude( double southEastLatitude )
        {
            southEastLatitude_ = southEastLatitude;
        }
        double SouthEastLongitude( ) const
        {
            return southEastLongitude_;
        }
        void SetSouthEastLongitude( double southEastLongitude )
        {
            southEastLongitude_ = southEastLongitude;
        }
        const Binary& Image( ) const
        {
            return image_;
        }
        void SetImage( const Binary& image )
        {
            image_ = image;
        }
        void BindColumns( const ODBC::Statement& statement )
        {
            Bind(statement, ID_FIELD_ID, id_);
            Bind(statement, ROWVERSION_FIELD_ID, rowVersion_);
            Bind(statement, SCALE_FIELD_ID, scale_);
            Bind(statement, LATITUDE_FIELD_ID, latitude_);
            Bind(statement, LONGITUDE_FIELD_ID, longitude_);
            Bind(statement, NORTHWESTLATITUDE_FIELD_ID, northWestLatitude_);
            Bind(statement, NORTHWESTLONGITUDE_FIELD_ID, northWestLongitude_);
            Bind(statement, SOUTHEASTLATITUDE_FIELD_ID, southEastLatitude_);
            Bind(statement, SOUTHEASTLONGITUDE_FIELD_ID, southEastLongitude_);
        }

        void ReadUnboundData( const ODBC::Statement& statement )
        {
            Base::ReadUnboundData( statement );

            image_ = statement.GetBinary(IMAGE_FIELD_ID);
        }
        template<IO::StreamWriter StreamT>
        void WriteColumns( IO::BinaryWriter<StreamT>& destination ) const
        {
            WriteColumnValue( destination, id_);
            WriteColumnValue( destination, rowVersion_);
            WriteColumnValue( destination, scale_);
            WriteColumnValue( destination, latitude_);
            WriteColumnValue( destination, longitude_);
            WriteColumnValue( destination, northWestLatitude_);
            WriteColumnValue( destination, northWestLongitude_);
            WriteColumnValue( destination, southEastLatitude_);
            WriteColumnValue( destination, southEastLongitude_);
            WriteColumnValue( destination, image_);
        }
    };

    using SimpleMapInfoDataReader = SimpleColumnDataReader<MapInfoColumnData>;

    class MapServiceOptionsColumnData : public BaseColumnData
    {
        Guid id_;
        Int64 rowVersion_ = 0;
        DateTime timestamp_;
        FixedDBWideString<127> ipAddress_;
        Int32 port_ = 0;
        double imageScaleFactorX_ = 0.0;
        double imageOffsetX_ = 0.0;
        double imageScaleFactorY_ = 0.0;
        double imageOffsetY_ = 0.0;
    public:
        using Base = BaseColumnData;

        static constexpr std::wstring_view FieldNames = L"[Id],[RowVersion],[Timestamp],[IpAddress],[Port],[ImageScaleFactorX],[ImageOffsetX],[ImageScaleFactorY],[ImageOffsetY]";
        static constexpr std::wstring_view ViewName = L"MapServiceOptionsView";

        static constexpr SQLUSMALLINT ID_FIELD_ID = 1;
        static constexpr SQLUSMALLINT ROWVERSION_FIELD_ID = 2;
        static constexpr SQLUSMALLINT TIMESTAMP_FIELD_ID = 3;
        static constexpr SQLUSMALLINT IPADDRESS_FIELD_ID = 4;
        static constexpr SQLUSMALLINT PORT_FIELD_ID = 5;
        static constexpr SQLUSMALLINT IMAGESCALEFACTORX_FIELD_ID = 6;
        static constexpr SQLUSMALLINT IMAGEOFFSETX_FIELD_ID = 7;
        static constexpr SQLUSMALLINT IMAGESCALEFACTORY_FIELD_ID = 8;
        static constexpr SQLUSMALLINT IMAGEOFFSETY_FIELD_ID = 9;

        MapServiceOptionsColumnData( ) = default;

        virtual Kind GetKind() const override
        {
            return Kind::MapServiceOptions;
        }

        const Guid& Id( ) const
        {
            return id_;
        }
        void SetId( const Guid& id )
        {
            id_ = id;
        }
        Int64 RowVersion( ) const
        {
            return rowVersion_;
        }
        void SetRowVersion( const Int64& rowVersion )
        {
            rowVersion_ = rowVersion;
        }
        const DateTime& Timestamp( ) const
        {
            return timestamp_;
        }
        void SetTimestamp( const DateTime& timestamp )
        {
            timestamp_ = timestamp;
        }
        const FixedDBWideString<127>& IpAddress( ) const
        {
            return ipAddress_;
        }
        void SetIpAddress( const WideString& ipAddress )
        {
            ipAddress_ = ipAddress;
        }
        Int32 Port( ) const
        {
            return port_;
        }
        void SetPort( Int32 port )
        {
            port_ = port;
        }
        double ImageScaleFactorX( ) const
        {
            return imageScaleFactorX_;
        }
        void SetImageScaleFactorX( double imageScaleFactorX )
        {
            imageScaleFactorX_ = imageScaleFactorX;
        }
        double ImageOffsetX( ) const
        {
            return imageOffsetX_;
        }
        void SetImageOffsetX( double imageOffsetX )
        {
            imageOffsetX_ = imageOffsetX;
        }
        double ImageScaleFactorY( ) const
        {
            return imageScaleFactorY_;
        }
        void SetImageScaleFactorY( double imageScaleFactorY )
        {
            imageScaleFactorY_ = imageScaleFactorY;
        }
        double ImageOffsetY( ) const
        {
            return imageOffsetY_;
        }
        void SetImageOffsetY( double imageOffsetY )
        {
            imageOffsetY_ = imageOffsetY;
        }
        void BindColumns( const ODBC::Statement& statement )
        {
            Bind(statement, ID_FIELD_ID, id_);
            Bind(statement, ROWVERSION_FIELD_ID, rowVersion_);
            Bind(statement, TIMESTAMP_FIELD_ID, timestamp_);
            Bind(statement, IPADDRESS_FIELD_ID, ipAddress_);
            Bind(statement, PORT_FIELD_ID, port_);
            Bind(statement, IMAGESCALEFACTORX_FIELD_ID, imageScaleFactorX_);
            Bind(statement, IMAGEOFFSETX_FIELD_ID, imageOffsetX_);
            Bind(statement, IMAGESCALEFACTORY_FIELD_ID, imageScaleFactorY_);
            Bind(statement, IMAGEOFFSETY_FIELD_ID, imageOffsetY_);
        }

        template<IO::StreamWriter StreamT>
        void WriteColumns( IO::BinaryWriter<StreamT>& destination ) const
        {
            WriteColumnValue( destination, id_);
            WriteColumnValue( destination, rowVersion_);
            WriteColumnValue( destination, timestamp_);
            WriteColumnValue( destination, ipAddress_);
            WriteColumnValue( destination, port_);
            WriteColumnValue( destination, imageScaleFactorX_);
            WriteColumnValue( destination, imageOffsetX_);
            WriteColumnValue( destination, imageScaleFactorY_);
            WriteColumnValue( destination, imageOffsetY_);
        }
    };

    using SimpleMapServiceOptionsDataReader = SimpleColumnDataReader<MapServiceOptionsColumnData>;

    class MaritimeIdentificationDigitsColumnData : public BaseColumnData
    {
        Guid id_;
        Int64 rowVersion_ = 0;
        Int32 code_ = 0;
        Guid country_;
    public:
        using Base = BaseColumnData;

        static constexpr std::wstring_view FieldNames = L"[Id],[RowVersion],[Code],[Country]";
        static constexpr std::wstring_view ViewName = L"MaritimeIdentificationDigitsView";

        static constexpr SQLUSMALLINT ID_FIELD_ID = 1;
        static constexpr SQLUSMALLINT ROWVERSION_FIELD_ID = 2;
        static constexpr SQLUSMALLINT CODE_FIELD_ID = 3;
        static constexpr SQLUSMALLINT COUNTRY_FIELD_ID = 4;

        MaritimeIdentificationDigitsColumnData( ) = default;

        virtual Kind GetKind() const override
        {
            return Kind::MaritimeIdentificationDigits;
        }

        const Guid& Id( ) const
        {
            return id_;
        }
        void SetId( const Guid& id )
        {
            id_ = id;
        }
        Int64 RowVersion( ) const
        {
            return rowVersion_;
        }
        void SetRowVersion( const Int64& rowVersion )
        {
            rowVersion_ = rowVersion;
        }
        Int32 Code( ) const
        {
            return code_;
        }
        void SetCode( Int32 code )
        {
            code_ = code;
        }
        const Guid& Country( ) const
        {
            return country_;
        }
        void SetCountry( const Guid& country )
        {
            country_ = country;
        }
        void BindColumns( const ODBC::Statement& statement )
        {
            Bind(statement, ID_FIELD_ID, id_);
            Bind(statement, ROWVERSION_FIELD_ID, rowVersion_);
            Bind(statement, CODE_FIELD_ID, code_);
            Bind(statement, COUNTRY_FIELD_ID, country_);
        }

        template<IO::StreamWriter StreamT>
        void WriteColumns( IO::BinaryWriter<StreamT>& destination ) const
        {
            WriteColumnValue( destination, id_);
            WriteColumnValue( destination, rowVersion_);
            WriteColumnValue( destination, code_);
            WriteColumnValue( destination, country_);
        }
    };

    using SimpleMaritimeIdentificationDigitsDataReader = SimpleColumnDataReader<MaritimeIdentificationDigitsColumnData>;

    class MediaProxySessionColumnData : public BaseColumnData
    {
        Guid id_;
        Int64 rowVersion_ = 0;
        Guid service_;
        FixedDBWideString<128> name_;
        Guid enabledTimeseries_;
    public:
        using Base = BaseColumnData;

        static constexpr std::wstring_view FieldNames = L"[Id],[RowVersion],[Service],[Name],[EnabledTimeseries]";
        static constexpr std::wstring_view ViewName = L"MediaProxySessionView";

        static constexpr SQLUSMALLINT ID_FIELD_ID = 1;
        static constexpr SQLUSMALLINT ROWVERSION_FIELD_ID = 2;
        static constexpr SQLUSMALLINT SERVICE_FIELD_ID = 3;
        static constexpr SQLUSMALLINT NAME_FIELD_ID = 4;
        static constexpr SQLUSMALLINT ENABLEDTIMESERIES_FIELD_ID = 5;

        MediaProxySessionColumnData( ) = default;

        virtual Kind GetKind() const override
        {
            return Kind::MediaProxySession;
        }

        const Guid& Id( ) const
        {
            return id_;
        }
        void SetId( const Guid& id )
        {
            id_ = id;
        }
        Int64 RowVersion( ) const
        {
            return rowVersion_;
        }
        void SetRowVersion( const Int64& rowVersion )
        {
            rowVersion_ = rowVersion;
        }
        const Guid& Service( ) const
        {
            return service_;
        }
        void SetService( const Guid& service )
        {
            service_ = service;
        }
        const FixedDBWideString<128>& Name( ) const
        {
            return name_;
        }
        void SetName( const WideString& name )
        {
            name_ = name;
        }
        const Guid& EnabledTimeseries( ) const
        {
            return enabledTimeseries_;
        }
        void SetEnabledTimeseries( const Guid& enabledTimeseries )
        {
            enabledTimeseries_ = enabledTimeseries;
        }
        void BindColumns( const ODBC::Statement& statement )
        {
            Bind(statement, ID_FIELD_ID, id_);
            Bind(statement, ROWVERSION_FIELD_ID, rowVersion_);
            Bind(statement, SERVICE_FIELD_ID, service_);
            Bind(statement, NAME_FIELD_ID, name_);
            Bind(statement, ENABLEDTIMESERIES_FIELD_ID, enabledTimeseries_);
        }

        template<IO::StreamWriter StreamT>
        void WriteColumns( IO::BinaryWriter<StreamT>& destination ) const
        {
            WriteColumnValue( destination, id_);
            WriteColumnValue( destination, rowVersion_);
            WriteColumnValue( destination, service_);
            WriteColumnValue( destination, name_);
            WriteColumnValue( destination, enabledTimeseries_);
        }
    };

    using SimpleMediaProxySessionDataReader = SimpleColumnDataReader<MediaProxySessionColumnData>;

    class MediaProxySessionFileColumnData : public BaseColumnData
    {
        Guid id_;
        Int64 rowVersion_ = 0;
        Guid proxySession_;
        DateTime timestamp_;
        FixedDBWideString<100> streamName_;
    public:
        using Base = BaseColumnData;

        static constexpr std::wstring_view FieldNames = L"[Id],[RowVersion],[ProxySession],[Timestamp],[StreamName]";
        static constexpr std::wstring_view ViewName = L"MediaProxySessionFileView";

        static constexpr SQLUSMALLINT ID_FIELD_ID = 1;
        static constexpr SQLUSMALLINT ROWVERSION_FIELD_ID = 2;
        static constexpr SQLUSMALLINT PROXYSESSION_FIELD_ID = 3;
        static constexpr SQLUSMALLINT TIMESTAMP_FIELD_ID = 4;
        static constexpr SQLUSMALLINT STREAMNAME_FIELD_ID = 5;

        MediaProxySessionFileColumnData( ) = default;

        virtual Kind GetKind() const override
        {
            return Kind::MediaProxySessionFile;
        }

        const Guid& Id( ) const
        {
            return id_;
        }
        void SetId( const Guid& id )
        {
            id_ = id;
        }
        Int64 RowVersion( ) const
        {
            return rowVersion_;
        }
        void SetRowVersion( const Int64& rowVersion )
        {
            rowVersion_ = rowVersion;
        }
        const Guid& ProxySession( ) const
        {
            return proxySession_;
        }
        void SetProxySession( const Guid& proxySession )
        {
            proxySession_ = proxySession;
        }
        const DateTime& Timestamp( ) const
        {
            return timestamp_;
        }
        void SetTimestamp( const DateTime& timestamp )
        {
            timestamp_ = timestamp;
        }
        const FixedDBWideString<100>& StreamName( ) const
        {
            return streamName_;
        }
        void SetStreamName( const WideString& streamName )
        {
            streamName_ = streamName;
        }
        void BindColumns( const ODBC::Statement& statement )
        {
            Bind(statement, ID_FIELD_ID, id_);
            Bind(statement, ROWVERSION_FIELD_ID, rowVersion_);
            Bind(statement, PROXYSESSION_FIELD_ID, proxySession_);
            Bind(statement, TIMESTAMP_FIELD_ID, timestamp_);
            Bind(statement, STREAMNAME_FIELD_ID, streamName_);
        }

        template<IO::StreamWriter StreamT>
        void WriteColumns( IO::BinaryWriter<StreamT>& destination ) const
        {
            WriteColumnValue( destination, id_);
            WriteColumnValue( destination, rowVersion_);
            WriteColumnValue( destination, proxySession_);
            WriteColumnValue( destination, timestamp_);
            WriteColumnValue( destination, streamName_);
        }
    };

    using SimpleMediaProxySessionFileDataReader = SimpleColumnDataReader<MediaProxySessionFileColumnData>;

    class MediaProxySessionOptionsColumnData : public BaseColumnData
    {
        Guid id_;
        Int64 rowVersion_ = 0;
        Guid proxySession_;
        DateTime timestamp_;
        FixedDBWideString<255> sourceStreamUrl_;
        FixedDBWideString<255> streamName_;
        Data::MediaProxySessionMode mode_ = Data::MediaProxySessionMode::Unknown;
        Int32 tunnelOverHTTPPortNumber_ = 0;
        FixedDBWideString<128> username_;
        FixedDBWideString<128> password_;
        Int32 recorderPortNumber_ = 0;
        Data::MediaProxySessionType sessionType_ = Data::MediaProxySessionType::Unknown;
        TimeSpan maxFileTime_;
        TimeSpan maxFileRetention_;
        FixedDBWideString<260> videoDirectory_;
    public:
        using Base = BaseColumnData;

        static constexpr std::wstring_view FieldNames = L"[Id],[RowVersion],[ProxySession],[Timestamp],[SourceStreamUrl],[StreamName],[Mode],[TunnelOverHTTPPortNumber],[Username],[Password],[RecorderPortNumber],[SessionType],[MaxFileTime],[MaxFileRetention],[VideoDirectory]";
        static constexpr std::wstring_view ViewName = L"MediaProxySessionOptionsView";

        static constexpr SQLUSMALLINT ID_FIELD_ID = 1;
        static constexpr SQLUSMALLINT ROWVERSION_FIELD_ID = 2;
        static constexpr SQLUSMALLINT PROXYSESSION_FIELD_ID = 3;
        static constexpr SQLUSMALLINT TIMESTAMP_FIELD_ID = 4;
        static constexpr SQLUSMALLINT SOURCESTREAMURL_FIELD_ID = 5;
        static constexpr SQLUSMALLINT STREAMNAME_FIELD_ID = 6;
        static constexpr SQLUSMALLINT MODE_FIELD_ID = 7;
        static constexpr SQLUSMALLINT TUNNELOVERHTTPPORTNUMBER_FIELD_ID = 8;
        static constexpr SQLUSMALLINT USERNAME_FIELD_ID = 9;
        static constexpr SQLUSMALLINT PASSWORD_FIELD_ID = 10;
        static constexpr SQLUSMALLINT RECORDERPORTNUMBER_FIELD_ID = 11;
        static constexpr SQLUSMALLINT SESSIONTYPE_FIELD_ID = 12;
        static constexpr SQLUSMALLINT MAXFILETIME_FIELD_ID = 13;
        static constexpr SQLUSMALLINT MAXFILERETENTION_FIELD_ID = 14;
        static constexpr SQLUSMALLINT VIDEODIRECTORY_FIELD_ID = 15;

        MediaProxySessionOptionsColumnData( ) = default;

        virtual Kind GetKind() const override
        {
            return Kind::MediaProxySessionOptions;
        }

        const Guid& Id( ) const
        {
            return id_;
        }
        void SetId( const Guid& id )
        {
            id_ = id;
        }
        Int64 RowVersion( ) const
        {
            return rowVersion_;
        }
        void SetRowVersion( const Int64& rowVersion )
        {
            rowVersion_ = rowVersion;
        }
        const Guid& ProxySession( ) const
        {
            return proxySession_;
        }
        void SetProxySession( const Guid& proxySession )
        {
            proxySession_ = proxySession;
        }
        const DateTime& Timestamp( ) const
        {
            return timestamp_;
        }
        void SetTimestamp( const DateTime& timestamp )
        {
            timestamp_ = timestamp;
        }
        const FixedDBWideString<255>& SourceStreamUrl( ) const
        {
            return sourceStreamUrl_;
        }
        void SetSourceStreamUrl( const WideString& sourceStreamUrl )
        {
            sourceStreamUrl_ = sourceStreamUrl;
        }
        const FixedDBWideString<255>& StreamName( ) const
        {
            return streamName_;
        }
        void SetStreamName( const WideString& streamName )
        {
            streamName_ = streamName;
        }
        Data::MediaProxySessionMode Mode( ) const
        {
            return mode_;
        }
        void SetMode( Data::MediaProxySessionMode mode )
        {
            mode_ = mode;
        }
        Int32 TunnelOverHTTPPortNumber( ) const
        {
            return tunnelOverHTTPPortNumber_;
        }
        void SetTunnelOverHTTPPortNumber( Int32 tunnelOverHTTPPortNumber )
        {
            tunnelOverHTTPPortNumber_ = tunnelOverHTTPPortNumber;
        }
        const FixedDBWideString<128>& Username( ) const
        {
            return username_;
        }
        void SetUsername( const WideString& username )
        {
            username_ = username;
        }
        const FixedDBWideString<128>& Password( ) const
        {
            return password_;
        }
        void SetPassword( const WideString& password )
        {
            password_ = password;
        }
        Int32 RecorderPortNumber( ) const
        {
            return recorderPortNumber_;
        }
        void SetRecorderPortNumber( Int32 recorderPortNumber )
        {
            recorderPortNumber_ = recorderPortNumber;
        }
        Data::MediaProxySessionType SessionType( ) const
        {
            return sessionType_;
        }
        void SetSessionType( Data::MediaProxySessionType sessionType )
        {
            sessionType_ = sessionType;
        }
        const TimeSpan& MaxFileTime( ) const
        {
            return maxFileTime_;
        }
        void SetMaxFileTime( const TimeSpan& maxFileTime )
        {
            maxFileTime_ = maxFileTime;
        }
        const TimeSpan& MaxFileRetention( ) const
        {
            return maxFileRetention_;
        }
        void SetMaxFileRetention( const TimeSpan& maxFileRetention )
        {
            maxFileRetention_ = maxFileRetention;
        }
        const FixedDBWideString<260>& VideoDirectory( ) const
        {
            return videoDirectory_;
        }
        void SetVideoDirectory( const WideString& videoDirectory )
        {
            videoDirectory_ = videoDirectory;
        }
        void BindColumns( const ODBC::Statement& statement )
        {
            Bind(statement, ID_FIELD_ID, id_);
            Bind(statement, ROWVERSION_FIELD_ID, rowVersion_);
            Bind(statement, PROXYSESSION_FIELD_ID, proxySession_);
            Bind(statement, TIMESTAMP_FIELD_ID, timestamp_);
            Bind(statement, SOURCESTREAMURL_FIELD_ID, sourceStreamUrl_);
            Bind(statement, STREAMNAME_FIELD_ID, streamName_);
            Bind(statement, MODE_FIELD_ID, mode_);
            Bind(statement, TUNNELOVERHTTPPORTNUMBER_FIELD_ID, tunnelOverHTTPPortNumber_);
            Bind(statement, USERNAME_FIELD_ID, username_);
            Bind(statement, PASSWORD_FIELD_ID, password_);
            Bind(statement, RECORDERPORTNUMBER_FIELD_ID, recorderPortNumber_);
            Bind(statement, SESSIONTYPE_FIELD_ID, sessionType_);
            Bind(statement, MAXFILETIME_FIELD_ID, maxFileTime_);
            Bind(statement, MAXFILERETENTION_FIELD_ID, maxFileRetention_);
            Bind(statement, VIDEODIRECTORY_FIELD_ID, videoDirectory_);
        }

        template<IO::StreamWriter StreamT>
        void WriteColumns( IO::BinaryWriter<StreamT>& destination ) const
        {
            WriteColumnValue( destination, id_);
            WriteColumnValue( destination, rowVersion_);
            WriteColumnValue( destination, proxySession_);
            WriteColumnValue( destination, timestamp_);
            WriteColumnValue( destination, sourceStreamUrl_);
            WriteColumnValue( destination, streamName_);
            WriteColumnValue( destination, mode_);
            WriteColumnValue( destination, tunnelOverHTTPPortNumber_);
            WriteColumnValue( destination, username_);
            WriteColumnValue( destination, password_);
            WriteColumnValue( destination, recorderPortNumber_);
            WriteColumnValue( destination, sessionType_);
            WriteColumnValue( destination, maxFileTime_);
            WriteColumnValue( destination, maxFileRetention_);
            WriteColumnValue( destination, videoDirectory_);
        }
    };

    using SimpleMediaProxySessionOptionsDataReader = SimpleColumnDataReader<MediaProxySessionOptionsColumnData>;

    class MediaServiceColumnData : public BaseColumnData
    {
        Guid id_;
        Int64 rowVersion_ = 0;
        Guid enabledTimeseries_;
    public:
        using Base = BaseColumnData;

        static constexpr std::wstring_view FieldNames = L"[Id],[RowVersion],[EnabledTimeseries]";
        static constexpr std::wstring_view ViewName = L"MediaServiceView";

        static constexpr SQLUSMALLINT ID_FIELD_ID = 1;
        static constexpr SQLUSMALLINT ROWVERSION_FIELD_ID = 2;
        static constexpr SQLUSMALLINT ENABLEDTIMESERIES_FIELD_ID = 3;

        MediaServiceColumnData( ) = default;

        virtual Kind GetKind() const override
        {
            return Kind::MediaService;
        }

        const Guid& Id( ) const
        {
            return id_;
        }
        void SetId( const Guid& id )
        {
            id_ = id;
        }
        Int64 RowVersion( ) const
        {
            return rowVersion_;
        }
        void SetRowVersion( const Int64& rowVersion )
        {
            rowVersion_ = rowVersion;
        }
        const Guid& EnabledTimeseries( ) const
        {
            return enabledTimeseries_;
        }
        void SetEnabledTimeseries( const Guid& enabledTimeseries )
        {
            enabledTimeseries_ = enabledTimeseries;
        }
        void BindColumns( const ODBC::Statement& statement )
        {
            Bind(statement, ID_FIELD_ID, id_);
            Bind(statement, ROWVERSION_FIELD_ID, rowVersion_);
            Bind(statement, ENABLEDTIMESERIES_FIELD_ID, enabledTimeseries_);
        }

        template<IO::StreamWriter StreamT>
        void WriteColumns( IO::BinaryWriter<StreamT>& destination ) const
        {
            WriteColumnValue( destination, id_);
            WriteColumnValue( destination, rowVersion_);
            WriteColumnValue( destination, enabledTimeseries_);
        }
    };

    using SimpleMediaServiceDataReader = SimpleColumnDataReader<MediaServiceColumnData>;

    class MediaServiceOptionsColumnData : public BaseColumnData
    {
        Guid id_;
        Int64 rowVersion_ = 0;
        Guid mediaService_;
        DateTime timestamp_;
        Int32 rtspPortNumber_ = 0;
        Int32 httpPortNumber_ = 0;
    public:
        using Base = BaseColumnData;

        static constexpr std::wstring_view FieldNames = L"[Id],[RowVersion],[MediaService],[Timestamp],[RtspPortNumber],[HttpPortNumber]";
        static constexpr std::wstring_view ViewName = L"MediaServiceOptionsView";

        static constexpr SQLUSMALLINT ID_FIELD_ID = 1;
        static constexpr SQLUSMALLINT ROWVERSION_FIELD_ID = 2;
        static constexpr SQLUSMALLINT MEDIASERVICE_FIELD_ID = 3;
        static constexpr SQLUSMALLINT TIMESTAMP_FIELD_ID = 4;
        static constexpr SQLUSMALLINT RTSPPORTNUMBER_FIELD_ID = 5;
        static constexpr SQLUSMALLINT HTTPPORTNUMBER_FIELD_ID = 6;

        MediaServiceOptionsColumnData( ) = default;

        virtual Kind GetKind() const override
        {
            return Kind::MediaServiceOptions;
        }

        const Guid& Id( ) const
        {
            return id_;
        }
        void SetId( const Guid& id )
        {
            id_ = id;
        }
        Int64 RowVersion( ) const
        {
            return rowVersion_;
        }
        void SetRowVersion( const Int64& rowVersion )
        {
            rowVersion_ = rowVersion;
        }
        const Guid& MediaService( ) const
        {
            return mediaService_;
        }
        void SetMediaService( const Guid& mediaService )
        {
            mediaService_ = mediaService;
        }
        const DateTime& Timestamp( ) const
        {
            return timestamp_;
        }
        void SetTimestamp( const DateTime& timestamp )
        {
            timestamp_ = timestamp;
        }
        Int32 RtspPortNumber( ) const
        {
            return rtspPortNumber_;
        }
        void SetRtspPortNumber( Int32 rtspPortNumber )
        {
            rtspPortNumber_ = rtspPortNumber;
        }
        Int32 HttpPortNumber( ) const
        {
            return httpPortNumber_;
        }
        void SetHttpPortNumber( Int32 httpPortNumber )
        {
            httpPortNumber_ = httpPortNumber;
        }
        void BindColumns( const ODBC::Statement& statement )
        {
            Bind(statement, ID_FIELD_ID, id_);
            Bind(statement, ROWVERSION_FIELD_ID, rowVersion_);
            Bind(statement, MEDIASERVICE_FIELD_ID, mediaService_);
            Bind(statement, TIMESTAMP_FIELD_ID, timestamp_);
            Bind(statement, RTSPPORTNUMBER_FIELD_ID, rtspPortNumber_);
            Bind(statement, HTTPPORTNUMBER_FIELD_ID, httpPortNumber_);
        }

        template<IO::StreamWriter StreamT>
        void WriteColumns( IO::BinaryWriter<StreamT>& destination ) const
        {
            WriteColumnValue( destination, id_);
            WriteColumnValue( destination, rowVersion_);
            WriteColumnValue( destination, mediaService_);
            WriteColumnValue( destination, timestamp_);
            WriteColumnValue( destination, rtspPortNumber_);
            WriteColumnValue( destination, httpPortNumber_);
        }
    };

    using SimpleMediaServiceOptionsDataReader = SimpleColumnDataReader<MediaServiceOptionsColumnData>;

    class NamespaceElementColumnData : public BaseColumnData
    {
        Guid id_;
        Int64 rowVersion_ = 0;
        Guid namespace_;
        FixedDBWideString<127> name_;
        WideString description_;
        SQLLEN descriptionLength_ = SQL_NULL_DATA;
    public:
        using Base = BaseColumnData;

        static constexpr std::wstring_view FieldNames = L"[Id],[RowVersion],[Namespace],[Name],[Description]";
        static constexpr std::wstring_view ViewName = L"NamespaceElementView";

        static constexpr SQLUSMALLINT ID_FIELD_ID = 1;
        static constexpr SQLUSMALLINT ROWVERSION_FIELD_ID = 2;
        static constexpr SQLUSMALLINT NAMESPACE_FIELD_ID = 3;
        static constexpr SQLUSMALLINT NAME_FIELD_ID = 4;
        static constexpr SQLUSMALLINT DESCRIPTION_FIELD_ID = 5;

        NamespaceElementColumnData( ) = default;

        virtual Kind GetKind() const override
        {
            return Kind::NamespaceElement;
        }

        const Guid& Id( ) const
        {
            return id_;
        }
        void SetId( const Guid& id )
        {
            id_ = id;
        }
        Int64 RowVersion( ) const
        {
            return rowVersion_;
        }
        void SetRowVersion( const Int64& rowVersion )
        {
            rowVersion_ = rowVersion;
        }
        const Guid& Namespace( ) const
        {
            return namespace_;
        }
        void SetNamespace( const Guid& namespace__ )
        {
            namespace_ = namespace__;
        }
        const FixedDBWideString<127>& Name( ) const
        {
            return name_;
        }
        void SetName( const WideString& name )
        {
            name_ = name;
        }
        const WideString& Description( ) const
        {
            return description_;
        }
        void SetDescription( const WideString& description )
        {
            description_ = description;
        }
        void BindColumns( const ODBC::Statement& statement )
        {
            Bind(statement, ID_FIELD_ID, id_);
            Bind(statement, ROWVERSION_FIELD_ID, rowVersion_);
            Bind(statement, NAMESPACE_FIELD_ID, namespace_);
            Bind(statement, NAME_FIELD_ID, name_);
        }

        void ReadUnboundData( const ODBC::Statement& statement )
        {
            Base::ReadUnboundData( statement );

            description_ = statement.GetWideString(DESCRIPTION_FIELD_ID);
        }
        template<IO::StreamWriter StreamT>
        void WriteColumns( IO::BinaryWriter<StreamT>& destination ) const
        {
            WriteColumnValue( destination, id_);
            WriteColumnValue( destination, rowVersion_);
            WriteColumnValue( destination, namespace_);
            WriteColumnValue( destination, name_);
            WriteColumnValue( destination, description_);
        }
    };

    using SimpleNamespaceElementDataReader = SimpleColumnDataReader<NamespaceElementColumnData>;

    class ElementTypeColumnData : public NamespaceElementColumnData
    {
    public:
        using Base = NamespaceElementColumnData;

        static constexpr std::wstring_view FieldNames = L"[Id],[RowVersion],[Namespace],[Name],[Description]";
        static constexpr std::wstring_view ViewName = L"ElementTypeView";

        ElementTypeColumnData( ) = default;

        virtual Kind GetKind() const override
        {
            return Kind::ElementType;
        }

        template<IO::StreamWriter StreamT>
        void WriteColumns( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteColumns( destination );
        }
    };

    using SimpleElementTypeDataReader = SimpleColumnDataReader<ElementTypeColumnData>;

    class NamespaceColumnData : public NamespaceElementColumnData
    {
    public:
        using Base = NamespaceElementColumnData;

        static constexpr std::wstring_view FieldNames = L"[Id],[RowVersion],[Namespace],[Name],[Description]";
        static constexpr std::wstring_view ViewName = L"NamespaceView";

        NamespaceColumnData( ) = default;

        virtual Kind GetKind() const override
        {
            return Kind::Namespace;
        }

        template<IO::StreamWriter StreamT>
        void WriteColumns( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteColumns( destination );
        }
    };

    using SimpleNamespaceDataReader = SimpleColumnDataReader<NamespaceColumnData>;

    class OilspillColumnData : public BaseColumnData
    {
        Guid id_;
        Int64 rowVersion_ = 0;
        Guid oilSpillDetector_;
        DateTime timestamp_;
        double oilArea_ = 0.0;
        Binary shape_;
        SQLLEN shapeLength_ = SQL_NULL_DATA;
        Binary bSI_;
        SQLLEN bSILength_ = SQL_NULL_DATA;
        Binary oil_;
        SQLLEN oilLength_ = SQL_NULL_DATA;
        Binary trace_;
        SQLLEN traceLength_ = SQL_NULL_DATA;
    public:
        using Base = BaseColumnData;

        static constexpr std::wstring_view FieldNames = L"[Id],[RowVersion],[OilSpillDetector],[Timestamp],[OilArea],[Shape],[BSI],[Oil],[Trace]";
        static constexpr std::wstring_view ViewName = L"OilspillView";

        static constexpr SQLUSMALLINT ID_FIELD_ID = 1;
        static constexpr SQLUSMALLINT ROWVERSION_FIELD_ID = 2;
        static constexpr SQLUSMALLINT OILSPILLDETECTOR_FIELD_ID = 3;
        static constexpr SQLUSMALLINT TIMESTAMP_FIELD_ID = 4;
        static constexpr SQLUSMALLINT OILAREA_FIELD_ID = 5;
        static constexpr SQLUSMALLINT SHAPE_FIELD_ID = 6;
        static constexpr SQLUSMALLINT BSI_FIELD_ID = 7;
        static constexpr SQLUSMALLINT OIL_FIELD_ID = 8;
        static constexpr SQLUSMALLINT TRACE_FIELD_ID = 9;

        OilspillColumnData( ) = default;

        virtual Kind GetKind() const override
        {
            return Kind::Oilspill;
        }

        const Guid& Id( ) const
        {
            return id_;
        }
        void SetId( const Guid& id )
        {
            id_ = id;
        }
        Int64 RowVersion( ) const
        {
            return rowVersion_;
        }
        void SetRowVersion( const Int64& rowVersion )
        {
            rowVersion_ = rowVersion;
        }
        const Guid& OilSpillDetector( ) const
        {
            return oilSpillDetector_;
        }
        void SetOilSpillDetector( const Guid& oilSpillDetector )
        {
            oilSpillDetector_ = oilSpillDetector;
        }
        const DateTime& Timestamp( ) const
        {
            return timestamp_;
        }
        void SetTimestamp( const DateTime& timestamp )
        {
            timestamp_ = timestamp;
        }
        double OilArea( ) const
        {
            return oilArea_;
        }
        void SetOilArea( double oilArea )
        {
            oilArea_ = oilArea;
        }
        const Binary& Shape( ) const
        {
            return shape_;
        }
        void SetShape( const Binary& shape )
        {
            shape_ = shape;
        }
        const Binary& BSI( ) const
        {
            return bSI_;
        }
        void SetBSI( const Binary& bSI )
        {
            bSI_ = bSI;
        }
        const Binary& Oil( ) const
        {
            return oil_;
        }
        void SetOil( const Binary& oil )
        {
            oil_ = oil;
        }
        const Binary& Trace( ) const
        {
            return trace_;
        }
        void SetTrace( const Binary& trace )
        {
            trace_ = trace;
        }
        void BindColumns( const ODBC::Statement& statement )
        {
            Bind(statement, ID_FIELD_ID, id_);
            Bind(statement, ROWVERSION_FIELD_ID, rowVersion_);
            Bind(statement, OILSPILLDETECTOR_FIELD_ID, oilSpillDetector_);
            Bind(statement, TIMESTAMP_FIELD_ID, timestamp_);
            Bind(statement, OILAREA_FIELD_ID, oilArea_);
        }

        void ReadUnboundData( const ODBC::Statement& statement )
        {
            Base::ReadUnboundData( statement );

            shape_ = statement.GetBinary(SHAPE_FIELD_ID);
            bSI_ = statement.GetBinary(BSI_FIELD_ID);
            oil_ = statement.GetBinary(OIL_FIELD_ID);
            trace_ = statement.GetBinary(TRACE_FIELD_ID);
        }
        template<IO::StreamWriter StreamT>
        void WriteColumns( IO::BinaryWriter<StreamT>& destination ) const
        {
            WriteColumnValue( destination, id_);
            WriteColumnValue( destination, rowVersion_);
            WriteColumnValue( destination, oilSpillDetector_);
            WriteColumnValue( destination, timestamp_);
            WriteColumnValue( destination, oilArea_);
            WriteColumnValue( destination, shape_);
            WriteColumnValue( destination, bSI_);
            WriteColumnValue( destination, oil_);
            WriteColumnValue( destination, trace_);
        }
    };

    using SimpleOilspillDataReader = SimpleColumnDataReader<OilspillColumnData>;

    class OilspillDetectorCommandColumnData : public BaseColumnData
    {
        Guid id_;
        Int64 rowVersion_ = 0;
        Guid oilSpillDetector_;
        DateTime timestamp_;
        Data::DeviceCommandSourceType deviceCommandSourceType_ = Data::DeviceCommandSourceType::Unknown;
        Guid deviceCommandSourceId_;
        Guid reply_;
    public:
        using Base = BaseColumnData;

        static constexpr std::wstring_view FieldNames = L"[Id],[RowVersion],[OilSpillDetector],[Timestamp],[DeviceCommandSourceType],[DeviceCommandSourceId],[Reply]";
        static constexpr std::wstring_view ViewName = L"OilspillDetectorCommandView";

        static constexpr SQLUSMALLINT ID_FIELD_ID = 1;
        static constexpr SQLUSMALLINT ROWVERSION_FIELD_ID = 2;
        static constexpr SQLUSMALLINT OILSPILLDETECTOR_FIELD_ID = 3;
        static constexpr SQLUSMALLINT TIMESTAMP_FIELD_ID = 4;
        static constexpr SQLUSMALLINT DEVICECOMMANDSOURCETYPE_FIELD_ID = 5;
        static constexpr SQLUSMALLINT DEVICECOMMANDSOURCEID_FIELD_ID = 6;
        static constexpr SQLUSMALLINT REPLY_FIELD_ID = 7;

        OilspillDetectorCommandColumnData( ) = default;

        virtual Kind GetKind() const override
        {
            return Kind::OilspillDetectorCommand;
        }

        const Guid& Id( ) const
        {
            return id_;
        }
        void SetId( const Guid& id )
        {
            id_ = id;
        }
        Int64 RowVersion( ) const
        {
            return rowVersion_;
        }
        void SetRowVersion( const Int64& rowVersion )
        {
            rowVersion_ = rowVersion;
        }
        const Guid& OilSpillDetector( ) const
        {
            return oilSpillDetector_;
        }
        void SetOilSpillDetector( const Guid& oilSpillDetector )
        {
            oilSpillDetector_ = oilSpillDetector;
        }
        const DateTime& Timestamp( ) const
        {
            return timestamp_;
        }
        void SetTimestamp( const DateTime& timestamp )
        {
            timestamp_ = timestamp;
        }
        Data::DeviceCommandSourceType DeviceCommandSourceType( ) const
        {
            return deviceCommandSourceType_;
        }
        void SetDeviceCommandSourceType( Data::DeviceCommandSourceType deviceCommandSourceType )
        {
            deviceCommandSourceType_ = deviceCommandSourceType;
        }
        const Guid& DeviceCommandSourceId( ) const
        {
            return deviceCommandSourceId_;
        }
        void SetDeviceCommandSourceId( const Guid& deviceCommandSourceId )
        {
            deviceCommandSourceId_ = deviceCommandSourceId;
        }
        const Guid& Reply( ) const
        {
            return reply_;
        }
        void SetReply( const Guid& reply )
        {
            reply_ = reply;
        }
        void BindColumns( const ODBC::Statement& statement )
        {
            Bind(statement, ID_FIELD_ID, id_);
            Bind(statement, ROWVERSION_FIELD_ID, rowVersion_);
            Bind(statement, OILSPILLDETECTOR_FIELD_ID, oilSpillDetector_);
            Bind(statement, TIMESTAMP_FIELD_ID, timestamp_);
            Bind(statement, DEVICECOMMANDSOURCETYPE_FIELD_ID, deviceCommandSourceType_);
            Bind(statement, DEVICECOMMANDSOURCEID_FIELD_ID, deviceCommandSourceId_);
            Bind(statement, REPLY_FIELD_ID, reply_);
        }

        template<IO::StreamWriter StreamT>
        void WriteColumns( IO::BinaryWriter<StreamT>& destination ) const
        {
            WriteColumnValue( destination, id_);
            WriteColumnValue( destination, rowVersion_);
            WriteColumnValue( destination, oilSpillDetector_);
            WriteColumnValue( destination, timestamp_);
            WriteColumnValue( destination, deviceCommandSourceType_);
            WriteColumnValue( destination, deviceCommandSourceId_);
            WriteColumnValue( destination, reply_);
        }
    };

    using SimpleOilspillDetectorCommandDataReader = SimpleColumnDataReader<OilspillDetectorCommandColumnData>;

    class OilspillDetectorCommandReplyColumnData : public BaseColumnData
    {
        Guid id_;
        Int64 rowVersion_ = 0;
        Guid oilSpillDetector_;
        DateTime timestamp_;
        Guid command_;
        Data::DeviceCommandReplyStatus status_ = Data::DeviceCommandReplyStatus::Unknown;
        WideString message_;
        SQLLEN messageLength_ = SQL_NULL_DATA;
    public:
        using Base = BaseColumnData;

        static constexpr std::wstring_view FieldNames = L"[Id],[RowVersion],[OilSpillDetector],[Timestamp],[Command],[Status],[Message]";
        static constexpr std::wstring_view ViewName = L"OilspillDetectorCommandReplyView";

        static constexpr SQLUSMALLINT ID_FIELD_ID = 1;
        static constexpr SQLUSMALLINT ROWVERSION_FIELD_ID = 2;
        static constexpr SQLUSMALLINT OILSPILLDETECTOR_FIELD_ID = 3;
        static constexpr SQLUSMALLINT TIMESTAMP_FIELD_ID = 4;
        static constexpr SQLUSMALLINT COMMAND_FIELD_ID = 5;
        static constexpr SQLUSMALLINT STATUS_FIELD_ID = 6;
        static constexpr SQLUSMALLINT MESSAGE_FIELD_ID = 7;

        OilspillDetectorCommandReplyColumnData( ) = default;

        virtual Kind GetKind() const override
        {
            return Kind::OilspillDetectorCommandReply;
        }

        const Guid& Id( ) const
        {
            return id_;
        }
        void SetId( const Guid& id )
        {
            id_ = id;
        }
        Int64 RowVersion( ) const
        {
            return rowVersion_;
        }
        void SetRowVersion( const Int64& rowVersion )
        {
            rowVersion_ = rowVersion;
        }
        const Guid& OilSpillDetector( ) const
        {
            return oilSpillDetector_;
        }
        void SetOilSpillDetector( const Guid& oilSpillDetector )
        {
            oilSpillDetector_ = oilSpillDetector;
        }
        const DateTime& Timestamp( ) const
        {
            return timestamp_;
        }
        void SetTimestamp( const DateTime& timestamp )
        {
            timestamp_ = timestamp;
        }
        const Guid& Command( ) const
        {
            return command_;
        }
        void SetCommand( const Guid& command )
        {
            command_ = command;
        }
        Data::DeviceCommandReplyStatus Status( ) const
        {
            return status_;
        }
        void SetStatus( Data::DeviceCommandReplyStatus status )
        {
            status_ = status;
        }
        const WideString& Message( ) const
        {
            return message_;
        }
        void SetMessage( const WideString& message )
        {
            message_ = message;
        }
        void BindColumns( const ODBC::Statement& statement )
        {
            Bind(statement, ID_FIELD_ID, id_);
            Bind(statement, ROWVERSION_FIELD_ID, rowVersion_);
            Bind(statement, OILSPILLDETECTOR_FIELD_ID, oilSpillDetector_);
            Bind(statement, TIMESTAMP_FIELD_ID, timestamp_);
            Bind(statement, COMMAND_FIELD_ID, command_);
            Bind(statement, STATUS_FIELD_ID, status_);
        }

        void ReadUnboundData( const ODBC::Statement& statement )
        {
            Base::ReadUnboundData( statement );

            message_ = statement.GetWideString(MESSAGE_FIELD_ID);
        }
        template<IO::StreamWriter StreamT>
        void WriteColumns( IO::BinaryWriter<StreamT>& destination ) const
        {
            WriteColumnValue( destination, id_);
            WriteColumnValue( destination, rowVersion_);
            WriteColumnValue( destination, oilSpillDetector_);
            WriteColumnValue( destination, timestamp_);
            WriteColumnValue( destination, command_);
            WriteColumnValue( destination, status_);
            WriteColumnValue( destination, message_);
        }
    };

    using SimpleOilspillDetectorCommandReplyDataReader = SimpleColumnDataReader<OilspillDetectorCommandReplyColumnData>;

    class OilspillDetectorConfigurationColumnData : public BaseColumnData
    {
        Guid id_;
        Int64 rowVersion_ = 0;
        Guid oilSpillDetector_;
        DateTime timestamp_;
        double range_ = 0.0;
        double startAngle_ = 0.0;
        double endAngle_ = 0.0;
        double startRange_ = 0.0;
        double endRange_ = 0.0;
        Int32 updateRate_ = 0;
        TimeSpan statusSendTime_;
        bool drawBorder_ = false;
        Binary colors_;
        SQLLEN colorsLength_ = SQL_NULL_DATA;
        bool sendToServer_ = false;
        FixedDBWideString<100> directory_;
        bool transparentWater_ = false;
        bool savePictures_ = false;
        bool sendAsTarget_ = false;
        bool writeLog_ = false;
        FixedDBWideString<100> targetFilePrefix_;
        Guid targetMMSI_;
        double latitude_ = 0.0;
        double longitude_ = 0.0;
        bool testSourceEnabled_ = false;
        FixedDBWideString<100> proxyServer_;
        bool useProxyServer_ = false;
    public:
        using Base = BaseColumnData;

        static constexpr std::wstring_view FieldNames = L"[Id],[RowVersion],[OilSpillDetector],[Timestamp],[Range],[StartAngle],[EndAngle],[StartRange],[EndRange],[UpdateRate],[StatusSendTime],[DrawBorder],[SendToServer],[Directory],[TransparentWater],[SavePictures],[SendAsTarget],[WriteLog],[TargetFilePrefix],[TargetMMSI],[Latitude],[Longitude],[TestSourceEnabled],[ProxyServer],[UseProxyServer],[Colors]";
        static constexpr std::wstring_view ViewName = L"OilspillDetectorConfigurationView";

        static constexpr SQLUSMALLINT ID_FIELD_ID = 1;
        static constexpr SQLUSMALLINT ROWVERSION_FIELD_ID = 2;
        static constexpr SQLUSMALLINT OILSPILLDETECTOR_FIELD_ID = 3;
        static constexpr SQLUSMALLINT TIMESTAMP_FIELD_ID = 4;
        static constexpr SQLUSMALLINT RANGE_FIELD_ID = 5;
        static constexpr SQLUSMALLINT STARTANGLE_FIELD_ID = 6;
        static constexpr SQLUSMALLINT ENDANGLE_FIELD_ID = 7;
        static constexpr SQLUSMALLINT STARTRANGE_FIELD_ID = 8;
        static constexpr SQLUSMALLINT ENDRANGE_FIELD_ID = 9;
        static constexpr SQLUSMALLINT UPDATERATE_FIELD_ID = 10;
        static constexpr SQLUSMALLINT STATUSSENDTIME_FIELD_ID = 11;
        static constexpr SQLUSMALLINT DRAWBORDER_FIELD_ID = 12;
        static constexpr SQLUSMALLINT SENDTOSERVER_FIELD_ID = 13;
        static constexpr SQLUSMALLINT DIRECTORY_FIELD_ID = 14;
        static constexpr SQLUSMALLINT TRANSPARENTWATER_FIELD_ID = 15;
        static constexpr SQLUSMALLINT SAVEPICTURES_FIELD_ID = 16;
        static constexpr SQLUSMALLINT SENDASTARGET_FIELD_ID = 17;
        static constexpr SQLUSMALLINT WRITELOG_FIELD_ID = 18;
        static constexpr SQLUSMALLINT TARGETFILEPREFIX_FIELD_ID = 19;
        static constexpr SQLUSMALLINT TARGETMMSI_FIELD_ID = 20;
        static constexpr SQLUSMALLINT LATITUDE_FIELD_ID = 21;
        static constexpr SQLUSMALLINT LONGITUDE_FIELD_ID = 22;
        static constexpr SQLUSMALLINT TESTSOURCEENABLED_FIELD_ID = 23;
        static constexpr SQLUSMALLINT PROXYSERVER_FIELD_ID = 24;
        static constexpr SQLUSMALLINT USEPROXYSERVER_FIELD_ID = 25;
        static constexpr SQLUSMALLINT COLORS_FIELD_ID = 26;

        OilspillDetectorConfigurationColumnData( ) = default;

        virtual Kind GetKind() const override
        {
            return Kind::OilspillDetectorConfiguration;
        }

        const Guid& Id( ) const
        {
            return id_;
        }
        void SetId( const Guid& id )
        {
            id_ = id;
        }
        Int64 RowVersion( ) const
        {
            return rowVersion_;
        }
        void SetRowVersion( const Int64& rowVersion )
        {
            rowVersion_ = rowVersion;
        }
        const Guid& OilSpillDetector( ) const
        {
            return oilSpillDetector_;
        }
        void SetOilSpillDetector( const Guid& oilSpillDetector )
        {
            oilSpillDetector_ = oilSpillDetector;
        }
        const DateTime& Timestamp( ) const
        {
            return timestamp_;
        }
        void SetTimestamp( const DateTime& timestamp )
        {
            timestamp_ = timestamp;
        }
        double Range( ) const
        {
            return range_;
        }
        void SetRange( double range )
        {
            range_ = range;
        }
        double StartAngle( ) const
        {
            return startAngle_;
        }
        void SetStartAngle( double startAngle )
        {
            startAngle_ = startAngle;
        }
        double EndAngle( ) const
        {
            return endAngle_;
        }
        void SetEndAngle( double endAngle )
        {
            endAngle_ = endAngle;
        }
        double StartRange( ) const
        {
            return startRange_;
        }
        void SetStartRange( double startRange )
        {
            startRange_ = startRange;
        }
        double EndRange( ) const
        {
            return endRange_;
        }
        void SetEndRange( double endRange )
        {
            endRange_ = endRange;
        }
        Int32 UpdateRate( ) const
        {
            return updateRate_;
        }
        void SetUpdateRate( Int32 updateRate )
        {
            updateRate_ = updateRate;
        }
        const TimeSpan& StatusSendTime( ) const
        {
            return statusSendTime_;
        }
        void SetStatusSendTime( const TimeSpan& statusSendTime )
        {
            statusSendTime_ = statusSendTime;
        }
        bool DrawBorder( ) const
        {
            return drawBorder_;
        }
        void SetDrawBorder( bool drawBorder )
        {
            drawBorder_ = drawBorder;
        }
        const Binary& Colors( ) const
        {
            return colors_;
        }
        void SetColors( const Binary& colors )
        {
            colors_ = colors;
        }
        bool SendToServer( ) const
        {
            return sendToServer_;
        }
        void SetSendToServer( bool sendToServer )
        {
            sendToServer_ = sendToServer;
        }
        const FixedDBWideString<100>& Directory( ) const
        {
            return directory_;
        }
        void SetDirectory( const WideString& directory )
        {
            directory_ = directory;
        }
        bool TransparentWater( ) const
        {
            return transparentWater_;
        }
        void SetTransparentWater( bool transparentWater )
        {
            transparentWater_ = transparentWater;
        }
        bool SavePictures( ) const
        {
            return savePictures_;
        }
        void SetSavePictures( bool savePictures )
        {
            savePictures_ = savePictures;
        }
        bool SendAsTarget( ) const
        {
            return sendAsTarget_;
        }
        void SetSendAsTarget( bool sendAsTarget )
        {
            sendAsTarget_ = sendAsTarget;
        }
        bool WriteLog( ) const
        {
            return writeLog_;
        }
        void SetWriteLog( bool writeLog )
        {
            writeLog_ = writeLog;
        }
        const FixedDBWideString<100>& TargetFilePrefix( ) const
        {
            return targetFilePrefix_;
        }
        void SetTargetFilePrefix( const WideString& targetFilePrefix )
        {
            targetFilePrefix_ = targetFilePrefix;
        }
        const Guid& TargetMMSI( ) const
        {
            return targetMMSI_;
        }
        void SetTargetMMSI( const Guid& targetMMSI )
        {
            targetMMSI_ = targetMMSI;
        }
        double Latitude( ) const
        {
            return latitude_;
        }
        void SetLatitude( double latitude )
        {
            latitude_ = latitude;
        }
        double Longitude( ) const
        {
            return longitude_;
        }
        void SetLongitude( double longitude )
        {
            longitude_ = longitude;
        }
        bool TestSourceEnabled( ) const
        {
            return testSourceEnabled_;
        }
        void SetTestSourceEnabled( bool testSourceEnabled )
        {
            testSourceEnabled_ = testSourceEnabled;
        }
        const FixedDBWideString<100>& ProxyServer( ) const
        {
            return proxyServer_;
        }
        void SetProxyServer( const WideString& proxyServer )
        {
            proxyServer_ = proxyServer;
        }
        bool UseProxyServer( ) const
        {
            return useProxyServer_;
        }
        void SetUseProxyServer( bool useProxyServer )
        {
            useProxyServer_ = useProxyServer;
        }
        void BindColumns( const ODBC::Statement& statement )
        {
            Bind(statement, ID_FIELD_ID, id_);
            Bind(statement, ROWVERSION_FIELD_ID, rowVersion_);
            Bind(statement, OILSPILLDETECTOR_FIELD_ID, oilSpillDetector_);
            Bind(statement, TIMESTAMP_FIELD_ID, timestamp_);
            Bind(statement, RANGE_FIELD_ID, range_);
            Bind(statement, STARTANGLE_FIELD_ID, startAngle_);
            Bind(statement, ENDANGLE_FIELD_ID, endAngle_);
            Bind(statement, STARTRANGE_FIELD_ID, startRange_);
            Bind(statement, ENDRANGE_FIELD_ID, endRange_);
            Bind(statement, UPDATERATE_FIELD_ID, updateRate_);
            Bind(statement, STATUSSENDTIME_FIELD_ID, statusSendTime_);
            Bind(statement, DRAWBORDER_FIELD_ID, drawBorder_);
            Bind(statement, SENDTOSERVER_FIELD_ID, sendToServer_);
            Bind(statement, DIRECTORY_FIELD_ID, directory_);
            Bind(statement, TRANSPARENTWATER_FIELD_ID, transparentWater_);
            Bind(statement, SAVEPICTURES_FIELD_ID, savePictures_);
            Bind(statement, SENDASTARGET_FIELD_ID, sendAsTarget_);
            Bind(statement, WRITELOG_FIELD_ID, writeLog_);
            Bind(statement, TARGETFILEPREFIX_FIELD_ID, targetFilePrefix_);
            Bind(statement, TARGETMMSI_FIELD_ID, targetMMSI_);
            Bind(statement, LATITUDE_FIELD_ID, latitude_);
            Bind(statement, LONGITUDE_FIELD_ID, longitude_);
            Bind(statement, TESTSOURCEENABLED_FIELD_ID, testSourceEnabled_);
            Bind(statement, PROXYSERVER_FIELD_ID, proxyServer_);
            Bind(statement, USEPROXYSERVER_FIELD_ID, useProxyServer_);
        }

        void ReadUnboundData( const ODBC::Statement& statement )
        {
            Base::ReadUnboundData( statement );

            colors_ = statement.GetBinary(COLORS_FIELD_ID);
        }
        template<IO::StreamWriter StreamT>
        void WriteColumns( IO::BinaryWriter<StreamT>& destination ) const
        {
            WriteColumnValue( destination, id_);
            WriteColumnValue( destination, rowVersion_);
            WriteColumnValue( destination, oilSpillDetector_);
            WriteColumnValue( destination, timestamp_);
            WriteColumnValue( destination, range_);
            WriteColumnValue( destination, startAngle_);
            WriteColumnValue( destination, endAngle_);
            WriteColumnValue( destination, startRange_);
            WriteColumnValue( destination, endRange_);
            WriteColumnValue( destination, updateRate_);
            WriteColumnValue( destination, statusSendTime_);
            WriteColumnValue( destination, drawBorder_);
            WriteColumnValue( destination, colors_);
            WriteColumnValue( destination, sendToServer_);
            WriteColumnValue( destination, directory_);
            WriteColumnValue( destination, transparentWater_);
            WriteColumnValue( destination, savePictures_);
            WriteColumnValue( destination, sendAsTarget_);
            WriteColumnValue( destination, writeLog_);
            WriteColumnValue( destination, targetFilePrefix_);
            WriteColumnValue( destination, targetMMSI_);
            WriteColumnValue( destination, latitude_);
            WriteColumnValue( destination, longitude_);
            WriteColumnValue( destination, testSourceEnabled_);
            WriteColumnValue( destination, proxyServer_);
            WriteColumnValue( destination, useProxyServer_);
        }
    };

    using SimpleOilspillDetectorConfigurationDataReader = SimpleColumnDataReader<OilspillDetectorConfigurationColumnData>;

    class Position2DTimeseriesValueColumnData : public BaseColumnData
    {
        Guid id_;
        Int64 rowVersion_ = 0;
        Guid timeseries_;
        DateTime timestamp_;
        DBDouble x_;
        DBDouble y_;
    public:
        using Base = BaseColumnData;

        static constexpr std::wstring_view FieldNames = L"[Id],[RowVersion],[Timeseries],[Timestamp],[X],[Y]";
        static constexpr std::wstring_view ViewName = L"Position2DTimeseriesValueView";

        static constexpr SQLUSMALLINT ID_FIELD_ID = 1;
        static constexpr SQLUSMALLINT ROWVERSION_FIELD_ID = 2;
        static constexpr SQLUSMALLINT TIMESERIES_FIELD_ID = 3;
        static constexpr SQLUSMALLINT TIMESTAMP_FIELD_ID = 4;
        static constexpr SQLUSMALLINT X_FIELD_ID = 5;
        static constexpr SQLUSMALLINT Y_FIELD_ID = 6;

        Position2DTimeseriesValueColumnData( ) = default;

        virtual Kind GetKind() const override
        {
            return Kind::Position2DTimeseriesValue;
        }

        const Guid& Id( ) const
        {
            return id_;
        }
        void SetId( const Guid& id )
        {
            id_ = id;
        }
        Int64 RowVersion( ) const
        {
            return rowVersion_;
        }
        void SetRowVersion( const Int64& rowVersion )
        {
            rowVersion_ = rowVersion;
        }
        const Guid& Timeseries( ) const
        {
            return timeseries_;
        }
        void SetTimeseries( const Guid& timeseries )
        {
            timeseries_ = timeseries;
        }
        const DateTime& Timestamp( ) const
        {
            return timestamp_;
        }
        void SetTimestamp( const DateTime& timestamp )
        {
            timestamp_ = timestamp;
        }
        const DBDouble& X( ) const
        {
            return x_;
        }
        void SetX( const DBDouble& x )
        {
            x_ = x;
        }
        const DBDouble& Y( ) const
        {
            return y_;
        }
        void SetY( const DBDouble& y )
        {
            y_ = y;
        }
        void BindColumns( const ODBC::Statement& statement )
        {
            Bind(statement, ID_FIELD_ID, id_);
            Bind(statement, ROWVERSION_FIELD_ID, rowVersion_);
            Bind(statement, TIMESERIES_FIELD_ID, timeseries_);
            Bind(statement, TIMESTAMP_FIELD_ID, timestamp_);
            Bind(statement, X_FIELD_ID, x_);
            Bind(statement, Y_FIELD_ID, y_);
        }

        template<IO::StreamWriter StreamT>
        void WriteColumns( IO::BinaryWriter<StreamT>& destination ) const
        {
            WriteColumnValue( destination, id_);
            WriteColumnValue( destination, rowVersion_);
            WriteColumnValue( destination, timeseries_);
            WriteColumnValue( destination, timestamp_);
            WriteColumnValue( destination, x_);
            WriteColumnValue( destination, y_);
        }
    };

    using SimplePosition2DTimeseriesValueDataReader = SimpleColumnDataReader<Position2DTimeseriesValueColumnData>;

    class Position3DTimeseriesValueColumnData : public BaseColumnData
    {
        Guid id_;
        Int64 rowVersion_ = 0;
        Guid timeseries_;
        DateTime timestamp_;
        DBDouble x_;
        DBDouble y_;
        DBDouble z_;
    public:
        using Base = BaseColumnData;

        static constexpr std::wstring_view FieldNames = L"[Id],[RowVersion],[Timeseries],[Timestamp],[X],[Y],[Z]";
        static constexpr std::wstring_view ViewName = L"Position3DTimeseriesValueView";

        static constexpr SQLUSMALLINT ID_FIELD_ID = 1;
        static constexpr SQLUSMALLINT ROWVERSION_FIELD_ID = 2;
        static constexpr SQLUSMALLINT TIMESERIES_FIELD_ID = 3;
        static constexpr SQLUSMALLINT TIMESTAMP_FIELD_ID = 4;
        static constexpr SQLUSMALLINT X_FIELD_ID = 5;
        static constexpr SQLUSMALLINT Y_FIELD_ID = 6;
        static constexpr SQLUSMALLINT Z_FIELD_ID = 7;

        Position3DTimeseriesValueColumnData( ) = default;

        virtual Kind GetKind() const override
        {
            return Kind::Position3DTimeseriesValue;
        }

        const Guid& Id( ) const
        {
            return id_;
        }
        void SetId( const Guid& id )
        {
            id_ = id;
        }
        Int64 RowVersion( ) const
        {
            return rowVersion_;
        }
        void SetRowVersion( const Int64& rowVersion )
        {
            rowVersion_ = rowVersion;
        }
        const Guid& Timeseries( ) const
        {
            return timeseries_;
        }
        void SetTimeseries( const Guid& timeseries )
        {
            timeseries_ = timeseries;
        }
        const DateTime& Timestamp( ) const
        {
            return timestamp_;
        }
        void SetTimestamp( const DateTime& timestamp )
        {
            timestamp_ = timestamp;
        }
        const DBDouble& X( ) const
        {
            return x_;
        }
        void SetX( const DBDouble& x )
        {
            x_ = x;
        }
        const DBDouble& Y( ) const
        {
            return y_;
        }
        void SetY( const DBDouble& y )
        {
            y_ = y;
        }
        const DBDouble& Z( ) const
        {
            return z_;
        }
        void SetZ( const DBDouble& z )
        {
            z_ = z;
        }
        void BindColumns( const ODBC::Statement& statement )
        {
            Bind(statement, ID_FIELD_ID, id_);
            Bind(statement, ROWVERSION_FIELD_ID, rowVersion_);
            Bind(statement, TIMESERIES_FIELD_ID, timeseries_);
            Bind(statement, TIMESTAMP_FIELD_ID, timestamp_);
            Bind(statement, X_FIELD_ID, x_);
            Bind(statement, Y_FIELD_ID, y_);
            Bind(statement, Z_FIELD_ID, z_);
        }

        template<IO::StreamWriter StreamT>
        void WriteColumns( IO::BinaryWriter<StreamT>& destination ) const
        {
            WriteColumnValue( destination, id_);
            WriteColumnValue( destination, rowVersion_);
            WriteColumnValue( destination, timeseries_);
            WriteColumnValue( destination, timestamp_);
            WriteColumnValue( destination, x_);
            WriteColumnValue( destination, y_);
            WriteColumnValue( destination, z_);
        }
    };

    using SimplePosition3DTimeseriesValueDataReader = SimpleColumnDataReader<Position3DTimeseriesValueColumnData>;

    class ProcessTrackValueResultColumnData : public BaseColumnData
    {
        Guid id_;
        Int64 rowVersion_ = 0;
        bool createdNewTrack_ = false;
        Guid trackId_;
    public:
        using Base = BaseColumnData;

        static constexpr std::wstring_view FieldNames = L"[Id],[RowVersion],[CreatedNewTrack],[TrackId]";
        static constexpr std::wstring_view ViewName = L"ProcessTrackValueResultView";

        static constexpr SQLUSMALLINT ID_FIELD_ID = 1;
        static constexpr SQLUSMALLINT ROWVERSION_FIELD_ID = 2;
        static constexpr SQLUSMALLINT CREATEDNEWTRACK_FIELD_ID = 3;
        static constexpr SQLUSMALLINT TRACKID_FIELD_ID = 4;

        ProcessTrackValueResultColumnData( ) = default;

        virtual Kind GetKind() const override
        {
            return Kind::ProcessTrackValueResult;
        }

        const Guid& Id( ) const
        {
            return id_;
        }
        void SetId( const Guid& id )
        {
            id_ = id;
        }
        Int64 RowVersion( ) const
        {
            return rowVersion_;
        }
        void SetRowVersion( const Int64& rowVersion )
        {
            rowVersion_ = rowVersion;
        }
        bool CreatedNewTrack( ) const
        {
            return createdNewTrack_;
        }
        void SetCreatedNewTrack( bool createdNewTrack )
        {
            createdNewTrack_ = createdNewTrack;
        }
        const Guid& TrackId( ) const
        {
            return trackId_;
        }
        void SetTrackId( const Guid& trackId )
        {
            trackId_ = trackId;
        }
        void BindColumns( const ODBC::Statement& statement )
        {
            Bind(statement, ID_FIELD_ID, id_);
            Bind(statement, ROWVERSION_FIELD_ID, rowVersion_);
            Bind(statement, CREATEDNEWTRACK_FIELD_ID, createdNewTrack_);
            Bind(statement, TRACKID_FIELD_ID, trackId_);
        }

        template<IO::StreamWriter StreamT>
        void WriteColumns( IO::BinaryWriter<StreamT>& destination ) const
        {
            WriteColumnValue( destination, id_);
            WriteColumnValue( destination, rowVersion_);
            WriteColumnValue( destination, createdNewTrack_);
            WriteColumnValue( destination, trackId_);
        }
    };

    using SimpleProcessTrackValueResultDataReader = SimpleColumnDataReader<ProcessTrackValueResultColumnData>;

    class PropertyColumnData : public BaseColumnData
    {
        Guid id_;
        Int64 rowVersion_ = 0;
        Guid element_;
        Guid definition_;
    public:
        using Base = BaseColumnData;

        static constexpr std::wstring_view FieldNames = L"[Id],[RowVersion],[Element],[Definition]";
        static constexpr std::wstring_view ViewName = L"PropertyView";

        static constexpr SQLUSMALLINT ID_FIELD_ID = 1;
        static constexpr SQLUSMALLINT ROWVERSION_FIELD_ID = 2;
        static constexpr SQLUSMALLINT ELEMENT_FIELD_ID = 3;
        static constexpr SQLUSMALLINT DEFINITION_FIELD_ID = 4;

        PropertyColumnData( ) = default;

        virtual Kind GetKind() const override
        {
            return Kind::Property;
        }

        const Guid& Id( ) const
        {
            return id_;
        }
        void SetId( const Guid& id )
        {
            id_ = id;
        }
        Int64 RowVersion( ) const
        {
            return rowVersion_;
        }
        void SetRowVersion( const Int64& rowVersion )
        {
            rowVersion_ = rowVersion;
        }
        const Guid& Element( ) const
        {
            return element_;
        }
        void SetElement( const Guid& element )
        {
            element_ = element;
        }
        const Guid& Definition( ) const
        {
            return definition_;
        }
        void SetDefinition( const Guid& definition )
        {
            definition_ = definition;
        }
        void BindColumns( const ODBC::Statement& statement )
        {
            Bind(statement, ID_FIELD_ID, id_);
            Bind(statement, ROWVERSION_FIELD_ID, rowVersion_);
            Bind(statement, ELEMENT_FIELD_ID, element_);
            Bind(statement, DEFINITION_FIELD_ID, definition_);
        }

        template<IO::StreamWriter StreamT>
        void WriteColumns( IO::BinaryWriter<StreamT>& destination ) const
        {
            WriteColumnValue( destination, id_);
            WriteColumnValue( destination, rowVersion_);
            WriteColumnValue( destination, element_);
            WriteColumnValue( destination, definition_);
        }
    };

    using SimplePropertyDataReader = SimpleColumnDataReader<PropertyColumnData>;

    class BinaryPropertyColumnData : public PropertyColumnData
    {
        Binary value_;
        SQLLEN valueLength_ = SQL_NULL_DATA;
    public:
        using Base = PropertyColumnData;

        static constexpr std::wstring_view FieldNames = L"[Id],[RowVersion],[Element],[Definition],[Value]";
        static constexpr std::wstring_view ViewName = L"BinaryPropertyView";

        static constexpr SQLUSMALLINT VALUE_FIELD_ID = 5;

        BinaryPropertyColumnData( ) = default;

        virtual Kind GetKind() const override
        {
            return Kind::BinaryProperty;
        }

        const Binary& Value( ) const
        {
            return value_;
        }
        void SetValue( const Binary& value )
        {
            value_ = value;
        }
        void BindColumns( const ODBC::Statement& statement )
        {
            Base::BindColumns( statement );

        }

        void ReadUnboundData( const ODBC::Statement& statement )
        {
            Base::ReadUnboundData( statement );

            value_ = statement.GetBinary(VALUE_FIELD_ID);
        }
        template<IO::StreamWriter StreamT>
        void WriteColumns( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteColumns( destination );
            WriteColumnValue( destination, value_);
        }
    };

    using SimpleBinaryPropertyDataReader = SimpleColumnDataReader<BinaryPropertyColumnData>;

    class BooleanPropertyColumnData : public PropertyColumnData
    {
        bool value_ = false;
    public:
        using Base = PropertyColumnData;

        static constexpr std::wstring_view FieldNames = L"[Id],[RowVersion],[Element],[Definition],[Value]";
        static constexpr std::wstring_view ViewName = L"BooleanPropertyView";

        static constexpr SQLUSMALLINT VALUE_FIELD_ID = 5;

        BooleanPropertyColumnData( ) = default;

        virtual Kind GetKind() const override
        {
            return Kind::BooleanProperty;
        }

        bool Value( ) const
        {
            return value_;
        }
        void SetValue( bool value )
        {
            value_ = value;
        }
        void BindColumns( const ODBC::Statement& statement )
        {
            Base::BindColumns( statement );

            Bind(statement, VALUE_FIELD_ID, value_);
        }

        template<IO::StreamWriter StreamT>
        void WriteColumns( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteColumns( destination );
            WriteColumnValue( destination, value_);
        }
    };

    using SimpleBooleanPropertyDataReader = SimpleColumnDataReader<BooleanPropertyColumnData>;

    class BytePropertyColumnData : public PropertyColumnData
    {
        Byte value_ = 0;
    public:
        using Base = PropertyColumnData;

        static constexpr std::wstring_view FieldNames = L"[Id],[RowVersion],[Element],[Definition],[Value]";
        static constexpr std::wstring_view ViewName = L"BytePropertyView";

        static constexpr SQLUSMALLINT VALUE_FIELD_ID = 5;

        BytePropertyColumnData( ) = default;

        virtual Kind GetKind() const override
        {
            return Kind::ByteProperty;
        }

        Byte Value( ) const
        {
            return value_;
        }
        void SetValue( Byte value )
        {
            value_ = value;
        }
        void BindColumns( const ODBC::Statement& statement )
        {
            Base::BindColumns( statement );

            Bind(statement, VALUE_FIELD_ID, value_);
        }

        template<IO::StreamWriter StreamT>
        void WriteColumns( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteColumns( destination );
            WriteColumnValue( destination, value_);
        }
    };

    using SimpleBytePropertyDataReader = SimpleColumnDataReader<BytePropertyColumnData>;

    class DateTimePropertyColumnData : public PropertyColumnData
    {
        DateTime value_;
    public:
        using Base = PropertyColumnData;

        static constexpr std::wstring_view FieldNames = L"[Id],[RowVersion],[Element],[Definition],[Value]";
        static constexpr std::wstring_view ViewName = L"DateTimePropertyView";

        static constexpr SQLUSMALLINT VALUE_FIELD_ID = 5;

        DateTimePropertyColumnData( ) = default;

        virtual Kind GetKind() const override
        {
            return Kind::DateTimeProperty;
        }

        const DateTime& Value( ) const
        {
            return value_;
        }
        void SetValue( const DateTime& value )
        {
            value_ = value;
        }
        void BindColumns( const ODBC::Statement& statement )
        {
            Base::BindColumns( statement );

            Bind(statement, VALUE_FIELD_ID, value_);
        }

        template<IO::StreamWriter StreamT>
        void WriteColumns( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteColumns( destination );
            WriteColumnValue( destination, value_);
        }
    };

    using SimpleDateTimePropertyDataReader = SimpleColumnDataReader<DateTimePropertyColumnData>;

    class DoublePropertyColumnData : public PropertyColumnData
    {
        double value_ = 0.0;
    public:
        using Base = PropertyColumnData;

        static constexpr std::wstring_view FieldNames = L"[Id],[RowVersion],[Element],[Definition],[Value]";
        static constexpr std::wstring_view ViewName = L"DoublePropertyView";

        static constexpr SQLUSMALLINT VALUE_FIELD_ID = 5;

        DoublePropertyColumnData( ) = default;

        virtual Kind GetKind() const override
        {
            return Kind::DoubleProperty;
        }

        double Value( ) const
        {
            return value_;
        }
        void SetValue( double value )
        {
            value_ = value;
        }
        void BindColumns( const ODBC::Statement& statement )
        {
            Base::BindColumns( statement );

            Bind(statement, VALUE_FIELD_ID, value_);
        }

        template<IO::StreamWriter StreamT>
        void WriteColumns( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteColumns( destination );
            WriteColumnValue( destination, value_);
        }
    };

    using SimpleDoublePropertyDataReader = SimpleColumnDataReader<DoublePropertyColumnData>;

    class GuidPropertyColumnData : public PropertyColumnData
    {
        Guid value_;
    public:
        using Base = PropertyColumnData;

        static constexpr std::wstring_view FieldNames = L"[Id],[RowVersion],[Element],[Definition],[Value]";
        static constexpr std::wstring_view ViewName = L"GuidPropertyView";

        static constexpr SQLUSMALLINT VALUE_FIELD_ID = 5;

        GuidPropertyColumnData( ) = default;

        virtual Kind GetKind() const override
        {
            return Kind::GuidProperty;
        }

        const Guid& Value( ) const
        {
            return value_;
        }
        void SetValue( const Guid& value )
        {
            value_ = value;
        }
        void BindColumns( const ODBC::Statement& statement )
        {
            Base::BindColumns( statement );

            Bind(statement, VALUE_FIELD_ID, value_);
        }

        template<IO::StreamWriter StreamT>
        void WriteColumns( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteColumns( destination );
            WriteColumnValue( destination, value_);
        }
    };

    using SimpleGuidPropertyDataReader = SimpleColumnDataReader<GuidPropertyColumnData>;

    class Int16PropertyColumnData : public PropertyColumnData
    {
        Int16 value_ = 0;
    public:
        using Base = PropertyColumnData;

        static constexpr std::wstring_view FieldNames = L"[Id],[RowVersion],[Element],[Definition],[Value]";
        static constexpr std::wstring_view ViewName = L"Int16PropertyView";

        static constexpr SQLUSMALLINT VALUE_FIELD_ID = 5;

        Int16PropertyColumnData( ) = default;

        virtual Kind GetKind() const override
        {
            return Kind::Int16Property;
        }

        Int16 Value( ) const
        {
            return value_;
        }
        void SetValue( Int16 value )
        {
            value_ = value;
        }
        void BindColumns( const ODBC::Statement& statement )
        {
            Base::BindColumns( statement );

            Bind(statement, VALUE_FIELD_ID, value_);
        }

        template<IO::StreamWriter StreamT>
        void WriteColumns( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteColumns( destination );
            WriteColumnValue( destination, value_);
        }
    };

    using SimpleInt16PropertyDataReader = SimpleColumnDataReader<Int16PropertyColumnData>;

    class Int32PropertyColumnData : public PropertyColumnData
    {
        Int32 value_ = 0;
    public:
        using Base = PropertyColumnData;

        static constexpr std::wstring_view FieldNames = L"[Id],[RowVersion],[Element],[Definition],[Value]";
        static constexpr std::wstring_view ViewName = L"Int32PropertyView";

        static constexpr SQLUSMALLINT VALUE_FIELD_ID = 5;

        Int32PropertyColumnData( ) = default;

        virtual Kind GetKind() const override
        {
            return Kind::Int32Property;
        }

        Int32 Value( ) const
        {
            return value_;
        }
        void SetValue( Int32 value )
        {
            value_ = value;
        }
        void BindColumns( const ODBC::Statement& statement )
        {
            Base::BindColumns( statement );

            Bind(statement, VALUE_FIELD_ID, value_);
        }

        template<IO::StreamWriter StreamT>
        void WriteColumns( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteColumns( destination );
            WriteColumnValue( destination, value_);
        }
    };

    using SimpleInt32PropertyDataReader = SimpleColumnDataReader<Int32PropertyColumnData>;

    class Int64PropertyColumnData : public PropertyColumnData
    {
        Int64 value_ = 0;
    public:
        using Base = PropertyColumnData;

        static constexpr std::wstring_view FieldNames = L"[Id],[RowVersion],[Element],[Definition],[Value]";
        static constexpr std::wstring_view ViewName = L"Int64PropertyView";

        static constexpr SQLUSMALLINT VALUE_FIELD_ID = 5;

        Int64PropertyColumnData( ) = default;

        virtual Kind GetKind() const override
        {
            return Kind::Int64Property;
        }

        Int64 Value( ) const
        {
            return value_;
        }
        void SetValue( Int64 value )
        {
            value_ = value;
        }
        void BindColumns( const ODBC::Statement& statement )
        {
            Base::BindColumns( statement );

            Bind(statement, VALUE_FIELD_ID, value_);
        }

        template<IO::StreamWriter StreamT>
        void WriteColumns( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteColumns( destination );
            WriteColumnValue( destination, value_);
        }
    };

    using SimpleInt64PropertyDataReader = SimpleColumnDataReader<Int64PropertyColumnData>;

    class ReferencePropertyColumnData : public PropertyColumnData
    {
        Guid value_;
    public:
        using Base = PropertyColumnData;

        static constexpr std::wstring_view FieldNames = L"[Id],[RowVersion],[Element],[Definition],[Value]";
        static constexpr std::wstring_view ViewName = L"ReferencePropertyView";

        static constexpr SQLUSMALLINT VALUE_FIELD_ID = 5;

        ReferencePropertyColumnData( ) = default;

        virtual Kind GetKind() const override
        {
            return Kind::ReferenceProperty;
        }

        const Guid& Value( ) const
        {
            return value_;
        }
        void SetValue( const Guid& value )
        {
            value_ = value;
        }
        void BindColumns( const ODBC::Statement& statement )
        {
            Base::BindColumns( statement );

            Bind(statement, VALUE_FIELD_ID, value_);
        }

        template<IO::StreamWriter StreamT>
        void WriteColumns( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteColumns( destination );
            WriteColumnValue( destination, value_);
        }
    };

    using SimpleReferencePropertyDataReader = SimpleColumnDataReader<ReferencePropertyColumnData>;

    class SBytePropertyColumnData : public PropertyColumnData
    {
        SByte value_ = 0;
    public:
        using Base = PropertyColumnData;

        static constexpr std::wstring_view FieldNames = L"[Id],[RowVersion],[Element],[Definition],[Value]";
        static constexpr std::wstring_view ViewName = L"SBytePropertyView";

        static constexpr SQLUSMALLINT VALUE_FIELD_ID = 5;

        SBytePropertyColumnData( ) = default;

        virtual Kind GetKind() const override
        {
            return Kind::SByteProperty;
        }

        SByte Value( ) const
        {
            return value_;
        }
        void SetValue( SByte value )
        {
            value_ = value;
        }
        void BindColumns( const ODBC::Statement& statement )
        {
            Base::BindColumns( statement );

            Bind(statement, VALUE_FIELD_ID, value_);
        }

        template<IO::StreamWriter StreamT>
        void WriteColumns( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteColumns( destination );
            WriteColumnValue( destination, value_);
        }
    };

    using SimpleSBytePropertyDataReader = SimpleColumnDataReader<SBytePropertyColumnData>;

    class SinglePropertyColumnData : public PropertyColumnData
    {
        float value_ = 0.0f;
    public:
        using Base = PropertyColumnData;

        static constexpr std::wstring_view FieldNames = L"[Id],[RowVersion],[Element],[Definition],[Value]";
        static constexpr std::wstring_view ViewName = L"SinglePropertyView";

        static constexpr SQLUSMALLINT VALUE_FIELD_ID = 5;

        SinglePropertyColumnData( ) = default;

        virtual Kind GetKind() const override
        {
            return Kind::SingleProperty;
        }

        float Value( ) const
        {
            return value_;
        }
        void SetValue( float value )
        {
            value_ = value;
        }
        void BindColumns( const ODBC::Statement& statement )
        {
            Base::BindColumns( statement );

            Bind(statement, VALUE_FIELD_ID, value_);
        }

        template<IO::StreamWriter StreamT>
        void WriteColumns( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteColumns( destination );
            WriteColumnValue( destination, value_);
        }
    };

    using SimpleSinglePropertyDataReader = SimpleColumnDataReader<SinglePropertyColumnData>;

    class StringPropertyColumnData : public PropertyColumnData
    {
        FixedDBWideString<100> value_;
    public:
        using Base = PropertyColumnData;

        static constexpr std::wstring_view FieldNames = L"[Id],[RowVersion],[Element],[Definition],[Value]";
        static constexpr std::wstring_view ViewName = L"StringPropertyView";

        static constexpr SQLUSMALLINT VALUE_FIELD_ID = 5;

        StringPropertyColumnData( ) = default;

        virtual Kind GetKind() const override
        {
            return Kind::StringProperty;
        }

        const FixedDBWideString<100>& Value( ) const
        {
            return value_;
        }
        void SetValue( const WideString& value )
        {
            value_ = value;
        }
        void BindColumns( const ODBC::Statement& statement )
        {
            Base::BindColumns( statement );

            Bind(statement, VALUE_FIELD_ID, value_);
        }

        template<IO::StreamWriter StreamT>
        void WriteColumns( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteColumns( destination );
            WriteColumnValue( destination, value_);
        }
    };

    using SimpleStringPropertyDataReader = SimpleColumnDataReader<StringPropertyColumnData>;

    class TimeseriesPropertyColumnData : public PropertyColumnData
    {
    public:
        using Base = PropertyColumnData;

        static constexpr std::wstring_view FieldNames = L"[Id],[RowVersion],[Element],[Definition]";
        static constexpr std::wstring_view ViewName = L"TimeseriesPropertyView";

        TimeseriesPropertyColumnData( ) = default;

        virtual Kind GetKind() const override
        {
            return Kind::TimeseriesProperty;
        }

        template<IO::StreamWriter StreamT>
        void WriteColumns( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteColumns( destination );
        }
    };

    using SimpleTimeseriesPropertyDataReader = SimpleColumnDataReader<TimeseriesPropertyColumnData>;

    class BinaryTimeseriesPropertyColumnData : public TimeseriesPropertyColumnData
    {
        Guid timeseries_;
    public:
        using Base = TimeseriesPropertyColumnData;

        static constexpr std::wstring_view FieldNames = L"[Id],[RowVersion],[Element],[Definition],[Timeseries]";
        static constexpr std::wstring_view ViewName = L"BinaryTimeseriesPropertyView";

        static constexpr SQLUSMALLINT TIMESERIES_FIELD_ID = 5;

        BinaryTimeseriesPropertyColumnData( ) = default;

        virtual Kind GetKind() const override
        {
            return Kind::BinaryTimeseriesProperty;
        }

        const Guid& Timeseries( ) const
        {
            return timeseries_;
        }
        void SetTimeseries( const Guid& timeseries )
        {
            timeseries_ = timeseries;
        }
        void BindColumns( const ODBC::Statement& statement )
        {
            Base::BindColumns( statement );

            Bind(statement, TIMESERIES_FIELD_ID, timeseries_);
        }

        template<IO::StreamWriter StreamT>
        void WriteColumns( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteColumns( destination );
            WriteColumnValue( destination, timeseries_);
        }
    };

    using SimpleBinaryTimeseriesPropertyDataReader = SimpleColumnDataReader<BinaryTimeseriesPropertyColumnData>;

    class BooleanTimeseriesPropertyColumnData : public TimeseriesPropertyColumnData
    {
        Guid timeseries_;
    public:
        using Base = TimeseriesPropertyColumnData;

        static constexpr std::wstring_view FieldNames = L"[Id],[RowVersion],[Element],[Definition],[Timeseries]";
        static constexpr std::wstring_view ViewName = L"BooleanTimeseriesPropertyView";

        static constexpr SQLUSMALLINT TIMESERIES_FIELD_ID = 5;

        BooleanTimeseriesPropertyColumnData( ) = default;

        virtual Kind GetKind() const override
        {
            return Kind::BooleanTimeseriesProperty;
        }

        const Guid& Timeseries( ) const
        {
            return timeseries_;
        }
        void SetTimeseries( const Guid& timeseries )
        {
            timeseries_ = timeseries;
        }
        void BindColumns( const ODBC::Statement& statement )
        {
            Base::BindColumns( statement );

            Bind(statement, TIMESERIES_FIELD_ID, timeseries_);
        }

        template<IO::StreamWriter StreamT>
        void WriteColumns( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteColumns( destination );
            WriteColumnValue( destination, timeseries_);
        }
    };

    using SimpleBooleanTimeseriesPropertyDataReader = SimpleColumnDataReader<BooleanTimeseriesPropertyColumnData>;

    class ByteTimeseriesPropertyColumnData : public TimeseriesPropertyColumnData
    {
        Guid timeseries_;
    public:
        using Base = TimeseriesPropertyColumnData;

        static constexpr std::wstring_view FieldNames = L"[Id],[RowVersion],[Element],[Definition],[Timeseries]";
        static constexpr std::wstring_view ViewName = L"ByteTimeseriesPropertyView";

        static constexpr SQLUSMALLINT TIMESERIES_FIELD_ID = 5;

        ByteTimeseriesPropertyColumnData( ) = default;

        virtual Kind GetKind() const override
        {
            return Kind::ByteTimeseriesProperty;
        }

        const Guid& Timeseries( ) const
        {
            return timeseries_;
        }
        void SetTimeseries( const Guid& timeseries )
        {
            timeseries_ = timeseries;
        }
        void BindColumns( const ODBC::Statement& statement )
        {
            Base::BindColumns( statement );

            Bind(statement, TIMESERIES_FIELD_ID, timeseries_);
        }

        template<IO::StreamWriter StreamT>
        void WriteColumns( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteColumns( destination );
            WriteColumnValue( destination, timeseries_);
        }
    };

    using SimpleByteTimeseriesPropertyDataReader = SimpleColumnDataReader<ByteTimeseriesPropertyColumnData>;

    class DateTimeTimeseriesPropertyColumnData : public TimeseriesPropertyColumnData
    {
        Guid timeseries_;
    public:
        using Base = TimeseriesPropertyColumnData;

        static constexpr std::wstring_view FieldNames = L"[Id],[RowVersion],[Element],[Definition],[Timeseries]";
        static constexpr std::wstring_view ViewName = L"DateTimeTimeseriesPropertyView";

        static constexpr SQLUSMALLINT TIMESERIES_FIELD_ID = 5;

        DateTimeTimeseriesPropertyColumnData( ) = default;

        virtual Kind GetKind() const override
        {
            return Kind::DateTimeTimeseriesProperty;
        }

        const Guid& Timeseries( ) const
        {
            return timeseries_;
        }
        void SetTimeseries( const Guid& timeseries )
        {
            timeseries_ = timeseries;
        }
        void BindColumns( const ODBC::Statement& statement )
        {
            Base::BindColumns( statement );

            Bind(statement, TIMESERIES_FIELD_ID, timeseries_);
        }

        template<IO::StreamWriter StreamT>
        void WriteColumns( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteColumns( destination );
            WriteColumnValue( destination, timeseries_);
        }
    };

    using SimpleDateTimeTimeseriesPropertyDataReader = SimpleColumnDataReader<DateTimeTimeseriesPropertyColumnData>;

    class DoubleTimeseriesPropertyColumnData : public TimeseriesPropertyColumnData
    {
        Guid timeseries_;
    public:
        using Base = TimeseriesPropertyColumnData;

        static constexpr std::wstring_view FieldNames = L"[Id],[RowVersion],[Element],[Definition],[Timeseries]";
        static constexpr std::wstring_view ViewName = L"DoubleTimeseriesPropertyView";

        static constexpr SQLUSMALLINT TIMESERIES_FIELD_ID = 5;

        DoubleTimeseriesPropertyColumnData( ) = default;

        virtual Kind GetKind() const override
        {
            return Kind::DoubleTimeseriesProperty;
        }

        const Guid& Timeseries( ) const
        {
            return timeseries_;
        }
        void SetTimeseries( const Guid& timeseries )
        {
            timeseries_ = timeseries;
        }
        void BindColumns( const ODBC::Statement& statement )
        {
            Base::BindColumns( statement );

            Bind(statement, TIMESERIES_FIELD_ID, timeseries_);
        }

        template<IO::StreamWriter StreamT>
        void WriteColumns( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteColumns( destination );
            WriteColumnValue( destination, timeseries_);
        }
    };

    using SimpleDoubleTimeseriesPropertyDataReader = SimpleColumnDataReader<DoubleTimeseriesPropertyColumnData>;

    class GuidTimeseriesPropertyColumnData : public TimeseriesPropertyColumnData
    {
        Guid timeseries_;
    public:
        using Base = TimeseriesPropertyColumnData;

        static constexpr std::wstring_view FieldNames = L"[Id],[RowVersion],[Element],[Definition],[Timeseries]";
        static constexpr std::wstring_view ViewName = L"GuidTimeseriesPropertyView";

        static constexpr SQLUSMALLINT TIMESERIES_FIELD_ID = 5;

        GuidTimeseriesPropertyColumnData( ) = default;

        virtual Kind GetKind() const override
        {
            return Kind::GuidTimeseriesProperty;
        }

        const Guid& Timeseries( ) const
        {
            return timeseries_;
        }
        void SetTimeseries( const Guid& timeseries )
        {
            timeseries_ = timeseries;
        }
        void BindColumns( const ODBC::Statement& statement )
        {
            Base::BindColumns( statement );

            Bind(statement, TIMESERIES_FIELD_ID, timeseries_);
        }

        template<IO::StreamWriter StreamT>
        void WriteColumns( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteColumns( destination );
            WriteColumnValue( destination, timeseries_);
        }
    };

    using SimpleGuidTimeseriesPropertyDataReader = SimpleColumnDataReader<GuidTimeseriesPropertyColumnData>;

    class Int16TimeseriesPropertyColumnData : public TimeseriesPropertyColumnData
    {
        Guid timeseries_;
    public:
        using Base = TimeseriesPropertyColumnData;

        static constexpr std::wstring_view FieldNames = L"[Id],[RowVersion],[Element],[Definition],[Timeseries]";
        static constexpr std::wstring_view ViewName = L"Int16TimeseriesPropertyView";

        static constexpr SQLUSMALLINT TIMESERIES_FIELD_ID = 5;

        Int16TimeseriesPropertyColumnData( ) = default;

        virtual Kind GetKind() const override
        {
            return Kind::Int16TimeseriesProperty;
        }

        const Guid& Timeseries( ) const
        {
            return timeseries_;
        }
        void SetTimeseries( const Guid& timeseries )
        {
            timeseries_ = timeseries;
        }
        void BindColumns( const ODBC::Statement& statement )
        {
            Base::BindColumns( statement );

            Bind(statement, TIMESERIES_FIELD_ID, timeseries_);
        }

        template<IO::StreamWriter StreamT>
        void WriteColumns( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteColumns( destination );
            WriteColumnValue( destination, timeseries_);
        }
    };

    using SimpleInt16TimeseriesPropertyDataReader = SimpleColumnDataReader<Int16TimeseriesPropertyColumnData>;

    class Int32TimeseriesPropertyColumnData : public TimeseriesPropertyColumnData
    {
        Guid timeseries_;
    public:
        using Base = TimeseriesPropertyColumnData;

        static constexpr std::wstring_view FieldNames = L"[Id],[RowVersion],[Element],[Definition],[Timeseries]";
        static constexpr std::wstring_view ViewName = L"Int32TimeseriesPropertyView";

        static constexpr SQLUSMALLINT TIMESERIES_FIELD_ID = 5;

        Int32TimeseriesPropertyColumnData( ) = default;

        virtual Kind GetKind() const override
        {
            return Kind::Int32TimeseriesProperty;
        }

        const Guid& Timeseries( ) const
        {
            return timeseries_;
        }
        void SetTimeseries( const Guid& timeseries )
        {
            timeseries_ = timeseries;
        }
        void BindColumns( const ODBC::Statement& statement )
        {
            Base::BindColumns( statement );

            Bind(statement, TIMESERIES_FIELD_ID, timeseries_);
        }

        template<IO::StreamWriter StreamT>
        void WriteColumns( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteColumns( destination );
            WriteColumnValue( destination, timeseries_);
        }
    };

    using SimpleInt32TimeseriesPropertyDataReader = SimpleColumnDataReader<Int32TimeseriesPropertyColumnData>;

    class Int64TimeseriesPropertyColumnData : public TimeseriesPropertyColumnData
    {
        Guid timeseries_;
    public:
        using Base = TimeseriesPropertyColumnData;

        static constexpr std::wstring_view FieldNames = L"[Id],[RowVersion],[Element],[Definition],[Timeseries]";
        static constexpr std::wstring_view ViewName = L"Int64TimeseriesPropertyView";

        static constexpr SQLUSMALLINT TIMESERIES_FIELD_ID = 5;

        Int64TimeseriesPropertyColumnData( ) = default;

        virtual Kind GetKind() const override
        {
            return Kind::Int64TimeseriesProperty;
        }

        const Guid& Timeseries( ) const
        {
            return timeseries_;
        }
        void SetTimeseries( const Guid& timeseries )
        {
            timeseries_ = timeseries;
        }
        void BindColumns( const ODBC::Statement& statement )
        {
            Base::BindColumns( statement );

            Bind(statement, TIMESERIES_FIELD_ID, timeseries_);
        }

        template<IO::StreamWriter StreamT>
        void WriteColumns( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteColumns( destination );
            WriteColumnValue( destination, timeseries_);
        }
    };

    using SimpleInt64TimeseriesPropertyDataReader = SimpleColumnDataReader<Int64TimeseriesPropertyColumnData>;

    class ReferenceTimeseriesPropertyColumnData : public TimeseriesPropertyColumnData
    {
        Guid timeseries_;
    public:
        using Base = TimeseriesPropertyColumnData;

        static constexpr std::wstring_view FieldNames = L"[Id],[RowVersion],[Element],[Definition],[Timeseries]";
        static constexpr std::wstring_view ViewName = L"ReferenceTimeseriesPropertyView";

        static constexpr SQLUSMALLINT TIMESERIES_FIELD_ID = 5;

        ReferenceTimeseriesPropertyColumnData( ) = default;

        virtual Kind GetKind() const override
        {
            return Kind::ReferenceTimeseriesProperty;
        }

        const Guid& Timeseries( ) const
        {
            return timeseries_;
        }
        void SetTimeseries( const Guid& timeseries )
        {
            timeseries_ = timeseries;
        }
        void BindColumns( const ODBC::Statement& statement )
        {
            Base::BindColumns( statement );

            Bind(statement, TIMESERIES_FIELD_ID, timeseries_);
        }

        template<IO::StreamWriter StreamT>
        void WriteColumns( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteColumns( destination );
            WriteColumnValue( destination, timeseries_);
        }
    };

    using SimpleReferenceTimeseriesPropertyDataReader = SimpleColumnDataReader<ReferenceTimeseriesPropertyColumnData>;

    class SByteTimeseriesPropertyColumnData : public TimeseriesPropertyColumnData
    {
        Guid timeseries_;
    public:
        using Base = TimeseriesPropertyColumnData;

        static constexpr std::wstring_view FieldNames = L"[Id],[RowVersion],[Element],[Definition],[Timeseries]";
        static constexpr std::wstring_view ViewName = L"SByteTimeseriesPropertyView";

        static constexpr SQLUSMALLINT TIMESERIES_FIELD_ID = 5;

        SByteTimeseriesPropertyColumnData( ) = default;

        virtual Kind GetKind() const override
        {
            return Kind::SByteTimeseriesProperty;
        }

        const Guid& Timeseries( ) const
        {
            return timeseries_;
        }
        void SetTimeseries( const Guid& timeseries )
        {
            timeseries_ = timeseries;
        }
        void BindColumns( const ODBC::Statement& statement )
        {
            Base::BindColumns( statement );

            Bind(statement, TIMESERIES_FIELD_ID, timeseries_);
        }

        template<IO::StreamWriter StreamT>
        void WriteColumns( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteColumns( destination );
            WriteColumnValue( destination, timeseries_);
        }
    };

    using SimpleSByteTimeseriesPropertyDataReader = SimpleColumnDataReader<SByteTimeseriesPropertyColumnData>;

    class SingleTimeseriesPropertyColumnData : public TimeseriesPropertyColumnData
    {
        Guid timeseries_;
    public:
        using Base = TimeseriesPropertyColumnData;

        static constexpr std::wstring_view FieldNames = L"[Id],[RowVersion],[Element],[Definition],[Timeseries]";
        static constexpr std::wstring_view ViewName = L"SingleTimeseriesPropertyView";

        static constexpr SQLUSMALLINT TIMESERIES_FIELD_ID = 5;

        SingleTimeseriesPropertyColumnData( ) = default;

        virtual Kind GetKind() const override
        {
            return Kind::SingleTimeseriesProperty;
        }

        const Guid& Timeseries( ) const
        {
            return timeseries_;
        }
        void SetTimeseries( const Guid& timeseries )
        {
            timeseries_ = timeseries;
        }
        void BindColumns( const ODBC::Statement& statement )
        {
            Base::BindColumns( statement );

            Bind(statement, TIMESERIES_FIELD_ID, timeseries_);
        }

        template<IO::StreamWriter StreamT>
        void WriteColumns( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteColumns( destination );
            WriteColumnValue( destination, timeseries_);
        }
    };

    using SimpleSingleTimeseriesPropertyDataReader = SimpleColumnDataReader<SingleTimeseriesPropertyColumnData>;

    class StringTimeseriesPropertyColumnData : public TimeseriesPropertyColumnData
    {
        Guid timeseries_;
    public:
        using Base = TimeseriesPropertyColumnData;

        static constexpr std::wstring_view FieldNames = L"[Id],[RowVersion],[Element],[Definition],[Timeseries]";
        static constexpr std::wstring_view ViewName = L"StringTimeseriesPropertyView";

        static constexpr SQLUSMALLINT TIMESERIES_FIELD_ID = 5;

        StringTimeseriesPropertyColumnData( ) = default;

        virtual Kind GetKind() const override
        {
            return Kind::StringTimeseriesProperty;
        }

        const Guid& Timeseries( ) const
        {
            return timeseries_;
        }
        void SetTimeseries( const Guid& timeseries )
        {
            timeseries_ = timeseries;
        }
        void BindColumns( const ODBC::Statement& statement )
        {
            Base::BindColumns( statement );

            Bind(statement, TIMESERIES_FIELD_ID, timeseries_);
        }

        template<IO::StreamWriter StreamT>
        void WriteColumns( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteColumns( destination );
            WriteColumnValue( destination, timeseries_);
        }
    };

    using SimpleStringTimeseriesPropertyDataReader = SimpleColumnDataReader<StringTimeseriesPropertyColumnData>;

    class TimeSpanTimeseriesPropertyColumnData : public TimeseriesPropertyColumnData
    {
        Guid timeseries_;
    public:
        using Base = TimeseriesPropertyColumnData;

        static constexpr std::wstring_view FieldNames = L"[Id],[RowVersion],[Element],[Definition],[Timeseries]";
        static constexpr std::wstring_view ViewName = L"TimeSpanTimeseriesPropertyView";

        static constexpr SQLUSMALLINT TIMESERIES_FIELD_ID = 5;

        TimeSpanTimeseriesPropertyColumnData( ) = default;

        virtual Kind GetKind() const override
        {
            return Kind::TimeSpanTimeseriesProperty;
        }

        const Guid& Timeseries( ) const
        {
            return timeseries_;
        }
        void SetTimeseries( const Guid& timeseries )
        {
            timeseries_ = timeseries;
        }
        void BindColumns( const ODBC::Statement& statement )
        {
            Base::BindColumns( statement );

            Bind(statement, TIMESERIES_FIELD_ID, timeseries_);
        }

        template<IO::StreamWriter StreamT>
        void WriteColumns( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteColumns( destination );
            WriteColumnValue( destination, timeseries_);
        }
    };

    using SimpleTimeSpanTimeseriesPropertyDataReader = SimpleColumnDataReader<TimeSpanTimeseriesPropertyColumnData>;

    class UInt16TimeseriesPropertyColumnData : public TimeseriesPropertyColumnData
    {
        Guid timeseries_;
    public:
        using Base = TimeseriesPropertyColumnData;

        static constexpr std::wstring_view FieldNames = L"[Id],[RowVersion],[Element],[Definition],[Timeseries]";
        static constexpr std::wstring_view ViewName = L"UInt16TimeseriesPropertyView";

        static constexpr SQLUSMALLINT TIMESERIES_FIELD_ID = 5;

        UInt16TimeseriesPropertyColumnData( ) = default;

        virtual Kind GetKind() const override
        {
            return Kind::UInt16TimeseriesProperty;
        }

        const Guid& Timeseries( ) const
        {
            return timeseries_;
        }
        void SetTimeseries( const Guid& timeseries )
        {
            timeseries_ = timeseries;
        }
        void BindColumns( const ODBC::Statement& statement )
        {
            Base::BindColumns( statement );

            Bind(statement, TIMESERIES_FIELD_ID, timeseries_);
        }

        template<IO::StreamWriter StreamT>
        void WriteColumns( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteColumns( destination );
            WriteColumnValue( destination, timeseries_);
        }
    };

    using SimpleUInt16TimeseriesPropertyDataReader = SimpleColumnDataReader<UInt16TimeseriesPropertyColumnData>;

    class UInt32TimeseriesPropertyColumnData : public TimeseriesPropertyColumnData
    {
        Guid timeseries_;
    public:
        using Base = TimeseriesPropertyColumnData;

        static constexpr std::wstring_view FieldNames = L"[Id],[RowVersion],[Element],[Definition],[Timeseries]";
        static constexpr std::wstring_view ViewName = L"UInt32TimeseriesPropertyView";

        static constexpr SQLUSMALLINT TIMESERIES_FIELD_ID = 5;

        UInt32TimeseriesPropertyColumnData( ) = default;

        virtual Kind GetKind() const override
        {
            return Kind::UInt32TimeseriesProperty;
        }

        const Guid& Timeseries( ) const
        {
            return timeseries_;
        }
        void SetTimeseries( const Guid& timeseries )
        {
            timeseries_ = timeseries;
        }
        void BindColumns( const ODBC::Statement& statement )
        {
            Base::BindColumns( statement );

            Bind(statement, TIMESERIES_FIELD_ID, timeseries_);
        }

        template<IO::StreamWriter StreamT>
        void WriteColumns( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteColumns( destination );
            WriteColumnValue( destination, timeseries_);
        }
    };

    using SimpleUInt32TimeseriesPropertyDataReader = SimpleColumnDataReader<UInt32TimeseriesPropertyColumnData>;

    class UInt64TimeseriesPropertyColumnData : public TimeseriesPropertyColumnData
    {
        Guid timeseries_;
    public:
        using Base = TimeseriesPropertyColumnData;

        static constexpr std::wstring_view FieldNames = L"[Id],[RowVersion],[Element],[Definition],[Timeseries]";
        static constexpr std::wstring_view ViewName = L"UInt64TimeseriesPropertyView";

        static constexpr SQLUSMALLINT TIMESERIES_FIELD_ID = 5;

        UInt64TimeseriesPropertyColumnData( ) = default;

        virtual Kind GetKind() const override
        {
            return Kind::UInt64TimeseriesProperty;
        }

        const Guid& Timeseries( ) const
        {
            return timeseries_;
        }
        void SetTimeseries( const Guid& timeseries )
        {
            timeseries_ = timeseries;
        }
        void BindColumns( const ODBC::Statement& statement )
        {
            Base::BindColumns( statement );

            Bind(statement, TIMESERIES_FIELD_ID, timeseries_);
        }

        template<IO::StreamWriter StreamT>
        void WriteColumns( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteColumns( destination );
            WriteColumnValue( destination, timeseries_);
        }
    };

    using SimpleUInt64TimeseriesPropertyDataReader = SimpleColumnDataReader<UInt64TimeseriesPropertyColumnData>;

    class TimeSpanPropertyColumnData : public PropertyColumnData
    {
        TimeSpan value_;
    public:
        using Base = PropertyColumnData;

        static constexpr std::wstring_view FieldNames = L"[Id],[RowVersion],[Element],[Definition],[Value]";
        static constexpr std::wstring_view ViewName = L"TimeSpanPropertyView";

        static constexpr SQLUSMALLINT VALUE_FIELD_ID = 5;

        TimeSpanPropertyColumnData( ) = default;

        virtual Kind GetKind() const override
        {
            return Kind::TimeSpanProperty;
        }

        const TimeSpan& Value( ) const
        {
            return value_;
        }
        void SetValue( const TimeSpan& value )
        {
            value_ = value;
        }
        void BindColumns( const ODBC::Statement& statement )
        {
            Base::BindColumns( statement );

            Bind(statement, VALUE_FIELD_ID, value_);
        }

        template<IO::StreamWriter StreamT>
        void WriteColumns( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteColumns( destination );
            WriteColumnValue( destination, value_);
        }
    };

    using SimpleTimeSpanPropertyDataReader = SimpleColumnDataReader<TimeSpanPropertyColumnData>;

    class UInt16PropertyColumnData : public PropertyColumnData
    {
        UInt16 value_ = 0;
    public:
        using Base = PropertyColumnData;

        static constexpr std::wstring_view FieldNames = L"[Id],[RowVersion],[Element],[Definition],[Value]";
        static constexpr std::wstring_view ViewName = L"UInt16PropertyView";

        static constexpr SQLUSMALLINT VALUE_FIELD_ID = 5;

        UInt16PropertyColumnData( ) = default;

        virtual Kind GetKind() const override
        {
            return Kind::UInt16Property;
        }

        UInt16 Value( ) const
        {
            return value_;
        }
        void SetValue( UInt16 value )
        {
            value_ = value;
        }
        void BindColumns( const ODBC::Statement& statement )
        {
            Base::BindColumns( statement );

            Bind(statement, VALUE_FIELD_ID, value_);
        }

        template<IO::StreamWriter StreamT>
        void WriteColumns( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteColumns( destination );
            WriteColumnValue( destination, value_);
        }
    };

    using SimpleUInt16PropertyDataReader = SimpleColumnDataReader<UInt16PropertyColumnData>;

    class UInt32PropertyColumnData : public PropertyColumnData
    {
        UInt32 value_ = 0;
    public:
        using Base = PropertyColumnData;

        static constexpr std::wstring_view FieldNames = L"[Id],[RowVersion],[Element],[Definition],[Value]";
        static constexpr std::wstring_view ViewName = L"UInt32PropertyView";

        static constexpr SQLUSMALLINT VALUE_FIELD_ID = 5;

        UInt32PropertyColumnData( ) = default;

        virtual Kind GetKind() const override
        {
            return Kind::UInt32Property;
        }

        UInt32 Value( ) const
        {
            return value_;
        }
        void SetValue( UInt32 value )
        {
            value_ = value;
        }
        void BindColumns( const ODBC::Statement& statement )
        {
            Base::BindColumns( statement );

            Bind(statement, VALUE_FIELD_ID, value_);
        }

        template<IO::StreamWriter StreamT>
        void WriteColumns( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteColumns( destination );
            WriteColumnValue( destination, value_);
        }
    };

    using SimpleUInt32PropertyDataReader = SimpleColumnDataReader<UInt32PropertyColumnData>;

    class UInt64PropertyColumnData : public PropertyColumnData
    {
        Int64 value_ = 0;
    public:
        using Base = PropertyColumnData;

        static constexpr std::wstring_view FieldNames = L"[Id],[RowVersion],[Element],[Definition],[Value]";
        static constexpr std::wstring_view ViewName = L"UInt64PropertyView";

        static constexpr SQLUSMALLINT VALUE_FIELD_ID = 5;

        UInt64PropertyColumnData( ) = default;

        virtual Kind GetKind() const override
        {
            return Kind::UInt64Property;
        }

        Int64 Value( ) const
        {
            return value_;
        }
        void SetValue( Int64 value )
        {
            value_ = value;
        }
        void BindColumns( const ODBC::Statement& statement )
        {
            Base::BindColumns( statement );

            Bind(statement, VALUE_FIELD_ID, value_);
        }

        template<IO::StreamWriter StreamT>
        void WriteColumns( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteColumns( destination );
            WriteColumnValue( destination, value_);
        }
    };

    using SimpleUInt64PropertyDataReader = SimpleColumnDataReader<UInt64PropertyColumnData>;

    class PropertyDefinitionColumnData : public BaseColumnData
    {
        Guid id_;
        Int64 rowVersion_ = 0;
        Guid elementType_;
        FixedDBWideString<127> name_;
        WideString description_;
        SQLLEN descriptionLength_ = SQL_NULL_DATA;
    public:
        using Base = BaseColumnData;

        static constexpr std::wstring_view FieldNames = L"[Id],[RowVersion],[ElementType],[Name],[Description]";
        static constexpr std::wstring_view ViewName = L"PropertyDefinitionView";

        static constexpr SQLUSMALLINT ID_FIELD_ID = 1;
        static constexpr SQLUSMALLINT ROWVERSION_FIELD_ID = 2;
        static constexpr SQLUSMALLINT ELEMENTTYPE_FIELD_ID = 3;
        static constexpr SQLUSMALLINT NAME_FIELD_ID = 4;
        static constexpr SQLUSMALLINT DESCRIPTION_FIELD_ID = 5;

        PropertyDefinitionColumnData( ) = default;

        virtual Kind GetKind() const override
        {
            return Kind::PropertyDefinition;
        }

        const Guid& Id( ) const
        {
            return id_;
        }
        void SetId( const Guid& id )
        {
            id_ = id;
        }
        Int64 RowVersion( ) const
        {
            return rowVersion_;
        }
        void SetRowVersion( const Int64& rowVersion )
        {
            rowVersion_ = rowVersion;
        }
        const Guid& ElementType( ) const
        {
            return elementType_;
        }
        void SetElementType( const Guid& elementType )
        {
            elementType_ = elementType;
        }
        const FixedDBWideString<127>& Name( ) const
        {
            return name_;
        }
        void SetName( const WideString& name )
        {
            name_ = name;
        }
        const WideString& Description( ) const
        {
            return description_;
        }
        void SetDescription( const WideString& description )
        {
            description_ = description;
        }
        void BindColumns( const ODBC::Statement& statement )
        {
            Bind(statement, ID_FIELD_ID, id_);
            Bind(statement, ROWVERSION_FIELD_ID, rowVersion_);
            Bind(statement, ELEMENTTYPE_FIELD_ID, elementType_);
            Bind(statement, NAME_FIELD_ID, name_);
        }

        void ReadUnboundData( const ODBC::Statement& statement )
        {
            Base::ReadUnboundData( statement );

            description_ = statement.GetWideString(DESCRIPTION_FIELD_ID);
        }
        template<IO::StreamWriter StreamT>
        void WriteColumns( IO::BinaryWriter<StreamT>& destination ) const
        {
            WriteColumnValue( destination, id_);
            WriteColumnValue( destination, rowVersion_);
            WriteColumnValue( destination, elementType_);
            WriteColumnValue( destination, name_);
            WriteColumnValue( destination, description_);
        }
    };

    using SimplePropertyDefinitionDataReader = SimpleColumnDataReader<PropertyDefinitionColumnData>;

    class BinaryPropertyDefinitionColumnData : public PropertyDefinitionColumnData
    {
        Binary defaultValue_;
        SQLLEN defaultValueLength_ = SQL_NULL_DATA;
    public:
        using Base = PropertyDefinitionColumnData;

        static constexpr std::wstring_view FieldNames = L"[Id],[RowVersion],[ElementType],[Name],[Description],[DefaultValue]";
        static constexpr std::wstring_view ViewName = L"BinaryPropertyDefinitionView";

        static constexpr SQLUSMALLINT DEFAULTVALUE_FIELD_ID = 6;

        BinaryPropertyDefinitionColumnData( ) = default;

        virtual Kind GetKind() const override
        {
            return Kind::BinaryPropertyDefinition;
        }

        const Binary& DefaultValue( ) const
        {
            return defaultValue_;
        }
        void SetDefaultValue( const Binary& defaultValue )
        {
            defaultValue_ = defaultValue;
        }
        void BindColumns( const ODBC::Statement& statement )
        {
            Base::BindColumns( statement );

        }

        void ReadUnboundData( const ODBC::Statement& statement )
        {
            Base::ReadUnboundData( statement );

            defaultValue_ = statement.GetBinary(DEFAULTVALUE_FIELD_ID);
        }
        template<IO::StreamWriter StreamT>
        void WriteColumns( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteColumns( destination );
            WriteColumnValue( destination, defaultValue_);
        }
    };

    using SimpleBinaryPropertyDefinitionDataReader = SimpleColumnDataReader<BinaryPropertyDefinitionColumnData>;

    class BooleanPropertyDefinitionColumnData : public PropertyDefinitionColumnData
    {
        bool defaultValue_ = false;
    public:
        using Base = PropertyDefinitionColumnData;

        static constexpr std::wstring_view FieldNames = L"[Id],[RowVersion],[ElementType],[Name],[DefaultValue],[Description]";
        static constexpr std::wstring_view ViewName = L"BooleanPropertyDefinitionView";

        static constexpr SQLUSMALLINT DEFAULTVALUE_FIELD_ID = 6;

        BooleanPropertyDefinitionColumnData( ) = default;

        virtual Kind GetKind() const override
        {
            return Kind::BooleanPropertyDefinition;
        }

        bool DefaultValue( ) const
        {
            return defaultValue_;
        }
        void SetDefaultValue( bool defaultValue )
        {
            defaultValue_ = defaultValue;
        }
        void BindColumns( const ODBC::Statement& statement )
        {
            Base::BindColumns( statement );

            Bind(statement, DEFAULTVALUE_FIELD_ID, defaultValue_);
        }

        template<IO::StreamWriter StreamT>
        void WriteColumns( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteColumns( destination );
            WriteColumnValue( destination, defaultValue_);
        }
    };

    using SimpleBooleanPropertyDefinitionDataReader = SimpleColumnDataReader<BooleanPropertyDefinitionColumnData>;

    class BytePropertyDefinitionColumnData : public PropertyDefinitionColumnData
    {
        Byte defaultValue_ = 0;
        Byte minValue_ = 0;
        Byte maxValue_ = 0;
    public:
        using Base = PropertyDefinitionColumnData;

        static constexpr std::wstring_view FieldNames = L"[Id],[RowVersion],[ElementType],[Name],[DefaultValue],[MinValue],[MaxValue],[Description]";
        static constexpr std::wstring_view ViewName = L"BytePropertyDefinitionView";

        static constexpr SQLUSMALLINT DEFAULTVALUE_FIELD_ID = 6;
        static constexpr SQLUSMALLINT MINVALUE_FIELD_ID = 7;
        static constexpr SQLUSMALLINT MAXVALUE_FIELD_ID = 8;

        BytePropertyDefinitionColumnData( ) = default;

        virtual Kind GetKind() const override
        {
            return Kind::BytePropertyDefinition;
        }

        Byte DefaultValue( ) const
        {
            return defaultValue_;
        }
        void SetDefaultValue( Byte defaultValue )
        {
            defaultValue_ = defaultValue;
        }
        Byte MinValue( ) const
        {
            return minValue_;
        }
        void SetMinValue( Byte minValue )
        {
            minValue_ = minValue;
        }
        Byte MaxValue( ) const
        {
            return maxValue_;
        }
        void SetMaxValue( Byte maxValue )
        {
            maxValue_ = maxValue;
        }
        void BindColumns( const ODBC::Statement& statement )
        {
            Base::BindColumns( statement );

            Bind(statement, DEFAULTVALUE_FIELD_ID, defaultValue_);
            Bind(statement, MINVALUE_FIELD_ID, minValue_);
            Bind(statement, MAXVALUE_FIELD_ID, maxValue_);
        }

        template<IO::StreamWriter StreamT>
        void WriteColumns( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteColumns( destination );
            WriteColumnValue( destination, defaultValue_);
            WriteColumnValue( destination, minValue_);
            WriteColumnValue( destination, maxValue_);
        }
    };

    using SimpleBytePropertyDefinitionDataReader = SimpleColumnDataReader<BytePropertyDefinitionColumnData>;

    class DateTimePropertyDefinitionColumnData : public PropertyDefinitionColumnData
    {
        FixedDBWideString<100> defaultValue_;
        FixedDBWideString<100> minValue_;
        FixedDBWideString<100> maxValue_;
    public:
        using Base = PropertyDefinitionColumnData;

        static constexpr std::wstring_view FieldNames = L"[Id],[RowVersion],[ElementType],[Name],[DefaultValue],[MinValue],[MaxValue],[Description]";
        static constexpr std::wstring_view ViewName = L"DateTimePropertyDefinitionView";

        static constexpr SQLUSMALLINT DEFAULTVALUE_FIELD_ID = 6;
        static constexpr SQLUSMALLINT MINVALUE_FIELD_ID = 7;
        static constexpr SQLUSMALLINT MAXVALUE_FIELD_ID = 8;

        DateTimePropertyDefinitionColumnData( ) = default;

        virtual Kind GetKind() const override
        {
            return Kind::DateTimePropertyDefinition;
        }

        const FixedDBWideString<100>& DefaultValue( ) const
        {
            return defaultValue_;
        }
        void SetDefaultValue( const WideString& defaultValue )
        {
            defaultValue_ = defaultValue;
        }
        const FixedDBWideString<100>& MinValue( ) const
        {
            return minValue_;
        }
        void SetMinValue( const WideString& minValue )
        {
            minValue_ = minValue;
        }
        const FixedDBWideString<100>& MaxValue( ) const
        {
            return maxValue_;
        }
        void SetMaxValue( const WideString& maxValue )
        {
            maxValue_ = maxValue;
        }
        void BindColumns( const ODBC::Statement& statement )
        {
            Base::BindColumns( statement );

            Bind(statement, DEFAULTVALUE_FIELD_ID, defaultValue_);
            Bind(statement, MINVALUE_FIELD_ID, minValue_);
            Bind(statement, MAXVALUE_FIELD_ID, maxValue_);
        }

        template<IO::StreamWriter StreamT>
        void WriteColumns( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteColumns( destination );
            WriteColumnValue( destination, defaultValue_);
            WriteColumnValue( destination, minValue_);
            WriteColumnValue( destination, maxValue_);
        }
    };

    using SimpleDateTimePropertyDefinitionDataReader = SimpleColumnDataReader<DateTimePropertyDefinitionColumnData>;

    class DoublePropertyDefinitionColumnData : public PropertyDefinitionColumnData
    {
        double defaultValue_ = 0.0;
        double minValue_ = 0.0;
        double maxValue_ = 0.0;
    public:
        using Base = PropertyDefinitionColumnData;

        static constexpr std::wstring_view FieldNames = L"[Id],[RowVersion],[ElementType],[Name],[DefaultValue],[MinValue],[MaxValue],[Description]";
        static constexpr std::wstring_view ViewName = L"DoublePropertyDefinitionView";

        static constexpr SQLUSMALLINT DEFAULTVALUE_FIELD_ID = 6;
        static constexpr SQLUSMALLINT MINVALUE_FIELD_ID = 7;
        static constexpr SQLUSMALLINT MAXVALUE_FIELD_ID = 8;

        DoublePropertyDefinitionColumnData( ) = default;

        virtual Kind GetKind() const override
        {
            return Kind::DoublePropertyDefinition;
        }

        double DefaultValue( ) const
        {
            return defaultValue_;
        }
        void SetDefaultValue( double defaultValue )
        {
            defaultValue_ = defaultValue;
        }
        double MinValue( ) const
        {
            return minValue_;
        }
        void SetMinValue( double minValue )
        {
            minValue_ = minValue;
        }
        double MaxValue( ) const
        {
            return maxValue_;
        }
        void SetMaxValue( double maxValue )
        {
            maxValue_ = maxValue;
        }
        void BindColumns( const ODBC::Statement& statement )
        {
            Base::BindColumns( statement );

            Bind(statement, DEFAULTVALUE_FIELD_ID, defaultValue_);
            Bind(statement, MINVALUE_FIELD_ID, minValue_);
            Bind(statement, MAXVALUE_FIELD_ID, maxValue_);
        }

        template<IO::StreamWriter StreamT>
        void WriteColumns( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteColumns( destination );
            WriteColumnValue( destination, defaultValue_);
            WriteColumnValue( destination, minValue_);
            WriteColumnValue( destination, maxValue_);
        }
    };

    using SimpleDoublePropertyDefinitionDataReader = SimpleColumnDataReader<DoublePropertyDefinitionColumnData>;

    class GuidPropertyDefinitionColumnData : public PropertyDefinitionColumnData
    {
        Guid defaultValue_;
    public:
        using Base = PropertyDefinitionColumnData;

        static constexpr std::wstring_view FieldNames = L"[Id],[RowVersion],[ElementType],[Name],[DefaultValue],[Description]";
        static constexpr std::wstring_view ViewName = L"GuidPropertyDefinitionView";

        static constexpr SQLUSMALLINT DEFAULTVALUE_FIELD_ID = 6;

        GuidPropertyDefinitionColumnData( ) = default;

        virtual Kind GetKind() const override
        {
            return Kind::GuidPropertyDefinition;
        }

        const Guid& DefaultValue( ) const
        {
            return defaultValue_;
        }
        void SetDefaultValue( const Guid& defaultValue )
        {
            defaultValue_ = defaultValue;
        }
        void BindColumns( const ODBC::Statement& statement )
        {
            Base::BindColumns( statement );

            Bind(statement, DEFAULTVALUE_FIELD_ID, defaultValue_);
        }

        template<IO::StreamWriter StreamT>
        void WriteColumns( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteColumns( destination );
            WriteColumnValue( destination, defaultValue_);
        }
    };

    using SimpleGuidPropertyDefinitionDataReader = SimpleColumnDataReader<GuidPropertyDefinitionColumnData>;

    class Int16PropertyDefinitionColumnData : public PropertyDefinitionColumnData
    {
        Int16 defaultValue_ = 0;
        Int16 minValue_ = 0;
        Int16 maxValue_ = 0;
    public:
        using Base = PropertyDefinitionColumnData;

        static constexpr std::wstring_view FieldNames = L"[Id],[RowVersion],[ElementType],[Name],[DefaultValue],[MinValue],[MaxValue],[Description]";
        static constexpr std::wstring_view ViewName = L"Int16PropertyDefinitionView";

        static constexpr SQLUSMALLINT DEFAULTVALUE_FIELD_ID = 6;
        static constexpr SQLUSMALLINT MINVALUE_FIELD_ID = 7;
        static constexpr SQLUSMALLINT MAXVALUE_FIELD_ID = 8;

        Int16PropertyDefinitionColumnData( ) = default;

        virtual Kind GetKind() const override
        {
            return Kind::Int16PropertyDefinition;
        }

        Int16 DefaultValue( ) const
        {
            return defaultValue_;
        }
        void SetDefaultValue( Int16 defaultValue )
        {
            defaultValue_ = defaultValue;
        }
        Int16 MinValue( ) const
        {
            return minValue_;
        }
        void SetMinValue( Int16 minValue )
        {
            minValue_ = minValue;
        }
        Int16 MaxValue( ) const
        {
            return maxValue_;
        }
        void SetMaxValue( Int16 maxValue )
        {
            maxValue_ = maxValue;
        }
        void BindColumns( const ODBC::Statement& statement )
        {
            Base::BindColumns( statement );

            Bind(statement, DEFAULTVALUE_FIELD_ID, defaultValue_);
            Bind(statement, MINVALUE_FIELD_ID, minValue_);
            Bind(statement, MAXVALUE_FIELD_ID, maxValue_);
        }

        template<IO::StreamWriter StreamT>
        void WriteColumns( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteColumns( destination );
            WriteColumnValue( destination, defaultValue_);
            WriteColumnValue( destination, minValue_);
            WriteColumnValue( destination, maxValue_);
        }
    };

    using SimpleInt16PropertyDefinitionDataReader = SimpleColumnDataReader<Int16PropertyDefinitionColumnData>;

    class Int32PropertyDefinitionColumnData : public PropertyDefinitionColumnData
    {
        Int32 defaultValue_ = 0;
        Int32 minValue_ = 0;
        Int32 maxValue_ = 0;
    public:
        using Base = PropertyDefinitionColumnData;

        static constexpr std::wstring_view FieldNames = L"[Id],[RowVersion],[ElementType],[Name],[DefaultValue],[MinValue],[MaxValue],[Description]";
        static constexpr std::wstring_view ViewName = L"Int32PropertyDefinitionView";

        static constexpr SQLUSMALLINT DEFAULTVALUE_FIELD_ID = 6;
        static constexpr SQLUSMALLINT MINVALUE_FIELD_ID = 7;
        static constexpr SQLUSMALLINT MAXVALUE_FIELD_ID = 8;

        Int32PropertyDefinitionColumnData( ) = default;

        virtual Kind GetKind() const override
        {
            return Kind::Int32PropertyDefinition;
        }

        Int32 DefaultValue( ) const
        {
            return defaultValue_;
        }
        void SetDefaultValue( Int32 defaultValue )
        {
            defaultValue_ = defaultValue;
        }
        Int32 MinValue( ) const
        {
            return minValue_;
        }
        void SetMinValue( Int32 minValue )
        {
            minValue_ = minValue;
        }
        Int32 MaxValue( ) const
        {
            return maxValue_;
        }
        void SetMaxValue( Int32 maxValue )
        {
            maxValue_ = maxValue;
        }
        void BindColumns( const ODBC::Statement& statement )
        {
            Base::BindColumns( statement );

            Bind(statement, DEFAULTVALUE_FIELD_ID, defaultValue_);
            Bind(statement, MINVALUE_FIELD_ID, minValue_);
            Bind(statement, MAXVALUE_FIELD_ID, maxValue_);
        }

        template<IO::StreamWriter StreamT>
        void WriteColumns( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteColumns( destination );
            WriteColumnValue( destination, defaultValue_);
            WriteColumnValue( destination, minValue_);
            WriteColumnValue( destination, maxValue_);
        }
    };

    using SimpleInt32PropertyDefinitionDataReader = SimpleColumnDataReader<Int32PropertyDefinitionColumnData>;

    class Int64PropertyDefinitionColumnData : public PropertyDefinitionColumnData
    {
        Int64 defaultValue_ = 0;
        Int64 minValue_ = 0;
        Int64 maxValue_ = 0;
    public:
        using Base = PropertyDefinitionColumnData;

        static constexpr std::wstring_view FieldNames = L"[Id],[RowVersion],[ElementType],[Name],[DefaultValue],[MinValue],[MaxValue],[Description]";
        static constexpr std::wstring_view ViewName = L"Int64PropertyDefinitionView";

        static constexpr SQLUSMALLINT DEFAULTVALUE_FIELD_ID = 6;
        static constexpr SQLUSMALLINT MINVALUE_FIELD_ID = 7;
        static constexpr SQLUSMALLINT MAXVALUE_FIELD_ID = 8;

        Int64PropertyDefinitionColumnData( ) = default;

        virtual Kind GetKind() const override
        {
            return Kind::Int64PropertyDefinition;
        }

        Int64 DefaultValue( ) const
        {
            return defaultValue_;
        }
        void SetDefaultValue( Int64 defaultValue )
        {
            defaultValue_ = defaultValue;
        }
        Int64 MinValue( ) const
        {
            return minValue_;
        }
        void SetMinValue( Int64 minValue )
        {
            minValue_ = minValue;
        }
        Int64 MaxValue( ) const
        {
            return maxValue_;
        }
        void SetMaxValue( Int64 maxValue )
        {
            maxValue_ = maxValue;
        }
        void BindColumns( const ODBC::Statement& statement )
        {
            Base::BindColumns( statement );

            Bind(statement, DEFAULTVALUE_FIELD_ID, defaultValue_);
            Bind(statement, MINVALUE_FIELD_ID, minValue_);
            Bind(statement, MAXVALUE_FIELD_ID, maxValue_);
        }

        template<IO::StreamWriter StreamT>
        void WriteColumns( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteColumns( destination );
            WriteColumnValue( destination, defaultValue_);
            WriteColumnValue( destination, minValue_);
            WriteColumnValue( destination, maxValue_);
        }
    };

    using SimpleInt64PropertyDefinitionDataReader = SimpleColumnDataReader<Int64PropertyDefinitionColumnData>;

    class ReferencePropertyDefinitionColumnData : public PropertyDefinitionColumnData
    {
        Guid defaultValue_;
        Guid referencedElementType_;
    public:
        using Base = PropertyDefinitionColumnData;

        static constexpr std::wstring_view FieldNames = L"[Id],[RowVersion],[ElementType],[Name],[DefaultValue],[ReferencedElementType],[Description]";
        static constexpr std::wstring_view ViewName = L"ReferencePropertyDefinitionView";

        static constexpr SQLUSMALLINT DEFAULTVALUE_FIELD_ID = 6;
        static constexpr SQLUSMALLINT REFERENCEDELEMENTTYPE_FIELD_ID = 7;

        ReferencePropertyDefinitionColumnData( ) = default;

        virtual Kind GetKind() const override
        {
            return Kind::ReferencePropertyDefinition;
        }

        const Guid& DefaultValue( ) const
        {
            return defaultValue_;
        }
        void SetDefaultValue( const Guid& defaultValue )
        {
            defaultValue_ = defaultValue;
        }
        const Guid& ReferencedElementType( ) const
        {
            return referencedElementType_;
        }
        void SetReferencedElementType( const Guid& referencedElementType )
        {
            referencedElementType_ = referencedElementType;
        }
        void BindColumns( const ODBC::Statement& statement )
        {
            Base::BindColumns( statement );

            Bind(statement, DEFAULTVALUE_FIELD_ID, defaultValue_);
            Bind(statement, REFERENCEDELEMENTTYPE_FIELD_ID, referencedElementType_);
        }

        template<IO::StreamWriter StreamT>
        void WriteColumns( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteColumns( destination );
            WriteColumnValue( destination, defaultValue_);
            WriteColumnValue( destination, referencedElementType_);
        }
    };

    using SimpleReferencePropertyDefinitionDataReader = SimpleColumnDataReader<ReferencePropertyDefinitionColumnData>;

    class SBytePropertyDefinitionColumnData : public PropertyDefinitionColumnData
    {
        SByte defaultValue_ = 0;
        SByte minValue_ = 0;
        SByte maxValue_ = 0;
    public:
        using Base = PropertyDefinitionColumnData;

        static constexpr std::wstring_view FieldNames = L"[Id],[RowVersion],[ElementType],[Name],[DefaultValue],[MinValue],[MaxValue],[Description]";
        static constexpr std::wstring_view ViewName = L"SBytePropertyDefinitionView";

        static constexpr SQLUSMALLINT DEFAULTVALUE_FIELD_ID = 6;
        static constexpr SQLUSMALLINT MINVALUE_FIELD_ID = 7;
        static constexpr SQLUSMALLINT MAXVALUE_FIELD_ID = 8;

        SBytePropertyDefinitionColumnData( ) = default;

        virtual Kind GetKind() const override
        {
            return Kind::SBytePropertyDefinition;
        }

        SByte DefaultValue( ) const
        {
            return defaultValue_;
        }
        void SetDefaultValue( SByte defaultValue )
        {
            defaultValue_ = defaultValue;
        }
        SByte MinValue( ) const
        {
            return minValue_;
        }
        void SetMinValue( SByte minValue )
        {
            minValue_ = minValue;
        }
        SByte MaxValue( ) const
        {
            return maxValue_;
        }
        void SetMaxValue( SByte maxValue )
        {
            maxValue_ = maxValue;
        }
        void BindColumns( const ODBC::Statement& statement )
        {
            Base::BindColumns( statement );

            Bind(statement, DEFAULTVALUE_FIELD_ID, defaultValue_);
            Bind(statement, MINVALUE_FIELD_ID, minValue_);
            Bind(statement, MAXVALUE_FIELD_ID, maxValue_);
        }

        template<IO::StreamWriter StreamT>
        void WriteColumns( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteColumns( destination );
            WriteColumnValue( destination, defaultValue_);
            WriteColumnValue( destination, minValue_);
            WriteColumnValue( destination, maxValue_);
        }
    };

    using SimpleSBytePropertyDefinitionDataReader = SimpleColumnDataReader<SBytePropertyDefinitionColumnData>;

    class SinglePropertyDefinitionColumnData : public PropertyDefinitionColumnData
    {
        float defaultValue_ = 0.0f;
        float minValue_ = 0.0f;
        float maxValue_ = 0.0f;
    public:
        using Base = PropertyDefinitionColumnData;

        static constexpr std::wstring_view FieldNames = L"[Id],[RowVersion],[ElementType],[Name],[DefaultValue],[MinValue],[MaxValue],[Description]";
        static constexpr std::wstring_view ViewName = L"SinglePropertyDefinitionView";

        static constexpr SQLUSMALLINT DEFAULTVALUE_FIELD_ID = 6;
        static constexpr SQLUSMALLINT MINVALUE_FIELD_ID = 7;
        static constexpr SQLUSMALLINT MAXVALUE_FIELD_ID = 8;

        SinglePropertyDefinitionColumnData( ) = default;

        virtual Kind GetKind() const override
        {
            return Kind::SinglePropertyDefinition;
        }

        float DefaultValue( ) const
        {
            return defaultValue_;
        }
        void SetDefaultValue( float defaultValue )
        {
            defaultValue_ = defaultValue;
        }
        float MinValue( ) const
        {
            return minValue_;
        }
        void SetMinValue( float minValue )
        {
            minValue_ = minValue;
        }
        float MaxValue( ) const
        {
            return maxValue_;
        }
        void SetMaxValue( float maxValue )
        {
            maxValue_ = maxValue;
        }
        void BindColumns( const ODBC::Statement& statement )
        {
            Base::BindColumns( statement );

            Bind(statement, DEFAULTVALUE_FIELD_ID, defaultValue_);
            Bind(statement, MINVALUE_FIELD_ID, minValue_);
            Bind(statement, MAXVALUE_FIELD_ID, maxValue_);
        }

        template<IO::StreamWriter StreamT>
        void WriteColumns( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteColumns( destination );
            WriteColumnValue( destination, defaultValue_);
            WriteColumnValue( destination, minValue_);
            WriteColumnValue( destination, maxValue_);
        }
    };

    using SimpleSinglePropertyDefinitionDataReader = SimpleColumnDataReader<SinglePropertyDefinitionColumnData>;

    class StringPropertyDefinitionColumnData : public PropertyDefinitionColumnData
    {
        FixedDBWideString<100> defaultValue_;
        FixedDBWideString<100> pattern_;
    public:
        using Base = PropertyDefinitionColumnData;

        static constexpr std::wstring_view FieldNames = L"[Id],[RowVersion],[ElementType],[Name],[DefaultValue],[Pattern],[Description]";
        static constexpr std::wstring_view ViewName = L"StringPropertyDefinitionView";

        static constexpr SQLUSMALLINT DEFAULTVALUE_FIELD_ID = 6;
        static constexpr SQLUSMALLINT PATTERN_FIELD_ID = 7;

        StringPropertyDefinitionColumnData( ) = default;

        virtual Kind GetKind() const override
        {
            return Kind::StringPropertyDefinition;
        }

        const FixedDBWideString<100>& DefaultValue( ) const
        {
            return defaultValue_;
        }
        void SetDefaultValue( const WideString& defaultValue )
        {
            defaultValue_ = defaultValue;
        }
        const FixedDBWideString<100>& Pattern( ) const
        {
            return pattern_;
        }
        void SetPattern( const WideString& pattern )
        {
            pattern_ = pattern;
        }
        void BindColumns( const ODBC::Statement& statement )
        {
            Base::BindColumns( statement );

            Bind(statement, DEFAULTVALUE_FIELD_ID, defaultValue_);
            Bind(statement, PATTERN_FIELD_ID, pattern_);
        }

        template<IO::StreamWriter StreamT>
        void WriteColumns( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteColumns( destination );
            WriteColumnValue( destination, defaultValue_);
            WriteColumnValue( destination, pattern_);
        }
    };

    using SimpleStringPropertyDefinitionDataReader = SimpleColumnDataReader<StringPropertyDefinitionColumnData>;

    class TimeseriesPropertyDefinitionColumnData : public PropertyDefinitionColumnData
    {
    public:
        using Base = PropertyDefinitionColumnData;

        static constexpr std::wstring_view FieldNames = L"[Id],[RowVersion],[ElementType],[Name],[Description]";
        static constexpr std::wstring_view ViewName = L"TimeseriesPropertyDefinitionView";

        TimeseriesPropertyDefinitionColumnData( ) = default;

        virtual Kind GetKind() const override
        {
            return Kind::TimeseriesPropertyDefinition;
        }

        template<IO::StreamWriter StreamT>
        void WriteColumns( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteColumns( destination );
        }
    };

    using SimpleTimeseriesPropertyDefinitionDataReader = SimpleColumnDataReader<TimeseriesPropertyDefinitionColumnData>;

    class BinaryTimeseriesPropertyDefinitionColumnData : public TimeseriesPropertyDefinitionColumnData
    {
    public:
        using Base = TimeseriesPropertyDefinitionColumnData;

        static constexpr std::wstring_view FieldNames = L"[Id],[RowVersion],[ElementType],[Name],[Description]";
        static constexpr std::wstring_view ViewName = L"BinaryTimeseriesPropertyDefinitionView";

        BinaryTimeseriesPropertyDefinitionColumnData( ) = default;

        virtual Kind GetKind() const override
        {
            return Kind::BinaryTimeseriesPropertyDefinition;
        }

        template<IO::StreamWriter StreamT>
        void WriteColumns( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteColumns( destination );
        }
    };

    using SimpleBinaryTimeseriesPropertyDefinitionDataReader = SimpleColumnDataReader<BinaryTimeseriesPropertyDefinitionColumnData>;

    class BooleanTimeseriesPropertyDefinitionColumnData : public TimeseriesPropertyDefinitionColumnData
    {
    public:
        using Base = TimeseriesPropertyDefinitionColumnData;

        static constexpr std::wstring_view FieldNames = L"[Id],[RowVersion],[ElementType],[Name],[Description]";
        static constexpr std::wstring_view ViewName = L"BooleanTimeseriesPropertyDefinitionView";

        BooleanTimeseriesPropertyDefinitionColumnData( ) = default;

        virtual Kind GetKind() const override
        {
            return Kind::BooleanTimeseriesPropertyDefinition;
        }

        template<IO::StreamWriter StreamT>
        void WriteColumns( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteColumns( destination );
        }
    };

    using SimpleBooleanTimeseriesPropertyDefinitionDataReader = SimpleColumnDataReader<BooleanTimeseriesPropertyDefinitionColumnData>;

    class ByteTimeseriesPropertyDefinitionColumnData : public TimeseriesPropertyDefinitionColumnData
    {
        Byte minValue_ = 0;
        Byte maxValue_ = 0;
    public:
        using Base = TimeseriesPropertyDefinitionColumnData;

        static constexpr std::wstring_view FieldNames = L"[Id],[RowVersion],[ElementType],[Name],[MinValue],[MaxValue],[Description]";
        static constexpr std::wstring_view ViewName = L"ByteTimeseriesPropertyDefinitionView";

        static constexpr SQLUSMALLINT MINVALUE_FIELD_ID = 6;
        static constexpr SQLUSMALLINT MAXVALUE_FIELD_ID = 7;

        ByteTimeseriesPropertyDefinitionColumnData( ) = default;

        virtual Kind GetKind() const override
        {
            return Kind::ByteTimeseriesPropertyDefinition;
        }

        Byte MinValue( ) const
        {
            return minValue_;
        }
        void SetMinValue( Byte minValue )
        {
            minValue_ = minValue;
        }
        Byte MaxValue( ) const
        {
            return maxValue_;
        }
        void SetMaxValue( Byte maxValue )
        {
            maxValue_ = maxValue;
        }
        void BindColumns( const ODBC::Statement& statement )
        {
            Base::BindColumns( statement );

            Bind(statement, MINVALUE_FIELD_ID, minValue_);
            Bind(statement, MAXVALUE_FIELD_ID, maxValue_);
        }

        template<IO::StreamWriter StreamT>
        void WriteColumns( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteColumns( destination );
            WriteColumnValue( destination, minValue_);
            WriteColumnValue( destination, maxValue_);
        }
    };

    using SimpleByteTimeseriesPropertyDefinitionDataReader = SimpleColumnDataReader<ByteTimeseriesPropertyDefinitionColumnData>;

    class DateTimeTimeseriesPropertyDefinitionColumnData : public TimeseriesPropertyDefinitionColumnData
    {
        FixedDBWideString<100> minValue_;
        FixedDBWideString<100> maxValue_;
    public:
        using Base = TimeseriesPropertyDefinitionColumnData;

        static constexpr std::wstring_view FieldNames = L"[Id],[RowVersion],[ElementType],[Name],[MinValue],[MaxValue],[Description]";
        static constexpr std::wstring_view ViewName = L"DateTimeTimeseriesPropertyDefinitionView";

        static constexpr SQLUSMALLINT MINVALUE_FIELD_ID = 6;
        static constexpr SQLUSMALLINT MAXVALUE_FIELD_ID = 7;

        DateTimeTimeseriesPropertyDefinitionColumnData( ) = default;

        virtual Kind GetKind() const override
        {
            return Kind::DateTimeTimeseriesPropertyDefinition;
        }

        const FixedDBWideString<100>& MinValue( ) const
        {
            return minValue_;
        }
        void SetMinValue( const WideString& minValue )
        {
            minValue_ = minValue;
        }
        const FixedDBWideString<100>& MaxValue( ) const
        {
            return maxValue_;
        }
        void SetMaxValue( const WideString& maxValue )
        {
            maxValue_ = maxValue;
        }
        void BindColumns( const ODBC::Statement& statement )
        {
            Base::BindColumns( statement );

            Bind(statement, MINVALUE_FIELD_ID, minValue_);
            Bind(statement, MAXVALUE_FIELD_ID, maxValue_);
        }

        template<IO::StreamWriter StreamT>
        void WriteColumns( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteColumns( destination );
            WriteColumnValue( destination, minValue_);
            WriteColumnValue( destination, maxValue_);
        }
    };

    using SimpleDateTimeTimeseriesPropertyDefinitionDataReader = SimpleColumnDataReader<DateTimeTimeseriesPropertyDefinitionColumnData>;

    class DoubleTimeseriesPropertyDefinitionColumnData : public TimeseriesPropertyDefinitionColumnData
    {
        double minValue_ = 0.0;
        double maxValue_ = 0.0;
    public:
        using Base = TimeseriesPropertyDefinitionColumnData;

        static constexpr std::wstring_view FieldNames = L"[Id],[RowVersion],[ElementType],[Name],[MinValue],[MaxValue],[Description]";
        static constexpr std::wstring_view ViewName = L"DoubleTimeseriesPropertyDefinitionView";

        static constexpr SQLUSMALLINT MINVALUE_FIELD_ID = 6;
        static constexpr SQLUSMALLINT MAXVALUE_FIELD_ID = 7;

        DoubleTimeseriesPropertyDefinitionColumnData( ) = default;

        virtual Kind GetKind() const override
        {
            return Kind::DoubleTimeseriesPropertyDefinition;
        }

        double MinValue( ) const
        {
            return minValue_;
        }
        void SetMinValue( double minValue )
        {
            minValue_ = minValue;
        }
        double MaxValue( ) const
        {
            return maxValue_;
        }
        void SetMaxValue( double maxValue )
        {
            maxValue_ = maxValue;
        }
        void BindColumns( const ODBC::Statement& statement )
        {
            Base::BindColumns( statement );

            Bind(statement, MINVALUE_FIELD_ID, minValue_);
            Bind(statement, MAXVALUE_FIELD_ID, maxValue_);
        }

        template<IO::StreamWriter StreamT>
        void WriteColumns( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteColumns( destination );
            WriteColumnValue( destination, minValue_);
            WriteColumnValue( destination, maxValue_);
        }
    };

    using SimpleDoubleTimeseriesPropertyDefinitionDataReader = SimpleColumnDataReader<DoubleTimeseriesPropertyDefinitionColumnData>;

    class GuidTimeseriesPropertyDefinitionColumnData : public TimeseriesPropertyDefinitionColumnData
    {
    public:
        using Base = TimeseriesPropertyDefinitionColumnData;

        static constexpr std::wstring_view FieldNames = L"[Id],[RowVersion],[ElementType],[Name],[Description]";
        static constexpr std::wstring_view ViewName = L"GuidTimeseriesPropertyDefinitionView";

        GuidTimeseriesPropertyDefinitionColumnData( ) = default;

        virtual Kind GetKind() const override
        {
            return Kind::GuidTimeseriesPropertyDefinition;
        }

        template<IO::StreamWriter StreamT>
        void WriteColumns( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteColumns( destination );
        }
    };

    using SimpleGuidTimeseriesPropertyDefinitionDataReader = SimpleColumnDataReader<GuidTimeseriesPropertyDefinitionColumnData>;

    class Int16TimeseriesPropertyDefinitionColumnData : public TimeseriesPropertyDefinitionColumnData
    {
        Int16 minValue_ = 0;
        Int16 maxValue_ = 0;
    public:
        using Base = TimeseriesPropertyDefinitionColumnData;

        static constexpr std::wstring_view FieldNames = L"[Id],[RowVersion],[ElementType],[Name],[MinValue],[MaxValue],[Description]";
        static constexpr std::wstring_view ViewName = L"Int16TimeseriesPropertyDefinitionView";

        static constexpr SQLUSMALLINT MINVALUE_FIELD_ID = 6;
        static constexpr SQLUSMALLINT MAXVALUE_FIELD_ID = 7;

        Int16TimeseriesPropertyDefinitionColumnData( ) = default;

        virtual Kind GetKind() const override
        {
            return Kind::Int16TimeseriesPropertyDefinition;
        }

        Int16 MinValue( ) const
        {
            return minValue_;
        }
        void SetMinValue( Int16 minValue )
        {
            minValue_ = minValue;
        }
        Int16 MaxValue( ) const
        {
            return maxValue_;
        }
        void SetMaxValue( Int16 maxValue )
        {
            maxValue_ = maxValue;
        }
        void BindColumns( const ODBC::Statement& statement )
        {
            Base::BindColumns( statement );

            Bind(statement, MINVALUE_FIELD_ID, minValue_);
            Bind(statement, MAXVALUE_FIELD_ID, maxValue_);
        }

        template<IO::StreamWriter StreamT>
        void WriteColumns( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteColumns( destination );
            WriteColumnValue( destination, minValue_);
            WriteColumnValue( destination, maxValue_);
        }
    };

    using SimpleInt16TimeseriesPropertyDefinitionDataReader = SimpleColumnDataReader<Int16TimeseriesPropertyDefinitionColumnData>;

    class Int32TimeseriesPropertyDefinitionColumnData : public TimeseriesPropertyDefinitionColumnData
    {
        Int32 minValue_ = 0;
        Int32 maxValue_ = 0;
    public:
        using Base = TimeseriesPropertyDefinitionColumnData;

        static constexpr std::wstring_view FieldNames = L"[Id],[RowVersion],[ElementType],[Name],[MinValue],[MaxValue],[Description]";
        static constexpr std::wstring_view ViewName = L"Int32TimeseriesPropertyDefinitionView";

        static constexpr SQLUSMALLINT MINVALUE_FIELD_ID = 6;
        static constexpr SQLUSMALLINT MAXVALUE_FIELD_ID = 7;

        Int32TimeseriesPropertyDefinitionColumnData( ) = default;

        virtual Kind GetKind() const override
        {
            return Kind::Int32TimeseriesPropertyDefinition;
        }

        Int32 MinValue( ) const
        {
            return minValue_;
        }
        void SetMinValue( Int32 minValue )
        {
            minValue_ = minValue;
        }
        Int32 MaxValue( ) const
        {
            return maxValue_;
        }
        void SetMaxValue( Int32 maxValue )
        {
            maxValue_ = maxValue;
        }
        void BindColumns( const ODBC::Statement& statement )
        {
            Base::BindColumns( statement );

            Bind(statement, MINVALUE_FIELD_ID, minValue_);
            Bind(statement, MAXVALUE_FIELD_ID, maxValue_);
        }

        template<IO::StreamWriter StreamT>
        void WriteColumns( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteColumns( destination );
            WriteColumnValue( destination, minValue_);
            WriteColumnValue( destination, maxValue_);
        }
    };

    using SimpleInt32TimeseriesPropertyDefinitionDataReader = SimpleColumnDataReader<Int32TimeseriesPropertyDefinitionColumnData>;

    class Int64TimeseriesPropertyDefinitionColumnData : public TimeseriesPropertyDefinitionColumnData
    {
        Int64 minValue_ = 0;
        Int64 maxValue_ = 0;
    public:
        using Base = TimeseriesPropertyDefinitionColumnData;

        static constexpr std::wstring_view FieldNames = L"[Id],[RowVersion],[ElementType],[Name],[MinValue],[MaxValue],[Description]";
        static constexpr std::wstring_view ViewName = L"Int64TimeseriesPropertyDefinitionView";

        static constexpr SQLUSMALLINT MINVALUE_FIELD_ID = 6;
        static constexpr SQLUSMALLINT MAXVALUE_FIELD_ID = 7;

        Int64TimeseriesPropertyDefinitionColumnData( ) = default;

        virtual Kind GetKind() const override
        {
            return Kind::Int64TimeseriesPropertyDefinition;
        }

        Int64 MinValue( ) const
        {
            return minValue_;
        }
        void SetMinValue( Int64 minValue )
        {
            minValue_ = minValue;
        }
        Int64 MaxValue( ) const
        {
            return maxValue_;
        }
        void SetMaxValue( Int64 maxValue )
        {
            maxValue_ = maxValue;
        }
        void BindColumns( const ODBC::Statement& statement )
        {
            Base::BindColumns( statement );

            Bind(statement, MINVALUE_FIELD_ID, minValue_);
            Bind(statement, MAXVALUE_FIELD_ID, maxValue_);
        }

        template<IO::StreamWriter StreamT>
        void WriteColumns( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteColumns( destination );
            WriteColumnValue( destination, minValue_);
            WriteColumnValue( destination, maxValue_);
        }
    };

    using SimpleInt64TimeseriesPropertyDefinitionDataReader = SimpleColumnDataReader<Int64TimeseriesPropertyDefinitionColumnData>;

    class ReferenceTimeseriesPropertyDefinitionColumnData : public TimeseriesPropertyDefinitionColumnData
    {
        Guid referencedElementType_;
    public:
        using Base = TimeseriesPropertyDefinitionColumnData;

        static constexpr std::wstring_view FieldNames = L"[Id],[RowVersion],[ElementType],[Name],[ReferencedElementType],[Description]";
        static constexpr std::wstring_view ViewName = L"ReferenceTimeseriesPropertyDefinitionView";

        static constexpr SQLUSMALLINT REFERENCEDELEMENTTYPE_FIELD_ID = 6;

        ReferenceTimeseriesPropertyDefinitionColumnData( ) = default;

        virtual Kind GetKind() const override
        {
            return Kind::ReferenceTimeseriesPropertyDefinition;
        }

        const Guid& ReferencedElementType( ) const
        {
            return referencedElementType_;
        }
        void SetReferencedElementType( const Guid& referencedElementType )
        {
            referencedElementType_ = referencedElementType;
        }
        void BindColumns( const ODBC::Statement& statement )
        {
            Base::BindColumns( statement );

            Bind(statement, REFERENCEDELEMENTTYPE_FIELD_ID, referencedElementType_);
        }

        template<IO::StreamWriter StreamT>
        void WriteColumns( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteColumns( destination );
            WriteColumnValue( destination, referencedElementType_);
        }
    };

    using SimpleReferenceTimeseriesPropertyDefinitionDataReader = SimpleColumnDataReader<ReferenceTimeseriesPropertyDefinitionColumnData>;

    class SByteTimeseriesPropertyDefinitionColumnData : public TimeseriesPropertyDefinitionColumnData
    {
        SByte minValue_ = 0;
        SByte maxValue_ = 0;
    public:
        using Base = TimeseriesPropertyDefinitionColumnData;

        static constexpr std::wstring_view FieldNames = L"[Id],[RowVersion],[ElementType],[Name],[MinValue],[MaxValue],[Description]";
        static constexpr std::wstring_view ViewName = L"SByteTimeseriesPropertyDefinitionView";

        static constexpr SQLUSMALLINT MINVALUE_FIELD_ID = 6;
        static constexpr SQLUSMALLINT MAXVALUE_FIELD_ID = 7;

        SByteTimeseriesPropertyDefinitionColumnData( ) = default;

        virtual Kind GetKind() const override
        {
            return Kind::SByteTimeseriesPropertyDefinition;
        }

        SByte MinValue( ) const
        {
            return minValue_;
        }
        void SetMinValue( SByte minValue )
        {
            minValue_ = minValue;
        }
        SByte MaxValue( ) const
        {
            return maxValue_;
        }
        void SetMaxValue( SByte maxValue )
        {
            maxValue_ = maxValue;
        }
        void BindColumns( const ODBC::Statement& statement )
        {
            Base::BindColumns( statement );

            Bind(statement, MINVALUE_FIELD_ID, minValue_);
            Bind(statement, MAXVALUE_FIELD_ID, maxValue_);
        }

        template<IO::StreamWriter StreamT>
        void WriteColumns( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteColumns( destination );
            WriteColumnValue( destination, minValue_);
            WriteColumnValue( destination, maxValue_);
        }
    };

    using SimpleSByteTimeseriesPropertyDefinitionDataReader = SimpleColumnDataReader<SByteTimeseriesPropertyDefinitionColumnData>;

    class SingleTimeseriesPropertyDefinitionColumnData : public TimeseriesPropertyDefinitionColumnData
    {
        float minValue_ = 0.0f;
        float maxValue_ = 0.0f;
    public:
        using Base = TimeseriesPropertyDefinitionColumnData;

        static constexpr std::wstring_view FieldNames = L"[Id],[RowVersion],[ElementType],[Name],[MinValue],[MaxValue],[Description]";
        static constexpr std::wstring_view ViewName = L"SingleTimeseriesPropertyDefinitionView";

        static constexpr SQLUSMALLINT MINVALUE_FIELD_ID = 6;
        static constexpr SQLUSMALLINT MAXVALUE_FIELD_ID = 7;

        SingleTimeseriesPropertyDefinitionColumnData( ) = default;

        virtual Kind GetKind() const override
        {
            return Kind::SingleTimeseriesPropertyDefinition;
        }

        float MinValue( ) const
        {
            return minValue_;
        }
        void SetMinValue( float minValue )
        {
            minValue_ = minValue;
        }
        float MaxValue( ) const
        {
            return maxValue_;
        }
        void SetMaxValue( float maxValue )
        {
            maxValue_ = maxValue;
        }
        void BindColumns( const ODBC::Statement& statement )
        {
            Base::BindColumns( statement );

            Bind(statement, MINVALUE_FIELD_ID, minValue_);
            Bind(statement, MAXVALUE_FIELD_ID, maxValue_);
        }

        template<IO::StreamWriter StreamT>
        void WriteColumns( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteColumns( destination );
            WriteColumnValue( destination, minValue_);
            WriteColumnValue( destination, maxValue_);
        }
    };

    using SimpleSingleTimeseriesPropertyDefinitionDataReader = SimpleColumnDataReader<SingleTimeseriesPropertyDefinitionColumnData>;

    class StringTimeseriesPropertyDefinitionColumnData : public TimeseriesPropertyDefinitionColumnData
    {
        FixedDBWideString<100> pattern_;
    public:
        using Base = TimeseriesPropertyDefinitionColumnData;

        static constexpr std::wstring_view FieldNames = L"[Id],[RowVersion],[ElementType],[Name],[Pattern],[Description]";
        static constexpr std::wstring_view ViewName = L"StringTimeseriesPropertyDefinitionView";

        static constexpr SQLUSMALLINT PATTERN_FIELD_ID = 6;

        StringTimeseriesPropertyDefinitionColumnData( ) = default;

        virtual Kind GetKind() const override
        {
            return Kind::StringTimeseriesPropertyDefinition;
        }

        const FixedDBWideString<100>& Pattern( ) const
        {
            return pattern_;
        }
        void SetPattern( const WideString& pattern )
        {
            pattern_ = pattern;
        }
        void BindColumns( const ODBC::Statement& statement )
        {
            Base::BindColumns( statement );

            Bind(statement, PATTERN_FIELD_ID, pattern_);
        }

        template<IO::StreamWriter StreamT>
        void WriteColumns( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteColumns( destination );
            WriteColumnValue( destination, pattern_);
        }
    };

    using SimpleStringTimeseriesPropertyDefinitionDataReader = SimpleColumnDataReader<StringTimeseriesPropertyDefinitionColumnData>;

    class TimeSpanTimeseriesPropertyDefinitionColumnData : public TimeseriesPropertyDefinitionColumnData
    {
        TimeSpan minValue_;
        TimeSpan maxValue_;
    public:
        using Base = TimeseriesPropertyDefinitionColumnData;

        static constexpr std::wstring_view FieldNames = L"[Id],[RowVersion],[ElementType],[Name],[MinValue],[MaxValue],[Description]";
        static constexpr std::wstring_view ViewName = L"TimeSpanTimeseriesPropertyDefinitionView";

        static constexpr SQLUSMALLINT MINVALUE_FIELD_ID = 6;
        static constexpr SQLUSMALLINT MAXVALUE_FIELD_ID = 7;

        TimeSpanTimeseriesPropertyDefinitionColumnData( ) = default;

        virtual Kind GetKind() const override
        {
            return Kind::TimeSpanTimeseriesPropertyDefinition;
        }

        const TimeSpan& MinValue( ) const
        {
            return minValue_;
        }
        void SetMinValue( const TimeSpan& minValue )
        {
            minValue_ = minValue;
        }
        const TimeSpan& MaxValue( ) const
        {
            return maxValue_;
        }
        void SetMaxValue( const TimeSpan& maxValue )
        {
            maxValue_ = maxValue;
        }
        void BindColumns( const ODBC::Statement& statement )
        {
            Base::BindColumns( statement );

            Bind(statement, MINVALUE_FIELD_ID, minValue_);
            Bind(statement, MAXVALUE_FIELD_ID, maxValue_);
        }

        template<IO::StreamWriter StreamT>
        void WriteColumns( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteColumns( destination );
            WriteColumnValue( destination, minValue_);
            WriteColumnValue( destination, maxValue_);
        }
    };

    using SimpleTimeSpanTimeseriesPropertyDefinitionDataReader = SimpleColumnDataReader<TimeSpanTimeseriesPropertyDefinitionColumnData>;

    class UInt16TimeseriesPropertyDefinitionColumnData : public TimeseriesPropertyDefinitionColumnData
    {
        UInt16 minValue_ = 0;
        UInt16 maxValue_ = 0;
    public:
        using Base = TimeseriesPropertyDefinitionColumnData;

        static constexpr std::wstring_view FieldNames = L"[Id],[RowVersion],[ElementType],[Name],[MinValue],[MaxValue],[Description]";
        static constexpr std::wstring_view ViewName = L"UInt16TimeseriesPropertyDefinitionView";

        static constexpr SQLUSMALLINT MINVALUE_FIELD_ID = 6;
        static constexpr SQLUSMALLINT MAXVALUE_FIELD_ID = 7;

        UInt16TimeseriesPropertyDefinitionColumnData( ) = default;

        virtual Kind GetKind() const override
        {
            return Kind::UInt16TimeseriesPropertyDefinition;
        }

        UInt16 MinValue( ) const
        {
            return minValue_;
        }
        void SetMinValue( UInt16 minValue )
        {
            minValue_ = minValue;
        }
        UInt16 MaxValue( ) const
        {
            return maxValue_;
        }
        void SetMaxValue( UInt16 maxValue )
        {
            maxValue_ = maxValue;
        }
        void BindColumns( const ODBC::Statement& statement )
        {
            Base::BindColumns( statement );

            Bind(statement, MINVALUE_FIELD_ID, minValue_);
            Bind(statement, MAXVALUE_FIELD_ID, maxValue_);
        }

        template<IO::StreamWriter StreamT>
        void WriteColumns( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteColumns( destination );
            WriteColumnValue( destination, minValue_);
            WriteColumnValue( destination, maxValue_);
        }
    };

    using SimpleUInt16TimeseriesPropertyDefinitionDataReader = SimpleColumnDataReader<UInt16TimeseriesPropertyDefinitionColumnData>;

    class UInt32TimeseriesPropertyDefinitionColumnData : public TimeseriesPropertyDefinitionColumnData
    {
        UInt32 minValue_ = 0;
        UInt32 maxValue_ = 0;
    public:
        using Base = TimeseriesPropertyDefinitionColumnData;

        static constexpr std::wstring_view FieldNames = L"[Id],[RowVersion],[ElementType],[Name],[MinValue],[MaxValue],[Description]";
        static constexpr std::wstring_view ViewName = L"UInt32TimeseriesPropertyDefinitionView";

        static constexpr SQLUSMALLINT MINVALUE_FIELD_ID = 6;
        static constexpr SQLUSMALLINT MAXVALUE_FIELD_ID = 7;

        UInt32TimeseriesPropertyDefinitionColumnData( ) = default;

        virtual Kind GetKind() const override
        {
            return Kind::UInt32TimeseriesPropertyDefinition;
        }

        UInt32 MinValue( ) const
        {
            return minValue_;
        }
        void SetMinValue( UInt32 minValue )
        {
            minValue_ = minValue;
        }
        UInt32 MaxValue( ) const
        {
            return maxValue_;
        }
        void SetMaxValue( UInt32 maxValue )
        {
            maxValue_ = maxValue;
        }
        void BindColumns( const ODBC::Statement& statement )
        {
            Base::BindColumns( statement );

            Bind(statement, MINVALUE_FIELD_ID, minValue_);
            Bind(statement, MAXVALUE_FIELD_ID, maxValue_);
        }

        template<IO::StreamWriter StreamT>
        void WriteColumns( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteColumns( destination );
            WriteColumnValue( destination, minValue_);
            WriteColumnValue( destination, maxValue_);
        }
    };

    using SimpleUInt32TimeseriesPropertyDefinitionDataReader = SimpleColumnDataReader<UInt32TimeseriesPropertyDefinitionColumnData>;

    class UInt64TimeseriesPropertyDefinitionColumnData : public TimeseriesPropertyDefinitionColumnData
    {
        Int64 minValue_ = 0;
        Int64 maxValue_ = 0;
    public:
        using Base = TimeseriesPropertyDefinitionColumnData;

        static constexpr std::wstring_view FieldNames = L"[Id],[RowVersion],[ElementType],[Name],[MinValue],[MaxValue],[Description]";
        static constexpr std::wstring_view ViewName = L"UInt64TimeseriesPropertyDefinitionView";

        static constexpr SQLUSMALLINT MINVALUE_FIELD_ID = 6;
        static constexpr SQLUSMALLINT MAXVALUE_FIELD_ID = 7;

        UInt64TimeseriesPropertyDefinitionColumnData( ) = default;

        virtual Kind GetKind() const override
        {
            return Kind::UInt64TimeseriesPropertyDefinition;
        }

        Int64 MinValue( ) const
        {
            return minValue_;
        }
        void SetMinValue( Int64 minValue )
        {
            minValue_ = minValue;
        }
        Int64 MaxValue( ) const
        {
            return maxValue_;
        }
        void SetMaxValue( Int64 maxValue )
        {
            maxValue_ = maxValue;
        }
        void BindColumns( const ODBC::Statement& statement )
        {
            Base::BindColumns( statement );

            Bind(statement, MINVALUE_FIELD_ID, minValue_);
            Bind(statement, MAXVALUE_FIELD_ID, maxValue_);
        }

        template<IO::StreamWriter StreamT>
        void WriteColumns( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteColumns( destination );
            WriteColumnValue( destination, minValue_);
            WriteColumnValue( destination, maxValue_);
        }
    };

    using SimpleUInt64TimeseriesPropertyDefinitionDataReader = SimpleColumnDataReader<UInt64TimeseriesPropertyDefinitionColumnData>;

    class TimeSpanPropertyDefinitionColumnData : public PropertyDefinitionColumnData
    {
        TimeSpan defaultValue_;
        TimeSpan minValue_;
        TimeSpan maxValue_;
    public:
        using Base = PropertyDefinitionColumnData;

        static constexpr std::wstring_view FieldNames = L"[Id],[RowVersion],[ElementType],[Name],[DefaultValue],[MinValue],[MaxValue],[Description]";
        static constexpr std::wstring_view ViewName = L"TimeSpanPropertyDefinitionView";

        static constexpr SQLUSMALLINT DEFAULTVALUE_FIELD_ID = 6;
        static constexpr SQLUSMALLINT MINVALUE_FIELD_ID = 7;
        static constexpr SQLUSMALLINT MAXVALUE_FIELD_ID = 8;

        TimeSpanPropertyDefinitionColumnData( ) = default;

        virtual Kind GetKind() const override
        {
            return Kind::TimeSpanPropertyDefinition;
        }

        const TimeSpan& DefaultValue( ) const
        {
            return defaultValue_;
        }
        void SetDefaultValue( const TimeSpan& defaultValue )
        {
            defaultValue_ = defaultValue;
        }
        const TimeSpan& MinValue( ) const
        {
            return minValue_;
        }
        void SetMinValue( const TimeSpan& minValue )
        {
            minValue_ = minValue;
        }
        const TimeSpan& MaxValue( ) const
        {
            return maxValue_;
        }
        void SetMaxValue( const TimeSpan& maxValue )
        {
            maxValue_ = maxValue;
        }
        void BindColumns( const ODBC::Statement& statement )
        {
            Base::BindColumns( statement );

            Bind(statement, DEFAULTVALUE_FIELD_ID, defaultValue_);
            Bind(statement, MINVALUE_FIELD_ID, minValue_);
            Bind(statement, MAXVALUE_FIELD_ID, maxValue_);
        }

        template<IO::StreamWriter StreamT>
        void WriteColumns( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteColumns( destination );
            WriteColumnValue( destination, defaultValue_);
            WriteColumnValue( destination, minValue_);
            WriteColumnValue( destination, maxValue_);
        }
    };

    using SimpleTimeSpanPropertyDefinitionDataReader = SimpleColumnDataReader<TimeSpanPropertyDefinitionColumnData>;

    class UInt16PropertyDefinitionColumnData : public PropertyDefinitionColumnData
    {
        UInt16 defaultValue_ = 0;
        UInt16 minValue_ = 0;
        UInt16 maxValue_ = 0;
    public:
        using Base = PropertyDefinitionColumnData;

        static constexpr std::wstring_view FieldNames = L"[Id],[RowVersion],[ElementType],[Name],[DefaultValue],[MinValue],[MaxValue],[Description]";
        static constexpr std::wstring_view ViewName = L"UInt16PropertyDefinitionView";

        static constexpr SQLUSMALLINT DEFAULTVALUE_FIELD_ID = 6;
        static constexpr SQLUSMALLINT MINVALUE_FIELD_ID = 7;
        static constexpr SQLUSMALLINT MAXVALUE_FIELD_ID = 8;

        UInt16PropertyDefinitionColumnData( ) = default;

        virtual Kind GetKind() const override
        {
            return Kind::UInt16PropertyDefinition;
        }

        UInt16 DefaultValue( ) const
        {
            return defaultValue_;
        }
        void SetDefaultValue( UInt16 defaultValue )
        {
            defaultValue_ = defaultValue;
        }
        UInt16 MinValue( ) const
        {
            return minValue_;
        }
        void SetMinValue( UInt16 minValue )
        {
            minValue_ = minValue;
        }
        UInt16 MaxValue( ) const
        {
            return maxValue_;
        }
        void SetMaxValue( UInt16 maxValue )
        {
            maxValue_ = maxValue;
        }
        void BindColumns( const ODBC::Statement& statement )
        {
            Base::BindColumns( statement );

            Bind(statement, DEFAULTVALUE_FIELD_ID, defaultValue_);
            Bind(statement, MINVALUE_FIELD_ID, minValue_);
            Bind(statement, MAXVALUE_FIELD_ID, maxValue_);
        }

        template<IO::StreamWriter StreamT>
        void WriteColumns( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteColumns( destination );
            WriteColumnValue( destination, defaultValue_);
            WriteColumnValue( destination, minValue_);
            WriteColumnValue( destination, maxValue_);
        }
    };

    using SimpleUInt16PropertyDefinitionDataReader = SimpleColumnDataReader<UInt16PropertyDefinitionColumnData>;

    class UInt32PropertyDefinitionColumnData : public PropertyDefinitionColumnData
    {
        UInt32 defaultValue_ = 0;
        UInt32 minValue_ = 0;
        UInt32 maxValue_ = 0;
    public:
        using Base = PropertyDefinitionColumnData;

        static constexpr std::wstring_view FieldNames = L"[Id],[RowVersion],[ElementType],[Name],[DefaultValue],[MinValue],[MaxValue],[Description]";
        static constexpr std::wstring_view ViewName = L"UInt32PropertyDefinitionView";

        static constexpr SQLUSMALLINT DEFAULTVALUE_FIELD_ID = 6;
        static constexpr SQLUSMALLINT MINVALUE_FIELD_ID = 7;
        static constexpr SQLUSMALLINT MAXVALUE_FIELD_ID = 8;

        UInt32PropertyDefinitionColumnData( ) = default;

        virtual Kind GetKind() const override
        {
            return Kind::UInt32PropertyDefinition;
        }

        UInt32 DefaultValue( ) const
        {
            return defaultValue_;
        }
        void SetDefaultValue( UInt32 defaultValue )
        {
            defaultValue_ = defaultValue;
        }
        UInt32 MinValue( ) const
        {
            return minValue_;
        }
        void SetMinValue( UInt32 minValue )
        {
            minValue_ = minValue;
        }
        UInt32 MaxValue( ) const
        {
            return maxValue_;
        }
        void SetMaxValue( UInt32 maxValue )
        {
            maxValue_ = maxValue;
        }
        void BindColumns( const ODBC::Statement& statement )
        {
            Base::BindColumns( statement );

            Bind(statement, DEFAULTVALUE_FIELD_ID, defaultValue_);
            Bind(statement, MINVALUE_FIELD_ID, minValue_);
            Bind(statement, MAXVALUE_FIELD_ID, maxValue_);
        }

        template<IO::StreamWriter StreamT>
        void WriteColumns( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteColumns( destination );
            WriteColumnValue( destination, defaultValue_);
            WriteColumnValue( destination, minValue_);
            WriteColumnValue( destination, maxValue_);
        }
    };

    using SimpleUInt32PropertyDefinitionDataReader = SimpleColumnDataReader<UInt32PropertyDefinitionColumnData>;

    class UInt64PropertyDefinitionColumnData : public PropertyDefinitionColumnData
    {
        Int64 defaultValue_ = 0;
        Int64 minValue_ = 0;
        Int64 maxValue_ = 0;
    public:
        using Base = PropertyDefinitionColumnData;

        static constexpr std::wstring_view FieldNames = L"[Id],[RowVersion],[ElementType],[Name],[DefaultValue],[MinValue],[MaxValue],[Description]";
        static constexpr std::wstring_view ViewName = L"UInt64PropertyDefinitionView";

        static constexpr SQLUSMALLINT DEFAULTVALUE_FIELD_ID = 6;
        static constexpr SQLUSMALLINT MINVALUE_FIELD_ID = 7;
        static constexpr SQLUSMALLINT MAXVALUE_FIELD_ID = 8;

        UInt64PropertyDefinitionColumnData( ) = default;

        virtual Kind GetKind() const override
        {
            return Kind::UInt64PropertyDefinition;
        }

        Int64 DefaultValue( ) const
        {
            return defaultValue_;
        }
        void SetDefaultValue( Int64 defaultValue )
        {
            defaultValue_ = defaultValue;
        }
        Int64 MinValue( ) const
        {
            return minValue_;
        }
        void SetMinValue( Int64 minValue )
        {
            minValue_ = minValue;
        }
        Int64 MaxValue( ) const
        {
            return maxValue_;
        }
        void SetMaxValue( Int64 maxValue )
        {
            maxValue_ = maxValue;
        }
        void BindColumns( const ODBC::Statement& statement )
        {
            Base::BindColumns( statement );

            Bind(statement, DEFAULTVALUE_FIELD_ID, defaultValue_);
            Bind(statement, MINVALUE_FIELD_ID, minValue_);
            Bind(statement, MAXVALUE_FIELD_ID, maxValue_);
        }

        template<IO::StreamWriter StreamT>
        void WriteColumns( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteColumns( destination );
            WriteColumnValue( destination, defaultValue_);
            WriteColumnValue( destination, minValue_);
            WriteColumnValue( destination, maxValue_);
        }
    };

    using SimpleUInt64PropertyDefinitionDataReader = SimpleColumnDataReader<UInt64PropertyDefinitionColumnData>;

    class RadarAlarmStatusColumnData : public BaseColumnData
    {
        Guid id_;
        Int64 rowVersion_ = 0;
        Guid radar_;
        DateTime timestamp_;
        Data::AlarmState type_ = Data::AlarmState::Unknown;
    public:
        using Base = BaseColumnData;

        static constexpr std::wstring_view FieldNames = L"[Id],[RowVersion],[Radar],[Timestamp],[Type]";
        static constexpr std::wstring_view ViewName = L"RadarAlarmStatusView";

        static constexpr SQLUSMALLINT ID_FIELD_ID = 1;
        static constexpr SQLUSMALLINT ROWVERSION_FIELD_ID = 2;
        static constexpr SQLUSMALLINT RADAR_FIELD_ID = 3;
        static constexpr SQLUSMALLINT TIMESTAMP_FIELD_ID = 4;
        static constexpr SQLUSMALLINT TYPE_FIELD_ID = 5;

        RadarAlarmStatusColumnData( ) = default;

        virtual Kind GetKind() const override
        {
            return Kind::RadarAlarmStatus;
        }

        const Guid& Id( ) const
        {
            return id_;
        }
        void SetId( const Guid& id )
        {
            id_ = id;
        }
        Int64 RowVersion( ) const
        {
            return rowVersion_;
        }
        void SetRowVersion( const Int64& rowVersion )
        {
            rowVersion_ = rowVersion;
        }
        const Guid& Radar( ) const
        {
            return radar_;
        }
        void SetRadar( const Guid& radar )
        {
            radar_ = radar;
        }
        const DateTime& Timestamp( ) const
        {
            return timestamp_;
        }
        void SetTimestamp( const DateTime& timestamp )
        {
            timestamp_ = timestamp;
        }
        Data::AlarmState Type( ) const
        {
            return type_;
        }
        void SetType( Data::AlarmState type )
        {
            type_ = type;
        }
        void BindColumns( const ODBC::Statement& statement )
        {
            Bind(statement, ID_FIELD_ID, id_);
            Bind(statement, ROWVERSION_FIELD_ID, rowVersion_);
            Bind(statement, RADAR_FIELD_ID, radar_);
            Bind(statement, TIMESTAMP_FIELD_ID, timestamp_);
            Bind(statement, TYPE_FIELD_ID, type_);
        }

        template<IO::StreamWriter StreamT>
        void WriteColumns( IO::BinaryWriter<StreamT>& destination ) const
        {
            WriteColumnValue( destination, id_);
            WriteColumnValue( destination, rowVersion_);
            WriteColumnValue( destination, radar_);
            WriteColumnValue( destination, timestamp_);
            WriteColumnValue( destination, type_);
        }
    };

    using SimpleRadarAlarmStatusDataReader = SimpleColumnDataReader<RadarAlarmStatusColumnData>;

    class RadarCommandColumnData : public BaseColumnData
    {
        Guid id_;
        Int64 rowVersion_ = 0;
        Guid radar_;
        DateTime timestamp_;
        Data::DeviceCommandSourceType deviceCommandSourceType_ = Data::DeviceCommandSourceType::Unknown;
        Guid deviceCommandSourceId_;
        Guid reply_;
    public:
        using Base = BaseColumnData;

        static constexpr std::wstring_view FieldNames = L"[Id],[RowVersion],[Radar],[Timestamp],[DeviceCommandSourceType],[DeviceCommandSourceId],[Reply]";
        static constexpr std::wstring_view ViewName = L"RadarCommandView";

        static constexpr SQLUSMALLINT ID_FIELD_ID = 1;
        static constexpr SQLUSMALLINT ROWVERSION_FIELD_ID = 2;
        static constexpr SQLUSMALLINT RADAR_FIELD_ID = 3;
        static constexpr SQLUSMALLINT TIMESTAMP_FIELD_ID = 4;
        static constexpr SQLUSMALLINT DEVICECOMMANDSOURCETYPE_FIELD_ID = 5;
        static constexpr SQLUSMALLINT DEVICECOMMANDSOURCEID_FIELD_ID = 6;
        static constexpr SQLUSMALLINT REPLY_FIELD_ID = 7;

        RadarCommandColumnData( ) = default;

        virtual Kind GetKind() const override
        {
            return Kind::RadarCommand;
        }

        const Guid& Id( ) const
        {
            return id_;
        }
        void SetId( const Guid& id )
        {
            id_ = id;
        }
        Int64 RowVersion( ) const
        {
            return rowVersion_;
        }
        void SetRowVersion( const Int64& rowVersion )
        {
            rowVersion_ = rowVersion;
        }
        const Guid& Radar( ) const
        {
            return radar_;
        }
        void SetRadar( const Guid& radar )
        {
            radar_ = radar;
        }
        const DateTime& Timestamp( ) const
        {
            return timestamp_;
        }
        void SetTimestamp( const DateTime& timestamp )
        {
            timestamp_ = timestamp;
        }
        Data::DeviceCommandSourceType DeviceCommandSourceType( ) const
        {
            return deviceCommandSourceType_;
        }
        void SetDeviceCommandSourceType( Data::DeviceCommandSourceType deviceCommandSourceType )
        {
            deviceCommandSourceType_ = deviceCommandSourceType;
        }
        const Guid& DeviceCommandSourceId( ) const
        {
            return deviceCommandSourceId_;
        }
        void SetDeviceCommandSourceId( const Guid& deviceCommandSourceId )
        {
            deviceCommandSourceId_ = deviceCommandSourceId;
        }
        const Guid& Reply( ) const
        {
            return reply_;
        }
        void SetReply( const Guid& reply )
        {
            reply_ = reply;
        }
        void BindColumns( const ODBC::Statement& statement )
        {
            Bind(statement, ID_FIELD_ID, id_);
            Bind(statement, ROWVERSION_FIELD_ID, rowVersion_);
            Bind(statement, RADAR_FIELD_ID, radar_);
            Bind(statement, TIMESTAMP_FIELD_ID, timestamp_);
            Bind(statement, DEVICECOMMANDSOURCETYPE_FIELD_ID, deviceCommandSourceType_);
            Bind(statement, DEVICECOMMANDSOURCEID_FIELD_ID, deviceCommandSourceId_);
            Bind(statement, REPLY_FIELD_ID, reply_);
        }

        template<IO::StreamWriter StreamT>
        void WriteColumns( IO::BinaryWriter<StreamT>& destination ) const
        {
            WriteColumnValue( destination, id_);
            WriteColumnValue( destination, rowVersion_);
            WriteColumnValue( destination, radar_);
            WriteColumnValue( destination, timestamp_);
            WriteColumnValue( destination, deviceCommandSourceType_);
            WriteColumnValue( destination, deviceCommandSourceId_);
            WriteColumnValue( destination, reply_);
        }
    };

    using SimpleRadarCommandDataReader = SimpleColumnDataReader<RadarCommandColumnData>;

    class RadarCommandGetStatusColumnData : public RadarCommandColumnData
    {
    public:
        using Base = RadarCommandColumnData;

        static constexpr std::wstring_view FieldNames = L"[Id],[RowVersion],[Radar],[Timestamp],[DeviceCommandSourceType],[DeviceCommandSourceId],[Reply]";
        static constexpr std::wstring_view ViewName = L"RadarCommandGetStatusView";

        RadarCommandGetStatusColumnData( ) = default;

        virtual Kind GetKind() const override
        {
            return Kind::RadarCommandGetStatus;
        }

        template<IO::StreamWriter StreamT>
        void WriteColumns( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteColumns( destination );
        }
    };

    using SimpleRadarCommandGetStatusDataReader = SimpleColumnDataReader<RadarCommandGetStatusColumnData>;

    class RadarCommandReplyColumnData : public BaseColumnData
    {
        Guid id_;
        Int64 rowVersion_ = 0;
        Guid radar_;
        DateTime timestamp_;
        Guid command_;
        Data::DeviceCommandReplyStatus status_ = Data::DeviceCommandReplyStatus::Unknown;
        WideString message_;
        SQLLEN messageLength_ = SQL_NULL_DATA;
    public:
        using Base = BaseColumnData;

        static constexpr std::wstring_view FieldNames = L"[Id],[RowVersion],[Radar],[Timestamp],[Command],[Status],[Message]";
        static constexpr std::wstring_view ViewName = L"RadarCommandReplyView";

        static constexpr SQLUSMALLINT ID_FIELD_ID = 1;
        static constexpr SQLUSMALLINT ROWVERSION_FIELD_ID = 2;
        static constexpr SQLUSMALLINT RADAR_FIELD_ID = 3;
        static constexpr SQLUSMALLINT TIMESTAMP_FIELD_ID = 4;
        static constexpr SQLUSMALLINT COMMAND_FIELD_ID = 5;
        static constexpr SQLUSMALLINT STATUS_FIELD_ID = 6;
        static constexpr SQLUSMALLINT MESSAGE_FIELD_ID = 7;

        RadarCommandReplyColumnData( ) = default;

        virtual Kind GetKind() const override
        {
            return Kind::RadarCommandReply;
        }

        const Guid& Id( ) const
        {
            return id_;
        }
        void SetId( const Guid& id )
        {
            id_ = id;
        }
        Int64 RowVersion( ) const
        {
            return rowVersion_;
        }
        void SetRowVersion( const Int64& rowVersion )
        {
            rowVersion_ = rowVersion;
        }
        const Guid& Radar( ) const
        {
            return radar_;
        }
        void SetRadar( const Guid& radar )
        {
            radar_ = radar;
        }
        const DateTime& Timestamp( ) const
        {
            return timestamp_;
        }
        void SetTimestamp( const DateTime& timestamp )
        {
            timestamp_ = timestamp;
        }
        const Guid& Command( ) const
        {
            return command_;
        }
        void SetCommand( const Guid& command )
        {
            command_ = command;
        }
        Data::DeviceCommandReplyStatus Status( ) const
        {
            return status_;
        }
        void SetStatus( Data::DeviceCommandReplyStatus status )
        {
            status_ = status;
        }
        const WideString& Message( ) const
        {
            return message_;
        }
        void SetMessage( const WideString& message )
        {
            message_ = message;
        }
        void BindColumns( const ODBC::Statement& statement )
        {
            Bind(statement, ID_FIELD_ID, id_);
            Bind(statement, ROWVERSION_FIELD_ID, rowVersion_);
            Bind(statement, RADAR_FIELD_ID, radar_);
            Bind(statement, TIMESTAMP_FIELD_ID, timestamp_);
            Bind(statement, COMMAND_FIELD_ID, command_);
            Bind(statement, STATUS_FIELD_ID, status_);
        }

        void ReadUnboundData( const ODBC::Statement& statement )
        {
            Base::ReadUnboundData( statement );

            message_ = statement.GetWideString(MESSAGE_FIELD_ID);
        }
        template<IO::StreamWriter StreamT>
        void WriteColumns( IO::BinaryWriter<StreamT>& destination ) const
        {
            WriteColumnValue( destination, id_);
            WriteColumnValue( destination, rowVersion_);
            WriteColumnValue( destination, radar_);
            WriteColumnValue( destination, timestamp_);
            WriteColumnValue( destination, command_);
            WriteColumnValue( destination, status_);
            WriteColumnValue( destination, message_);
        }
    };

    using SimpleRadarCommandReplyDataReader = SimpleColumnDataReader<RadarCommandReplyColumnData>;

    class RadarCommandReplyGetStatusColumnData : public RadarCommandReplyColumnData
    {
        Int32 azimuthCount_ = 0;
        Int32 triggerCount_ = 0;
        TimeSpan rotationCount_;
        Data::RadarPulse pulse_ = Data::RadarPulse::Short;
        bool tx_ = false;
    public:
        using Base = RadarCommandReplyColumnData;

        static constexpr std::wstring_view FieldNames = L"[Id],[RowVersion],[Radar],[Timestamp],[Command],[Status],[AzimuthCount],[TriggerCount],[RotationCount],[Pulse],[Tx],[Message]";
        static constexpr std::wstring_view ViewName = L"RadarCommandReplyGetStatusView";

        static constexpr SQLUSMALLINT AZIMUTHCOUNT_FIELD_ID = 8;
        static constexpr SQLUSMALLINT TRIGGERCOUNT_FIELD_ID = 9;
        static constexpr SQLUSMALLINT ROTATIONCOUNT_FIELD_ID = 10;
        static constexpr SQLUSMALLINT PULSE_FIELD_ID = 11;
        static constexpr SQLUSMALLINT TX_FIELD_ID = 12;

        RadarCommandReplyGetStatusColumnData( ) = default;

        virtual Kind GetKind() const override
        {
            return Kind::RadarCommandReplyGetStatus;
        }

        Int32 AzimuthCount( ) const
        {
            return azimuthCount_;
        }
        void SetAzimuthCount( Int32 azimuthCount )
        {
            azimuthCount_ = azimuthCount;
        }
        Int32 TriggerCount( ) const
        {
            return triggerCount_;
        }
        void SetTriggerCount( Int32 triggerCount )
        {
            triggerCount_ = triggerCount;
        }
        const TimeSpan& RotationCount( ) const
        {
            return rotationCount_;
        }
        void SetRotationCount( const TimeSpan& rotationCount )
        {
            rotationCount_ = rotationCount;
        }
        Data::RadarPulse Pulse( ) const
        {
            return pulse_;
        }
        void SetPulse( Data::RadarPulse pulse )
        {
            pulse_ = pulse;
        }
        bool Tx( ) const
        {
            return tx_;
        }
        void SetTx( bool tx )
        {
            tx_ = tx;
        }
        void BindColumns( const ODBC::Statement& statement )
        {
            Base::BindColumns( statement );

            Bind(statement, AZIMUTHCOUNT_FIELD_ID, azimuthCount_);
            Bind(statement, TRIGGERCOUNT_FIELD_ID, triggerCount_);
            Bind(statement, ROTATIONCOUNT_FIELD_ID, rotationCount_);
            Bind(statement, PULSE_FIELD_ID, pulse_);
            Bind(statement, TX_FIELD_ID, tx_);
        }

        template<IO::StreamWriter StreamT>
        void WriteColumns( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteColumns( destination );
            WriteColumnValue( destination, azimuthCount_);
            WriteColumnValue( destination, triggerCount_);
            WriteColumnValue( destination, rotationCount_);
            WriteColumnValue( destination, pulse_);
            WriteColumnValue( destination, tx_);
        }
    };

    using SimpleRadarCommandReplyGetStatusDataReader = SimpleColumnDataReader<RadarCommandReplyGetStatusColumnData>;

    class RadarConfigurationColumnData : public BaseColumnData
    {
        Guid id_;
        Int64 rowVersion_ = 0;
        Guid radar_;
        DateTime timestamp_;
        Int32 radarProtocolVersion_ = 0;
        FixedDBWideString<100> radarIPAddress_;
        Int32 radarPort_ = 0;
        Int32 radarConfigurationPort_ = 0;
        TimeSpan skipMagicTimeout_;
        TimeSpan readTimeout_;
        TimeSpan synchronizationInterval_;
        Int32 targetsRefreshRate_ = 0;
        Int32 range_ = 0;
        Int32 sectorCount_ = 0;
        Int32 sectorOffset_ = 0;
        UInt32 imageColor_ = 0;
        DBUInt32 imageSubstitutionColor_;
        UInt32 transparentColor_ = 0;
        double imageScaleFactorX_ = 0.0;
        double imageOffsetX_ = 0.0;
        double imageScaleFactorY_ = 0.0;
        double imageOffsetY_ = 0.0;
        Data::RadarImageType radarImageType_ = Data::RadarImageType::MaskedProcessed;
        UInt32 trackColor_ = 0;
        UInt32 vectorColor_ = 0;
        bool enableNmea_ = false;
        FixedDBWideString<100> nmeaReceiverIPAddress_;
        Int32 nmeaReceiverPort_ = 0;
        FixedDBWideString<100> nmeaReceiverSourceId_;
    public:
        using Base = BaseColumnData;

        static constexpr std::wstring_view FieldNames = L"[Id],[RowVersion],[Radar],[Timestamp],[RadarProtocolVersion],[RadarIPAddress],[RadarPort],[RadarConfigurationPort],[SkipMagicTimeout],[ReadTimeout],[SynchronizationInterval],[TargetsRefreshRate],[Range],[SectorCount],[SectorOffset],[ImageColor],[ImageSubstitutionColor],[TransparentColor],[ImageScaleFactorX],[ImageOffsetX],[ImageScaleFactorY],[ImageOffsetY],[RadarImageType],[TrackColor],[VectorColor],[EnableNmea],[NmeaReceiverIPAddress],[NmeaReceiverPort],[NmeaReceiverSourceId]";
        static constexpr std::wstring_view ViewName = L"RadarConfigurationView";

        static constexpr SQLUSMALLINT ID_FIELD_ID = 1;
        static constexpr SQLUSMALLINT ROWVERSION_FIELD_ID = 2;
        static constexpr SQLUSMALLINT RADAR_FIELD_ID = 3;
        static constexpr SQLUSMALLINT TIMESTAMP_FIELD_ID = 4;
        static constexpr SQLUSMALLINT RADARPROTOCOLVERSION_FIELD_ID = 5;
        static constexpr SQLUSMALLINT RADARIPADDRESS_FIELD_ID = 6;
        static constexpr SQLUSMALLINT RADARPORT_FIELD_ID = 7;
        static constexpr SQLUSMALLINT RADARCONFIGURATIONPORT_FIELD_ID = 8;
        static constexpr SQLUSMALLINT SKIPMAGICTIMEOUT_FIELD_ID = 9;
        static constexpr SQLUSMALLINT READTIMEOUT_FIELD_ID = 10;
        static constexpr SQLUSMALLINT SYNCHRONIZATIONINTERVAL_FIELD_ID = 11;
        static constexpr SQLUSMALLINT TARGETSREFRESHRATE_FIELD_ID = 12;
        static constexpr SQLUSMALLINT RANGE_FIELD_ID = 13;
        static constexpr SQLUSMALLINT SECTORCOUNT_FIELD_ID = 14;
        static constexpr SQLUSMALLINT SECTOROFFSET_FIELD_ID = 15;
        static constexpr SQLUSMALLINT IMAGECOLOR_FIELD_ID = 16;
        static constexpr SQLUSMALLINT IMAGESUBSTITUTIONCOLOR_FIELD_ID = 17;
        static constexpr SQLUSMALLINT TRANSPARENTCOLOR_FIELD_ID = 18;
        static constexpr SQLUSMALLINT IMAGESCALEFACTORX_FIELD_ID = 19;
        static constexpr SQLUSMALLINT IMAGEOFFSETX_FIELD_ID = 20;
        static constexpr SQLUSMALLINT IMAGESCALEFACTORY_FIELD_ID = 21;
        static constexpr SQLUSMALLINT IMAGEOFFSETY_FIELD_ID = 22;
        static constexpr SQLUSMALLINT RADARIMAGETYPE_FIELD_ID = 23;
        static constexpr SQLUSMALLINT TRACKCOLOR_FIELD_ID = 24;
        static constexpr SQLUSMALLINT VECTORCOLOR_FIELD_ID = 25;
        static constexpr SQLUSMALLINT ENABLENMEA_FIELD_ID = 26;
        static constexpr SQLUSMALLINT NMEARECEIVERIPADDRESS_FIELD_ID = 27;
        static constexpr SQLUSMALLINT NMEARECEIVERPORT_FIELD_ID = 28;
        static constexpr SQLUSMALLINT NMEARECEIVERSOURCEID_FIELD_ID = 29;

        RadarConfigurationColumnData( ) = default;

        virtual Kind GetKind() const override
        {
            return Kind::RadarConfiguration;
        }

        const Guid& Id( ) const
        {
            return id_;
        }
        void SetId( const Guid& id )
        {
            id_ = id;
        }
        Int64 RowVersion( ) const
        {
            return rowVersion_;
        }
        void SetRowVersion( const Int64& rowVersion )
        {
            rowVersion_ = rowVersion;
        }
        const Guid& Radar( ) const
        {
            return radar_;
        }
        void SetRadar( const Guid& radar )
        {
            radar_ = radar;
        }
        const DateTime& Timestamp( ) const
        {
            return timestamp_;
        }
        void SetTimestamp( const DateTime& timestamp )
        {
            timestamp_ = timestamp;
        }
        Int32 RadarProtocolVersion( ) const
        {
            return radarProtocolVersion_;
        }
        void SetRadarProtocolVersion( Int32 radarProtocolVersion )
        {
            radarProtocolVersion_ = radarProtocolVersion;
        }
        const FixedDBWideString<100>& RadarIPAddress( ) const
        {
            return radarIPAddress_;
        }
        void SetRadarIPAddress( const WideString& radarIPAddress )
        {
            radarIPAddress_ = radarIPAddress;
        }
        Int32 RadarPort( ) const
        {
            return radarPort_;
        }
        void SetRadarPort( Int32 radarPort )
        {
            radarPort_ = radarPort;
        }
        Int32 RadarConfigurationPort( ) const
        {
            return radarConfigurationPort_;
        }
        void SetRadarConfigurationPort( Int32 radarConfigurationPort )
        {
            radarConfigurationPort_ = radarConfigurationPort;
        }
        const TimeSpan& SkipMagicTimeout( ) const
        {
            return skipMagicTimeout_;
        }
        void SetSkipMagicTimeout( const TimeSpan& skipMagicTimeout )
        {
            skipMagicTimeout_ = skipMagicTimeout;
        }
        const TimeSpan& ReadTimeout( ) const
        {
            return readTimeout_;
        }
        void SetReadTimeout( const TimeSpan& readTimeout )
        {
            readTimeout_ = readTimeout;
        }
        const TimeSpan& SynchronizationInterval( ) const
        {
            return synchronizationInterval_;
        }
        void SetSynchronizationInterval( const TimeSpan& synchronizationInterval )
        {
            synchronizationInterval_ = synchronizationInterval;
        }
        Int32 TargetsRefreshRate( ) const
        {
            return targetsRefreshRate_;
        }
        void SetTargetsRefreshRate( Int32 targetsRefreshRate )
        {
            targetsRefreshRate_ = targetsRefreshRate;
        }
        Int32 Range( ) const
        {
            return range_;
        }
        void SetRange( Int32 range )
        {
            range_ = range;
        }
        Int32 SectorCount( ) const
        {
            return sectorCount_;
        }
        void SetSectorCount( Int32 sectorCount )
        {
            sectorCount_ = sectorCount;
        }
        Int32 SectorOffset( ) const
        {
            return sectorOffset_;
        }
        void SetSectorOffset( Int32 sectorOffset )
        {
            sectorOffset_ = sectorOffset;
        }
        UInt32 ImageColor( ) const
        {
            return imageColor_;
        }
        void SetImageColor( UInt32 imageColor )
        {
            imageColor_ = imageColor;
        }
        const DBUInt32& ImageSubstitutionColor( ) const
        {
            return imageSubstitutionColor_;
        }
        void SetImageSubstitutionColor( const DBUInt32& imageSubstitutionColor )
        {
            imageSubstitutionColor_ = imageSubstitutionColor;
        }
        UInt32 TransparentColor( ) const
        {
            return transparentColor_;
        }
        void SetTransparentColor( UInt32 transparentColor )
        {
            transparentColor_ = transparentColor;
        }
        double ImageScaleFactorX( ) const
        {
            return imageScaleFactorX_;
        }
        void SetImageScaleFactorX( double imageScaleFactorX )
        {
            imageScaleFactorX_ = imageScaleFactorX;
        }
        double ImageOffsetX( ) const
        {
            return imageOffsetX_;
        }
        void SetImageOffsetX( double imageOffsetX )
        {
            imageOffsetX_ = imageOffsetX;
        }
        double ImageScaleFactorY( ) const
        {
            return imageScaleFactorY_;
        }
        void SetImageScaleFactorY( double imageScaleFactorY )
        {
            imageScaleFactorY_ = imageScaleFactorY;
        }
        double ImageOffsetY( ) const
        {
            return imageOffsetY_;
        }
        void SetImageOffsetY( double imageOffsetY )
        {
            imageOffsetY_ = imageOffsetY;
        }
        Data::RadarImageType RadarImageType( ) const
        {
            return radarImageType_;
        }
        void SetRadarImageType( Data::RadarImageType radarImageType )
        {
            radarImageType_ = radarImageType;
        }
        UInt32 TrackColor( ) const
        {
            return trackColor_;
        }
        void SetTrackColor( UInt32 trackColor )
        {
            trackColor_ = trackColor;
        }
        UInt32 VectorColor( ) const
        {
            return vectorColor_;
        }
        void SetVectorColor( UInt32 vectorColor )
        {
            vectorColor_ = vectorColor;
        }
        bool EnableNmea( ) const
        {
            return enableNmea_;
        }
        void SetEnableNmea( bool enableNmea )
        {
            enableNmea_ = enableNmea;
        }
        const FixedDBWideString<100>& NmeaReceiverIPAddress( ) const
        {
            return nmeaReceiverIPAddress_;
        }
        void SetNmeaReceiverIPAddress( const WideString& nmeaReceiverIPAddress )
        {
            nmeaReceiverIPAddress_ = nmeaReceiverIPAddress;
        }
        Int32 NmeaReceiverPort( ) const
        {
            return nmeaReceiverPort_;
        }
        void SetNmeaReceiverPort( Int32 nmeaReceiverPort )
        {
            nmeaReceiverPort_ = nmeaReceiverPort;
        }
        const FixedDBWideString<100>& NmeaReceiverSourceId( ) const
        {
            return nmeaReceiverSourceId_;
        }
        void SetNmeaReceiverSourceId( const WideString& nmeaReceiverSourceId )
        {
            nmeaReceiverSourceId_ = nmeaReceiverSourceId;
        }
        void BindColumns( const ODBC::Statement& statement )
        {
            Bind(statement, ID_FIELD_ID, id_);
            Bind(statement, ROWVERSION_FIELD_ID, rowVersion_);
            Bind(statement, RADAR_FIELD_ID, radar_);
            Bind(statement, TIMESTAMP_FIELD_ID, timestamp_);
            Bind(statement, RADARPROTOCOLVERSION_FIELD_ID, radarProtocolVersion_);
            Bind(statement, RADARIPADDRESS_FIELD_ID, radarIPAddress_);
            Bind(statement, RADARPORT_FIELD_ID, radarPort_);
            Bind(statement, RADARCONFIGURATIONPORT_FIELD_ID, radarConfigurationPort_);
            Bind(statement, SKIPMAGICTIMEOUT_FIELD_ID, skipMagicTimeout_);
            Bind(statement, READTIMEOUT_FIELD_ID, readTimeout_);
            Bind(statement, SYNCHRONIZATIONINTERVAL_FIELD_ID, synchronizationInterval_);
            Bind(statement, TARGETSREFRESHRATE_FIELD_ID, targetsRefreshRate_);
            Bind(statement, RANGE_FIELD_ID, range_);
            Bind(statement, SECTORCOUNT_FIELD_ID, sectorCount_);
            Bind(statement, SECTOROFFSET_FIELD_ID, sectorOffset_);
            Bind(statement, IMAGECOLOR_FIELD_ID, imageColor_);
            Bind(statement, IMAGESUBSTITUTIONCOLOR_FIELD_ID, imageSubstitutionColor_);
            Bind(statement, TRANSPARENTCOLOR_FIELD_ID, transparentColor_);
            Bind(statement, IMAGESCALEFACTORX_FIELD_ID, imageScaleFactorX_);
            Bind(statement, IMAGEOFFSETX_FIELD_ID, imageOffsetX_);
            Bind(statement, IMAGESCALEFACTORY_FIELD_ID, imageScaleFactorY_);
            Bind(statement, IMAGEOFFSETY_FIELD_ID, imageOffsetY_);
            Bind(statement, RADARIMAGETYPE_FIELD_ID, radarImageType_);
            Bind(statement, TRACKCOLOR_FIELD_ID, trackColor_);
            Bind(statement, VECTORCOLOR_FIELD_ID, vectorColor_);
            Bind(statement, ENABLENMEA_FIELD_ID, enableNmea_);
            Bind(statement, NMEARECEIVERIPADDRESS_FIELD_ID, nmeaReceiverIPAddress_);
            Bind(statement, NMEARECEIVERPORT_FIELD_ID, nmeaReceiverPort_);
            Bind(statement, NMEARECEIVERSOURCEID_FIELD_ID, nmeaReceiverSourceId_);
        }

        template<IO::StreamWriter StreamT>
        void WriteColumns( IO::BinaryWriter<StreamT>& destination ) const
        {
            WriteColumnValue( destination, id_);
            WriteColumnValue( destination, rowVersion_);
            WriteColumnValue( destination, radar_);
            WriteColumnValue( destination, timestamp_);
            WriteColumnValue( destination, radarProtocolVersion_);
            WriteColumnValue( destination, radarIPAddress_);
            WriteColumnValue( destination, radarPort_);
            WriteColumnValue( destination, radarConfigurationPort_);
            WriteColumnValue( destination, skipMagicTimeout_);
            WriteColumnValue( destination, readTimeout_);
            WriteColumnValue( destination, synchronizationInterval_);
            WriteColumnValue( destination, targetsRefreshRate_);
            WriteColumnValue( destination, range_);
            WriteColumnValue( destination, sectorCount_);
            WriteColumnValue( destination, sectorOffset_);
            WriteColumnValue( destination, imageColor_);
            WriteColumnValue( destination, imageSubstitutionColor_);
            WriteColumnValue( destination, transparentColor_);
            WriteColumnValue( destination, imageScaleFactorX_);
            WriteColumnValue( destination, imageOffsetX_);
            WriteColumnValue( destination, imageScaleFactorY_);
            WriteColumnValue( destination, imageOffsetY_);
            WriteColumnValue( destination, radarImageType_);
            WriteColumnValue( destination, trackColor_);
            WriteColumnValue( destination, vectorColor_);
            WriteColumnValue( destination, enableNmea_);
            WriteColumnValue( destination, nmeaReceiverIPAddress_);
            WriteColumnValue( destination, nmeaReceiverPort_);
            WriteColumnValue( destination, nmeaReceiverSourceId_);
        }
    };

    using SimpleRadarConfigurationDataReader = SimpleColumnDataReader<RadarConfigurationColumnData>;

    class RadarImageColumnData : public BaseColumnData
    {
        Guid id_;
        Int64 rowVersion_ = 0;
        Guid radar_;
        DateTime timestamp_;
        UInt32 depth_ = 0;
        Int32 resolution_ = 0;
        Int32 range_ = 0;
        Binary image_;
        SQLLEN imageLength_ = SQL_NULL_DATA;
    public:
        using Base = BaseColumnData;

        static constexpr std::wstring_view FieldNames = L"[Id],[RowVersion],[Radar],[Timestamp],[Depth],[Resolution],[Range],[Image]";
        static constexpr std::wstring_view ViewName = L"RadarImageView";

        static constexpr SQLUSMALLINT ID_FIELD_ID = 1;
        static constexpr SQLUSMALLINT ROWVERSION_FIELD_ID = 2;
        static constexpr SQLUSMALLINT RADAR_FIELD_ID = 3;
        static constexpr SQLUSMALLINT TIMESTAMP_FIELD_ID = 4;
        static constexpr SQLUSMALLINT DEPTH_FIELD_ID = 5;
        static constexpr SQLUSMALLINT RESOLUTION_FIELD_ID = 6;
        static constexpr SQLUSMALLINT RANGE_FIELD_ID = 7;
        static constexpr SQLUSMALLINT IMAGE_FIELD_ID = 8;

        RadarImageColumnData( ) = default;

        virtual Kind GetKind() const override
        {
            return Kind::RadarImage;
        }

        const Guid& Id( ) const
        {
            return id_;
        }
        void SetId( const Guid& id )
        {
            id_ = id;
        }
        Int64 RowVersion( ) const
        {
            return rowVersion_;
        }
        void SetRowVersion( const Int64& rowVersion )
        {
            rowVersion_ = rowVersion;
        }
        const Guid& Radar( ) const
        {
            return radar_;
        }
        void SetRadar( const Guid& radar )
        {
            radar_ = radar;
        }
        const DateTime& Timestamp( ) const
        {
            return timestamp_;
        }
        void SetTimestamp( const DateTime& timestamp )
        {
            timestamp_ = timestamp;
        }
        UInt32 Depth( ) const
        {
            return depth_;
        }
        void SetDepth( UInt32 depth )
        {
            depth_ = depth;
        }
        Int32 Resolution( ) const
        {
            return resolution_;
        }
        void SetResolution( Int32 resolution )
        {
            resolution_ = resolution;
        }
        Int32 Range( ) const
        {
            return range_;
        }
        void SetRange( Int32 range )
        {
            range_ = range;
        }
        const Binary& Image( ) const
        {
            return image_;
        }
        void SetImage( const Binary& image )
        {
            image_ = image;
        }
        void BindColumns( const ODBC::Statement& statement )
        {
            Bind(statement, ID_FIELD_ID, id_);
            Bind(statement, ROWVERSION_FIELD_ID, rowVersion_);
            Bind(statement, RADAR_FIELD_ID, radar_);
            Bind(statement, TIMESTAMP_FIELD_ID, timestamp_);
            Bind(statement, DEPTH_FIELD_ID, depth_);
            Bind(statement, RESOLUTION_FIELD_ID, resolution_);
            Bind(statement, RANGE_FIELD_ID, range_);
        }

        void ReadUnboundData( const ODBC::Statement& statement )
        {
            Base::ReadUnboundData( statement );

            image_ = statement.GetBinary(IMAGE_FIELD_ID);
        }
        template<IO::StreamWriter StreamT>
        void WriteColumns( IO::BinaryWriter<StreamT>& destination ) const
        {
            WriteColumnValue( destination, id_);
            WriteColumnValue( destination, rowVersion_);
            WriteColumnValue( destination, radar_);
            WriteColumnValue( destination, timestamp_);
            WriteColumnValue( destination, depth_);
            WriteColumnValue( destination, resolution_);
            WriteColumnValue( destination, range_);
            WriteColumnValue( destination, image_);
        }
    };

    using SimpleRadarImageDataReader = SimpleColumnDataReader<RadarImageColumnData>;

    class RadarRawTrackTableColumnData : public BaseColumnData
    {
        Guid id_;
        Int64 rowVersion_ = 0;
        Guid radar_;
        DateTime timestamp_;
        Int32 count_ = 0;
        Binary table_;
        SQLLEN tableLength_ = SQL_NULL_DATA;
    public:
        using Base = BaseColumnData;

        static constexpr std::wstring_view FieldNames = L"[Id],[RowVersion],[Radar],[Timestamp],[Count],[Table]";
        static constexpr std::wstring_view ViewName = L"RadarRawTrackTableView";

        static constexpr SQLUSMALLINT ID_FIELD_ID = 1;
        static constexpr SQLUSMALLINT ROWVERSION_FIELD_ID = 2;
        static constexpr SQLUSMALLINT RADAR_FIELD_ID = 3;
        static constexpr SQLUSMALLINT TIMESTAMP_FIELD_ID = 4;
        static constexpr SQLUSMALLINT COUNT_FIELD_ID = 5;
        static constexpr SQLUSMALLINT TABLE_FIELD_ID = 6;

        RadarRawTrackTableColumnData( ) = default;

        virtual Kind GetKind() const override
        {
            return Kind::RadarRawTrackTable;
        }

        const Guid& Id( ) const
        {
            return id_;
        }
        void SetId( const Guid& id )
        {
            id_ = id;
        }
        Int64 RowVersion( ) const
        {
            return rowVersion_;
        }
        void SetRowVersion( const Int64& rowVersion )
        {
            rowVersion_ = rowVersion;
        }
        const Guid& Radar( ) const
        {
            return radar_;
        }
        void SetRadar( const Guid& radar )
        {
            radar_ = radar;
        }
        const DateTime& Timestamp( ) const
        {
            return timestamp_;
        }
        void SetTimestamp( const DateTime& timestamp )
        {
            timestamp_ = timestamp;
        }
        Int32 Count( ) const
        {
            return count_;
        }
        void SetCount( Int32 count )
        {
            count_ = count;
        }
        const Binary& Table( ) const
        {
            return table_;
        }
        void SetTable( const Binary& table )
        {
            table_ = table;
        }
        void BindColumns( const ODBC::Statement& statement )
        {
            Bind(statement, ID_FIELD_ID, id_);
            Bind(statement, ROWVERSION_FIELD_ID, rowVersion_);
            Bind(statement, RADAR_FIELD_ID, radar_);
            Bind(statement, TIMESTAMP_FIELD_ID, timestamp_);
            Bind(statement, COUNT_FIELD_ID, count_);
        }

        void ReadUnboundData( const ODBC::Statement& statement )
        {
            Base::ReadUnboundData( statement );

            table_ = statement.GetBinary(TABLE_FIELD_ID);
        }
        template<IO::StreamWriter StreamT>
        void WriteColumns( IO::BinaryWriter<StreamT>& destination ) const
        {
            WriteColumnValue( destination, id_);
            WriteColumnValue( destination, rowVersion_);
            WriteColumnValue( destination, radar_);
            WriteColumnValue( destination, timestamp_);
            WriteColumnValue( destination, count_);
            WriteColumnValue( destination, table_);
        }
    };

    using SimpleRadarRawTrackTableDataReader = SimpleColumnDataReader<RadarRawTrackTableColumnData>;

    class RadarStatusColumnData : public BaseColumnData
    {
        Guid id_;
        Int64 rowVersion_ = 0;
        Guid radar_;
        DateTime timestamp_;
        Int32 azimuthCount_ = 0;
        Int32 triggerCount_ = 0;
        TimeSpan rotationTime_;
        Data::RadarPulse pulse_ = Data::RadarPulse::Short;
        bool tx_ = false;
        bool tracking_ = false;
    public:
        using Base = BaseColumnData;

        static constexpr std::wstring_view FieldNames = L"[Id],[RowVersion],[Radar],[Timestamp],[AzimuthCount],[TriggerCount],[RotationTime],[Pulse],[Tx],[Tracking]";
        static constexpr std::wstring_view ViewName = L"RadarStatusView";

        static constexpr SQLUSMALLINT ID_FIELD_ID = 1;
        static constexpr SQLUSMALLINT ROWVERSION_FIELD_ID = 2;
        static constexpr SQLUSMALLINT RADAR_FIELD_ID = 3;
        static constexpr SQLUSMALLINT TIMESTAMP_FIELD_ID = 4;
        static constexpr SQLUSMALLINT AZIMUTHCOUNT_FIELD_ID = 5;
        static constexpr SQLUSMALLINT TRIGGERCOUNT_FIELD_ID = 6;
        static constexpr SQLUSMALLINT ROTATIONTIME_FIELD_ID = 7;
        static constexpr SQLUSMALLINT PULSE_FIELD_ID = 8;
        static constexpr SQLUSMALLINT TX_FIELD_ID = 9;
        static constexpr SQLUSMALLINT TRACKING_FIELD_ID = 10;

        RadarStatusColumnData( ) = default;

        virtual Kind GetKind() const override
        {
            return Kind::RadarStatus;
        }

        const Guid& Id( ) const
        {
            return id_;
        }
        void SetId( const Guid& id )
        {
            id_ = id;
        }
        Int64 RowVersion( ) const
        {
            return rowVersion_;
        }
        void SetRowVersion( const Int64& rowVersion )
        {
            rowVersion_ = rowVersion;
        }
        const Guid& Radar( ) const
        {
            return radar_;
        }
        void SetRadar( const Guid& radar )
        {
            radar_ = radar;
        }
        const DateTime& Timestamp( ) const
        {
            return timestamp_;
        }
        void SetTimestamp( const DateTime& timestamp )
        {
            timestamp_ = timestamp;
        }
        Int32 AzimuthCount( ) const
        {
            return azimuthCount_;
        }
        void SetAzimuthCount( Int32 azimuthCount )
        {
            azimuthCount_ = azimuthCount;
        }
        Int32 TriggerCount( ) const
        {
            return triggerCount_;
        }
        void SetTriggerCount( Int32 triggerCount )
        {
            triggerCount_ = triggerCount;
        }
        const TimeSpan& RotationTime( ) const
        {
            return rotationTime_;
        }
        void SetRotationTime( const TimeSpan& rotationTime )
        {
            rotationTime_ = rotationTime;
        }
        Data::RadarPulse Pulse( ) const
        {
            return pulse_;
        }
        void SetPulse( Data::RadarPulse pulse )
        {
            pulse_ = pulse;
        }
        bool Tx( ) const
        {
            return tx_;
        }
        void SetTx( bool tx )
        {
            tx_ = tx;
        }
        bool Tracking( ) const
        {
            return tracking_;
        }
        void SetTracking( bool tracking )
        {
            tracking_ = tracking;
        }
        void BindColumns( const ODBC::Statement& statement )
        {
            Bind(statement, ID_FIELD_ID, id_);
            Bind(statement, ROWVERSION_FIELD_ID, rowVersion_);
            Bind(statement, RADAR_FIELD_ID, radar_);
            Bind(statement, TIMESTAMP_FIELD_ID, timestamp_);
            Bind(statement, AZIMUTHCOUNT_FIELD_ID, azimuthCount_);
            Bind(statement, TRIGGERCOUNT_FIELD_ID, triggerCount_);
            Bind(statement, ROTATIONTIME_FIELD_ID, rotationTime_);
            Bind(statement, PULSE_FIELD_ID, pulse_);
            Bind(statement, TX_FIELD_ID, tx_);
            Bind(statement, TRACKING_FIELD_ID, tracking_);
        }

        template<IO::StreamWriter StreamT>
        void WriteColumns( IO::BinaryWriter<StreamT>& destination ) const
        {
            WriteColumnValue( destination, id_);
            WriteColumnValue( destination, rowVersion_);
            WriteColumnValue( destination, radar_);
            WriteColumnValue( destination, timestamp_);
            WriteColumnValue( destination, azimuthCount_);
            WriteColumnValue( destination, triggerCount_);
            WriteColumnValue( destination, rotationTime_);
            WriteColumnValue( destination, pulse_);
            WriteColumnValue( destination, tx_);
            WriteColumnValue( destination, tracking_);
        }
    };

    using SimpleRadarStatusDataReader = SimpleColumnDataReader<RadarStatusColumnData>;

    class RadioCommandColumnData : public BaseColumnData
    {
        Guid id_;
        Int64 rowVersion_ = 0;
        Guid radio_;
        DateTime timestamp_;
        Data::DeviceCommandSourceType deviceCommandSourceType_ = Data::DeviceCommandSourceType::Unknown;
        Guid deviceCommandSourceId_;
        Guid reply_;
    public:
        using Base = BaseColumnData;

        static constexpr std::wstring_view FieldNames = L"[Id],[RowVersion],[Radio],[Timestamp],[DeviceCommandSourceType],[DeviceCommandSourceId],[Reply]";
        static constexpr std::wstring_view ViewName = L"RadioCommandView";

        static constexpr SQLUSMALLINT ID_FIELD_ID = 1;
        static constexpr SQLUSMALLINT ROWVERSION_FIELD_ID = 2;
        static constexpr SQLUSMALLINT RADIO_FIELD_ID = 3;
        static constexpr SQLUSMALLINT TIMESTAMP_FIELD_ID = 4;
        static constexpr SQLUSMALLINT DEVICECOMMANDSOURCETYPE_FIELD_ID = 5;
        static constexpr SQLUSMALLINT DEVICECOMMANDSOURCEID_FIELD_ID = 6;
        static constexpr SQLUSMALLINT REPLY_FIELD_ID = 7;

        RadioCommandColumnData( ) = default;

        virtual Kind GetKind() const override
        {
            return Kind::RadioCommand;
        }

        const Guid& Id( ) const
        {
            return id_;
        }
        void SetId( const Guid& id )
        {
            id_ = id;
        }
        Int64 RowVersion( ) const
        {
            return rowVersion_;
        }
        void SetRowVersion( const Int64& rowVersion )
        {
            rowVersion_ = rowVersion;
        }
        const Guid& Radio( ) const
        {
            return radio_;
        }
        void SetRadio( const Guid& radio )
        {
            radio_ = radio;
        }
        const DateTime& Timestamp( ) const
        {
            return timestamp_;
        }
        void SetTimestamp( const DateTime& timestamp )
        {
            timestamp_ = timestamp;
        }
        Data::DeviceCommandSourceType DeviceCommandSourceType( ) const
        {
            return deviceCommandSourceType_;
        }
        void SetDeviceCommandSourceType( Data::DeviceCommandSourceType deviceCommandSourceType )
        {
            deviceCommandSourceType_ = deviceCommandSourceType;
        }
        const Guid& DeviceCommandSourceId( ) const
        {
            return deviceCommandSourceId_;
        }
        void SetDeviceCommandSourceId( const Guid& deviceCommandSourceId )
        {
            deviceCommandSourceId_ = deviceCommandSourceId;
        }
        const Guid& Reply( ) const
        {
            return reply_;
        }
        void SetReply( const Guid& reply )
        {
            reply_ = reply;
        }
        void BindColumns( const ODBC::Statement& statement )
        {
            Bind(statement, ID_FIELD_ID, id_);
            Bind(statement, ROWVERSION_FIELD_ID, rowVersion_);
            Bind(statement, RADIO_FIELD_ID, radio_);
            Bind(statement, TIMESTAMP_FIELD_ID, timestamp_);
            Bind(statement, DEVICECOMMANDSOURCETYPE_FIELD_ID, deviceCommandSourceType_);
            Bind(statement, DEVICECOMMANDSOURCEID_FIELD_ID, deviceCommandSourceId_);
            Bind(statement, REPLY_FIELD_ID, reply_);
        }

        template<IO::StreamWriter StreamT>
        void WriteColumns( IO::BinaryWriter<StreamT>& destination ) const
        {
            WriteColumnValue( destination, id_);
            WriteColumnValue( destination, rowVersion_);
            WriteColumnValue( destination, radio_);
            WriteColumnValue( destination, timestamp_);
            WriteColumnValue( destination, deviceCommandSourceType_);
            WriteColumnValue( destination, deviceCommandSourceId_);
            WriteColumnValue( destination, reply_);
        }
    };

    using SimpleRadioCommandDataReader = SimpleColumnDataReader<RadioCommandColumnData>;

    class RadioCommandReplyColumnData : public BaseColumnData
    {
        Guid id_;
        Int64 rowVersion_ = 0;
        Guid radio_;
        DateTime timestamp_;
        Guid command_;
        Data::DeviceCommandReplyStatus status_ = Data::DeviceCommandReplyStatus::Unknown;
        WideString message_;
        SQLLEN messageLength_ = SQL_NULL_DATA;
    public:
        using Base = BaseColumnData;

        static constexpr std::wstring_view FieldNames = L"[Id],[RowVersion],[Radio],[Timestamp],[Command],[Status],[Message]";
        static constexpr std::wstring_view ViewName = L"RadioCommandReplyView";

        static constexpr SQLUSMALLINT ID_FIELD_ID = 1;
        static constexpr SQLUSMALLINT ROWVERSION_FIELD_ID = 2;
        static constexpr SQLUSMALLINT RADIO_FIELD_ID = 3;
        static constexpr SQLUSMALLINT TIMESTAMP_FIELD_ID = 4;
        static constexpr SQLUSMALLINT COMMAND_FIELD_ID = 5;
        static constexpr SQLUSMALLINT STATUS_FIELD_ID = 6;
        static constexpr SQLUSMALLINT MESSAGE_FIELD_ID = 7;

        RadioCommandReplyColumnData( ) = default;

        virtual Kind GetKind() const override
        {
            return Kind::RadioCommandReply;
        }

        const Guid& Id( ) const
        {
            return id_;
        }
        void SetId( const Guid& id )
        {
            id_ = id;
        }
        Int64 RowVersion( ) const
        {
            return rowVersion_;
        }
        void SetRowVersion( const Int64& rowVersion )
        {
            rowVersion_ = rowVersion;
        }
        const Guid& Radio( ) const
        {
            return radio_;
        }
        void SetRadio( const Guid& radio )
        {
            radio_ = radio;
        }
        const DateTime& Timestamp( ) const
        {
            return timestamp_;
        }
        void SetTimestamp( const DateTime& timestamp )
        {
            timestamp_ = timestamp;
        }
        const Guid& Command( ) const
        {
            return command_;
        }
        void SetCommand( const Guid& command )
        {
            command_ = command;
        }
        Data::DeviceCommandReplyStatus Status( ) const
        {
            return status_;
        }
        void SetStatus( Data::DeviceCommandReplyStatus status )
        {
            status_ = status;
        }
        const WideString& Message( ) const
        {
            return message_;
        }
        void SetMessage( const WideString& message )
        {
            message_ = message;
        }
        void BindColumns( const ODBC::Statement& statement )
        {
            Bind(statement, ID_FIELD_ID, id_);
            Bind(statement, ROWVERSION_FIELD_ID, rowVersion_);
            Bind(statement, RADIO_FIELD_ID, radio_);
            Bind(statement, TIMESTAMP_FIELD_ID, timestamp_);
            Bind(statement, COMMAND_FIELD_ID, command_);
            Bind(statement, STATUS_FIELD_ID, status_);
        }

        void ReadUnboundData( const ODBC::Statement& statement )
        {
            Base::ReadUnboundData( statement );

            message_ = statement.GetWideString(MESSAGE_FIELD_ID);
        }
        template<IO::StreamWriter StreamT>
        void WriteColumns( IO::BinaryWriter<StreamT>& destination ) const
        {
            WriteColumnValue( destination, id_);
            WriteColumnValue( destination, rowVersion_);
            WriteColumnValue( destination, radio_);
            WriteColumnValue( destination, timestamp_);
            WriteColumnValue( destination, command_);
            WriteColumnValue( destination, status_);
            WriteColumnValue( destination, message_);
        }
    };

    using SimpleRadioCommandReplyDataReader = SimpleColumnDataReader<RadioCommandReplyColumnData>;

    class RadioConfigurationColumnData : public BaseColumnData
    {
        Guid id_;
        Int64 rowVersion_ = 0;
        Guid radio_;
        DateTime timestamp_;
        double longitude_ = 0.0;
        double latitude_ = 0.0;
        FixedDBWideString<100> playbackUrl_;
        FixedDBWideString<100> radioIPAddress_;
        Int32 radioPort_ = 0;
        FixedDBWideString<100> ed137IPAddress_;
        Int32 ed137Port_ = 0;
    public:
        using Base = BaseColumnData;

        static constexpr std::wstring_view FieldNames = L"[Id],[RowVersion],[Radio],[Timestamp],[Longitude],[Latitude],[PlaybackUrl],[RadioIPAddress],[RadioPort],[Ed137IPAddress],[Ed137Port]";
        static constexpr std::wstring_view ViewName = L"RadioConfigurationView";

        static constexpr SQLUSMALLINT ID_FIELD_ID = 1;
        static constexpr SQLUSMALLINT ROWVERSION_FIELD_ID = 2;
        static constexpr SQLUSMALLINT RADIO_FIELD_ID = 3;
        static constexpr SQLUSMALLINT TIMESTAMP_FIELD_ID = 4;
        static constexpr SQLUSMALLINT LONGITUDE_FIELD_ID = 5;
        static constexpr SQLUSMALLINT LATITUDE_FIELD_ID = 6;
        static constexpr SQLUSMALLINT PLAYBACKURL_FIELD_ID = 7;
        static constexpr SQLUSMALLINT RADIOIPADDRESS_FIELD_ID = 8;
        static constexpr SQLUSMALLINT RADIOPORT_FIELD_ID = 9;
        static constexpr SQLUSMALLINT ED137IPADDRESS_FIELD_ID = 10;
        static constexpr SQLUSMALLINT ED137PORT_FIELD_ID = 11;

        RadioConfigurationColumnData( ) = default;

        virtual Kind GetKind() const override
        {
            return Kind::RadioConfiguration;
        }

        const Guid& Id( ) const
        {
            return id_;
        }
        void SetId( const Guid& id )
        {
            id_ = id;
        }
        Int64 RowVersion( ) const
        {
            return rowVersion_;
        }
        void SetRowVersion( const Int64& rowVersion )
        {
            rowVersion_ = rowVersion;
        }
        const Guid& Radio( ) const
        {
            return radio_;
        }
        void SetRadio( const Guid& radio )
        {
            radio_ = radio;
        }
        const DateTime& Timestamp( ) const
        {
            return timestamp_;
        }
        void SetTimestamp( const DateTime& timestamp )
        {
            timestamp_ = timestamp;
        }
        double Longitude( ) const
        {
            return longitude_;
        }
        void SetLongitude( double longitude )
        {
            longitude_ = longitude;
        }
        double Latitude( ) const
        {
            return latitude_;
        }
        void SetLatitude( double latitude )
        {
            latitude_ = latitude;
        }
        const FixedDBWideString<100>& PlaybackUrl( ) const
        {
            return playbackUrl_;
        }
        void SetPlaybackUrl( const WideString& playbackUrl )
        {
            playbackUrl_ = playbackUrl;
        }
        const FixedDBWideString<100>& RadioIPAddress( ) const
        {
            return radioIPAddress_;
        }
        void SetRadioIPAddress( const WideString& radioIPAddress )
        {
            radioIPAddress_ = radioIPAddress;
        }
        Int32 RadioPort( ) const
        {
            return radioPort_;
        }
        void SetRadioPort( Int32 radioPort )
        {
            radioPort_ = radioPort;
        }
        const FixedDBWideString<100>& Ed137IPAddress( ) const
        {
            return ed137IPAddress_;
        }
        void SetEd137IPAddress( const WideString& ed137IPAddress )
        {
            ed137IPAddress_ = ed137IPAddress;
        }
        Int32 Ed137Port( ) const
        {
            return ed137Port_;
        }
        void SetEd137Port( Int32 ed137Port )
        {
            ed137Port_ = ed137Port;
        }
        void BindColumns( const ODBC::Statement& statement )
        {
            Bind(statement, ID_FIELD_ID, id_);
            Bind(statement, ROWVERSION_FIELD_ID, rowVersion_);
            Bind(statement, RADIO_FIELD_ID, radio_);
            Bind(statement, TIMESTAMP_FIELD_ID, timestamp_);
            Bind(statement, LONGITUDE_FIELD_ID, longitude_);
            Bind(statement, LATITUDE_FIELD_ID, latitude_);
            Bind(statement, PLAYBACKURL_FIELD_ID, playbackUrl_);
            Bind(statement, RADIOIPADDRESS_FIELD_ID, radioIPAddress_);
            Bind(statement, RADIOPORT_FIELD_ID, radioPort_);
            Bind(statement, ED137IPADDRESS_FIELD_ID, ed137IPAddress_);
            Bind(statement, ED137PORT_FIELD_ID, ed137Port_);
        }

        template<IO::StreamWriter StreamT>
        void WriteColumns( IO::BinaryWriter<StreamT>& destination ) const
        {
            WriteColumnValue( destination, id_);
            WriteColumnValue( destination, rowVersion_);
            WriteColumnValue( destination, radio_);
            WriteColumnValue( destination, timestamp_);
            WriteColumnValue( destination, longitude_);
            WriteColumnValue( destination, latitude_);
            WriteColumnValue( destination, playbackUrl_);
            WriteColumnValue( destination, radioIPAddress_);
            WriteColumnValue( destination, radioPort_);
            WriteColumnValue( destination, ed137IPAddress_);
            WriteColumnValue( destination, ed137Port_);
        }
    };

    using SimpleRadioConfigurationDataReader = SimpleColumnDataReader<RadioConfigurationColumnData>;

    class RadomeCommandColumnData : public BaseColumnData
    {
        Guid id_;
        Int64 rowVersion_ = 0;
        Guid radome_;
        DateTime timestamp_;
        Data::DeviceCommandSourceType deviceCommandSourceType_ = Data::DeviceCommandSourceType::Unknown;
        Guid deviceCommandSourceId_;
        Guid reply_;
    public:
        using Base = BaseColumnData;

        static constexpr std::wstring_view FieldNames = L"[Id],[RowVersion],[Radome],[Timestamp],[DeviceCommandSourceType],[DeviceCommandSourceId],[Reply]";
        static constexpr std::wstring_view ViewName = L"RadomeCommandView";

        static constexpr SQLUSMALLINT ID_FIELD_ID = 1;
        static constexpr SQLUSMALLINT ROWVERSION_FIELD_ID = 2;
        static constexpr SQLUSMALLINT RADOME_FIELD_ID = 3;
        static constexpr SQLUSMALLINT TIMESTAMP_FIELD_ID = 4;
        static constexpr SQLUSMALLINT DEVICECOMMANDSOURCETYPE_FIELD_ID = 5;
        static constexpr SQLUSMALLINT DEVICECOMMANDSOURCEID_FIELD_ID = 6;
        static constexpr SQLUSMALLINT REPLY_FIELD_ID = 7;

        RadomeCommandColumnData( ) = default;

        virtual Kind GetKind() const override
        {
            return Kind::RadomeCommand;
        }

        const Guid& Id( ) const
        {
            return id_;
        }
        void SetId( const Guid& id )
        {
            id_ = id;
        }
        Int64 RowVersion( ) const
        {
            return rowVersion_;
        }
        void SetRowVersion( const Int64& rowVersion )
        {
            rowVersion_ = rowVersion;
        }
        const Guid& Radome( ) const
        {
            return radome_;
        }
        void SetRadome( const Guid& radome )
        {
            radome_ = radome;
        }
        const DateTime& Timestamp( ) const
        {
            return timestamp_;
        }
        void SetTimestamp( const DateTime& timestamp )
        {
            timestamp_ = timestamp;
        }
        Data::DeviceCommandSourceType DeviceCommandSourceType( ) const
        {
            return deviceCommandSourceType_;
        }
        void SetDeviceCommandSourceType( Data::DeviceCommandSourceType deviceCommandSourceType )
        {
            deviceCommandSourceType_ = deviceCommandSourceType;
        }
        const Guid& DeviceCommandSourceId( ) const
        {
            return deviceCommandSourceId_;
        }
        void SetDeviceCommandSourceId( const Guid& deviceCommandSourceId )
        {
            deviceCommandSourceId_ = deviceCommandSourceId;
        }
        const Guid& Reply( ) const
        {
            return reply_;
        }
        void SetReply( const Guid& reply )
        {
            reply_ = reply;
        }
        void BindColumns( const ODBC::Statement& statement )
        {
            Bind(statement, ID_FIELD_ID, id_);
            Bind(statement, ROWVERSION_FIELD_ID, rowVersion_);
            Bind(statement, RADOME_FIELD_ID, radome_);
            Bind(statement, TIMESTAMP_FIELD_ID, timestamp_);
            Bind(statement, DEVICECOMMANDSOURCETYPE_FIELD_ID, deviceCommandSourceType_);
            Bind(statement, DEVICECOMMANDSOURCEID_FIELD_ID, deviceCommandSourceId_);
            Bind(statement, REPLY_FIELD_ID, reply_);
        }

        template<IO::StreamWriter StreamT>
        void WriteColumns( IO::BinaryWriter<StreamT>& destination ) const
        {
            WriteColumnValue( destination, id_);
            WriteColumnValue( destination, rowVersion_);
            WriteColumnValue( destination, radome_);
            WriteColumnValue( destination, timestamp_);
            WriteColumnValue( destination, deviceCommandSourceType_);
            WriteColumnValue( destination, deviceCommandSourceId_);
            WriteColumnValue( destination, reply_);
        }
    };

    using SimpleRadomeCommandDataReader = SimpleColumnDataReader<RadomeCommandColumnData>;

    class RadomeCommandReplyColumnData : public BaseColumnData
    {
        Guid id_;
        Int64 rowVersion_ = 0;
        Guid radome_;
        DateTime timestamp_;
        Guid command_;
        Data::DeviceCommandReplyStatus status_ = Data::DeviceCommandReplyStatus::Unknown;
        WideString message_;
        SQLLEN messageLength_ = SQL_NULL_DATA;
    public:
        using Base = BaseColumnData;

        static constexpr std::wstring_view FieldNames = L"[Id],[RowVersion],[Radome],[Timestamp],[Command],[Status],[Message]";
        static constexpr std::wstring_view ViewName = L"RadomeCommandReplyView";

        static constexpr SQLUSMALLINT ID_FIELD_ID = 1;
        static constexpr SQLUSMALLINT ROWVERSION_FIELD_ID = 2;
        static constexpr SQLUSMALLINT RADOME_FIELD_ID = 3;
        static constexpr SQLUSMALLINT TIMESTAMP_FIELD_ID = 4;
        static constexpr SQLUSMALLINT COMMAND_FIELD_ID = 5;
        static constexpr SQLUSMALLINT STATUS_FIELD_ID = 6;
        static constexpr SQLUSMALLINT MESSAGE_FIELD_ID = 7;

        RadomeCommandReplyColumnData( ) = default;

        virtual Kind GetKind() const override
        {
            return Kind::RadomeCommandReply;
        }

        const Guid& Id( ) const
        {
            return id_;
        }
        void SetId( const Guid& id )
        {
            id_ = id;
        }
        Int64 RowVersion( ) const
        {
            return rowVersion_;
        }
        void SetRowVersion( const Int64& rowVersion )
        {
            rowVersion_ = rowVersion;
        }
        const Guid& Radome( ) const
        {
            return radome_;
        }
        void SetRadome( const Guid& radome )
        {
            radome_ = radome;
        }
        const DateTime& Timestamp( ) const
        {
            return timestamp_;
        }
        void SetTimestamp( const DateTime& timestamp )
        {
            timestamp_ = timestamp;
        }
        const Guid& Command( ) const
        {
            return command_;
        }
        void SetCommand( const Guid& command )
        {
            command_ = command;
        }
        Data::DeviceCommandReplyStatus Status( ) const
        {
            return status_;
        }
        void SetStatus( Data::DeviceCommandReplyStatus status )
        {
            status_ = status;
        }
        const WideString& Message( ) const
        {
            return message_;
        }
        void SetMessage( const WideString& message )
        {
            message_ = message;
        }
        void BindColumns( const ODBC::Statement& statement )
        {
            Bind(statement, ID_FIELD_ID, id_);
            Bind(statement, ROWVERSION_FIELD_ID, rowVersion_);
            Bind(statement, RADOME_FIELD_ID, radome_);
            Bind(statement, TIMESTAMP_FIELD_ID, timestamp_);
            Bind(statement, COMMAND_FIELD_ID, command_);
            Bind(statement, STATUS_FIELD_ID, status_);
        }

        void ReadUnboundData( const ODBC::Statement& statement )
        {
            Base::ReadUnboundData( statement );

            message_ = statement.GetWideString(MESSAGE_FIELD_ID);
        }
        template<IO::StreamWriter StreamT>
        void WriteColumns( IO::BinaryWriter<StreamT>& destination ) const
        {
            WriteColumnValue( destination, id_);
            WriteColumnValue( destination, rowVersion_);
            WriteColumnValue( destination, radome_);
            WriteColumnValue( destination, timestamp_);
            WriteColumnValue( destination, command_);
            WriteColumnValue( destination, status_);
            WriteColumnValue( destination, message_);
        }
    };

    using SimpleRadomeCommandReplyDataReader = SimpleColumnDataReader<RadomeCommandReplyColumnData>;

    class RadomeConfigurationColumnData : public BaseColumnData
    {
        Guid id_;
        Int64 rowVersion_ = 0;
        Guid radome_;
        DateTime timestamp_;
        TimeSpan interval_;
        double lowPressureLimit_ = 0.0;
        double highPressureLimit_ = 0.0;
        double lowTemperatureLimit_ = 0.0;
        double highTemperatureLimit_ = 0.0;
    public:
        using Base = BaseColumnData;

        static constexpr std::wstring_view FieldNames = L"[Id],[RowVersion],[Radome],[Timestamp],[Interval],[LowPressureLimit],[HighPressureLimit],[LowTemperatureLimit],[HighTemperatureLimit]";
        static constexpr std::wstring_view ViewName = L"RadomeConfigurationView";

        static constexpr SQLUSMALLINT ID_FIELD_ID = 1;
        static constexpr SQLUSMALLINT ROWVERSION_FIELD_ID = 2;
        static constexpr SQLUSMALLINT RADOME_FIELD_ID = 3;
        static constexpr SQLUSMALLINT TIMESTAMP_FIELD_ID = 4;
        static constexpr SQLUSMALLINT INTERVAL_FIELD_ID = 5;
        static constexpr SQLUSMALLINT LOWPRESSURELIMIT_FIELD_ID = 6;
        static constexpr SQLUSMALLINT HIGHPRESSURELIMIT_FIELD_ID = 7;
        static constexpr SQLUSMALLINT LOWTEMPERATURELIMIT_FIELD_ID = 8;
        static constexpr SQLUSMALLINT HIGHTEMPERATURELIMIT_FIELD_ID = 9;

        RadomeConfigurationColumnData( ) = default;

        virtual Kind GetKind() const override
        {
            return Kind::RadomeConfiguration;
        }

        const Guid& Id( ) const
        {
            return id_;
        }
        void SetId( const Guid& id )
        {
            id_ = id;
        }
        Int64 RowVersion( ) const
        {
            return rowVersion_;
        }
        void SetRowVersion( const Int64& rowVersion )
        {
            rowVersion_ = rowVersion;
        }
        const Guid& Radome( ) const
        {
            return radome_;
        }
        void SetRadome( const Guid& radome )
        {
            radome_ = radome;
        }
        const DateTime& Timestamp( ) const
        {
            return timestamp_;
        }
        void SetTimestamp( const DateTime& timestamp )
        {
            timestamp_ = timestamp;
        }
        const TimeSpan& Interval( ) const
        {
            return interval_;
        }
        void SetInterval( const TimeSpan& interval )
        {
            interval_ = interval;
        }
        double LowPressureLimit( ) const
        {
            return lowPressureLimit_;
        }
        void SetLowPressureLimit( double lowPressureLimit )
        {
            lowPressureLimit_ = lowPressureLimit;
        }
        double HighPressureLimit( ) const
        {
            return highPressureLimit_;
        }
        void SetHighPressureLimit( double highPressureLimit )
        {
            highPressureLimit_ = highPressureLimit;
        }
        double LowTemperatureLimit( ) const
        {
            return lowTemperatureLimit_;
        }
        void SetLowTemperatureLimit( double lowTemperatureLimit )
        {
            lowTemperatureLimit_ = lowTemperatureLimit;
        }
        double HighTemperatureLimit( ) const
        {
            return highTemperatureLimit_;
        }
        void SetHighTemperatureLimit( double highTemperatureLimit )
        {
            highTemperatureLimit_ = highTemperatureLimit;
        }
        void BindColumns( const ODBC::Statement& statement )
        {
            Bind(statement, ID_FIELD_ID, id_);
            Bind(statement, ROWVERSION_FIELD_ID, rowVersion_);
            Bind(statement, RADOME_FIELD_ID, radome_);
            Bind(statement, TIMESTAMP_FIELD_ID, timestamp_);
            Bind(statement, INTERVAL_FIELD_ID, interval_);
            Bind(statement, LOWPRESSURELIMIT_FIELD_ID, lowPressureLimit_);
            Bind(statement, HIGHPRESSURELIMIT_FIELD_ID, highPressureLimit_);
            Bind(statement, LOWTEMPERATURELIMIT_FIELD_ID, lowTemperatureLimit_);
            Bind(statement, HIGHTEMPERATURELIMIT_FIELD_ID, highTemperatureLimit_);
        }

        template<IO::StreamWriter StreamT>
        void WriteColumns( IO::BinaryWriter<StreamT>& destination ) const
        {
            WriteColumnValue( destination, id_);
            WriteColumnValue( destination, rowVersion_);
            WriteColumnValue( destination, radome_);
            WriteColumnValue( destination, timestamp_);
            WriteColumnValue( destination, interval_);
            WriteColumnValue( destination, lowPressureLimit_);
            WriteColumnValue( destination, highPressureLimit_);
            WriteColumnValue( destination, lowTemperatureLimit_);
            WriteColumnValue( destination, highTemperatureLimit_);
        }
    };

    using SimpleRadomeConfigurationDataReader = SimpleColumnDataReader<RadomeConfigurationColumnData>;

    class ReferenceTimeseriesValueColumnData : public BaseColumnData
    {
        Guid id_;
        Int64 rowVersion_ = 0;
        Guid timeseries_;
        DateTime timestamp_;
        Guid value_;
    public:
        using Base = BaseColumnData;

        static constexpr std::wstring_view FieldNames = L"[Id],[RowVersion],[Timeseries],[Timestamp],[Value]";
        static constexpr std::wstring_view ViewName = L"ReferenceTimeseriesValueView";

        static constexpr SQLUSMALLINT ID_FIELD_ID = 1;
        static constexpr SQLUSMALLINT ROWVERSION_FIELD_ID = 2;
        static constexpr SQLUSMALLINT TIMESERIES_FIELD_ID = 3;
        static constexpr SQLUSMALLINT TIMESTAMP_FIELD_ID = 4;
        static constexpr SQLUSMALLINT VALUE_FIELD_ID = 5;

        ReferenceTimeseriesValueColumnData( ) = default;

        virtual Kind GetKind() const override
        {
            return Kind::ReferenceTimeseriesValue;
        }

        const Guid& Id( ) const
        {
            return id_;
        }
        void SetId( const Guid& id )
        {
            id_ = id;
        }
        Int64 RowVersion( ) const
        {
            return rowVersion_;
        }
        void SetRowVersion( const Int64& rowVersion )
        {
            rowVersion_ = rowVersion;
        }
        const Guid& Timeseries( ) const
        {
            return timeseries_;
        }
        void SetTimeseries( const Guid& timeseries )
        {
            timeseries_ = timeseries;
        }
        const DateTime& Timestamp( ) const
        {
            return timestamp_;
        }
        void SetTimestamp( const DateTime& timestamp )
        {
            timestamp_ = timestamp;
        }
        const Guid& Value( ) const
        {
            return value_;
        }
        void SetValue( const Guid& value )
        {
            value_ = value;
        }
        void BindColumns( const ODBC::Statement& statement )
        {
            Bind(statement, ID_FIELD_ID, id_);
            Bind(statement, ROWVERSION_FIELD_ID, rowVersion_);
            Bind(statement, TIMESERIES_FIELD_ID, timeseries_);
            Bind(statement, TIMESTAMP_FIELD_ID, timestamp_);
            Bind(statement, VALUE_FIELD_ID, value_);
        }

        template<IO::StreamWriter StreamT>
        void WriteColumns( IO::BinaryWriter<StreamT>& destination ) const
        {
            WriteColumnValue( destination, id_);
            WriteColumnValue( destination, rowVersion_);
            WriteColumnValue( destination, timeseries_);
            WriteColumnValue( destination, timestamp_);
            WriteColumnValue( destination, value_);
        }
    };

    using SimpleReferenceTimeseriesValueDataReader = SimpleColumnDataReader<ReferenceTimeseriesValueColumnData>;

    class SByteTimeseriesValueColumnData : public BaseColumnData
    {
        Guid id_;
        Int64 rowVersion_ = 0;
        Guid timeseries_;
        DateTime timestamp_;
        DBSByte value_;
    public:
        using Base = BaseColumnData;

        static constexpr std::wstring_view FieldNames = L"[Id],[RowVersion],[Timeseries],[Timestamp],[Value]";
        static constexpr std::wstring_view ViewName = L"SByteTimeseriesValueView";

        static constexpr SQLUSMALLINT ID_FIELD_ID = 1;
        static constexpr SQLUSMALLINT ROWVERSION_FIELD_ID = 2;
        static constexpr SQLUSMALLINT TIMESERIES_FIELD_ID = 3;
        static constexpr SQLUSMALLINT TIMESTAMP_FIELD_ID = 4;
        static constexpr SQLUSMALLINT VALUE_FIELD_ID = 5;

        SByteTimeseriesValueColumnData( ) = default;

        virtual Kind GetKind() const override
        {
            return Kind::SByteTimeseriesValue;
        }

        const Guid& Id( ) const
        {
            return id_;
        }
        void SetId( const Guid& id )
        {
            id_ = id;
        }
        Int64 RowVersion( ) const
        {
            return rowVersion_;
        }
        void SetRowVersion( const Int64& rowVersion )
        {
            rowVersion_ = rowVersion;
        }
        const Guid& Timeseries( ) const
        {
            return timeseries_;
        }
        void SetTimeseries( const Guid& timeseries )
        {
            timeseries_ = timeseries;
        }
        const DateTime& Timestamp( ) const
        {
            return timestamp_;
        }
        void SetTimestamp( const DateTime& timestamp )
        {
            timestamp_ = timestamp;
        }
        const DBSByte& Value( ) const
        {
            return value_;
        }
        void SetValue( const DBSByte& value )
        {
            value_ = value;
        }
        void BindColumns( const ODBC::Statement& statement )
        {
            Bind(statement, ID_FIELD_ID, id_);
            Bind(statement, ROWVERSION_FIELD_ID, rowVersion_);
            Bind(statement, TIMESERIES_FIELD_ID, timeseries_);
            Bind(statement, TIMESTAMP_FIELD_ID, timestamp_);
            Bind(statement, VALUE_FIELD_ID, value_);
        }

        template<IO::StreamWriter StreamT>
        void WriteColumns( IO::BinaryWriter<StreamT>& destination ) const
        {
            WriteColumnValue( destination, id_);
            WriteColumnValue( destination, rowVersion_);
            WriteColumnValue( destination, timeseries_);
            WriteColumnValue( destination, timestamp_);
            WriteColumnValue( destination, value_);
        }
    };

    using SimpleSByteTimeseriesValueDataReader = SimpleColumnDataReader<SByteTimeseriesValueColumnData>;

    class SecurityDomainColumnData : public BaseColumnData
    {
        Guid id_;
        Int64 rowVersion_ = 0;
        FixedDBWideString<127> name_;
        WideString description_;
        SQLLEN descriptionLength_ = SQL_NULL_DATA;
    public:
        using Base = BaseColumnData;

        static constexpr std::wstring_view FieldNames = L"[Id],[RowVersion],[Name],[Description]";
        static constexpr std::wstring_view ViewName = L"SecurityDomainView";

        static constexpr SQLUSMALLINT ID_FIELD_ID = 1;
        static constexpr SQLUSMALLINT ROWVERSION_FIELD_ID = 2;
        static constexpr SQLUSMALLINT NAME_FIELD_ID = 3;
        static constexpr SQLUSMALLINT DESCRIPTION_FIELD_ID = 4;

        SecurityDomainColumnData( ) = default;

        virtual Kind GetKind() const override
        {
            return Kind::SecurityDomain;
        }

        const Guid& Id( ) const
        {
            return id_;
        }
        void SetId( const Guid& id )
        {
            id_ = id;
        }
        Int64 RowVersion( ) const
        {
            return rowVersion_;
        }
        void SetRowVersion( const Int64& rowVersion )
        {
            rowVersion_ = rowVersion;
        }
        const FixedDBWideString<127>& Name( ) const
        {
            return name_;
        }
        void SetName( const WideString& name )
        {
            name_ = name;
        }
        const WideString& Description( ) const
        {
            return description_;
        }
        void SetDescription( const WideString& description )
        {
            description_ = description;
        }
        void BindColumns( const ODBC::Statement& statement )
        {
            Bind(statement, ID_FIELD_ID, id_);
            Bind(statement, ROWVERSION_FIELD_ID, rowVersion_);
            Bind(statement, NAME_FIELD_ID, name_);
        }

        void ReadUnboundData( const ODBC::Statement& statement )
        {
            Base::ReadUnboundData( statement );

            description_ = statement.GetWideString(DESCRIPTION_FIELD_ID);
        }
        template<IO::StreamWriter StreamT>
        void WriteColumns( IO::BinaryWriter<StreamT>& destination ) const
        {
            WriteColumnValue( destination, id_);
            WriteColumnValue( destination, rowVersion_);
            WriteColumnValue( destination, name_);
            WriteColumnValue( destination, description_);
        }
    };

    using SimpleSecurityDomainDataReader = SimpleColumnDataReader<SecurityDomainColumnData>;

    class SecurityIdentifierColumnData : public BaseColumnData
    {
        Guid id_;
        Int64 rowVersion_ = 0;
        Guid domain_;
        FixedDBWideString<255> identity_;
        WideString description_;
        SQLLEN descriptionLength_ = SQL_NULL_DATA;
    public:
        using Base = BaseColumnData;

        static constexpr std::wstring_view FieldNames = L"[Id],[RowVersion],[Domain],[Identity],[Description]";
        static constexpr std::wstring_view ViewName = L"SecurityIdentifierView";

        static constexpr SQLUSMALLINT ID_FIELD_ID = 1;
        static constexpr SQLUSMALLINT ROWVERSION_FIELD_ID = 2;
        static constexpr SQLUSMALLINT DOMAIN_FIELD_ID = 3;
        static constexpr SQLUSMALLINT IDENTITY_FIELD_ID = 4;
        static constexpr SQLUSMALLINT DESCRIPTION_FIELD_ID = 5;

        SecurityIdentifierColumnData( ) = default;

        virtual Kind GetKind() const override
        {
            return Kind::SecurityIdentifier;
        }

        const Guid& Id( ) const
        {
            return id_;
        }
        void SetId( const Guid& id )
        {
            id_ = id;
        }
        Int64 RowVersion( ) const
        {
            return rowVersion_;
        }
        void SetRowVersion( const Int64& rowVersion )
        {
            rowVersion_ = rowVersion;
        }
        const Guid& Domain( ) const
        {
            return domain_;
        }
        void SetDomain( const Guid& domain )
        {
            domain_ = domain;
        }
        const FixedDBWideString<255>& Identity( ) const
        {
            return identity_;
        }
        void SetIdentity( const WideString& identity )
        {
            identity_ = identity;
        }
        const WideString& Description( ) const
        {
            return description_;
        }
        void SetDescription( const WideString& description )
        {
            description_ = description;
        }
        void BindColumns( const ODBC::Statement& statement )
        {
            Bind(statement, ID_FIELD_ID, id_);
            Bind(statement, ROWVERSION_FIELD_ID, rowVersion_);
            Bind(statement, DOMAIN_FIELD_ID, domain_);
            Bind(statement, IDENTITY_FIELD_ID, identity_);
        }

        void ReadUnboundData( const ODBC::Statement& statement )
        {
            Base::ReadUnboundData( statement );

            description_ = statement.GetWideString(DESCRIPTION_FIELD_ID);
        }
        template<IO::StreamWriter StreamT>
        void WriteColumns( IO::BinaryWriter<StreamT>& destination ) const
        {
            WriteColumnValue( destination, id_);
            WriteColumnValue( destination, rowVersion_);
            WriteColumnValue( destination, domain_);
            WriteColumnValue( destination, identity_);
            WriteColumnValue( destination, description_);
        }
    };

    using SimpleSecurityIdentifierDataReader = SimpleColumnDataReader<SecurityIdentifierColumnData>;

    class SecurityLoginColumnData : public SecurityIdentifierColumnData
    {
    public:
        using Base = SecurityIdentifierColumnData;

        static constexpr std::wstring_view FieldNames = L"[Id],[RowVersion],[Domain],[Identity],[Description]";
        static constexpr std::wstring_view ViewName = L"SecurityLoginView";

        SecurityLoginColumnData( ) = default;

        virtual Kind GetKind() const override
        {
            return Kind::SecurityLogin;
        }

        template<IO::StreamWriter StreamT>
        void WriteColumns( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteColumns( destination );
        }
    };

    using SimpleSecurityLoginDataReader = SimpleColumnDataReader<SecurityLoginColumnData>;

    class SecurityRoleColumnData : public SecurityIdentifierColumnData
    {
        FixedDBWideString<127> name_;
    public:
        using Base = SecurityIdentifierColumnData;

        static constexpr std::wstring_view FieldNames = L"[Id],[RowVersion],[Domain],[Identity],[Name],[Description]";
        static constexpr std::wstring_view ViewName = L"SecurityRoleView";

        static constexpr SQLUSMALLINT NAME_FIELD_ID = 6;

        SecurityRoleColumnData( ) = default;

        virtual Kind GetKind() const override
        {
            return Kind::SecurityRole;
        }

        const FixedDBWideString<127>& Name( ) const
        {
            return name_;
        }
        void SetName( const WideString& name )
        {
            name_ = name;
        }
        void BindColumns( const ODBC::Statement& statement )
        {
            Base::BindColumns( statement );

            Bind(statement, NAME_FIELD_ID, name_);
        }

        template<IO::StreamWriter StreamT>
        void WriteColumns( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteColumns( destination );
            WriteColumnValue( destination, name_);
        }
    };

    using SimpleSecurityRoleDataReader = SimpleColumnDataReader<SecurityRoleColumnData>;

    class SecurityIdentifierRoleLinkColumnData : public BaseColumnData
    {
        Guid id_;
        Int64 rowVersion_ = 0;
        Guid member_;
        Guid role_;
        DateTime start_;
        DBDateTime end_;
    public:
        using Base = BaseColumnData;

        static constexpr std::wstring_view FieldNames = L"[Id],[RowVersion],[Member],[Role],[Start],[End]";
        static constexpr std::wstring_view ViewName = L"SecurityIdentifierRoleLinkView";

        static constexpr SQLUSMALLINT ID_FIELD_ID = 1;
        static constexpr SQLUSMALLINT ROWVERSION_FIELD_ID = 2;
        static constexpr SQLUSMALLINT MEMBER_FIELD_ID = 3;
        static constexpr SQLUSMALLINT ROLE_FIELD_ID = 4;
        static constexpr SQLUSMALLINT START_FIELD_ID = 5;
        static constexpr SQLUSMALLINT END_FIELD_ID = 6;

        SecurityIdentifierRoleLinkColumnData( ) = default;

        virtual Kind GetKind() const override
        {
            return Kind::SecurityIdentifierRoleLink;
        }

        const Guid& Id( ) const
        {
            return id_;
        }
        void SetId( const Guid& id )
        {
            id_ = id;
        }
        Int64 RowVersion( ) const
        {
            return rowVersion_;
        }
        void SetRowVersion( const Int64& rowVersion )
        {
            rowVersion_ = rowVersion;
        }
        const Guid& Member( ) const
        {
            return member_;
        }
        void SetMember( const Guid& member )
        {
            member_ = member;
        }
        const Guid& Role( ) const
        {
            return role_;
        }
        void SetRole( const Guid& role )
        {
            role_ = role;
        }
        const DateTime& Start( ) const
        {
            return start_;
        }
        void SetStart( const DateTime& start )
        {
            start_ = start;
        }
        const DBDateTime& End( ) const
        {
            return end_;
        }
        void SetEnd( const DBDateTime& end )
        {
            end_ = end;
        }
        void BindColumns( const ODBC::Statement& statement )
        {
            Bind(statement, ID_FIELD_ID, id_);
            Bind(statement, ROWVERSION_FIELD_ID, rowVersion_);
            Bind(statement, MEMBER_FIELD_ID, member_);
            Bind(statement, ROLE_FIELD_ID, role_);
            Bind(statement, START_FIELD_ID, start_);
            Bind(statement, END_FIELD_ID, end_);
        }

        template<IO::StreamWriter StreamT>
        void WriteColumns( IO::BinaryWriter<StreamT>& destination ) const
        {
            WriteColumnValue( destination, id_);
            WriteColumnValue( destination, rowVersion_);
            WriteColumnValue( destination, member_);
            WriteColumnValue( destination, role_);
            WriteColumnValue( destination, start_);
            WriteColumnValue( destination, end_);
        }
    };

    using SimpleSecurityIdentifierRoleLinkDataReader = SimpleColumnDataReader<SecurityIdentifierRoleLinkColumnData>;

    class SecurityLoginSessionColumnData : public BaseColumnData
    {
        Guid id_;
        Int64 rowVersion_ = 0;
        Guid login_;
        DateTime fromTime_;
        DBDateTime throughTime_;
        Guid clientSession_;
        FixedDBWideString<260> notificationQueueName_;
        FixedDBWideString<260> messageQueueName_;
    public:
        using Base = BaseColumnData;

        static constexpr std::wstring_view FieldNames = L"[Id],[RowVersion],[Login],[FromTime],[ThroughTime],[ClientSession],[NotificationQueueName],[MessageQueueName]";
        static constexpr std::wstring_view ViewName = L"SecurityLoginSessionView";

        static constexpr SQLUSMALLINT ID_FIELD_ID = 1;
        static constexpr SQLUSMALLINT ROWVERSION_FIELD_ID = 2;
        static constexpr SQLUSMALLINT LOGIN_FIELD_ID = 3;
        static constexpr SQLUSMALLINT FROMTIME_FIELD_ID = 4;
        static constexpr SQLUSMALLINT THROUGHTIME_FIELD_ID = 5;
        static constexpr SQLUSMALLINT CLIENTSESSION_FIELD_ID = 6;
        static constexpr SQLUSMALLINT NOTIFICATIONQUEUENAME_FIELD_ID = 7;
        static constexpr SQLUSMALLINT MESSAGEQUEUENAME_FIELD_ID = 8;

        SecurityLoginSessionColumnData( ) = default;

        virtual Kind GetKind() const override
        {
            return Kind::SecurityLoginSession;
        }

        const Guid& Id( ) const
        {
            return id_;
        }
        void SetId( const Guid& id )
        {
            id_ = id;
        }
        Int64 RowVersion( ) const
        {
            return rowVersion_;
        }
        void SetRowVersion( const Int64& rowVersion )
        {
            rowVersion_ = rowVersion;
        }
        const Guid& Login( ) const
        {
            return login_;
        }
        void SetLogin( const Guid& login )
        {
            login_ = login;
        }
        const DateTime& FromTime( ) const
        {
            return fromTime_;
        }
        void SetFromTime( const DateTime& fromTime )
        {
            fromTime_ = fromTime;
        }
        const DBDateTime& ThroughTime( ) const
        {
            return throughTime_;
        }
        void SetThroughTime( const DBDateTime& throughTime )
        {
            throughTime_ = throughTime;
        }
        const Guid& ClientSession( ) const
        {
            return clientSession_;
        }
        void SetClientSession( const Guid& clientSession )
        {
            clientSession_ = clientSession;
        }
        const FixedDBWideString<260>& NotificationQueueName( ) const
        {
            return notificationQueueName_;
        }
        void SetNotificationQueueName( const WideString& notificationQueueName )
        {
            notificationQueueName_ = notificationQueueName;
        }
        const FixedDBWideString<260>& MessageQueueName( ) const
        {
            return messageQueueName_;
        }
        void SetMessageQueueName( const WideString& messageQueueName )
        {
            messageQueueName_ = messageQueueName;
        }
        void BindColumns( const ODBC::Statement& statement )
        {
            Bind(statement, ID_FIELD_ID, id_);
            Bind(statement, ROWVERSION_FIELD_ID, rowVersion_);
            Bind(statement, LOGIN_FIELD_ID, login_);
            Bind(statement, FROMTIME_FIELD_ID, fromTime_);
            Bind(statement, THROUGHTIME_FIELD_ID, throughTime_);
            Bind(statement, CLIENTSESSION_FIELD_ID, clientSession_);
            Bind(statement, NOTIFICATIONQUEUENAME_FIELD_ID, notificationQueueName_);
            Bind(statement, MESSAGEQUEUENAME_FIELD_ID, messageQueueName_);
        }

        template<IO::StreamWriter StreamT>
        void WriteColumns( IO::BinaryWriter<StreamT>& destination ) const
        {
            WriteColumnValue( destination, id_);
            WriteColumnValue( destination, rowVersion_);
            WriteColumnValue( destination, login_);
            WriteColumnValue( destination, fromTime_);
            WriteColumnValue( destination, throughTime_);
            WriteColumnValue( destination, clientSession_);
            WriteColumnValue( destination, notificationQueueName_);
            WriteColumnValue( destination, messageQueueName_);
        }
    };

    using SimpleSecurityLoginSessionDataReader = SimpleColumnDataReader<SecurityLoginSessionColumnData>;

    class SecurityPermissionColumnData : public BaseColumnData
    {
        Guid id_;
        Int64 rowVersion_ = 0;
        Guid identifier_;
        DateTime timestamp_;
        Int32 typeCode_ = 0;
        bool canCreate_ = false;
        bool canRead_ = false;
        bool canUpdate_ = false;
        bool canDelete_ = false;
    public:
        using Base = BaseColumnData;

        static constexpr std::wstring_view FieldNames = L"[Id],[RowVersion],[Identifier],[Timestamp],[TypeCode],[CanCreate],[CanRead],[CanUpdate],[CanDelete]";
        static constexpr std::wstring_view ViewName = L"SecurityPermissionView";

        static constexpr SQLUSMALLINT ID_FIELD_ID = 1;
        static constexpr SQLUSMALLINT ROWVERSION_FIELD_ID = 2;
        static constexpr SQLUSMALLINT IDENTIFIER_FIELD_ID = 3;
        static constexpr SQLUSMALLINT TIMESTAMP_FIELD_ID = 4;
        static constexpr SQLUSMALLINT TYPECODE_FIELD_ID = 5;
        static constexpr SQLUSMALLINT CANCREATE_FIELD_ID = 6;
        static constexpr SQLUSMALLINT CANREAD_FIELD_ID = 7;
        static constexpr SQLUSMALLINT CANUPDATE_FIELD_ID = 8;
        static constexpr SQLUSMALLINT CANDELETE_FIELD_ID = 9;

        SecurityPermissionColumnData( ) = default;

        virtual Kind GetKind() const override
        {
            return Kind::SecurityPermission;
        }

        const Guid& Id( ) const
        {
            return id_;
        }
        void SetId( const Guid& id )
        {
            id_ = id;
        }
        Int64 RowVersion( ) const
        {
            return rowVersion_;
        }
        void SetRowVersion( const Int64& rowVersion )
        {
            rowVersion_ = rowVersion;
        }
        const Guid& Identifier( ) const
        {
            return identifier_;
        }
        void SetIdentifier( const Guid& identifier )
        {
            identifier_ = identifier;
        }
        const DateTime& Timestamp( ) const
        {
            return timestamp_;
        }
        void SetTimestamp( const DateTime& timestamp )
        {
            timestamp_ = timestamp;
        }
        Int32 TypeCode( ) const
        {
            return typeCode_;
        }
        void SetTypeCode( Int32 typeCode )
        {
            typeCode_ = typeCode;
        }
        bool CanCreate( ) const
        {
            return canCreate_;
        }
        void SetCanCreate( bool canCreate )
        {
            canCreate_ = canCreate;
        }
        bool CanRead( ) const
        {
            return canRead_;
        }
        void SetCanRead( bool canRead )
        {
            canRead_ = canRead;
        }
        bool CanUpdate( ) const
        {
            return canUpdate_;
        }
        void SetCanUpdate( bool canUpdate )
        {
            canUpdate_ = canUpdate;
        }
        bool CanDelete( ) const
        {
            return canDelete_;
        }
        void SetCanDelete( bool canDelete )
        {
            canDelete_ = canDelete;
        }
        void BindColumns( const ODBC::Statement& statement )
        {
            Bind(statement, ID_FIELD_ID, id_);
            Bind(statement, ROWVERSION_FIELD_ID, rowVersion_);
            Bind(statement, IDENTIFIER_FIELD_ID, identifier_);
            Bind(statement, TIMESTAMP_FIELD_ID, timestamp_);
            Bind(statement, TYPECODE_FIELD_ID, typeCode_);
            Bind(statement, CANCREATE_FIELD_ID, canCreate_);
            Bind(statement, CANREAD_FIELD_ID, canRead_);
            Bind(statement, CANUPDATE_FIELD_ID, canUpdate_);
            Bind(statement, CANDELETE_FIELD_ID, canDelete_);
        }

        template<IO::StreamWriter StreamT>
        void WriteColumns( IO::BinaryWriter<StreamT>& destination ) const
        {
            WriteColumnValue( destination, id_);
            WriteColumnValue( destination, rowVersion_);
            WriteColumnValue( destination, identifier_);
            WriteColumnValue( destination, timestamp_);
            WriteColumnValue( destination, typeCode_);
            WriteColumnValue( destination, canCreate_);
            WriteColumnValue( destination, canRead_);
            WriteColumnValue( destination, canUpdate_);
            WriteColumnValue( destination, canDelete_);
        }
    };

    using SimpleSecurityPermissionDataReader = SimpleColumnDataReader<SecurityPermissionColumnData>;

    class SingleTimeseriesValueColumnData : public BaseColumnData
    {
        Guid id_;
        Int64 rowVersion_ = 0;
        Guid timeseries_;
        DateTime timestamp_;
        DBSingle value_;
    public:
        using Base = BaseColumnData;

        static constexpr std::wstring_view FieldNames = L"[Id],[RowVersion],[Timeseries],[Timestamp],[Value]";
        static constexpr std::wstring_view ViewName = L"SingleTimeseriesValueView";

        static constexpr SQLUSMALLINT ID_FIELD_ID = 1;
        static constexpr SQLUSMALLINT ROWVERSION_FIELD_ID = 2;
        static constexpr SQLUSMALLINT TIMESERIES_FIELD_ID = 3;
        static constexpr SQLUSMALLINT TIMESTAMP_FIELD_ID = 4;
        static constexpr SQLUSMALLINT VALUE_FIELD_ID = 5;

        SingleTimeseriesValueColumnData( ) = default;

        virtual Kind GetKind() const override
        {
            return Kind::SingleTimeseriesValue;
        }

        const Guid& Id( ) const
        {
            return id_;
        }
        void SetId( const Guid& id )
        {
            id_ = id;
        }
        Int64 RowVersion( ) const
        {
            return rowVersion_;
        }
        void SetRowVersion( const Int64& rowVersion )
        {
            rowVersion_ = rowVersion;
        }
        const Guid& Timeseries( ) const
        {
            return timeseries_;
        }
        void SetTimeseries( const Guid& timeseries )
        {
            timeseries_ = timeseries;
        }
        const DateTime& Timestamp( ) const
        {
            return timestamp_;
        }
        void SetTimestamp( const DateTime& timestamp )
        {
            timestamp_ = timestamp;
        }
        const DBSingle& Value( ) const
        {
            return value_;
        }
        void SetValue( const DBSingle& value )
        {
            value_ = value;
        }
        void BindColumns( const ODBC::Statement& statement )
        {
            Bind(statement, ID_FIELD_ID, id_);
            Bind(statement, ROWVERSION_FIELD_ID, rowVersion_);
            Bind(statement, TIMESERIES_FIELD_ID, timeseries_);
            Bind(statement, TIMESTAMP_FIELD_ID, timestamp_);
            Bind(statement, VALUE_FIELD_ID, value_);
        }

        template<IO::StreamWriter StreamT>
        void WriteColumns( IO::BinaryWriter<StreamT>& destination ) const
        {
            WriteColumnValue( destination, id_);
            WriteColumnValue( destination, rowVersion_);
            WriteColumnValue( destination, timeseries_);
            WriteColumnValue( destination, timestamp_);
            WriteColumnValue( destination, value_);
        }
    };

    using SimpleSingleTimeseriesValueDataReader = SimpleColumnDataReader<SingleTimeseriesValueColumnData>;

    class StringTimeseriesValueColumnData : public BaseColumnData
    {
        Guid id_;
        Int64 rowVersion_ = 0;
        Guid timeseries_;
        DateTime timestamp_;
        WideString value_;
        SQLLEN valueLength_ = SQL_NULL_DATA;
    public:
        using Base = BaseColumnData;

        static constexpr std::wstring_view FieldNames = L"[Id],[RowVersion],[Timeseries],[Timestamp],[Value]";
        static constexpr std::wstring_view ViewName = L"StringTimeseriesValueView";

        static constexpr SQLUSMALLINT ID_FIELD_ID = 1;
        static constexpr SQLUSMALLINT ROWVERSION_FIELD_ID = 2;
        static constexpr SQLUSMALLINT TIMESERIES_FIELD_ID = 3;
        static constexpr SQLUSMALLINT TIMESTAMP_FIELD_ID = 4;
        static constexpr SQLUSMALLINT VALUE_FIELD_ID = 5;

        StringTimeseriesValueColumnData( ) = default;

        virtual Kind GetKind() const override
        {
            return Kind::StringTimeseriesValue;
        }

        const Guid& Id( ) const
        {
            return id_;
        }
        void SetId( const Guid& id )
        {
            id_ = id;
        }
        Int64 RowVersion( ) const
        {
            return rowVersion_;
        }
        void SetRowVersion( const Int64& rowVersion )
        {
            rowVersion_ = rowVersion;
        }
        const Guid& Timeseries( ) const
        {
            return timeseries_;
        }
        void SetTimeseries( const Guid& timeseries )
        {
            timeseries_ = timeseries;
        }
        const DateTime& Timestamp( ) const
        {
            return timestamp_;
        }
        void SetTimestamp( const DateTime& timestamp )
        {
            timestamp_ = timestamp;
        }
        const WideString& Value( ) const
        {
            return value_;
        }
        void SetValue( const WideString& value )
        {
            value_ = value;
        }
        void BindColumns( const ODBC::Statement& statement )
        {
            Bind(statement, ID_FIELD_ID, id_);
            Bind(statement, ROWVERSION_FIELD_ID, rowVersion_);
            Bind(statement, TIMESERIES_FIELD_ID, timeseries_);
            Bind(statement, TIMESTAMP_FIELD_ID, timestamp_);
        }

        void ReadUnboundData( const ODBC::Statement& statement )
        {
            Base::ReadUnboundData( statement );

            value_ = statement.GetWideString(VALUE_FIELD_ID);
        }
        template<IO::StreamWriter StreamT>
        void WriteColumns( IO::BinaryWriter<StreamT>& destination ) const
        {
            WriteColumnValue( destination, id_);
            WriteColumnValue( destination, rowVersion_);
            WriteColumnValue( destination, timeseries_);
            WriteColumnValue( destination, timestamp_);
            WriteColumnValue( destination, value_);
        }
    };

    using SimpleStringTimeseriesValueDataReader = SimpleColumnDataReader<StringTimeseriesValueColumnData>;

    class TimeseriesCatalogElementColumnData : public BaseColumnData
    {
        Guid id_;
        Int64 rowVersion_ = 0;
        Guid catalog_;
        FixedDBWideString<100> name_;
    public:
        using Base = BaseColumnData;

        static constexpr std::wstring_view FieldNames = L"[Id],[RowVersion],[Catalog],[Name]";
        static constexpr std::wstring_view ViewName = L"TimeseriesCatalogElementView";

        static constexpr SQLUSMALLINT ID_FIELD_ID = 1;
        static constexpr SQLUSMALLINT ROWVERSION_FIELD_ID = 2;
        static constexpr SQLUSMALLINT CATALOG_FIELD_ID = 3;
        static constexpr SQLUSMALLINT NAME_FIELD_ID = 4;

        TimeseriesCatalogElementColumnData( ) = default;

        virtual Kind GetKind() const override
        {
            return Kind::TimeseriesCatalogElement;
        }

        const Guid& Id( ) const
        {
            return id_;
        }
        void SetId( const Guid& id )
        {
            id_ = id;
        }
        Int64 RowVersion( ) const
        {
            return rowVersion_;
        }
        void SetRowVersion( const Int64& rowVersion )
        {
            rowVersion_ = rowVersion;
        }
        const Guid& Catalog( ) const
        {
            return catalog_;
        }
        void SetCatalog( const Guid& catalog )
        {
            catalog_ = catalog;
        }
        const FixedDBWideString<100>& Name( ) const
        {
            return name_;
        }
        void SetName( const WideString& name )
        {
            name_ = name;
        }
        void BindColumns( const ODBC::Statement& statement )
        {
            Bind(statement, ID_FIELD_ID, id_);
            Bind(statement, ROWVERSION_FIELD_ID, rowVersion_);
            Bind(statement, CATALOG_FIELD_ID, catalog_);
            Bind(statement, NAME_FIELD_ID, name_);
        }

        template<IO::StreamWriter StreamT>
        void WriteColumns( IO::BinaryWriter<StreamT>& destination ) const
        {
            WriteColumnValue( destination, id_);
            WriteColumnValue( destination, rowVersion_);
            WriteColumnValue( destination, catalog_);
            WriteColumnValue( destination, name_);
        }
    };

    using SimpleTimeseriesCatalogElementDataReader = SimpleColumnDataReader<TimeseriesCatalogElementColumnData>;

    class TimeseriesColumnData : public TimeseriesCatalogElementColumnData
    {
        TimeSpan maxRetention_;
    public:
        using Base = TimeseriesCatalogElementColumnData;

        static constexpr std::wstring_view FieldNames = L"[Id],[RowVersion],[Catalog],[Name],[MaxRetention]";
        static constexpr std::wstring_view ViewName = L"TimeseriesView";

        static constexpr SQLUSMALLINT MAXRETENTION_FIELD_ID = 5;

        TimeseriesColumnData( ) = default;

        virtual Kind GetKind() const override
        {
            return Kind::Timeseries;
        }

        const TimeSpan& MaxRetention( ) const
        {
            return maxRetention_;
        }
        void SetMaxRetention( const TimeSpan& maxRetention )
        {
            maxRetention_ = maxRetention;
        }
        void BindColumns( const ODBC::Statement& statement )
        {
            Base::BindColumns( statement );

            Bind(statement, MAXRETENTION_FIELD_ID, maxRetention_);
        }

        template<IO::StreamWriter StreamT>
        void WriteColumns( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteColumns( destination );
            WriteColumnValue( destination, maxRetention_);
        }
    };

    using SimpleTimeseriesDataReader = SimpleColumnDataReader<TimeseriesColumnData>;

    class BinaryTimeseriesColumnData : public TimeseriesColumnData
    {
    public:
        using Base = TimeseriesColumnData;

        static constexpr std::wstring_view FieldNames = L"[Id],[RowVersion],[Catalog],[Name],[MaxRetention]";
        static constexpr std::wstring_view ViewName = L"BinaryTimeseriesView";

        BinaryTimeseriesColumnData( ) = default;

        virtual Kind GetKind() const override
        {
            return Kind::BinaryTimeseries;
        }

        template<IO::StreamWriter StreamT>
        void WriteColumns( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteColumns( destination );
        }
    };

    using SimpleBinaryTimeseriesDataReader = SimpleColumnDataReader<BinaryTimeseriesColumnData>;

    class BooleanTimeseriesColumnData : public TimeseriesColumnData
    {
    public:
        using Base = TimeseriesColumnData;

        static constexpr std::wstring_view FieldNames = L"[Id],[RowVersion],[Catalog],[Name],[MaxRetention]";
        static constexpr std::wstring_view ViewName = L"BooleanTimeseriesView";

        BooleanTimeseriesColumnData( ) = default;

        virtual Kind GetKind() const override
        {
            return Kind::BooleanTimeseries;
        }

        template<IO::StreamWriter StreamT>
        void WriteColumns( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteColumns( destination );
        }
    };

    using SimpleBooleanTimeseriesDataReader = SimpleColumnDataReader<BooleanTimeseriesColumnData>;

    class AisAidToNavigationOffPositionTimeseriesColumnData : public BooleanTimeseriesColumnData
    {
        Guid aidToNavigation_;
    public:
        using Base = BooleanTimeseriesColumnData;

        static constexpr std::wstring_view FieldNames = L"[Id],[RowVersion],[Catalog],[Name],[MaxRetention],[AidToNavigation]";
        static constexpr std::wstring_view ViewName = L"AisAidToNavigationOffPositionTimeseriesView";

        static constexpr SQLUSMALLINT AIDTONAVIGATION_FIELD_ID = 6;

        AisAidToNavigationOffPositionTimeseriesColumnData( ) = default;

        virtual Kind GetKind() const override
        {
            return Kind::AisAidToNavigationOffPositionTimeseries;
        }

        const Guid& AidToNavigation( ) const
        {
            return aidToNavigation_;
        }
        void SetAidToNavigation( const Guid& aidToNavigation )
        {
            aidToNavigation_ = aidToNavigation;
        }
        void BindColumns( const ODBC::Statement& statement )
        {
            Base::BindColumns( statement );

            Bind(statement, AIDTONAVIGATION_FIELD_ID, aidToNavigation_);
        }

        template<IO::StreamWriter StreamT>
        void WriteColumns( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteColumns( destination );
            WriteColumnValue( destination, aidToNavigation_);
        }
    };

    using SimpleAisAidToNavigationOffPositionTimeseriesDataReader = SimpleColumnDataReader<AisAidToNavigationOffPositionTimeseriesColumnData>;

    class DeviceEnabledTimeseriesColumnData : public BooleanTimeseriesColumnData
    {
        Guid device_;
    public:
        using Base = BooleanTimeseriesColumnData;

        static constexpr std::wstring_view FieldNames = L"[Id],[RowVersion],[Catalog],[Name],[MaxRetention],[Device]";
        static constexpr std::wstring_view ViewName = L"DeviceEnabledTimeseriesView";

        static constexpr SQLUSMALLINT DEVICE_FIELD_ID = 6;

        DeviceEnabledTimeseriesColumnData( ) = default;

        virtual Kind GetKind() const override
        {
            return Kind::DeviceEnabledTimeseries;
        }

        const Guid& Device( ) const
        {
            return device_;
        }
        void SetDevice( const Guid& device )
        {
            device_ = device;
        }
        void BindColumns( const ODBC::Statement& statement )
        {
            Base::BindColumns( statement );

            Bind(statement, DEVICE_FIELD_ID, device_);
        }

        template<IO::StreamWriter StreamT>
        void WriteColumns( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteColumns( destination );
            WriteColumnValue( destination, device_);
        }
    };

    using SimpleDeviceEnabledTimeseriesDataReader = SimpleColumnDataReader<DeviceEnabledTimeseriesColumnData>;

    class RadarAutomaticSensitivityTimeControlTimeseriesColumnData : public BooleanTimeseriesColumnData
    {
        Guid radar_;
    public:
        using Base = BooleanTimeseriesColumnData;

        static constexpr std::wstring_view FieldNames = L"[Id],[RowVersion],[Catalog],[Name],[MaxRetention],[Radar]";
        static constexpr std::wstring_view ViewName = L"RadarAutomaticSensitivityTimeControlTimeseriesView";

        static constexpr SQLUSMALLINT RADAR_FIELD_ID = 6;

        RadarAutomaticSensitivityTimeControlTimeseriesColumnData( ) = default;

        virtual Kind GetKind() const override
        {
            return Kind::RadarAutomaticSensitivityTimeControlTimeseries;
        }

        const Guid& Radar( ) const
        {
            return radar_;
        }
        void SetRadar( const Guid& radar )
        {
            radar_ = radar;
        }
        void BindColumns( const ODBC::Statement& statement )
        {
            Base::BindColumns( statement );

            Bind(statement, RADAR_FIELD_ID, radar_);
        }

        template<IO::StreamWriter StreamT>
        void WriteColumns( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteColumns( destination );
            WriteColumnValue( destination, radar_);
        }
    };

    using SimpleRadarAutomaticSensitivityTimeControlTimeseriesDataReader = SimpleColumnDataReader<RadarAutomaticSensitivityTimeControlTimeseriesColumnData>;

    class RadarBlankSector1TimeseriesColumnData : public BooleanTimeseriesColumnData
    {
        Guid radar_;
    public:
        using Base = BooleanTimeseriesColumnData;

        static constexpr std::wstring_view FieldNames = L"[Id],[RowVersion],[Catalog],[Name],[MaxRetention],[Radar]";
        static constexpr std::wstring_view ViewName = L"RadarBlankSector1TimeseriesView";

        static constexpr SQLUSMALLINT RADAR_FIELD_ID = 6;

        RadarBlankSector1TimeseriesColumnData( ) = default;

        virtual Kind GetKind() const override
        {
            return Kind::RadarBlankSector1Timeseries;
        }

        const Guid& Radar( ) const
        {
            return radar_;
        }
        void SetRadar( const Guid& radar )
        {
            radar_ = radar;
        }
        void BindColumns( const ODBC::Statement& statement )
        {
            Base::BindColumns( statement );

            Bind(statement, RADAR_FIELD_ID, radar_);
        }

        template<IO::StreamWriter StreamT>
        void WriteColumns( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteColumns( destination );
            WriteColumnValue( destination, radar_);
        }
    };

    using SimpleRadarBlankSector1TimeseriesDataReader = SimpleColumnDataReader<RadarBlankSector1TimeseriesColumnData>;

    class RadarBlankSector2TimeseriesColumnData : public BooleanTimeseriesColumnData
    {
        Guid radar_;
    public:
        using Base = BooleanTimeseriesColumnData;

        static constexpr std::wstring_view FieldNames = L"[Id],[RowVersion],[Catalog],[Name],[MaxRetention],[Radar]";
        static constexpr std::wstring_view ViewName = L"RadarBlankSector2TimeseriesView";

        static constexpr SQLUSMALLINT RADAR_FIELD_ID = 6;

        RadarBlankSector2TimeseriesColumnData( ) = default;

        virtual Kind GetKind() const override
        {
            return Kind::RadarBlankSector2Timeseries;
        }

        const Guid& Radar( ) const
        {
            return radar_;
        }
        void SetRadar( const Guid& radar )
        {
            radar_ = radar;
        }
        void BindColumns( const ODBC::Statement& statement )
        {
            Base::BindColumns( statement );

            Bind(statement, RADAR_FIELD_ID, radar_);
        }

        template<IO::StreamWriter StreamT>
        void WriteColumns( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteColumns( destination );
            WriteColumnValue( destination, radar_);
        }
    };

    using SimpleRadarBlankSector2TimeseriesDataReader = SimpleColumnDataReader<RadarBlankSector2TimeseriesColumnData>;

    class RadarEnableAutomaticFrequencyControlTimeseriesColumnData : public BooleanTimeseriesColumnData
    {
        Guid radar_;
    public:
        using Base = BooleanTimeseriesColumnData;

        static constexpr std::wstring_view FieldNames = L"[Id],[RowVersion],[Catalog],[Name],[MaxRetention],[Radar]";
        static constexpr std::wstring_view ViewName = L"RadarEnableAutomaticFrequencyControlTimeseriesView";

        static constexpr SQLUSMALLINT RADAR_FIELD_ID = 6;

        RadarEnableAutomaticFrequencyControlTimeseriesColumnData( ) = default;

        virtual Kind GetKind() const override
        {
            return Kind::RadarEnableAutomaticFrequencyControlTimeseries;
        }

        const Guid& Radar( ) const
        {
            return radar_;
        }
        void SetRadar( const Guid& radar )
        {
            radar_ = radar;
        }
        void BindColumns( const ODBC::Statement& statement )
        {
            Base::BindColumns( statement );

            Bind(statement, RADAR_FIELD_ID, radar_);
        }

        template<IO::StreamWriter StreamT>
        void WriteColumns( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteColumns( destination );
            WriteColumnValue( destination, radar_);
        }
    };

    using SimpleRadarEnableAutomaticFrequencyControlTimeseriesDataReader = SimpleColumnDataReader<RadarEnableAutomaticFrequencyControlTimeseriesColumnData>;

    class RadarEnableFastTimeConstantTimeseriesColumnData : public BooleanTimeseriesColumnData
    {
        Guid radar_;
    public:
        using Base = BooleanTimeseriesColumnData;

        static constexpr std::wstring_view FieldNames = L"[Id],[RowVersion],[Catalog],[Name],[MaxRetention],[Radar]";
        static constexpr std::wstring_view ViewName = L"RadarEnableFastTimeConstantTimeseriesView";

        static constexpr SQLUSMALLINT RADAR_FIELD_ID = 6;

        RadarEnableFastTimeConstantTimeseriesColumnData( ) = default;

        virtual Kind GetKind() const override
        {
            return Kind::RadarEnableFastTimeConstantTimeseries;
        }

        const Guid& Radar( ) const
        {
            return radar_;
        }
        void SetRadar( const Guid& radar )
        {
            radar_ = radar;
        }
        void BindColumns( const ODBC::Statement& statement )
        {
            Base::BindColumns( statement );

            Bind(statement, RADAR_FIELD_ID, radar_);
        }

        template<IO::StreamWriter StreamT>
        void WriteColumns( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteColumns( destination );
            WriteColumnValue( destination, radar_);
        }
    };

    using SimpleRadarEnableFastTimeConstantTimeseriesDataReader = SimpleColumnDataReader<RadarEnableFastTimeConstantTimeseriesColumnData>;

    class RadarEnableSensitivityTimeControlTimeseriesColumnData : public BooleanTimeseriesColumnData
    {
        Guid radar_;
    public:
        using Base = BooleanTimeseriesColumnData;

        static constexpr std::wstring_view FieldNames = L"[Id],[RowVersion],[Catalog],[Name],[MaxRetention],[Radar]";
        static constexpr std::wstring_view ViewName = L"RadarEnableSensitivityTimeControlTimeseriesView";

        static constexpr SQLUSMALLINT RADAR_FIELD_ID = 6;

        RadarEnableSensitivityTimeControlTimeseriesColumnData( ) = default;

        virtual Kind GetKind() const override
        {
            return Kind::RadarEnableSensitivityTimeControlTimeseries;
        }

        const Guid& Radar( ) const
        {
            return radar_;
        }
        void SetRadar( const Guid& radar )
        {
            radar_ = radar;
        }
        void BindColumns( const ODBC::Statement& statement )
        {
            Base::BindColumns( statement );

            Bind(statement, RADAR_FIELD_ID, radar_);
        }

        template<IO::StreamWriter StreamT>
        void WriteColumns( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteColumns( destination );
            WriteColumnValue( destination, radar_);
        }
    };

    using SimpleRadarEnableSensitivityTimeControlTimeseriesDataReader = SimpleColumnDataReader<RadarEnableSensitivityTimeControlTimeseriesColumnData>;

    class RadarPowerOnTimeseriesColumnData : public BooleanTimeseriesColumnData
    {
        Guid radar_;
    public:
        using Base = BooleanTimeseriesColumnData;

        static constexpr std::wstring_view FieldNames = L"[Id],[RowVersion],[Catalog],[Name],[MaxRetention],[Radar]";
        static constexpr std::wstring_view ViewName = L"RadarPowerOnTimeseriesView";

        static constexpr SQLUSMALLINT RADAR_FIELD_ID = 6;

        RadarPowerOnTimeseriesColumnData( ) = default;

        virtual Kind GetKind() const override
        {
            return Kind::RadarPowerOnTimeseries;
        }

        const Guid& Radar( ) const
        {
            return radar_;
        }
        void SetRadar( const Guid& radar )
        {
            radar_ = radar;
        }
        void BindColumns( const ODBC::Statement& statement )
        {
            Base::BindColumns( statement );

            Bind(statement, RADAR_FIELD_ID, radar_);
        }

        template<IO::StreamWriter StreamT>
        void WriteColumns( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteColumns( destination );
            WriteColumnValue( destination, radar_);
        }
    };

    using SimpleRadarPowerOnTimeseriesDataReader = SimpleColumnDataReader<RadarPowerOnTimeseriesColumnData>;

    class RadarSaveSettingsTimeseriesColumnData : public BooleanTimeseriesColumnData
    {
        Guid radar_;
    public:
        using Base = BooleanTimeseriesColumnData;

        static constexpr std::wstring_view FieldNames = L"[Id],[RowVersion],[Catalog],[Name],[MaxRetention],[Radar]";
        static constexpr std::wstring_view ViewName = L"RadarSaveSettingsTimeseriesView";

        static constexpr SQLUSMALLINT RADAR_FIELD_ID = 6;

        RadarSaveSettingsTimeseriesColumnData( ) = default;

        virtual Kind GetKind() const override
        {
            return Kind::RadarSaveSettingsTimeseries;
        }

        const Guid& Radar( ) const
        {
            return radar_;
        }
        void SetRadar( const Guid& radar )
        {
            radar_ = radar;
        }
        void BindColumns( const ODBC::Statement& statement )
        {
            Base::BindColumns( statement );

            Bind(statement, RADAR_FIELD_ID, radar_);
        }

        template<IO::StreamWriter StreamT>
        void WriteColumns( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteColumns( destination );
            WriteColumnValue( destination, radar_);
        }
    };

    using SimpleRadarSaveSettingsTimeseriesDataReader = SimpleColumnDataReader<RadarSaveSettingsTimeseriesColumnData>;

    class RadarTrackingTimeseriesColumnData : public BooleanTimeseriesColumnData
    {
        Guid radar_;
    public:
        using Base = BooleanTimeseriesColumnData;

        static constexpr std::wstring_view FieldNames = L"[Id],[RowVersion],[Catalog],[Name],[MaxRetention],[Radar]";
        static constexpr std::wstring_view ViewName = L"RadarTrackingTimeseriesView";

        static constexpr SQLUSMALLINT RADAR_FIELD_ID = 6;

        RadarTrackingTimeseriesColumnData( ) = default;

        virtual Kind GetKind() const override
        {
            return Kind::RadarTrackingTimeseries;
        }

        const Guid& Radar( ) const
        {
            return radar_;
        }
        void SetRadar( const Guid& radar )
        {
            radar_ = radar;
        }
        void BindColumns( const ODBC::Statement& statement )
        {
            Base::BindColumns( statement );

            Bind(statement, RADAR_FIELD_ID, radar_);
        }

        template<IO::StreamWriter StreamT>
        void WriteColumns( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteColumns( destination );
            WriteColumnValue( destination, radar_);
        }
    };

    using SimpleRadarTrackingTimeseriesDataReader = SimpleColumnDataReader<RadarTrackingTimeseriesColumnData>;

    class MediaProxySessionEnabledTimeseriesColumnData : public BooleanTimeseriesColumnData
    {
        Guid proxySession_;
    public:
        using Base = BooleanTimeseriesColumnData;

        static constexpr std::wstring_view FieldNames = L"[Id],[RowVersion],[Catalog],[Name],[MaxRetention],[ProxySession]";
        static constexpr std::wstring_view ViewName = L"MediaProxySessionEnabledTimeseriesView";

        static constexpr SQLUSMALLINT PROXYSESSION_FIELD_ID = 6;

        MediaProxySessionEnabledTimeseriesColumnData( ) = default;

        virtual Kind GetKind() const override
        {
            return Kind::MediaProxySessionEnabledTimeseries;
        }

        const Guid& ProxySession( ) const
        {
            return proxySession_;
        }
        void SetProxySession( const Guid& proxySession )
        {
            proxySession_ = proxySession;
        }
        void BindColumns( const ODBC::Statement& statement )
        {
            Base::BindColumns( statement );

            Bind(statement, PROXYSESSION_FIELD_ID, proxySession_);
        }

        template<IO::StreamWriter StreamT>
        void WriteColumns( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteColumns( destination );
            WriteColumnValue( destination, proxySession_);
        }
    };

    using SimpleMediaProxySessionEnabledTimeseriesDataReader = SimpleColumnDataReader<MediaProxySessionEnabledTimeseriesColumnData>;

    class MediaServiceEnabledTimeseriesColumnData : public BooleanTimeseriesColumnData
    {
        Guid service_;
    public:
        using Base = BooleanTimeseriesColumnData;

        static constexpr std::wstring_view FieldNames = L"[Id],[RowVersion],[Catalog],[Name],[MaxRetention],[Service]";
        static constexpr std::wstring_view ViewName = L"MediaServiceEnabledTimeseriesView";

        static constexpr SQLUSMALLINT SERVICE_FIELD_ID = 6;

        MediaServiceEnabledTimeseriesColumnData( ) = default;

        virtual Kind GetKind() const override
        {
            return Kind::MediaServiceEnabledTimeseries;
        }

        const Guid& Service( ) const
        {
            return service_;
        }
        void SetService( const Guid& service )
        {
            service_ = service;
        }
        void BindColumns( const ODBC::Statement& statement )
        {
            Base::BindColumns( statement );

            Bind(statement, SERVICE_FIELD_ID, service_);
        }

        template<IO::StreamWriter StreamT>
        void WriteColumns( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteColumns( destination );
            WriteColumnValue( destination, service_);
        }
    };

    using SimpleMediaServiceEnabledTimeseriesDataReader = SimpleColumnDataReader<MediaServiceEnabledTimeseriesColumnData>;

    class ByteTimeseriesColumnData : public TimeseriesColumnData
    {
    public:
        using Base = TimeseriesColumnData;

        static constexpr std::wstring_view FieldNames = L"[Id],[RowVersion],[Catalog],[Name],[MaxRetention]";
        static constexpr std::wstring_view ViewName = L"ByteTimeseriesView";

        ByteTimeseriesColumnData( ) = default;

        virtual Kind GetKind() const override
        {
            return Kind::ByteTimeseries;
        }

        template<IO::StreamWriter StreamT>
        void WriteColumns( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteColumns( destination );
        }
    };

    using SimpleByteTimeseriesDataReader = SimpleColumnDataReader<ByteTimeseriesColumnData>;

    class DateTimeTimeseriesColumnData : public TimeseriesColumnData
    {
    public:
        using Base = TimeseriesColumnData;

        static constexpr std::wstring_view FieldNames = L"[Id],[RowVersion],[Catalog],[Name],[MaxRetention]";
        static constexpr std::wstring_view ViewName = L"DateTimeTimeseriesView";

        DateTimeTimeseriesColumnData( ) = default;

        virtual Kind GetKind() const override
        {
            return Kind::DateTimeTimeseries;
        }

        template<IO::StreamWriter StreamT>
        void WriteColumns( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteColumns( destination );
        }
    };

    using SimpleDateTimeTimeseriesDataReader = SimpleColumnDataReader<DateTimeTimeseriesColumnData>;

    class DoubleTimeseriesColumnData : public TimeseriesColumnData
    {
    public:
        using Base = TimeseriesColumnData;

        static constexpr std::wstring_view FieldNames = L"[Id],[RowVersion],[Catalog],[Name],[MaxRetention]";
        static constexpr std::wstring_view ViewName = L"DoubleTimeseriesView";

        DoubleTimeseriesColumnData( ) = default;

        virtual Kind GetKind() const override
        {
            return Kind::DoubleTimeseries;
        }

        template<IO::StreamWriter StreamT>
        void WriteColumns( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteColumns( destination );
        }
    };

    using SimpleDoubleTimeseriesDataReader = SimpleColumnDataReader<DoubleTimeseriesColumnData>;

    class GNSSAltitudeTimeseriesColumnData : public DoubleTimeseriesColumnData
    {
        Guid gNSSDevice_;
    public:
        using Base = DoubleTimeseriesColumnData;

        static constexpr std::wstring_view FieldNames = L"[Id],[RowVersion],[Catalog],[Name],[MaxRetention],[GNSSDevice]";
        static constexpr std::wstring_view ViewName = L"GNSSAltitudeTimeseriesView";

        static constexpr SQLUSMALLINT GNSSDEVICE_FIELD_ID = 6;

        GNSSAltitudeTimeseriesColumnData( ) = default;

        virtual Kind GetKind() const override
        {
            return Kind::GNSSAltitudeTimeseries;
        }

        const Guid& GNSSDevice( ) const
        {
            return gNSSDevice_;
        }
        void SetGNSSDevice( const Guid& gNSSDevice )
        {
            gNSSDevice_ = gNSSDevice;
        }
        void BindColumns( const ODBC::Statement& statement )
        {
            Base::BindColumns( statement );

            Bind(statement, GNSSDEVICE_FIELD_ID, gNSSDevice_);
        }

        template<IO::StreamWriter StreamT>
        void WriteColumns( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteColumns( destination );
            WriteColumnValue( destination, gNSSDevice_);
        }
    };

    using SimpleGNSSAltitudeTimeseriesDataReader = SimpleColumnDataReader<GNSSAltitudeTimeseriesColumnData>;

    class GNSSLatitudeTimeseriesColumnData : public DoubleTimeseriesColumnData
    {
        Guid gNSSDevice_;
    public:
        using Base = DoubleTimeseriesColumnData;

        static constexpr std::wstring_view FieldNames = L"[Id],[RowVersion],[Catalog],[Name],[MaxRetention],[GNSSDevice]";
        static constexpr std::wstring_view ViewName = L"GNSSLatitudeTimeseriesView";

        static constexpr SQLUSMALLINT GNSSDEVICE_FIELD_ID = 6;

        GNSSLatitudeTimeseriesColumnData( ) = default;

        virtual Kind GetKind() const override
        {
            return Kind::GNSSLatitudeTimeseries;
        }

        const Guid& GNSSDevice( ) const
        {
            return gNSSDevice_;
        }
        void SetGNSSDevice( const Guid& gNSSDevice )
        {
            gNSSDevice_ = gNSSDevice;
        }
        void BindColumns( const ODBC::Statement& statement )
        {
            Base::BindColumns( statement );

            Bind(statement, GNSSDEVICE_FIELD_ID, gNSSDevice_);
        }

        template<IO::StreamWriter StreamT>
        void WriteColumns( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteColumns( destination );
            WriteColumnValue( destination, gNSSDevice_);
        }
    };

    using SimpleGNSSLatitudeTimeseriesDataReader = SimpleColumnDataReader<GNSSLatitudeTimeseriesColumnData>;

    class GNSSLongitudeTimeseriesColumnData : public DoubleTimeseriesColumnData
    {
        Guid gNSSDevice_;
    public:
        using Base = DoubleTimeseriesColumnData;

        static constexpr std::wstring_view FieldNames = L"[Id],[RowVersion],[Catalog],[Name],[MaxRetention],[GNSSDevice]";
        static constexpr std::wstring_view ViewName = L"GNSSLongitudeTimeseriesView";

        static constexpr SQLUSMALLINT GNSSDEVICE_FIELD_ID = 6;

        GNSSLongitudeTimeseriesColumnData( ) = default;

        virtual Kind GetKind() const override
        {
            return Kind::GNSSLongitudeTimeseries;
        }

        const Guid& GNSSDevice( ) const
        {
            return gNSSDevice_;
        }
        void SetGNSSDevice( const Guid& gNSSDevice )
        {
            gNSSDevice_ = gNSSDevice;
        }
        void BindColumns( const ODBC::Statement& statement )
        {
            Base::BindColumns( statement );

            Bind(statement, GNSSDEVICE_FIELD_ID, gNSSDevice_);
        }

        template<IO::StreamWriter StreamT>
        void WriteColumns( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteColumns( destination );
            WriteColumnValue( destination, gNSSDevice_);
        }
    };

    using SimpleGNSSLongitudeTimeseriesDataReader = SimpleColumnDataReader<GNSSLongitudeTimeseriesColumnData>;

    class GyroCourseTimeseriesColumnData : public DoubleTimeseriesColumnData
    {
        Guid gyroDevice_;
    public:
        using Base = DoubleTimeseriesColumnData;

        static constexpr std::wstring_view FieldNames = L"[Id],[RowVersion],[Catalog],[Name],[MaxRetention],[GyroDevice]";
        static constexpr std::wstring_view ViewName = L"GyroCourseTimeseriesView";

        static constexpr SQLUSMALLINT GYRODEVICE_FIELD_ID = 6;

        GyroCourseTimeseriesColumnData( ) = default;

        virtual Kind GetKind() const override
        {
            return Kind::GyroCourseTimeseries;
        }

        const Guid& GyroDevice( ) const
        {
            return gyroDevice_;
        }
        void SetGyroDevice( const Guid& gyroDevice )
        {
            gyroDevice_ = gyroDevice;
        }
        void BindColumns( const ODBC::Statement& statement )
        {
            Base::BindColumns( statement );

            Bind(statement, GYRODEVICE_FIELD_ID, gyroDevice_);
        }

        template<IO::StreamWriter StreamT>
        void WriteColumns( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteColumns( destination );
            WriteColumnValue( destination, gyroDevice_);
        }
    };

    using SimpleGyroCourseTimeseriesDataReader = SimpleColumnDataReader<GyroCourseTimeseriesColumnData>;

    class GyroHeadingMagneticNorthTimeseriesColumnData : public DoubleTimeseriesColumnData
    {
        Guid gyroDevice_;
    public:
        using Base = DoubleTimeseriesColumnData;

        static constexpr std::wstring_view FieldNames = L"[Id],[RowVersion],[Catalog],[Name],[MaxRetention],[GyroDevice]";
        static constexpr std::wstring_view ViewName = L"GyroHeadingMagneticNorthTimeseriesView";

        static constexpr SQLUSMALLINT GYRODEVICE_FIELD_ID = 6;

        GyroHeadingMagneticNorthTimeseriesColumnData( ) = default;

        virtual Kind GetKind() const override
        {
            return Kind::GyroHeadingMagneticNorthTimeseries;
        }

        const Guid& GyroDevice( ) const
        {
            return gyroDevice_;
        }
        void SetGyroDevice( const Guid& gyroDevice )
        {
            gyroDevice_ = gyroDevice;
        }
        void BindColumns( const ODBC::Statement& statement )
        {
            Base::BindColumns( statement );

            Bind(statement, GYRODEVICE_FIELD_ID, gyroDevice_);
        }

        template<IO::StreamWriter StreamT>
        void WriteColumns( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteColumns( destination );
            WriteColumnValue( destination, gyroDevice_);
        }
    };

    using SimpleGyroHeadingMagneticNorthTimeseriesDataReader = SimpleColumnDataReader<GyroHeadingMagneticNorthTimeseriesColumnData>;

    class GyroHeadingTrueNorthTimeseriesColumnData : public DoubleTimeseriesColumnData
    {
        Guid gyroDevice_;
    public:
        using Base = DoubleTimeseriesColumnData;

        static constexpr std::wstring_view FieldNames = L"[Id],[RowVersion],[Catalog],[Name],[MaxRetention],[GyroDevice]";
        static constexpr std::wstring_view ViewName = L"GyroHeadingTrueNorthTimeseriesView";

        static constexpr SQLUSMALLINT GYRODEVICE_FIELD_ID = 6;

        GyroHeadingTrueNorthTimeseriesColumnData( ) = default;

        virtual Kind GetKind() const override
        {
            return Kind::GyroHeadingTrueNorthTimeseries;
        }

        const Guid& GyroDevice( ) const
        {
            return gyroDevice_;
        }
        void SetGyroDevice( const Guid& gyroDevice )
        {
            gyroDevice_ = gyroDevice;
        }
        void BindColumns( const ODBC::Statement& statement )
        {
            Base::BindColumns( statement );

            Bind(statement, GYRODEVICE_FIELD_ID, gyroDevice_);
        }

        template<IO::StreamWriter StreamT>
        void WriteColumns( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteColumns( destination );
            WriteColumnValue( destination, gyroDevice_);
        }
    };

    using SimpleGyroHeadingTrueNorthTimeseriesDataReader = SimpleColumnDataReader<GyroHeadingTrueNorthTimeseriesColumnData>;

    class GyroPitchTimeseriesColumnData : public DoubleTimeseriesColumnData
    {
        Guid gyroDevice_;
    public:
        using Base = DoubleTimeseriesColumnData;

        static constexpr std::wstring_view FieldNames = L"[Id],[RowVersion],[Catalog],[Name],[MaxRetention],[GyroDevice]";
        static constexpr std::wstring_view ViewName = L"GyroPitchTimeseriesView";

        static constexpr SQLUSMALLINT GYRODEVICE_FIELD_ID = 6;

        GyroPitchTimeseriesColumnData( ) = default;

        virtual Kind GetKind() const override
        {
            return Kind::GyroPitchTimeseries;
        }

        const Guid& GyroDevice( ) const
        {
            return gyroDevice_;
        }
        void SetGyroDevice( const Guid& gyroDevice )
        {
            gyroDevice_ = gyroDevice;
        }
        void BindColumns( const ODBC::Statement& statement )
        {
            Base::BindColumns( statement );

            Bind(statement, GYRODEVICE_FIELD_ID, gyroDevice_);
        }

        template<IO::StreamWriter StreamT>
        void WriteColumns( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteColumns( destination );
            WriteColumnValue( destination, gyroDevice_);
        }
    };

    using SimpleGyroPitchTimeseriesDataReader = SimpleColumnDataReader<GyroPitchTimeseriesColumnData>;

    class GyroRateOfTurnTimeseriesColumnData : public DoubleTimeseriesColumnData
    {
        Guid gyroDevice_;
    public:
        using Base = DoubleTimeseriesColumnData;

        static constexpr std::wstring_view FieldNames = L"[Id],[RowVersion],[Catalog],[Name],[MaxRetention],[GyroDevice]";
        static constexpr std::wstring_view ViewName = L"GyroRateOfTurnTimeseriesView";

        static constexpr SQLUSMALLINT GYRODEVICE_FIELD_ID = 6;

        GyroRateOfTurnTimeseriesColumnData( ) = default;

        virtual Kind GetKind() const override
        {
            return Kind::GyroRateOfTurnTimeseries;
        }

        const Guid& GyroDevice( ) const
        {
            return gyroDevice_;
        }
        void SetGyroDevice( const Guid& gyroDevice )
        {
            gyroDevice_ = gyroDevice;
        }
        void BindColumns( const ODBC::Statement& statement )
        {
            Base::BindColumns( statement );

            Bind(statement, GYRODEVICE_FIELD_ID, gyroDevice_);
        }

        template<IO::StreamWriter StreamT>
        void WriteColumns( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteColumns( destination );
            WriteColumnValue( destination, gyroDevice_);
        }
    };

    using SimpleGyroRateOfTurnTimeseriesDataReader = SimpleColumnDataReader<GyroRateOfTurnTimeseriesColumnData>;

    class GyroRollTimeseriesColumnData : public DoubleTimeseriesColumnData
    {
        Guid gyroDevice_;
    public:
        using Base = DoubleTimeseriesColumnData;

        static constexpr std::wstring_view FieldNames = L"[Id],[RowVersion],[Catalog],[Name],[MaxRetention],[GyroDevice]";
        static constexpr std::wstring_view ViewName = L"GyroRollTimeseriesView";

        static constexpr SQLUSMALLINT GYRODEVICE_FIELD_ID = 6;

        GyroRollTimeseriesColumnData( ) = default;

        virtual Kind GetKind() const override
        {
            return Kind::GyroRollTimeseries;
        }

        const Guid& GyroDevice( ) const
        {
            return gyroDevice_;
        }
        void SetGyroDevice( const Guid& gyroDevice )
        {
            gyroDevice_ = gyroDevice;
        }
        void BindColumns( const ODBC::Statement& statement )
        {
            Base::BindColumns( statement );

            Bind(statement, GYRODEVICE_FIELD_ID, gyroDevice_);
        }

        template<IO::StreamWriter StreamT>
        void WriteColumns( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteColumns( destination );
            WriteColumnValue( destination, gyroDevice_);
        }
    };

    using SimpleGyroRollTimeseriesDataReader = SimpleColumnDataReader<GyroRollTimeseriesColumnData>;

    class GyroSpeedTimeseriesColumnData : public DoubleTimeseriesColumnData
    {
        Guid gyroDevice_;
    public:
        using Base = DoubleTimeseriesColumnData;

        static constexpr std::wstring_view FieldNames = L"[Id],[RowVersion],[Catalog],[Name],[MaxRetention],[GyroDevice]";
        static constexpr std::wstring_view ViewName = L"GyroSpeedTimeseriesView";

        static constexpr SQLUSMALLINT GYRODEVICE_FIELD_ID = 6;

        GyroSpeedTimeseriesColumnData( ) = default;

        virtual Kind GetKind() const override
        {
            return Kind::GyroSpeedTimeseries;
        }

        const Guid& GyroDevice( ) const
        {
            return gyroDevice_;
        }
        void SetGyroDevice( const Guid& gyroDevice )
        {
            gyroDevice_ = gyroDevice;
        }
        void BindColumns( const ODBC::Statement& statement )
        {
            Base::BindColumns( statement );

            Bind(statement, GYRODEVICE_FIELD_ID, gyroDevice_);
        }

        template<IO::StreamWriter StreamT>
        void WriteColumns( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteColumns( destination );
            WriteColumnValue( destination, gyroDevice_);
        }
    };

    using SimpleGyroSpeedTimeseriesDataReader = SimpleColumnDataReader<GyroSpeedTimeseriesColumnData>;

    class RadarLatitudeTimeseriesColumnData : public DoubleTimeseriesColumnData
    {
        Guid radar_;
    public:
        using Base = DoubleTimeseriesColumnData;

        static constexpr std::wstring_view FieldNames = L"[Id],[RowVersion],[Catalog],[Name],[MaxRetention],[Radar]";
        static constexpr std::wstring_view ViewName = L"RadarLatitudeTimeseriesView";

        static constexpr SQLUSMALLINT RADAR_FIELD_ID = 6;

        RadarLatitudeTimeseriesColumnData( ) = default;

        virtual Kind GetKind() const override
        {
            return Kind::RadarLatitudeTimeseries;
        }

        const Guid& Radar( ) const
        {
            return radar_;
        }
        void SetRadar( const Guid& radar )
        {
            radar_ = radar;
        }
        void BindColumns( const ODBC::Statement& statement )
        {
            Base::BindColumns( statement );

            Bind(statement, RADAR_FIELD_ID, radar_);
        }

        template<IO::StreamWriter StreamT>
        void WriteColumns( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteColumns( destination );
            WriteColumnValue( destination, radar_);
        }
    };

    using SimpleRadarLatitudeTimeseriesDataReader = SimpleColumnDataReader<RadarLatitudeTimeseriesColumnData>;

    class RadarLongitudeTimeseriesColumnData : public DoubleTimeseriesColumnData
    {
        Guid radar_;
    public:
        using Base = DoubleTimeseriesColumnData;

        static constexpr std::wstring_view FieldNames = L"[Id],[RowVersion],[Catalog],[Name],[MaxRetention],[Radar]";
        static constexpr std::wstring_view ViewName = L"RadarLongitudeTimeseriesView";

        static constexpr SQLUSMALLINT RADAR_FIELD_ID = 6;

        RadarLongitudeTimeseriesColumnData( ) = default;

        virtual Kind GetKind() const override
        {
            return Kind::RadarLongitudeTimeseries;
        }

        const Guid& Radar( ) const
        {
            return radar_;
        }
        void SetRadar( const Guid& radar )
        {
            radar_ = radar;
        }
        void BindColumns( const ODBC::Statement& statement )
        {
            Base::BindColumns( statement );

            Bind(statement, RADAR_FIELD_ID, radar_);
        }

        template<IO::StreamWriter StreamT>
        void WriteColumns( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteColumns( destination );
            WriteColumnValue( destination, radar_);
        }
    };

    using SimpleRadarLongitudeTimeseriesDataReader = SimpleColumnDataReader<RadarLongitudeTimeseriesColumnData>;

    class RadomeDewPointTimeseriesColumnData : public DoubleTimeseriesColumnData
    {
        Guid radome_;
    public:
        using Base = DoubleTimeseriesColumnData;

        static constexpr std::wstring_view FieldNames = L"[Id],[RowVersion],[Catalog],[Name],[MaxRetention],[Radome]";
        static constexpr std::wstring_view ViewName = L"RadomeDewPointTimeseriesView";

        static constexpr SQLUSMALLINT RADOME_FIELD_ID = 6;

        RadomeDewPointTimeseriesColumnData( ) = default;

        virtual Kind GetKind() const override
        {
            return Kind::RadomeDewPointTimeseries;
        }

        const Guid& Radome( ) const
        {
            return radome_;
        }
        void SetRadome( const Guid& radome )
        {
            radome_ = radome;
        }
        void BindColumns( const ODBC::Statement& statement )
        {
            Base::BindColumns( statement );

            Bind(statement, RADOME_FIELD_ID, radome_);
        }

        template<IO::StreamWriter StreamT>
        void WriteColumns( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteColumns( destination );
            WriteColumnValue( destination, radome_);
        }
    };

    using SimpleRadomeDewPointTimeseriesDataReader = SimpleColumnDataReader<RadomeDewPointTimeseriesColumnData>;

    class RadomePressureTimeseriesColumnData : public DoubleTimeseriesColumnData
    {
        Guid radome_;
    public:
        using Base = DoubleTimeseriesColumnData;

        static constexpr std::wstring_view FieldNames = L"[Id],[RowVersion],[Catalog],[Name],[MaxRetention],[Radome]";
        static constexpr std::wstring_view ViewName = L"RadomePressureTimeseriesView";

        static constexpr SQLUSMALLINT RADOME_FIELD_ID = 6;

        RadomePressureTimeseriesColumnData( ) = default;

        virtual Kind GetKind() const override
        {
            return Kind::RadomePressureTimeseries;
        }

        const Guid& Radome( ) const
        {
            return radome_;
        }
        void SetRadome( const Guid& radome )
        {
            radome_ = radome;
        }
        void BindColumns( const ODBC::Statement& statement )
        {
            Base::BindColumns( statement );

            Bind(statement, RADOME_FIELD_ID, radome_);
        }

        template<IO::StreamWriter StreamT>
        void WriteColumns( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteColumns( destination );
            WriteColumnValue( destination, radome_);
        }
    };

    using SimpleRadomePressureTimeseriesDataReader = SimpleColumnDataReader<RadomePressureTimeseriesColumnData>;

    class RadomeTemperatureTimeseriesColumnData : public DoubleTimeseriesColumnData
    {
        Guid radome_;
    public:
        using Base = DoubleTimeseriesColumnData;

        static constexpr std::wstring_view FieldNames = L"[Id],[RowVersion],[Catalog],[Name],[MaxRetention],[Radome]";
        static constexpr std::wstring_view ViewName = L"RadomeTemperatureTimeseriesView";

        static constexpr SQLUSMALLINT RADOME_FIELD_ID = 6;

        RadomeTemperatureTimeseriesColumnData( ) = default;

        virtual Kind GetKind() const override
        {
            return Kind::RadomeTemperatureTimeseries;
        }

        const Guid& Radome( ) const
        {
            return radome_;
        }
        void SetRadome( const Guid& radome )
        {
            radome_ = radome;
        }
        void BindColumns( const ODBC::Statement& statement )
        {
            Base::BindColumns( statement );

            Bind(statement, RADOME_FIELD_ID, radome_);
        }

        template<IO::StreamWriter StreamT>
        void WriteColumns( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteColumns( destination );
            WriteColumnValue( destination, radome_);
        }
    };

    using SimpleRadomeTemperatureTimeseriesDataReader = SimpleColumnDataReader<RadomeTemperatureTimeseriesColumnData>;

    class VesselDraughtTimeseriesColumnData : public DoubleTimeseriesColumnData
    {
        Guid vessel_;
    public:
        using Base = DoubleTimeseriesColumnData;

        static constexpr std::wstring_view FieldNames = L"[Id],[RowVersion],[Catalog],[Name],[MaxRetention],[Vessel]";
        static constexpr std::wstring_view ViewName = L"VesselDraughtTimeseriesView";

        static constexpr SQLUSMALLINT VESSEL_FIELD_ID = 6;

        VesselDraughtTimeseriesColumnData( ) = default;

        virtual Kind GetKind() const override
        {
            return Kind::VesselDraughtTimeseries;
        }

        const Guid& Vessel( ) const
        {
            return vessel_;
        }
        void SetVessel( const Guid& vessel )
        {
            vessel_ = vessel;
        }
        void BindColumns( const ODBC::Statement& statement )
        {
            Base::BindColumns( statement );

            Bind(statement, VESSEL_FIELD_ID, vessel_);
        }

        template<IO::StreamWriter StreamT>
        void WriteColumns( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteColumns( destination );
            WriteColumnValue( destination, vessel_);
        }
    };

    using SimpleVesselDraughtTimeseriesDataReader = SimpleColumnDataReader<VesselDraughtTimeseriesColumnData>;

    class ViewLatitudeTimeseriesColumnData : public DoubleTimeseriesColumnData
    {
        Guid view_;
    public:
        using Base = DoubleTimeseriesColumnData;

        static constexpr std::wstring_view FieldNames = L"[Id],[RowVersion],[Catalog],[Name],[MaxRetention],[View]";
        static constexpr std::wstring_view ViewName = L"ViewLatitudeTimeseriesView";

        static constexpr SQLUSMALLINT VIEW_FIELD_ID = 6;

        ViewLatitudeTimeseriesColumnData( ) = default;

        virtual Kind GetKind() const override
        {
            return Kind::ViewLatitudeTimeseries;
        }

        const Guid& View( ) const
        {
            return view_;
        }
        void SetView( const Guid& view )
        {
            view_ = view;
        }
        void BindColumns( const ODBC::Statement& statement )
        {
            Base::BindColumns( statement );

            Bind(statement, VIEW_FIELD_ID, view_);
        }

        template<IO::StreamWriter StreamT>
        void WriteColumns( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteColumns( destination );
            WriteColumnValue( destination, view_);
        }
    };

    using SimpleViewLatitudeTimeseriesDataReader = SimpleColumnDataReader<ViewLatitudeTimeseriesColumnData>;

    class ViewLongitudeTimeseriesColumnData : public DoubleTimeseriesColumnData
    {
        Guid view_;
    public:
        using Base = DoubleTimeseriesColumnData;

        static constexpr std::wstring_view FieldNames = L"[Id],[RowVersion],[Catalog],[Name],[MaxRetention],[View]";
        static constexpr std::wstring_view ViewName = L"ViewLongitudeTimeseriesView";

        static constexpr SQLUSMALLINT VIEW_FIELD_ID = 6;

        ViewLongitudeTimeseriesColumnData( ) = default;

        virtual Kind GetKind() const override
        {
            return Kind::ViewLongitudeTimeseries;
        }

        const Guid& View( ) const
        {
            return view_;
        }
        void SetView( const Guid& view )
        {
            view_ = view;
        }
        void BindColumns( const ODBC::Statement& statement )
        {
            Base::BindColumns( statement );

            Bind(statement, VIEW_FIELD_ID, view_);
        }

        template<IO::StreamWriter StreamT>
        void WriteColumns( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteColumns( destination );
            WriteColumnValue( destination, view_);
        }
    };

    using SimpleViewLongitudeTimeseriesDataReader = SimpleColumnDataReader<ViewLongitudeTimeseriesColumnData>;

    class ViewZoomLevelTimeseriesColumnData : public DoubleTimeseriesColumnData
    {
        Guid view_;
    public:
        using Base = DoubleTimeseriesColumnData;

        static constexpr std::wstring_view FieldNames = L"[Id],[RowVersion],[Catalog],[Name],[MaxRetention],[View]";
        static constexpr std::wstring_view ViewName = L"ViewZoomLevelTimeseriesView";

        static constexpr SQLUSMALLINT VIEW_FIELD_ID = 6;

        ViewZoomLevelTimeseriesColumnData( ) = default;

        virtual Kind GetKind() const override
        {
            return Kind::ViewZoomLevelTimeseries;
        }

        const Guid& View( ) const
        {
            return view_;
        }
        void SetView( const Guid& view )
        {
            view_ = view;
        }
        void BindColumns( const ODBC::Statement& statement )
        {
            Base::BindColumns( statement );

            Bind(statement, VIEW_FIELD_ID, view_);
        }

        template<IO::StreamWriter StreamT>
        void WriteColumns( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteColumns( destination );
            WriteColumnValue( destination, view_);
        }
    };

    using SimpleViewZoomLevelTimeseriesDataReader = SimpleColumnDataReader<ViewZoomLevelTimeseriesColumnData>;

    class WeatherStationAbsoluteHumidityTimeseriesColumnData : public DoubleTimeseriesColumnData
    {
        Guid weatherStation_;
    public:
        using Base = DoubleTimeseriesColumnData;

        static constexpr std::wstring_view FieldNames = L"[Id],[RowVersion],[Catalog],[Name],[MaxRetention],[WeatherStation]";
        static constexpr std::wstring_view ViewName = L"WeatherStationAbsoluteHumidityTimeseriesView";

        static constexpr SQLUSMALLINT WEATHERSTATION_FIELD_ID = 6;

        WeatherStationAbsoluteHumidityTimeseriesColumnData( ) = default;

        virtual Kind GetKind() const override
        {
            return Kind::WeatherStationAbsoluteHumidityTimeseries;
        }

        const Guid& WeatherStation( ) const
        {
            return weatherStation_;
        }
        void SetWeatherStation( const Guid& weatherStation )
        {
            weatherStation_ = weatherStation;
        }
        void BindColumns( const ODBC::Statement& statement )
        {
            Base::BindColumns( statement );

            Bind(statement, WEATHERSTATION_FIELD_ID, weatherStation_);
        }

        template<IO::StreamWriter StreamT>
        void WriteColumns( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteColumns( destination );
            WriteColumnValue( destination, weatherStation_);
        }
    };

    using SimpleWeatherStationAbsoluteHumidityTimeseriesDataReader = SimpleColumnDataReader<WeatherStationAbsoluteHumidityTimeseriesColumnData>;

    class WeatherStationAirTemperatureTimeseriesColumnData : public DoubleTimeseriesColumnData
    {
        Guid weatherStation_;
    public:
        using Base = DoubleTimeseriesColumnData;

        static constexpr std::wstring_view FieldNames = L"[Id],[RowVersion],[Catalog],[Name],[MaxRetention],[WeatherStation]";
        static constexpr std::wstring_view ViewName = L"WeatherStationAirTemperatureTimeseriesView";

        static constexpr SQLUSMALLINT WEATHERSTATION_FIELD_ID = 6;

        WeatherStationAirTemperatureTimeseriesColumnData( ) = default;

        virtual Kind GetKind() const override
        {
            return Kind::WeatherStationAirTemperatureTimeseries;
        }

        const Guid& WeatherStation( ) const
        {
            return weatherStation_;
        }
        void SetWeatherStation( const Guid& weatherStation )
        {
            weatherStation_ = weatherStation;
        }
        void BindColumns( const ODBC::Statement& statement )
        {
            Base::BindColumns( statement );

            Bind(statement, WEATHERSTATION_FIELD_ID, weatherStation_);
        }

        template<IO::StreamWriter StreamT>
        void WriteColumns( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteColumns( destination );
            WriteColumnValue( destination, weatherStation_);
        }
    };

    using SimpleWeatherStationAirTemperatureTimeseriesDataReader = SimpleColumnDataReader<WeatherStationAirTemperatureTimeseriesColumnData>;

    class WeatherStationBarometricPressureTimeseriesColumnData : public DoubleTimeseriesColumnData
    {
        Guid weatherStation_;
    public:
        using Base = DoubleTimeseriesColumnData;

        static constexpr std::wstring_view FieldNames = L"[Id],[RowVersion],[Catalog],[Name],[MaxRetention],[WeatherStation]";
        static constexpr std::wstring_view ViewName = L"WeatherStationBarometricPressureTimeseriesView";

        static constexpr SQLUSMALLINT WEATHERSTATION_FIELD_ID = 6;

        WeatherStationBarometricPressureTimeseriesColumnData( ) = default;

        virtual Kind GetKind() const override
        {
            return Kind::WeatherStationBarometricPressureTimeseries;
        }

        const Guid& WeatherStation( ) const
        {
            return weatherStation_;
        }
        void SetWeatherStation( const Guid& weatherStation )
        {
            weatherStation_ = weatherStation;
        }
        void BindColumns( const ODBC::Statement& statement )
        {
            Base::BindColumns( statement );

            Bind(statement, WEATHERSTATION_FIELD_ID, weatherStation_);
        }

        template<IO::StreamWriter StreamT>
        void WriteColumns( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteColumns( destination );
            WriteColumnValue( destination, weatherStation_);
        }
    };

    using SimpleWeatherStationBarometricPressureTimeseriesDataReader = SimpleColumnDataReader<WeatherStationBarometricPressureTimeseriesColumnData>;

    class WeatherStationDewPointTimeseriesColumnData : public DoubleTimeseriesColumnData
    {
        Guid weatherStation_;
    public:
        using Base = DoubleTimeseriesColumnData;

        static constexpr std::wstring_view FieldNames = L"[Id],[RowVersion],[Catalog],[Name],[MaxRetention],[WeatherStation]";
        static constexpr std::wstring_view ViewName = L"WeatherStationDewPointTimeseriesView";

        static constexpr SQLUSMALLINT WEATHERSTATION_FIELD_ID = 6;

        WeatherStationDewPointTimeseriesColumnData( ) = default;

        virtual Kind GetKind() const override
        {
            return Kind::WeatherStationDewPointTimeseries;
        }

        const Guid& WeatherStation( ) const
        {
            return weatherStation_;
        }
        void SetWeatherStation( const Guid& weatherStation )
        {
            weatherStation_ = weatherStation;
        }
        void BindColumns( const ODBC::Statement& statement )
        {
            Base::BindColumns( statement );

            Bind(statement, WEATHERSTATION_FIELD_ID, weatherStation_);
        }

        template<IO::StreamWriter StreamT>
        void WriteColumns( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteColumns( destination );
            WriteColumnValue( destination, weatherStation_);
        }
    };

    using SimpleWeatherStationDewPointTimeseriesDataReader = SimpleColumnDataReader<WeatherStationDewPointTimeseriesColumnData>;

    class WeatherStationRelativeHumidityTimeseriesColumnData : public DoubleTimeseriesColumnData
    {
        Guid weatherStation_;
    public:
        using Base = DoubleTimeseriesColumnData;

        static constexpr std::wstring_view FieldNames = L"[Id],[RowVersion],[Catalog],[Name],[MaxRetention],[WeatherStation]";
        static constexpr std::wstring_view ViewName = L"WeatherStationRelativeHumidityTimeseriesView";

        static constexpr SQLUSMALLINT WEATHERSTATION_FIELD_ID = 6;

        WeatherStationRelativeHumidityTimeseriesColumnData( ) = default;

        virtual Kind GetKind() const override
        {
            return Kind::WeatherStationRelativeHumidityTimeseries;
        }

        const Guid& WeatherStation( ) const
        {
            return weatherStation_;
        }
        void SetWeatherStation( const Guid& weatherStation )
        {
            weatherStation_ = weatherStation;
        }
        void BindColumns( const ODBC::Statement& statement )
        {
            Base::BindColumns( statement );

            Bind(statement, WEATHERSTATION_FIELD_ID, weatherStation_);
        }

        template<IO::StreamWriter StreamT>
        void WriteColumns( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteColumns( destination );
            WriteColumnValue( destination, weatherStation_);
        }
    };

    using SimpleWeatherStationRelativeHumidityTimeseriesDataReader = SimpleColumnDataReader<WeatherStationRelativeHumidityTimeseriesColumnData>;

    class WeatherStationWaterTemperatureTimeseriesColumnData : public DoubleTimeseriesColumnData
    {
        Guid weatherStation_;
    public:
        using Base = DoubleTimeseriesColumnData;

        static constexpr std::wstring_view FieldNames = L"[Id],[RowVersion],[Catalog],[Name],[MaxRetention],[WeatherStation]";
        static constexpr std::wstring_view ViewName = L"WeatherStationWaterTemperatureTimeseriesView";

        static constexpr SQLUSMALLINT WEATHERSTATION_FIELD_ID = 6;

        WeatherStationWaterTemperatureTimeseriesColumnData( ) = default;

        virtual Kind GetKind() const override
        {
            return Kind::WeatherStationWaterTemperatureTimeseries;
        }

        const Guid& WeatherStation( ) const
        {
            return weatherStation_;
        }
        void SetWeatherStation( const Guid& weatherStation )
        {
            weatherStation_ = weatherStation;
        }
        void BindColumns( const ODBC::Statement& statement )
        {
            Base::BindColumns( statement );

            Bind(statement, WEATHERSTATION_FIELD_ID, weatherStation_);
        }

        template<IO::StreamWriter StreamT>
        void WriteColumns( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteColumns( destination );
            WriteColumnValue( destination, weatherStation_);
        }
    };

    using SimpleWeatherStationWaterTemperatureTimeseriesDataReader = SimpleColumnDataReader<WeatherStationWaterTemperatureTimeseriesColumnData>;

    class WeatherStationWindDirectionTimeseriesColumnData : public DoubleTimeseriesColumnData
    {
        Guid weatherStation_;
    public:
        using Base = DoubleTimeseriesColumnData;

        static constexpr std::wstring_view FieldNames = L"[Id],[RowVersion],[Catalog],[Name],[MaxRetention],[WeatherStation]";
        static constexpr std::wstring_view ViewName = L"WeatherStationWindDirectionTimeseriesView";

        static constexpr SQLUSMALLINT WEATHERSTATION_FIELD_ID = 6;

        WeatherStationWindDirectionTimeseriesColumnData( ) = default;

        virtual Kind GetKind() const override
        {
            return Kind::WeatherStationWindDirectionTimeseries;
        }

        const Guid& WeatherStation( ) const
        {
            return weatherStation_;
        }
        void SetWeatherStation( const Guid& weatherStation )
        {
            weatherStation_ = weatherStation;
        }
        void BindColumns( const ODBC::Statement& statement )
        {
            Base::BindColumns( statement );

            Bind(statement, WEATHERSTATION_FIELD_ID, weatherStation_);
        }

        template<IO::StreamWriter StreamT>
        void WriteColumns( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteColumns( destination );
            WriteColumnValue( destination, weatherStation_);
        }
    };

    using SimpleWeatherStationWindDirectionTimeseriesDataReader = SimpleColumnDataReader<WeatherStationWindDirectionTimeseriesColumnData>;

    class WeatherStationWindSpeedTimeseriesColumnData : public DoubleTimeseriesColumnData
    {
        Guid weatherStation_;
    public:
        using Base = DoubleTimeseriesColumnData;

        static constexpr std::wstring_view FieldNames = L"[Id],[RowVersion],[Catalog],[Name],[MaxRetention],[WeatherStation]";
        static constexpr std::wstring_view ViewName = L"WeatherStationWindSpeedTimeseriesView";

        static constexpr SQLUSMALLINT WEATHERSTATION_FIELD_ID = 6;

        WeatherStationWindSpeedTimeseriesColumnData( ) = default;

        virtual Kind GetKind() const override
        {
            return Kind::WeatherStationWindSpeedTimeseries;
        }

        const Guid& WeatherStation( ) const
        {
            return weatherStation_;
        }
        void SetWeatherStation( const Guid& weatherStation )
        {
            weatherStation_ = weatherStation;
        }
        void BindColumns( const ODBC::Statement& statement )
        {
            Base::BindColumns( statement );

            Bind(statement, WEATHERSTATION_FIELD_ID, weatherStation_);
        }

        template<IO::StreamWriter StreamT>
        void WriteColumns( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteColumns( destination );
            WriteColumnValue( destination, weatherStation_);
        }
    };

    using SimpleWeatherStationWindSpeedTimeseriesDataReader = SimpleColumnDataReader<WeatherStationWindSpeedTimeseriesColumnData>;

    class GeoPosition2DTimeseriesColumnData : public TimeseriesColumnData
    {
    public:
        using Base = TimeseriesColumnData;

        static constexpr std::wstring_view FieldNames = L"[Id],[RowVersion],[Catalog],[Name],[MaxRetention]";
        static constexpr std::wstring_view ViewName = L"GeoPosition2DTimeseriesView";

        GeoPosition2DTimeseriesColumnData( ) = default;

        virtual Kind GetKind() const override
        {
            return Kind::GeoPosition2DTimeseries;
        }

        template<IO::StreamWriter StreamT>
        void WriteColumns( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteColumns( destination );
        }
    };

    using SimpleGeoPosition2DTimeseriesDataReader = SimpleColumnDataReader<GeoPosition2DTimeseriesColumnData>;

    class AisAidToNavigationPositionTimeseriesColumnData : public GeoPosition2DTimeseriesColumnData
    {
        Guid aidToNavigation_;
    public:
        using Base = GeoPosition2DTimeseriesColumnData;

        static constexpr std::wstring_view FieldNames = L"[Id],[RowVersion],[Catalog],[Name],[MaxRetention],[AidToNavigation]";
        static constexpr std::wstring_view ViewName = L"AisAidToNavigationPositionTimeseriesView";

        static constexpr SQLUSMALLINT AIDTONAVIGATION_FIELD_ID = 6;

        AisAidToNavigationPositionTimeseriesColumnData( ) = default;

        virtual Kind GetKind() const override
        {
            return Kind::AisAidToNavigationPositionTimeseries;
        }

        const Guid& AidToNavigation( ) const
        {
            return aidToNavigation_;
        }
        void SetAidToNavigation( const Guid& aidToNavigation )
        {
            aidToNavigation_ = aidToNavigation;
        }
        void BindColumns( const ODBC::Statement& statement )
        {
            Base::BindColumns( statement );

            Bind(statement, AIDTONAVIGATION_FIELD_ID, aidToNavigation_);
        }

        template<IO::StreamWriter StreamT>
        void WriteColumns( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteColumns( destination );
            WriteColumnValue( destination, aidToNavigation_);
        }
    };

    using SimpleAisAidToNavigationPositionTimeseriesDataReader = SimpleColumnDataReader<AisAidToNavigationPositionTimeseriesColumnData>;

    class GeoPosition3DTimeseriesColumnData : public TimeseriesColumnData
    {
    public:
        using Base = TimeseriesColumnData;

        static constexpr std::wstring_view FieldNames = L"[Id],[RowVersion],[Catalog],[Name],[MaxRetention]";
        static constexpr std::wstring_view ViewName = L"GeoPosition3DTimeseriesView";

        GeoPosition3DTimeseriesColumnData( ) = default;

        virtual Kind GetKind() const override
        {
            return Kind::GeoPosition3DTimeseries;
        }

        template<IO::StreamWriter StreamT>
        void WriteColumns( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteColumns( destination );
        }
    };

    using SimpleGeoPosition3DTimeseriesDataReader = SimpleColumnDataReader<GeoPosition3DTimeseriesColumnData>;

    class GuidTimeseriesColumnData : public TimeseriesColumnData
    {
    public:
        using Base = TimeseriesColumnData;

        static constexpr std::wstring_view FieldNames = L"[Id],[RowVersion],[Catalog],[Name],[MaxRetention]";
        static constexpr std::wstring_view ViewName = L"GuidTimeseriesView";

        GuidTimeseriesColumnData( ) = default;

        virtual Kind GetKind() const override
        {
            return Kind::GuidTimeseries;
        }

        template<IO::StreamWriter StreamT>
        void WriteColumns( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteColumns( destination );
        }
    };

    using SimpleGuidTimeseriesDataReader = SimpleColumnDataReader<GuidTimeseriesColumnData>;

    class Int16TimeseriesColumnData : public TimeseriesColumnData
    {
    public:
        using Base = TimeseriesColumnData;

        static constexpr std::wstring_view FieldNames = L"[Id],[RowVersion],[Catalog],[Name],[MaxRetention]";
        static constexpr std::wstring_view ViewName = L"Int16TimeseriesView";

        Int16TimeseriesColumnData( ) = default;

        virtual Kind GetKind() const override
        {
            return Kind::Int16Timeseries;
        }

        template<IO::StreamWriter StreamT>
        void WriteColumns( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteColumns( destination );
        }
    };

    using SimpleInt16TimeseriesDataReader = SimpleColumnDataReader<Int16TimeseriesColumnData>;

    class Int32TimeseriesColumnData : public TimeseriesColumnData
    {
    public:
        using Base = TimeseriesColumnData;

        static constexpr std::wstring_view FieldNames = L"[Id],[RowVersion],[Catalog],[Name],[MaxRetention]";
        static constexpr std::wstring_view ViewName = L"Int32TimeseriesView";

        Int32TimeseriesColumnData( ) = default;

        virtual Kind GetKind() const override
        {
            return Kind::Int32Timeseries;
        }

        template<IO::StreamWriter StreamT>
        void WriteColumns( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteColumns( destination );
        }
    };

    using SimpleInt32TimeseriesDataReader = SimpleColumnDataReader<Int32TimeseriesColumnData>;

    class RadarAzimuthOffsetTimeseriesColumnData : public Int32TimeseriesColumnData
    {
        Guid radar_;
    public:
        using Base = Int32TimeseriesColumnData;

        static constexpr std::wstring_view FieldNames = L"[Id],[RowVersion],[Catalog],[Name],[MaxRetention],[Radar]";
        static constexpr std::wstring_view ViewName = L"RadarAzimuthOffsetTimeseriesView";

        static constexpr SQLUSMALLINT RADAR_FIELD_ID = 6;

        RadarAzimuthOffsetTimeseriesColumnData( ) = default;

        virtual Kind GetKind() const override
        {
            return Kind::RadarAzimuthOffsetTimeseries;
        }

        const Guid& Radar( ) const
        {
            return radar_;
        }
        void SetRadar( const Guid& radar )
        {
            radar_ = radar;
        }
        void BindColumns( const ODBC::Statement& statement )
        {
            Base::BindColumns( statement );

            Bind(statement, RADAR_FIELD_ID, radar_);
        }

        template<IO::StreamWriter StreamT>
        void WriteColumns( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteColumns( destination );
            WriteColumnValue( destination, radar_);
        }
    };

    using SimpleRadarAzimuthOffsetTimeseriesDataReader = SimpleColumnDataReader<RadarAzimuthOffsetTimeseriesColumnData>;

    class RadarFastTimeConstantLevelTimeseriesColumnData : public Int32TimeseriesColumnData
    {
        Guid radar_;
    public:
        using Base = Int32TimeseriesColumnData;

        static constexpr std::wstring_view FieldNames = L"[Id],[RowVersion],[Catalog],[Name],[MaxRetention],[Radar]";
        static constexpr std::wstring_view ViewName = L"RadarFastTimeConstantLevelTimeseriesView";

        static constexpr SQLUSMALLINT RADAR_FIELD_ID = 6;

        RadarFastTimeConstantLevelTimeseriesColumnData( ) = default;

        virtual Kind GetKind() const override
        {
            return Kind::RadarFastTimeConstantLevelTimeseries;
        }

        const Guid& Radar( ) const
        {
            return radar_;
        }
        void SetRadar( const Guid& radar )
        {
            radar_ = radar;
        }
        void BindColumns( const ODBC::Statement& statement )
        {
            Base::BindColumns( statement );

            Bind(statement, RADAR_FIELD_ID, radar_);
        }

        template<IO::StreamWriter StreamT>
        void WriteColumns( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteColumns( destination );
            WriteColumnValue( destination, radar_);
        }
    };

    using SimpleRadarFastTimeConstantLevelTimeseriesDataReader = SimpleColumnDataReader<RadarFastTimeConstantLevelTimeseriesColumnData>;

    class RadarFastTimeConstantModeTimeseriesColumnData : public Int32TimeseriesColumnData
    {
        Guid radar_;
    public:
        using Base = Int32TimeseriesColumnData;

        static constexpr std::wstring_view FieldNames = L"[Id],[RowVersion],[Catalog],[Name],[MaxRetention],[Radar]";
        static constexpr std::wstring_view ViewName = L"RadarFastTimeConstantModeTimeseriesView";

        static constexpr SQLUSMALLINT RADAR_FIELD_ID = 6;

        RadarFastTimeConstantModeTimeseriesColumnData( ) = default;

        virtual Kind GetKind() const override
        {
            return Kind::RadarFastTimeConstantModeTimeseries;
        }

        const Guid& Radar( ) const
        {
            return radar_;
        }
        void SetRadar( const Guid& radar )
        {
            radar_ = radar;
        }
        void BindColumns( const ODBC::Statement& statement )
        {
            Base::BindColumns( statement );

            Bind(statement, RADAR_FIELD_ID, radar_);
        }

        template<IO::StreamWriter StreamT>
        void WriteColumns( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteColumns( destination );
            WriteColumnValue( destination, radar_);
        }
    };

    using SimpleRadarFastTimeConstantModeTimeseriesDataReader = SimpleColumnDataReader<RadarFastTimeConstantModeTimeseriesColumnData>;

    class RadarPulseTimeseriesColumnData : public Int32TimeseriesColumnData
    {
        Guid radar_;
    public:
        using Base = Int32TimeseriesColumnData;

        static constexpr std::wstring_view FieldNames = L"[Id],[RowVersion],[Catalog],[Name],[MaxRetention],[Radar]";
        static constexpr std::wstring_view ViewName = L"RadarPulseTimeseriesView";

        static constexpr SQLUSMALLINT RADAR_FIELD_ID = 6;

        RadarPulseTimeseriesColumnData( ) = default;

        virtual Kind GetKind() const override
        {
            return Kind::RadarPulseTimeseries;
        }

        const Guid& Radar( ) const
        {
            return radar_;
        }
        void SetRadar( const Guid& radar )
        {
            radar_ = radar;
        }
        void BindColumns( const ODBC::Statement& statement )
        {
            Base::BindColumns( statement );

            Bind(statement, RADAR_FIELD_ID, radar_);
        }

        template<IO::StreamWriter StreamT>
        void WriteColumns( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteColumns( destination );
            WriteColumnValue( destination, radar_);
        }
    };

    using SimpleRadarPulseTimeseriesDataReader = SimpleColumnDataReader<RadarPulseTimeseriesColumnData>;

    class RadarSector1EndTimeseriesColumnData : public Int32TimeseriesColumnData
    {
        Guid radar_;
    public:
        using Base = Int32TimeseriesColumnData;

        static constexpr std::wstring_view FieldNames = L"[Id],[RowVersion],[Catalog],[Name],[MaxRetention],[Radar]";
        static constexpr std::wstring_view ViewName = L"RadarSector1EndTimeseriesView";

        static constexpr SQLUSMALLINT RADAR_FIELD_ID = 6;

        RadarSector1EndTimeseriesColumnData( ) = default;

        virtual Kind GetKind() const override
        {
            return Kind::RadarSector1EndTimeseries;
        }

        const Guid& Radar( ) const
        {
            return radar_;
        }
        void SetRadar( const Guid& radar )
        {
            radar_ = radar;
        }
        void BindColumns( const ODBC::Statement& statement )
        {
            Base::BindColumns( statement );

            Bind(statement, RADAR_FIELD_ID, radar_);
        }

        template<IO::StreamWriter StreamT>
        void WriteColumns( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteColumns( destination );
            WriteColumnValue( destination, radar_);
        }
    };

    using SimpleRadarSector1EndTimeseriesDataReader = SimpleColumnDataReader<RadarSector1EndTimeseriesColumnData>;

    class RadarSector1StartTimeseriesColumnData : public Int32TimeseriesColumnData
    {
        Guid radar_;
    public:
        using Base = Int32TimeseriesColumnData;

        static constexpr std::wstring_view FieldNames = L"[Id],[RowVersion],[Catalog],[Name],[MaxRetention],[Radar]";
        static constexpr std::wstring_view ViewName = L"RadarSector1StartTimeseriesView";

        static constexpr SQLUSMALLINT RADAR_FIELD_ID = 6;

        RadarSector1StartTimeseriesColumnData( ) = default;

        virtual Kind GetKind() const override
        {
            return Kind::RadarSector1StartTimeseries;
        }

        const Guid& Radar( ) const
        {
            return radar_;
        }
        void SetRadar( const Guid& radar )
        {
            radar_ = radar;
        }
        void BindColumns( const ODBC::Statement& statement )
        {
            Base::BindColumns( statement );

            Bind(statement, RADAR_FIELD_ID, radar_);
        }

        template<IO::StreamWriter StreamT>
        void WriteColumns( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteColumns( destination );
            WriteColumnValue( destination, radar_);
        }
    };

    using SimpleRadarSector1StartTimeseriesDataReader = SimpleColumnDataReader<RadarSector1StartTimeseriesColumnData>;

    class RadarSector2EndTimeseriesColumnData : public Int32TimeseriesColumnData
    {
        Guid radar_;
    public:
        using Base = Int32TimeseriesColumnData;

        static constexpr std::wstring_view FieldNames = L"[Id],[RowVersion],[Catalog],[Name],[MaxRetention],[Radar]";
        static constexpr std::wstring_view ViewName = L"RadarSector2EndTimeseriesView";

        static constexpr SQLUSMALLINT RADAR_FIELD_ID = 6;

        RadarSector2EndTimeseriesColumnData( ) = default;

        virtual Kind GetKind() const override
        {
            return Kind::RadarSector2EndTimeseries;
        }

        const Guid& Radar( ) const
        {
            return radar_;
        }
        void SetRadar( const Guid& radar )
        {
            radar_ = radar;
        }
        void BindColumns( const ODBC::Statement& statement )
        {
            Base::BindColumns( statement );

            Bind(statement, RADAR_FIELD_ID, radar_);
        }

        template<IO::StreamWriter StreamT>
        void WriteColumns( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteColumns( destination );
            WriteColumnValue( destination, radar_);
        }
    };

    using SimpleRadarSector2EndTimeseriesDataReader = SimpleColumnDataReader<RadarSector2EndTimeseriesColumnData>;

    class RadarSector2StartTimeseriesColumnData : public Int32TimeseriesColumnData
    {
        Guid radar_;
    public:
        using Base = Int32TimeseriesColumnData;

        static constexpr std::wstring_view FieldNames = L"[Id],[RowVersion],[Catalog],[Name],[MaxRetention],[Radar]";
        static constexpr std::wstring_view ViewName = L"RadarSector2StartTimeseriesView";

        static constexpr SQLUSMALLINT RADAR_FIELD_ID = 6;

        RadarSector2StartTimeseriesColumnData( ) = default;

        virtual Kind GetKind() const override
        {
            return Kind::RadarSector2StartTimeseries;
        }

        const Guid& Radar( ) const
        {
            return radar_;
        }
        void SetRadar( const Guid& radar )
        {
            radar_ = radar;
        }
        void BindColumns( const ODBC::Statement& statement )
        {
            Base::BindColumns( statement );

            Bind(statement, RADAR_FIELD_ID, radar_);
        }

        template<IO::StreamWriter StreamT>
        void WriteColumns( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteColumns( destination );
            WriteColumnValue( destination, radar_);
        }
    };

    using SimpleRadarSector2StartTimeseriesDataReader = SimpleColumnDataReader<RadarSector2StartTimeseriesColumnData>;

    class RadarSensitivityTimeControlLevelTimeseriesColumnData : public Int32TimeseriesColumnData
    {
        Guid radar_;
    public:
        using Base = Int32TimeseriesColumnData;

        static constexpr std::wstring_view FieldNames = L"[Id],[RowVersion],[Catalog],[Name],[MaxRetention],[Radar]";
        static constexpr std::wstring_view ViewName = L"RadarSensitivityTimeControlLevelTimeseriesView";

        static constexpr SQLUSMALLINT RADAR_FIELD_ID = 6;

        RadarSensitivityTimeControlLevelTimeseriesColumnData( ) = default;

        virtual Kind GetKind() const override
        {
            return Kind::RadarSensitivityTimeControlLevelTimeseries;
        }

        const Guid& Radar( ) const
        {
            return radar_;
        }
        void SetRadar( const Guid& radar )
        {
            radar_ = radar;
        }
        void BindColumns( const ODBC::Statement& statement )
        {
            Base::BindColumns( statement );

            Bind(statement, RADAR_FIELD_ID, radar_);
        }

        template<IO::StreamWriter StreamT>
        void WriteColumns( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteColumns( destination );
            WriteColumnValue( destination, radar_);
        }
    };

    using SimpleRadarSensitivityTimeControlLevelTimeseriesDataReader = SimpleColumnDataReader<RadarSensitivityTimeControlLevelTimeseriesColumnData>;

    class RadarTuningTimeseriesColumnData : public Int32TimeseriesColumnData
    {
        Guid radar_;
    public:
        using Base = Int32TimeseriesColumnData;

        static constexpr std::wstring_view FieldNames = L"[Id],[RowVersion],[Catalog],[Name],[MaxRetention],[Radar]";
        static constexpr std::wstring_view ViewName = L"RadarTuningTimeseriesView";

        static constexpr SQLUSMALLINT RADAR_FIELD_ID = 6;

        RadarTuningTimeseriesColumnData( ) = default;

        virtual Kind GetKind() const override
        {
            return Kind::RadarTuningTimeseries;
        }

        const Guid& Radar( ) const
        {
            return radar_;
        }
        void SetRadar( const Guid& radar )
        {
            radar_ = radar;
        }
        void BindColumns( const ODBC::Statement& statement )
        {
            Base::BindColumns( statement );

            Bind(statement, RADAR_FIELD_ID, radar_);
        }

        template<IO::StreamWriter StreamT>
        void WriteColumns( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteColumns( destination );
            WriteColumnValue( destination, radar_);
        }
    };

    using SimpleRadarTuningTimeseriesDataReader = SimpleColumnDataReader<RadarTuningTimeseriesColumnData>;

    class VesselPersonsOnBoardTimeseriesColumnData : public Int32TimeseriesColumnData
    {
        Guid vessel_;
    public:
        using Base = Int32TimeseriesColumnData;

        static constexpr std::wstring_view FieldNames = L"[Id],[RowVersion],[Catalog],[Name],[MaxRetention],[Vessel]";
        static constexpr std::wstring_view ViewName = L"VesselPersonsOnBoardTimeseriesView";

        static constexpr SQLUSMALLINT VESSEL_FIELD_ID = 6;

        VesselPersonsOnBoardTimeseriesColumnData( ) = default;

        virtual Kind GetKind() const override
        {
            return Kind::VesselPersonsOnBoardTimeseries;
        }

        const Guid& Vessel( ) const
        {
            return vessel_;
        }
        void SetVessel( const Guid& vessel )
        {
            vessel_ = vessel;
        }
        void BindColumns( const ODBC::Statement& statement )
        {
            Base::BindColumns( statement );

            Bind(statement, VESSEL_FIELD_ID, vessel_);
        }

        template<IO::StreamWriter StreamT>
        void WriteColumns( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteColumns( destination );
            WriteColumnValue( destination, vessel_);
        }
    };

    using SimpleVesselPersonsOnBoardTimeseriesDataReader = SimpleColumnDataReader<VesselPersonsOnBoardTimeseriesColumnData>;

    class Int64TimeseriesColumnData : public TimeseriesColumnData
    {
    public:
        using Base = TimeseriesColumnData;

        static constexpr std::wstring_view FieldNames = L"[Id],[RowVersion],[Catalog],[Name],[MaxRetention]";
        static constexpr std::wstring_view ViewName = L"Int64TimeseriesView";

        Int64TimeseriesColumnData( ) = default;

        virtual Kind GetKind() const override
        {
            return Kind::Int64Timeseries;
        }

        template<IO::StreamWriter StreamT>
        void WriteColumns( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteColumns( destination );
        }
    };

    using SimpleInt64TimeseriesDataReader = SimpleColumnDataReader<Int64TimeseriesColumnData>;

    class Position2DTimeseriesColumnData : public TimeseriesColumnData
    {
    public:
        using Base = TimeseriesColumnData;

        static constexpr std::wstring_view FieldNames = L"[Id],[RowVersion],[Catalog],[Name],[MaxRetention]";
        static constexpr std::wstring_view ViewName = L"Position2DTimeseriesView";

        Position2DTimeseriesColumnData( ) = default;

        virtual Kind GetKind() const override
        {
            return Kind::Position2DTimeseries;
        }

        template<IO::StreamWriter StreamT>
        void WriteColumns( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteColumns( destination );
        }
    };

    using SimplePosition2DTimeseriesDataReader = SimpleColumnDataReader<Position2DTimeseriesColumnData>;

    class Position3DTimeseriesColumnData : public TimeseriesColumnData
    {
    public:
        using Base = TimeseriesColumnData;

        static constexpr std::wstring_view FieldNames = L"[Id],[RowVersion],[Catalog],[Name],[MaxRetention]";
        static constexpr std::wstring_view ViewName = L"Position3DTimeseriesView";

        Position3DTimeseriesColumnData( ) = default;

        virtual Kind GetKind() const override
        {
            return Kind::Position3DTimeseries;
        }

        template<IO::StreamWriter StreamT>
        void WriteColumns( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteColumns( destination );
        }
    };

    using SimplePosition3DTimeseriesDataReader = SimpleColumnDataReader<Position3DTimeseriesColumnData>;

    class ReferenceTimeseriesColumnData : public TimeseriesColumnData
    {
    public:
        using Base = TimeseriesColumnData;

        static constexpr std::wstring_view FieldNames = L"[Id],[RowVersion],[Catalog],[Name],[MaxRetention]";
        static constexpr std::wstring_view ViewName = L"ReferenceTimeseriesView";

        ReferenceTimeseriesColumnData( ) = default;

        virtual Kind GetKind() const override
        {
            return Kind::ReferenceTimeseries;
        }

        template<IO::StreamWriter StreamT>
        void WriteColumns( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteColumns( destination );
        }
    };

    using SimpleReferenceTimeseriesDataReader = SimpleColumnDataReader<ReferenceTimeseriesColumnData>;

    class SByteTimeseriesColumnData : public TimeseriesColumnData
    {
    public:
        using Base = TimeseriesColumnData;

        static constexpr std::wstring_view FieldNames = L"[Id],[RowVersion],[Catalog],[Name],[MaxRetention]";
        static constexpr std::wstring_view ViewName = L"SByteTimeseriesView";

        SByteTimeseriesColumnData( ) = default;

        virtual Kind GetKind() const override
        {
            return Kind::SByteTimeseries;
        }

        template<IO::StreamWriter StreamT>
        void WriteColumns( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteColumns( destination );
        }
    };

    using SimpleSByteTimeseriesDataReader = SimpleColumnDataReader<SByteTimeseriesColumnData>;

    class SingleTimeseriesColumnData : public TimeseriesColumnData
    {
    public:
        using Base = TimeseriesColumnData;

        static constexpr std::wstring_view FieldNames = L"[Id],[RowVersion],[Catalog],[Name],[MaxRetention]";
        static constexpr std::wstring_view ViewName = L"SingleTimeseriesView";

        SingleTimeseriesColumnData( ) = default;

        virtual Kind GetKind() const override
        {
            return Kind::SingleTimeseries;
        }

        template<IO::StreamWriter StreamT>
        void WriteColumns( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteColumns( destination );
        }
    };

    using SimpleSingleTimeseriesDataReader = SimpleColumnDataReader<SingleTimeseriesColumnData>;

    class StringTimeseriesColumnData : public TimeseriesColumnData
    {
    public:
        using Base = TimeseriesColumnData;

        static constexpr std::wstring_view FieldNames = L"[Id],[RowVersion],[Catalog],[Name],[MaxRetention]";
        static constexpr std::wstring_view ViewName = L"StringTimeseriesView";

        StringTimeseriesColumnData( ) = default;

        virtual Kind GetKind() const override
        {
            return Kind::StringTimeseries;
        }

        template<IO::StreamWriter StreamT>
        void WriteColumns( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteColumns( destination );
        }
    };

    using SimpleStringTimeseriesDataReader = SimpleColumnDataReader<StringTimeseriesColumnData>;

    class TimeSpanTimeseriesColumnData : public TimeseriesColumnData
    {
    public:
        using Base = TimeseriesColumnData;

        static constexpr std::wstring_view FieldNames = L"[Id],[RowVersion],[Catalog],[Name],[MaxRetention]";
        static constexpr std::wstring_view ViewName = L"TimeSpanTimeseriesView";

        TimeSpanTimeseriesColumnData( ) = default;

        virtual Kind GetKind() const override
        {
            return Kind::TimeSpanTimeseries;
        }

        template<IO::StreamWriter StreamT>
        void WriteColumns( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteColumns( destination );
        }
    };

    using SimpleTimeSpanTimeseriesDataReader = SimpleColumnDataReader<TimeSpanTimeseriesColumnData>;

    class UInt16TimeseriesColumnData : public TimeseriesColumnData
    {
    public:
        using Base = TimeseriesColumnData;

        static constexpr std::wstring_view FieldNames = L"[Id],[RowVersion],[Catalog],[Name],[MaxRetention]";
        static constexpr std::wstring_view ViewName = L"UInt16TimeseriesView";

        UInt16TimeseriesColumnData( ) = default;

        virtual Kind GetKind() const override
        {
            return Kind::UInt16Timeseries;
        }

        template<IO::StreamWriter StreamT>
        void WriteColumns( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteColumns( destination );
        }
    };

    using SimpleUInt16TimeseriesDataReader = SimpleColumnDataReader<UInt16TimeseriesColumnData>;

    class UInt32TimeseriesColumnData : public TimeseriesColumnData
    {
    public:
        using Base = TimeseriesColumnData;

        static constexpr std::wstring_view FieldNames = L"[Id],[RowVersion],[Catalog],[Name],[MaxRetention]";
        static constexpr std::wstring_view ViewName = L"UInt32TimeseriesView";

        UInt32TimeseriesColumnData( ) = default;

        virtual Kind GetKind() const override
        {
            return Kind::UInt32Timeseries;
        }

        template<IO::StreamWriter StreamT>
        void WriteColumns( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteColumns( destination );
        }
    };

    using SimpleUInt32TimeseriesDataReader = SimpleColumnDataReader<UInt32TimeseriesColumnData>;

    class RadomeStatusTimeseriesColumnData : public UInt32TimeseriesColumnData
    {
        Guid radome_;
    public:
        using Base = UInt32TimeseriesColumnData;

        static constexpr std::wstring_view FieldNames = L"[Id],[RowVersion],[Catalog],[Name],[MaxRetention],[Radome]";
        static constexpr std::wstring_view ViewName = L"RadomeStatusTimeseriesView";

        static constexpr SQLUSMALLINT RADOME_FIELD_ID = 6;

        RadomeStatusTimeseriesColumnData( ) = default;

        virtual Kind GetKind() const override
        {
            return Kind::RadomeStatusTimeseries;
        }

        const Guid& Radome( ) const
        {
            return radome_;
        }
        void SetRadome( const Guid& radome )
        {
            radome_ = radome;
        }
        void BindColumns( const ODBC::Statement& statement )
        {
            Base::BindColumns( statement );

            Bind(statement, RADOME_FIELD_ID, radome_);
        }

        template<IO::StreamWriter StreamT>
        void WriteColumns( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteColumns( destination );
            WriteColumnValue( destination, radome_);
        }
    };

    using SimpleRadomeStatusTimeseriesDataReader = SimpleColumnDataReader<RadomeStatusTimeseriesColumnData>;

    class UInt64TimeseriesColumnData : public TimeseriesColumnData
    {
    public:
        using Base = TimeseriesColumnData;

        static constexpr std::wstring_view FieldNames = L"[Id],[RowVersion],[Catalog],[Name],[MaxRetention]";
        static constexpr std::wstring_view ViewName = L"UInt64TimeseriesView";

        UInt64TimeseriesColumnData( ) = default;

        virtual Kind GetKind() const override
        {
            return Kind::UInt64Timeseries;
        }

        template<IO::StreamWriter StreamT>
        void WriteColumns( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteColumns( destination );
        }
    };

    using SimpleUInt64TimeseriesDataReader = SimpleColumnDataReader<UInt64TimeseriesColumnData>;

    class TimeseriesCatalogColumnData : public TimeseriesCatalogElementColumnData
    {
    public:
        using Base = TimeseriesCatalogElementColumnData;

        static constexpr std::wstring_view FieldNames = L"[Id],[RowVersion],[Catalog],[Name]";
        static constexpr std::wstring_view ViewName = L"TimeseriesCatalogView";

        TimeseriesCatalogColumnData( ) = default;

        virtual Kind GetKind() const override
        {
            return Kind::TimeseriesCatalog;
        }

        template<IO::StreamWriter StreamT>
        void WriteColumns( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteColumns( destination );
        }
    };

    using SimpleTimeseriesCatalogDataReader = SimpleColumnDataReader<TimeseriesCatalogColumnData>;

    class TimeseriesInfoColumnData : public BaseColumnData
    {
        Guid id_;
        Int64 rowVersion_ = 0;
        DBDateTime firstTimestamp_;
        DBDateTime lastTimestamp_;
        Int64 count_ = 0;
    public:
        using Base = BaseColumnData;

        static constexpr std::wstring_view FieldNames = L"[Id],[RowVersion],[FirstTimestamp],[LastTimestamp],[Count]";
        static constexpr std::wstring_view ViewName = L"TimeseriesInfoView";

        static constexpr SQLUSMALLINT ID_FIELD_ID = 1;
        static constexpr SQLUSMALLINT ROWVERSION_FIELD_ID = 2;
        static constexpr SQLUSMALLINT FIRSTTIMESTAMP_FIELD_ID = 3;
        static constexpr SQLUSMALLINT LASTTIMESTAMP_FIELD_ID = 4;
        static constexpr SQLUSMALLINT COUNT_FIELD_ID = 5;

        TimeseriesInfoColumnData( ) = default;

        virtual Kind GetKind() const override
        {
            return Kind::TimeseriesInfo;
        }

        const Guid& Id( ) const
        {
            return id_;
        }
        void SetId( const Guid& id )
        {
            id_ = id;
        }
        Int64 RowVersion( ) const
        {
            return rowVersion_;
        }
        void SetRowVersion( const Int64& rowVersion )
        {
            rowVersion_ = rowVersion;
        }
        const DBDateTime& FirstTimestamp( ) const
        {
            return firstTimestamp_;
        }
        void SetFirstTimestamp( const DBDateTime& firstTimestamp )
        {
            firstTimestamp_ = firstTimestamp;
        }
        const DBDateTime& LastTimestamp( ) const
        {
            return lastTimestamp_;
        }
        void SetLastTimestamp( const DBDateTime& lastTimestamp )
        {
            lastTimestamp_ = lastTimestamp;
        }
        Int64 Count( ) const
        {
            return count_;
        }
        void SetCount( Int64 count )
        {
            count_ = count;
        }
        void BindColumns( const ODBC::Statement& statement )
        {
            Bind(statement, ID_FIELD_ID, id_);
            Bind(statement, ROWVERSION_FIELD_ID, rowVersion_);
            Bind(statement, FIRSTTIMESTAMP_FIELD_ID, firstTimestamp_);
            Bind(statement, LASTTIMESTAMP_FIELD_ID, lastTimestamp_);
            Bind(statement, COUNT_FIELD_ID, count_);
        }

        template<IO::StreamWriter StreamT>
        void WriteColumns( IO::BinaryWriter<StreamT>& destination ) const
        {
            WriteColumnValue( destination, id_);
            WriteColumnValue( destination, rowVersion_);
            WriteColumnValue( destination, firstTimestamp_);
            WriteColumnValue( destination, lastTimestamp_);
            WriteColumnValue( destination, count_);
        }
    };

    using SimpleTimeseriesInfoDataReader = SimpleColumnDataReader<TimeseriesInfoColumnData>;

    class TimeSpanTimeseriesValueColumnData : public BaseColumnData
    {
        Guid id_;
        Int64 rowVersion_ = 0;
        Guid timeseries_;
        DateTime timestamp_;
        DBTimeSpan value_;
    public:
        using Base = BaseColumnData;

        static constexpr std::wstring_view FieldNames = L"[Id],[RowVersion],[Timeseries],[Timestamp],[Value]";
        static constexpr std::wstring_view ViewName = L"TimeSpanTimeseriesValueView";

        static constexpr SQLUSMALLINT ID_FIELD_ID = 1;
        static constexpr SQLUSMALLINT ROWVERSION_FIELD_ID = 2;
        static constexpr SQLUSMALLINT TIMESERIES_FIELD_ID = 3;
        static constexpr SQLUSMALLINT TIMESTAMP_FIELD_ID = 4;
        static constexpr SQLUSMALLINT VALUE_FIELD_ID = 5;

        TimeSpanTimeseriesValueColumnData( ) = default;

        virtual Kind GetKind() const override
        {
            return Kind::TimeSpanTimeseriesValue;
        }

        const Guid& Id( ) const
        {
            return id_;
        }
        void SetId( const Guid& id )
        {
            id_ = id;
        }
        Int64 RowVersion( ) const
        {
            return rowVersion_;
        }
        void SetRowVersion( const Int64& rowVersion )
        {
            rowVersion_ = rowVersion;
        }
        const Guid& Timeseries( ) const
        {
            return timeseries_;
        }
        void SetTimeseries( const Guid& timeseries )
        {
            timeseries_ = timeseries;
        }
        const DateTime& Timestamp( ) const
        {
            return timestamp_;
        }
        void SetTimestamp( const DateTime& timestamp )
        {
            timestamp_ = timestamp;
        }
        const DBTimeSpan& Value( ) const
        {
            return value_;
        }
        void SetValue( const DBTimeSpan& value )
        {
            value_ = value;
        }
        void BindColumns( const ODBC::Statement& statement )
        {
            Bind(statement, ID_FIELD_ID, id_);
            Bind(statement, ROWVERSION_FIELD_ID, rowVersion_);
            Bind(statement, TIMESERIES_FIELD_ID, timeseries_);
            Bind(statement, TIMESTAMP_FIELD_ID, timestamp_);
            Bind(statement, VALUE_FIELD_ID, value_);
        }

        template<IO::StreamWriter StreamT>
        void WriteColumns( IO::BinaryWriter<StreamT>& destination ) const
        {
            WriteColumnValue( destination, id_);
            WriteColumnValue( destination, rowVersion_);
            WriteColumnValue( destination, timeseries_);
            WriteColumnValue( destination, timestamp_);
            WriteColumnValue( destination, value_);
        }
    };

    using SimpleTimeSpanTimeseriesValueDataReader = SimpleColumnDataReader<TimeSpanTimeseriesValueColumnData>;

    class TrackableItemTrackLinkColumnData : public BaseColumnData
    {
        Guid id_;
        Int64 rowVersion_ = 0;
        Guid item_;
        Guid track_;
        DateTime start_;
        DBDateTime end_;
    public:
        using Base = BaseColumnData;

        static constexpr std::wstring_view FieldNames = L"[Id],[RowVersion],[Item],[Track],[Start],[End]";
        static constexpr std::wstring_view ViewName = L"TrackableItemTrackLinkView";

        static constexpr SQLUSMALLINT ID_FIELD_ID = 1;
        static constexpr SQLUSMALLINT ROWVERSION_FIELD_ID = 2;
        static constexpr SQLUSMALLINT ITEM_FIELD_ID = 3;
        static constexpr SQLUSMALLINT TRACK_FIELD_ID = 4;
        static constexpr SQLUSMALLINT START_FIELD_ID = 5;
        static constexpr SQLUSMALLINT END_FIELD_ID = 6;

        TrackableItemTrackLinkColumnData( ) = default;

        virtual Kind GetKind() const override
        {
            return Kind::TrackableItemTrackLink;
        }

        const Guid& Id( ) const
        {
            return id_;
        }
        void SetId( const Guid& id )
        {
            id_ = id;
        }
        Int64 RowVersion( ) const
        {
            return rowVersion_;
        }
        void SetRowVersion( const Int64& rowVersion )
        {
            rowVersion_ = rowVersion;
        }
        const Guid& Item( ) const
        {
            return item_;
        }
        void SetItem( const Guid& item )
        {
            item_ = item;
        }
        const Guid& Track( ) const
        {
            return track_;
        }
        void SetTrack( const Guid& track )
        {
            track_ = track;
        }
        const DateTime& Start( ) const
        {
            return start_;
        }
        void SetStart( const DateTime& start )
        {
            start_ = start;
        }
        const DBDateTime& End( ) const
        {
            return end_;
        }
        void SetEnd( const DBDateTime& end )
        {
            end_ = end;
        }
        void BindColumns( const ODBC::Statement& statement )
        {
            Bind(statement, ID_FIELD_ID, id_);
            Bind(statement, ROWVERSION_FIELD_ID, rowVersion_);
            Bind(statement, ITEM_FIELD_ID, item_);
            Bind(statement, TRACK_FIELD_ID, track_);
            Bind(statement, START_FIELD_ID, start_);
            Bind(statement, END_FIELD_ID, end_);
        }

        template<IO::StreamWriter StreamT>
        void WriteColumns( IO::BinaryWriter<StreamT>& destination ) const
        {
            WriteColumnValue( destination, id_);
            WriteColumnValue( destination, rowVersion_);
            WriteColumnValue( destination, item_);
            WriteColumnValue( destination, track_);
            WriteColumnValue( destination, start_);
            WriteColumnValue( destination, end_);
        }
    };

    using SimpleTrackableItemTrackLinkDataReader = SimpleColumnDataReader<TrackableItemTrackLinkColumnData>;

    class TrackBaseColumnData : public BaseColumnData
    {
        Guid id_;
        Int64 rowVersion_ = 0;
        Guid tracker_;
        Int64 trackNumber_ = 0;
        DateTime timestamp_;
    public:
        using Base = BaseColumnData;

        static constexpr std::wstring_view FieldNames = L"[Id],[RowVersion],[Tracker],[TrackNumber],[Timestamp]";
        static constexpr std::wstring_view ViewName = L"TrackBaseView";

        static constexpr SQLUSMALLINT ID_FIELD_ID = 1;
        static constexpr SQLUSMALLINT ROWVERSION_FIELD_ID = 2;
        static constexpr SQLUSMALLINT TRACKER_FIELD_ID = 3;
        static constexpr SQLUSMALLINT TRACKNUMBER_FIELD_ID = 4;
        static constexpr SQLUSMALLINT TIMESTAMP_FIELD_ID = 5;

        TrackBaseColumnData( ) = default;

        virtual Kind GetKind() const override
        {
            return Kind::TrackBase;
        }

        const Guid& Id( ) const
        {
            return id_;
        }
        void SetId( const Guid& id )
        {
            id_ = id;
        }
        Int64 RowVersion( ) const
        {
            return rowVersion_;
        }
        void SetRowVersion( const Int64& rowVersion )
        {
            rowVersion_ = rowVersion;
        }
        const Guid& Tracker( ) const
        {
            return tracker_;
        }
        void SetTracker( const Guid& tracker )
        {
            tracker_ = tracker;
        }
        Int64 TrackNumber( ) const
        {
            return trackNumber_;
        }
        void SetTrackNumber( Int64 trackNumber )
        {
            trackNumber_ = trackNumber;
        }
        const DateTime& Timestamp( ) const
        {
            return timestamp_;
        }
        void SetTimestamp( const DateTime& timestamp )
        {
            timestamp_ = timestamp;
        }
        void BindColumns( const ODBC::Statement& statement )
        {
            Bind(statement, ID_FIELD_ID, id_);
            Bind(statement, ROWVERSION_FIELD_ID, rowVersion_);
            Bind(statement, TRACKER_FIELD_ID, tracker_);
            Bind(statement, TRACKNUMBER_FIELD_ID, trackNumber_);
            Bind(statement, TIMESTAMP_FIELD_ID, timestamp_);
        }

        template<IO::StreamWriter StreamT>
        void WriteColumns( IO::BinaryWriter<StreamT>& destination ) const
        {
            WriteColumnValue( destination, id_);
            WriteColumnValue( destination, rowVersion_);
            WriteColumnValue( destination, tracker_);
            WriteColumnValue( destination, trackNumber_);
            WriteColumnValue( destination, timestamp_);
        }
    };

    using SimpleTrackBaseDataReader = SimpleColumnDataReader<TrackBaseColumnData>;

    class TrackColumnData : public TrackBaseColumnData
    {
    public:
        using Base = TrackBaseColumnData;

        static constexpr std::wstring_view FieldNames = L"[Id],[RowVersion],[Tracker],[TrackNumber],[Timestamp]";
        static constexpr std::wstring_view ViewName = L"TrackView";

        TrackColumnData( ) = default;

        virtual Kind GetKind() const override
        {
            return Kind::Track;
        }

        template<IO::StreamWriter StreamT>
        void WriteColumns( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteColumns( destination );
        }
    };

    using SimpleTrackDataReader = SimpleColumnDataReader<TrackColumnData>;

    class Track3DColumnData : public TrackBaseColumnData
    {
    public:
        using Base = TrackBaseColumnData;

        static constexpr std::wstring_view FieldNames = L"[Id],[RowVersion],[Tracker],[TrackNumber],[Timestamp]";
        static constexpr std::wstring_view ViewName = L"Track3DView";

        Track3DColumnData( ) = default;

        virtual Kind GetKind() const override
        {
            return Kind::Track3D;
        }

        template<IO::StreamWriter StreamT>
        void WriteColumns( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteColumns( destination );
        }
    };

    using SimpleTrack3DDataReader = SimpleColumnDataReader<Track3DColumnData>;

    class TrackerFilterParametersColumnData : public BaseColumnData
    {
        Guid id_;
        Int64 rowVersion_ = 0;
        Guid tracker_;
        FixedDBWideString<100> name_;
    public:
        using Base = BaseColumnData;

        static constexpr std::wstring_view FieldNames = L"[Id],[RowVersion],[Tracker],[Name]";
        static constexpr std::wstring_view ViewName = L"TrackerFilterParametersView";

        static constexpr SQLUSMALLINT ID_FIELD_ID = 1;
        static constexpr SQLUSMALLINT ROWVERSION_FIELD_ID = 2;
        static constexpr SQLUSMALLINT TRACKER_FIELD_ID = 3;
        static constexpr SQLUSMALLINT NAME_FIELD_ID = 4;

        TrackerFilterParametersColumnData( ) = default;

        virtual Kind GetKind() const override
        {
            return Kind::TrackerFilterParameters;
        }

        const Guid& Id( ) const
        {
            return id_;
        }
        void SetId( const Guid& id )
        {
            id_ = id;
        }
        Int64 RowVersion( ) const
        {
            return rowVersion_;
        }
        void SetRowVersion( const Int64& rowVersion )
        {
            rowVersion_ = rowVersion;
        }
        const Guid& Tracker( ) const
        {
            return tracker_;
        }
        void SetTracker( const Guid& tracker )
        {
            tracker_ = tracker;
        }
        const FixedDBWideString<100>& Name( ) const
        {
            return name_;
        }
        void SetName( const WideString& name )
        {
            name_ = name;
        }
        void BindColumns( const ODBC::Statement& statement )
        {
            Bind(statement, ID_FIELD_ID, id_);
            Bind(statement, ROWVERSION_FIELD_ID, rowVersion_);
            Bind(statement, TRACKER_FIELD_ID, tracker_);
            Bind(statement, NAME_FIELD_ID, name_);
        }

        template<IO::StreamWriter StreamT>
        void WriteColumns( IO::BinaryWriter<StreamT>& destination ) const
        {
            WriteColumnValue( destination, id_);
            WriteColumnValue( destination, rowVersion_);
            WriteColumnValue( destination, tracker_);
            WriteColumnValue( destination, name_);
        }
    };

    using SimpleTrackerFilterParametersDataReader = SimpleColumnDataReader<TrackerFilterParametersColumnData>;

    class TrackerFilterParametersConfigurationColumnData : public BaseColumnData
    {
        Guid id_;
        Int64 rowVersion_ = 0;
        Guid parameters_;
        DateTime timestamp_;
        bool useNaivePredictor_ = false;
        Int32 numberOfPoints_ = 0;
        Int32 windowSize_ = 0;
        Int32 stabilizeCount_ = 0;
        Int32 maxBadPoints_ = 0;
        Data::TrackerFilterModelType modelType_ = Data::TrackerFilterModelType::Unknown;
        double sigmaR_ = 0.0;
        double sigmaAcc_ = 0.0;
        double tauVel_ = 0.0;
        double tauAcc_ = 0.0;
        double deltaRMin_ = 0.0;
        double deltaVMax_ = 0.0;
        double deltaAMax_ = 0.0;
    public:
        using Base = BaseColumnData;

        static constexpr std::wstring_view FieldNames = L"[Id],[RowVersion],[Parameters],[Timestamp],[UseNaivePredictor],[NumberOfPoints],[WindowSize],[StabilizeCount],[MaxBadPoints],[ModelType],[SigmaR],[SigmaAcc],[TauVel],[TauAcc],[DeltaRMin],[DeltaVMax],[DeltaAMax]";
        static constexpr std::wstring_view ViewName = L"TrackerFilterParametersConfigurationView";

        static constexpr SQLUSMALLINT ID_FIELD_ID = 1;
        static constexpr SQLUSMALLINT ROWVERSION_FIELD_ID = 2;
        static constexpr SQLUSMALLINT PARAMETERS_FIELD_ID = 3;
        static constexpr SQLUSMALLINT TIMESTAMP_FIELD_ID = 4;
        static constexpr SQLUSMALLINT USENAIVEPREDICTOR_FIELD_ID = 5;
        static constexpr SQLUSMALLINT NUMBEROFPOINTS_FIELD_ID = 6;
        static constexpr SQLUSMALLINT WINDOWSIZE_FIELD_ID = 7;
        static constexpr SQLUSMALLINT STABILIZECOUNT_FIELD_ID = 8;
        static constexpr SQLUSMALLINT MAXBADPOINTS_FIELD_ID = 9;
        static constexpr SQLUSMALLINT MODELTYPE_FIELD_ID = 10;
        static constexpr SQLUSMALLINT SIGMAR_FIELD_ID = 11;
        static constexpr SQLUSMALLINT SIGMAACC_FIELD_ID = 12;
        static constexpr SQLUSMALLINT TAUVEL_FIELD_ID = 13;
        static constexpr SQLUSMALLINT TAUACC_FIELD_ID = 14;
        static constexpr SQLUSMALLINT DELTARMIN_FIELD_ID = 15;
        static constexpr SQLUSMALLINT DELTAVMAX_FIELD_ID = 16;
        static constexpr SQLUSMALLINT DELTAAMAX_FIELD_ID = 17;

        TrackerFilterParametersConfigurationColumnData( ) = default;

        virtual Kind GetKind() const override
        {
            return Kind::TrackerFilterParametersConfiguration;
        }

        const Guid& Id( ) const
        {
            return id_;
        }
        void SetId( const Guid& id )
        {
            id_ = id;
        }
        Int64 RowVersion( ) const
        {
            return rowVersion_;
        }
        void SetRowVersion( const Int64& rowVersion )
        {
            rowVersion_ = rowVersion;
        }
        const Guid& Parameters( ) const
        {
            return parameters_;
        }
        void SetParameters( const Guid& parameters )
        {
            parameters_ = parameters;
        }
        const DateTime& Timestamp( ) const
        {
            return timestamp_;
        }
        void SetTimestamp( const DateTime& timestamp )
        {
            timestamp_ = timestamp;
        }
        bool UseNaivePredictor( ) const
        {
            return useNaivePredictor_;
        }
        void SetUseNaivePredictor( bool useNaivePredictor )
        {
            useNaivePredictor_ = useNaivePredictor;
        }
        Int32 NumberOfPoints( ) const
        {
            return numberOfPoints_;
        }
        void SetNumberOfPoints( Int32 numberOfPoints )
        {
            numberOfPoints_ = numberOfPoints;
        }
        Int32 WindowSize( ) const
        {
            return windowSize_;
        }
        void SetWindowSize( Int32 windowSize )
        {
            windowSize_ = windowSize;
        }
        Int32 StabilizeCount( ) const
        {
            return stabilizeCount_;
        }
        void SetStabilizeCount( Int32 stabilizeCount )
        {
            stabilizeCount_ = stabilizeCount;
        }
        Int32 MaxBadPoints( ) const
        {
            return maxBadPoints_;
        }
        void SetMaxBadPoints( Int32 maxBadPoints )
        {
            maxBadPoints_ = maxBadPoints;
        }
        Data::TrackerFilterModelType ModelType( ) const
        {
            return modelType_;
        }
        void SetModelType( Data::TrackerFilterModelType modelType )
        {
            modelType_ = modelType;
        }
        double SigmaR( ) const
        {
            return sigmaR_;
        }
        void SetSigmaR( double sigmaR )
        {
            sigmaR_ = sigmaR;
        }
        double SigmaAcc( ) const
        {
            return sigmaAcc_;
        }
        void SetSigmaAcc( double sigmaAcc )
        {
            sigmaAcc_ = sigmaAcc;
        }
        double TauVel( ) const
        {
            return tauVel_;
        }
        void SetTauVel( double tauVel )
        {
            tauVel_ = tauVel;
        }
        double TauAcc( ) const
        {
            return tauAcc_;
        }
        void SetTauAcc( double tauAcc )
        {
            tauAcc_ = tauAcc;
        }
        double DeltaRMin( ) const
        {
            return deltaRMin_;
        }
        void SetDeltaRMin( double deltaRMin )
        {
            deltaRMin_ = deltaRMin;
        }
        double DeltaVMax( ) const
        {
            return deltaVMax_;
        }
        void SetDeltaVMax( double deltaVMax )
        {
            deltaVMax_ = deltaVMax;
        }
        double DeltaAMax( ) const
        {
            return deltaAMax_;
        }
        void SetDeltaAMax( double deltaAMax )
        {
            deltaAMax_ = deltaAMax;
        }
        void BindColumns( const ODBC::Statement& statement )
        {
            Bind(statement, ID_FIELD_ID, id_);
            Bind(statement, ROWVERSION_FIELD_ID, rowVersion_);
            Bind(statement, PARAMETERS_FIELD_ID, parameters_);
            Bind(statement, TIMESTAMP_FIELD_ID, timestamp_);
            Bind(statement, USENAIVEPREDICTOR_FIELD_ID, useNaivePredictor_);
            Bind(statement, NUMBEROFPOINTS_FIELD_ID, numberOfPoints_);
            Bind(statement, WINDOWSIZE_FIELD_ID, windowSize_);
            Bind(statement, STABILIZECOUNT_FIELD_ID, stabilizeCount_);
            Bind(statement, MAXBADPOINTS_FIELD_ID, maxBadPoints_);
            Bind(statement, MODELTYPE_FIELD_ID, modelType_);
            Bind(statement, SIGMAR_FIELD_ID, sigmaR_);
            Bind(statement, SIGMAACC_FIELD_ID, sigmaAcc_);
            Bind(statement, TAUVEL_FIELD_ID, tauVel_);
            Bind(statement, TAUACC_FIELD_ID, tauAcc_);
            Bind(statement, DELTARMIN_FIELD_ID, deltaRMin_);
            Bind(statement, DELTAVMAX_FIELD_ID, deltaVMax_);
            Bind(statement, DELTAAMAX_FIELD_ID, deltaAMax_);
        }

        template<IO::StreamWriter StreamT>
        void WriteColumns( IO::BinaryWriter<StreamT>& destination ) const
        {
            WriteColumnValue( destination, id_);
            WriteColumnValue( destination, rowVersion_);
            WriteColumnValue( destination, parameters_);
            WriteColumnValue( destination, timestamp_);
            WriteColumnValue( destination, useNaivePredictor_);
            WriteColumnValue( destination, numberOfPoints_);
            WriteColumnValue( destination, windowSize_);
            WriteColumnValue( destination, stabilizeCount_);
            WriteColumnValue( destination, maxBadPoints_);
            WriteColumnValue( destination, modelType_);
            WriteColumnValue( destination, sigmaR_);
            WriteColumnValue( destination, sigmaAcc_);
            WriteColumnValue( destination, tauVel_);
            WriteColumnValue( destination, tauAcc_);
            WriteColumnValue( destination, deltaRMin_);
            WriteColumnValue( destination, deltaVMax_);
            WriteColumnValue( destination, deltaAMax_);
        }
    };

    using SimpleTrackerFilterParametersConfigurationDataReader = SimpleColumnDataReader<TrackerFilterParametersConfigurationColumnData>;

    class TrackInfoColumnData : public BaseColumnData
    {
        Guid id_;
        Int64 rowVersion_ = 0;
        DBDateTime firstTimestamp_;
        DBDateTime lastTimestamp_;
        Int64 count_ = 0;
        DBDouble northWestLatitude_;
        DBDouble northWestLongitude_;
        DBDouble southEastLatitude_;
        DBDouble southEastLongitude_;
    public:
        using Base = BaseColumnData;

        static constexpr std::wstring_view FieldNames = L"[Id],[RowVersion],[FirstTimestamp],[LastTimestamp],[Count],[NorthWestLatitude],[NorthWestLongitude],[SouthEastLatitude],[SouthEastLongitude]";
        static constexpr std::wstring_view ViewName = L"TrackInfoView";

        static constexpr SQLUSMALLINT ID_FIELD_ID = 1;
        static constexpr SQLUSMALLINT ROWVERSION_FIELD_ID = 2;
        static constexpr SQLUSMALLINT FIRSTTIMESTAMP_FIELD_ID = 3;
        static constexpr SQLUSMALLINT LASTTIMESTAMP_FIELD_ID = 4;
        static constexpr SQLUSMALLINT COUNT_FIELD_ID = 5;
        static constexpr SQLUSMALLINT NORTHWESTLATITUDE_FIELD_ID = 6;
        static constexpr SQLUSMALLINT NORTHWESTLONGITUDE_FIELD_ID = 7;
        static constexpr SQLUSMALLINT SOUTHEASTLATITUDE_FIELD_ID = 8;
        static constexpr SQLUSMALLINT SOUTHEASTLONGITUDE_FIELD_ID = 9;

        TrackInfoColumnData( ) = default;

        virtual Kind GetKind() const override
        {
            return Kind::TrackInfo;
        }

        const Guid& Id( ) const
        {
            return id_;
        }
        void SetId( const Guid& id )
        {
            id_ = id;
        }
        Int64 RowVersion( ) const
        {
            return rowVersion_;
        }
        void SetRowVersion( const Int64& rowVersion )
        {
            rowVersion_ = rowVersion;
        }
        const DBDateTime& FirstTimestamp( ) const
        {
            return firstTimestamp_;
        }
        void SetFirstTimestamp( const DBDateTime& firstTimestamp )
        {
            firstTimestamp_ = firstTimestamp;
        }
        const DBDateTime& LastTimestamp( ) const
        {
            return lastTimestamp_;
        }
        void SetLastTimestamp( const DBDateTime& lastTimestamp )
        {
            lastTimestamp_ = lastTimestamp;
        }
        Int64 Count( ) const
        {
            return count_;
        }
        void SetCount( Int64 count )
        {
            count_ = count;
        }
        const DBDouble& NorthWestLatitude( ) const
        {
            return northWestLatitude_;
        }
        void SetNorthWestLatitude( const DBDouble& northWestLatitude )
        {
            northWestLatitude_ = northWestLatitude;
        }
        const DBDouble& NorthWestLongitude( ) const
        {
            return northWestLongitude_;
        }
        void SetNorthWestLongitude( const DBDouble& northWestLongitude )
        {
            northWestLongitude_ = northWestLongitude;
        }
        const DBDouble& SouthEastLatitude( ) const
        {
            return southEastLatitude_;
        }
        void SetSouthEastLatitude( const DBDouble& southEastLatitude )
        {
            southEastLatitude_ = southEastLatitude;
        }
        const DBDouble& SouthEastLongitude( ) const
        {
            return southEastLongitude_;
        }
        void SetSouthEastLongitude( const DBDouble& southEastLongitude )
        {
            southEastLongitude_ = southEastLongitude;
        }
        void BindColumns( const ODBC::Statement& statement )
        {
            Bind(statement, ID_FIELD_ID, id_);
            Bind(statement, ROWVERSION_FIELD_ID, rowVersion_);
            Bind(statement, FIRSTTIMESTAMP_FIELD_ID, firstTimestamp_);
            Bind(statement, LASTTIMESTAMP_FIELD_ID, lastTimestamp_);
            Bind(statement, COUNT_FIELD_ID, count_);
            Bind(statement, NORTHWESTLATITUDE_FIELD_ID, northWestLatitude_);
            Bind(statement, NORTHWESTLONGITUDE_FIELD_ID, northWestLongitude_);
            Bind(statement, SOUTHEASTLATITUDE_FIELD_ID, southEastLatitude_);
            Bind(statement, SOUTHEASTLONGITUDE_FIELD_ID, southEastLongitude_);
        }

        template<IO::StreamWriter StreamT>
        void WriteColumns( IO::BinaryWriter<StreamT>& destination ) const
        {
            WriteColumnValue( destination, id_);
            WriteColumnValue( destination, rowVersion_);
            WriteColumnValue( destination, firstTimestamp_);
            WriteColumnValue( destination, lastTimestamp_);
            WriteColumnValue( destination, count_);
            WriteColumnValue( destination, northWestLatitude_);
            WriteColumnValue( destination, northWestLongitude_);
            WriteColumnValue( destination, southEastLatitude_);
            WriteColumnValue( destination, southEastLongitude_);
        }
    };

    using SimpleTrackInfoDataReader = SimpleColumnDataReader<TrackInfoColumnData>;

    class TrackingServiceOptionsColumnData : public BaseColumnData
    {
        Guid id_;
        Int64 rowVersion_ = 0;
        DateTime timestamp_;
        TimeSpan timerInterval_;
        TimeSpan maxAgeOfCurrentTrackValue_;
        double falseThreshold_ = 0.0;
        double distanceThreshold_ = 0.0;
        double distanceUnmergeThreshold_ = 0.0;
        Int64 unmergeLatency_ = 0;
        bool kalmanFiltering_ = false;
        double maxCourseDeviation_ = 0.0;
        double maxSpeedDeviation_ = 0.0;
        double minimumSpeedThreshold_ = 0.0;
    public:
        using Base = BaseColumnData;

        static constexpr std::wstring_view FieldNames = L"[Id],[RowVersion],[Timestamp],[TimerInterval],[MaxAgeOfCurrentTrackValue],[FalseThreshold],[DistanceThreshold],[DistanceUnmergeThreshold],[UnmergeLatency],[KalmanFiltering],[MaxCourseDeviation],[MaxSpeedDeviation],[MinimumSpeedThreshold]";
        static constexpr std::wstring_view ViewName = L"TrackingServiceOptionsView";

        static constexpr SQLUSMALLINT ID_FIELD_ID = 1;
        static constexpr SQLUSMALLINT ROWVERSION_FIELD_ID = 2;
        static constexpr SQLUSMALLINT TIMESTAMP_FIELD_ID = 3;
        static constexpr SQLUSMALLINT TIMERINTERVAL_FIELD_ID = 4;
        static constexpr SQLUSMALLINT MAXAGEOFCURRENTTRACKVALUE_FIELD_ID = 5;
        static constexpr SQLUSMALLINT FALSETHRESHOLD_FIELD_ID = 6;
        static constexpr SQLUSMALLINT DISTANCETHRESHOLD_FIELD_ID = 7;
        static constexpr SQLUSMALLINT DISTANCEUNMERGETHRESHOLD_FIELD_ID = 8;
        static constexpr SQLUSMALLINT UNMERGELATENCY_FIELD_ID = 9;
        static constexpr SQLUSMALLINT KALMANFILTERING_FIELD_ID = 10;
        static constexpr SQLUSMALLINT MAXCOURSEDEVIATION_FIELD_ID = 11;
        static constexpr SQLUSMALLINT MAXSPEEDDEVIATION_FIELD_ID = 12;
        static constexpr SQLUSMALLINT MINIMUMSPEEDTHRESHOLD_FIELD_ID = 13;

        TrackingServiceOptionsColumnData( ) = default;

        virtual Kind GetKind() const override
        {
            return Kind::TrackingServiceOptions;
        }

        const Guid& Id( ) const
        {
            return id_;
        }
        void SetId( const Guid& id )
        {
            id_ = id;
        }
        Int64 RowVersion( ) const
        {
            return rowVersion_;
        }
        void SetRowVersion( const Int64& rowVersion )
        {
            rowVersion_ = rowVersion;
        }
        const DateTime& Timestamp( ) const
        {
            return timestamp_;
        }
        void SetTimestamp( const DateTime& timestamp )
        {
            timestamp_ = timestamp;
        }
        const TimeSpan& TimerInterval( ) const
        {
            return timerInterval_;
        }
        void SetTimerInterval( const TimeSpan& timerInterval )
        {
            timerInterval_ = timerInterval;
        }
        const TimeSpan& MaxAgeOfCurrentTrackValue( ) const
        {
            return maxAgeOfCurrentTrackValue_;
        }
        void SetMaxAgeOfCurrentTrackValue( const TimeSpan& maxAgeOfCurrentTrackValue )
        {
            maxAgeOfCurrentTrackValue_ = maxAgeOfCurrentTrackValue;
        }
        double FalseThreshold( ) const
        {
            return falseThreshold_;
        }
        void SetFalseThreshold( double falseThreshold )
        {
            falseThreshold_ = falseThreshold;
        }
        double DistanceThreshold( ) const
        {
            return distanceThreshold_;
        }
        void SetDistanceThreshold( double distanceThreshold )
        {
            distanceThreshold_ = distanceThreshold;
        }
        double DistanceUnmergeThreshold( ) const
        {
            return distanceUnmergeThreshold_;
        }
        void SetDistanceUnmergeThreshold( double distanceUnmergeThreshold )
        {
            distanceUnmergeThreshold_ = distanceUnmergeThreshold;
        }
        Int64 UnmergeLatency( ) const
        {
            return unmergeLatency_;
        }
        void SetUnmergeLatency( Int64 unmergeLatency )
        {
            unmergeLatency_ = unmergeLatency;
        }
        bool KalmanFiltering( ) const
        {
            return kalmanFiltering_;
        }
        void SetKalmanFiltering( bool kalmanFiltering )
        {
            kalmanFiltering_ = kalmanFiltering;
        }
        double MaxCourseDeviation( ) const
        {
            return maxCourseDeviation_;
        }
        void SetMaxCourseDeviation( double maxCourseDeviation )
        {
            maxCourseDeviation_ = maxCourseDeviation;
        }
        double MaxSpeedDeviation( ) const
        {
            return maxSpeedDeviation_;
        }
        void SetMaxSpeedDeviation( double maxSpeedDeviation )
        {
            maxSpeedDeviation_ = maxSpeedDeviation;
        }
        double MinimumSpeedThreshold( ) const
        {
            return minimumSpeedThreshold_;
        }
        void SetMinimumSpeedThreshold( double minimumSpeedThreshold )
        {
            minimumSpeedThreshold_ = minimumSpeedThreshold;
        }
        void BindColumns( const ODBC::Statement& statement )
        {
            Bind(statement, ID_FIELD_ID, id_);
            Bind(statement, ROWVERSION_FIELD_ID, rowVersion_);
            Bind(statement, TIMESTAMP_FIELD_ID, timestamp_);
            Bind(statement, TIMERINTERVAL_FIELD_ID, timerInterval_);
            Bind(statement, MAXAGEOFCURRENTTRACKVALUE_FIELD_ID, maxAgeOfCurrentTrackValue_);
            Bind(statement, FALSETHRESHOLD_FIELD_ID, falseThreshold_);
            Bind(statement, DISTANCETHRESHOLD_FIELD_ID, distanceThreshold_);
            Bind(statement, DISTANCEUNMERGETHRESHOLD_FIELD_ID, distanceUnmergeThreshold_);
            Bind(statement, UNMERGELATENCY_FIELD_ID, unmergeLatency_);
            Bind(statement, KALMANFILTERING_FIELD_ID, kalmanFiltering_);
            Bind(statement, MAXCOURSEDEVIATION_FIELD_ID, maxCourseDeviation_);
            Bind(statement, MAXSPEEDDEVIATION_FIELD_ID, maxSpeedDeviation_);
            Bind(statement, MINIMUMSPEEDTHRESHOLD_FIELD_ID, minimumSpeedThreshold_);
        }

        template<IO::StreamWriter StreamT>
        void WriteColumns( IO::BinaryWriter<StreamT>& destination ) const
        {
            WriteColumnValue( destination, id_);
            WriteColumnValue( destination, rowVersion_);
            WriteColumnValue( destination, timestamp_);
            WriteColumnValue( destination, timerInterval_);
            WriteColumnValue( destination, maxAgeOfCurrentTrackValue_);
            WriteColumnValue( destination, falseThreshold_);
            WriteColumnValue( destination, distanceThreshold_);
            WriteColumnValue( destination, distanceUnmergeThreshold_);
            WriteColumnValue( destination, unmergeLatency_);
            WriteColumnValue( destination, kalmanFiltering_);
            WriteColumnValue( destination, maxCourseDeviation_);
            WriteColumnValue( destination, maxSpeedDeviation_);
            WriteColumnValue( destination, minimumSpeedThreshold_);
        }
    };

    using SimpleTrackingServiceOptionsDataReader = SimpleColumnDataReader<TrackingServiceOptionsColumnData>;

    class TrackLinkColumnData : public BaseColumnData
    {
        Guid id_;
        Int64 rowVersion_ = 0;
        Guid primary_;
        Guid secondary_;
        DateTime start_;
        DBDateTime end_;
    public:
        using Base = BaseColumnData;

        static constexpr std::wstring_view FieldNames = L"[Id],[RowVersion],[Primary],[Secondary],[Start],[End]";
        static constexpr std::wstring_view ViewName = L"TrackLinkView";

        static constexpr SQLUSMALLINT ID_FIELD_ID = 1;
        static constexpr SQLUSMALLINT ROWVERSION_FIELD_ID = 2;
        static constexpr SQLUSMALLINT PRIMARY_FIELD_ID = 3;
        static constexpr SQLUSMALLINT SECONDARY_FIELD_ID = 4;
        static constexpr SQLUSMALLINT START_FIELD_ID = 5;
        static constexpr SQLUSMALLINT END_FIELD_ID = 6;

        TrackLinkColumnData( ) = default;

        virtual Kind GetKind() const override
        {
            return Kind::TrackLink;
        }

        const Guid& Id( ) const
        {
            return id_;
        }
        void SetId( const Guid& id )
        {
            id_ = id;
        }
        Int64 RowVersion( ) const
        {
            return rowVersion_;
        }
        void SetRowVersion( const Int64& rowVersion )
        {
            rowVersion_ = rowVersion;
        }
        const Guid& Primary( ) const
        {
            return primary_;
        }
        void SetPrimary( const Guid& primary )
        {
            primary_ = primary;
        }
        const Guid& Secondary( ) const
        {
            return secondary_;
        }
        void SetSecondary( const Guid& secondary )
        {
            secondary_ = secondary;
        }
        const DateTime& Start( ) const
        {
            return start_;
        }
        void SetStart( const DateTime& start )
        {
            start_ = start;
        }
        const DBDateTime& End( ) const
        {
            return end_;
        }
        void SetEnd( const DBDateTime& end )
        {
            end_ = end;
        }
        void BindColumns( const ODBC::Statement& statement )
        {
            Bind(statement, ID_FIELD_ID, id_);
            Bind(statement, ROWVERSION_FIELD_ID, rowVersion_);
            Bind(statement, PRIMARY_FIELD_ID, primary_);
            Bind(statement, SECONDARY_FIELD_ID, secondary_);
            Bind(statement, START_FIELD_ID, start_);
            Bind(statement, END_FIELD_ID, end_);
        }

        template<IO::StreamWriter StreamT>
        void WriteColumns( IO::BinaryWriter<StreamT>& destination ) const
        {
            WriteColumnValue( destination, id_);
            WriteColumnValue( destination, rowVersion_);
            WriteColumnValue( destination, primary_);
            WriteColumnValue( destination, secondary_);
            WriteColumnValue( destination, start_);
            WriteColumnValue( destination, end_);
        }
    };

    using SimpleTrackLinkDataReader = SimpleColumnDataReader<TrackLinkColumnData>;

    class TrackValueColumnData : public BaseColumnData
    {
        Guid id_;
        Int64 rowVersion_ = 0;
        Guid track_;
        DateTime timestamp_;
        Data::TrackFlags flags_ = Data::TrackFlags::None;
        Data::TrackStatus status_ = Data::TrackStatus::Unknown;
        double latitude_ = 0.0;
        double longitude_ = 0.0;
        double speed_ = 0.0;
        double course_ = 0.0;
        double heading_ = 0.0;
    public:
        using Base = BaseColumnData;

        static constexpr std::wstring_view FieldNames = L"[Id],[RowVersion],[Track],[Timestamp],[Flags],[Status],[Latitude],[Longitude],[Speed],[Course],[Heading]";
        static constexpr std::wstring_view ViewName = L"TrackValueView";

        static constexpr SQLUSMALLINT ID_FIELD_ID = 1;
        static constexpr SQLUSMALLINT ROWVERSION_FIELD_ID = 2;
        static constexpr SQLUSMALLINT TRACK_FIELD_ID = 3;
        static constexpr SQLUSMALLINT TIMESTAMP_FIELD_ID = 4;
        static constexpr SQLUSMALLINT FLAGS_FIELD_ID = 5;
        static constexpr SQLUSMALLINT STATUS_FIELD_ID = 6;
        static constexpr SQLUSMALLINT LATITUDE_FIELD_ID = 7;
        static constexpr SQLUSMALLINT LONGITUDE_FIELD_ID = 8;
        static constexpr SQLUSMALLINT SPEED_FIELD_ID = 9;
        static constexpr SQLUSMALLINT COURSE_FIELD_ID = 10;
        static constexpr SQLUSMALLINT HEADING_FIELD_ID = 11;

        TrackValueColumnData( ) = default;

        virtual Kind GetKind() const override
        {
            return Kind::TrackValue;
        }

        const Guid& Id( ) const
        {
            return id_;
        }
        void SetId( const Guid& id )
        {
            id_ = id;
        }
        Int64 RowVersion( ) const
        {
            return rowVersion_;
        }
        void SetRowVersion( const Int64& rowVersion )
        {
            rowVersion_ = rowVersion;
        }
        const Guid& Track( ) const
        {
            return track_;
        }
        void SetTrack( const Guid& track )
        {
            track_ = track;
        }
        const DateTime& Timestamp( ) const
        {
            return timestamp_;
        }
        void SetTimestamp( const DateTime& timestamp )
        {
            timestamp_ = timestamp;
        }
        Data::TrackFlags Flags( ) const
        {
            return flags_;
        }
        void SetFlags( Data::TrackFlags flags )
        {
            flags_ = flags;
        }
        Data::TrackStatus Status( ) const
        {
            return status_;
        }
        void SetStatus( Data::TrackStatus status )
        {
            status_ = status;
        }
        double Latitude( ) const
        {
            return latitude_;
        }
        void SetLatitude( double latitude )
        {
            latitude_ = latitude;
        }
        double Longitude( ) const
        {
            return longitude_;
        }
        void SetLongitude( double longitude )
        {
            longitude_ = longitude;
        }
        double Speed( ) const
        {
            return speed_;
        }
        void SetSpeed( double speed )
        {
            speed_ = speed;
        }
        double Course( ) const
        {
            return course_;
        }
        void SetCourse( double course )
        {
            course_ = course;
        }
        double Heading( ) const
        {
            return heading_;
        }
        void SetHeading( double heading )
        {
            heading_ = heading;
        }
        void BindColumns( const ODBC::Statement& statement )
        {
            Bind(statement, ID_FIELD_ID, id_);
            Bind(statement, ROWVERSION_FIELD_ID, rowVersion_);
            Bind(statement, TRACK_FIELD_ID, track_);
            Bind(statement, TIMESTAMP_FIELD_ID, timestamp_);
            Bind(statement, FLAGS_FIELD_ID, flags_);
            Bind(statement, STATUS_FIELD_ID, status_);
            Bind(statement, LATITUDE_FIELD_ID, latitude_);
            Bind(statement, LONGITUDE_FIELD_ID, longitude_);
            Bind(statement, SPEED_FIELD_ID, speed_);
            Bind(statement, COURSE_FIELD_ID, course_);
            Bind(statement, HEADING_FIELD_ID, heading_);
        }

        template<IO::StreamWriter StreamT>
        void WriteColumns( IO::BinaryWriter<StreamT>& destination ) const
        {
            WriteColumnValue( destination, id_);
            WriteColumnValue( destination, rowVersion_);
            WriteColumnValue( destination, track_);
            WriteColumnValue( destination, timestamp_);
            WriteColumnValue( destination, flags_);
            WriteColumnValue( destination, status_);
            WriteColumnValue( destination, latitude_);
            WriteColumnValue( destination, longitude_);
            WriteColumnValue( destination, speed_);
            WriteColumnValue( destination, course_);
            WriteColumnValue( destination, heading_);
        }
    };

    using SimpleTrackValueDataReader = SimpleColumnDataReader<TrackValueColumnData>;

    class TrackValue3DColumnData : public BaseColumnData
    {
        Guid id_;
        Int64 rowVersion_ = 0;
        Guid track_;
        DateTime timestamp_;
        Data::TrackFlags3D flags_ = Data::TrackFlags3D::None;
        UInt32 status_ = 0;
        double latitude_ = 0.0;
        double longitude_ = 0.0;
        double altitude_ = 0.0;
        double speed_ = 0.0;
        double course_ = 0.0;
        double rateOfClimb_ = 0.0;
    public:
        using Base = BaseColumnData;

        static constexpr std::wstring_view FieldNames = L"[Id],[RowVersion],[Track],[Timestamp],[Flags],[Status],[Latitude],[Longitude],[Altitude],[Speed],[Course],[RateOfClimb]";
        static constexpr std::wstring_view ViewName = L"TrackValue3DView";

        static constexpr SQLUSMALLINT ID_FIELD_ID = 1;
        static constexpr SQLUSMALLINT ROWVERSION_FIELD_ID = 2;
        static constexpr SQLUSMALLINT TRACK_FIELD_ID = 3;
        static constexpr SQLUSMALLINT TIMESTAMP_FIELD_ID = 4;
        static constexpr SQLUSMALLINT FLAGS_FIELD_ID = 5;
        static constexpr SQLUSMALLINT STATUS_FIELD_ID = 6;
        static constexpr SQLUSMALLINT LATITUDE_FIELD_ID = 7;
        static constexpr SQLUSMALLINT LONGITUDE_FIELD_ID = 8;
        static constexpr SQLUSMALLINT ALTITUDE_FIELD_ID = 9;
        static constexpr SQLUSMALLINT SPEED_FIELD_ID = 10;
        static constexpr SQLUSMALLINT COURSE_FIELD_ID = 11;
        static constexpr SQLUSMALLINT RATEOFCLIMB_FIELD_ID = 12;

        TrackValue3DColumnData( ) = default;

        virtual Kind GetKind() const override
        {
            return Kind::TrackValue3D;
        }

        const Guid& Id( ) const
        {
            return id_;
        }
        void SetId( const Guid& id )
        {
            id_ = id;
        }
        Int64 RowVersion( ) const
        {
            return rowVersion_;
        }
        void SetRowVersion( const Int64& rowVersion )
        {
            rowVersion_ = rowVersion;
        }
        const Guid& Track( ) const
        {
            return track_;
        }
        void SetTrack( const Guid& track )
        {
            track_ = track;
        }
        const DateTime& Timestamp( ) const
        {
            return timestamp_;
        }
        void SetTimestamp( const DateTime& timestamp )
        {
            timestamp_ = timestamp;
        }
        Data::TrackFlags3D Flags( ) const
        {
            return flags_;
        }
        void SetFlags( Data::TrackFlags3D flags )
        {
            flags_ = flags;
        }
        UInt32 Status( ) const
        {
            return status_;
        }
        void SetStatus( UInt32 status )
        {
            status_ = status;
        }
        double Latitude( ) const
        {
            return latitude_;
        }
        void SetLatitude( double latitude )
        {
            latitude_ = latitude;
        }
        double Longitude( ) const
        {
            return longitude_;
        }
        void SetLongitude( double longitude )
        {
            longitude_ = longitude;
        }
        double Altitude( ) const
        {
            return altitude_;
        }
        void SetAltitude( double altitude )
        {
            altitude_ = altitude;
        }
        double Speed( ) const
        {
            return speed_;
        }
        void SetSpeed( double speed )
        {
            speed_ = speed;
        }
        double Course( ) const
        {
            return course_;
        }
        void SetCourse( double course )
        {
            course_ = course;
        }
        double RateOfClimb( ) const
        {
            return rateOfClimb_;
        }
        void SetRateOfClimb( double rateOfClimb )
        {
            rateOfClimb_ = rateOfClimb;
        }
        void BindColumns( const ODBC::Statement& statement )
        {
            Bind(statement, ID_FIELD_ID, id_);
            Bind(statement, ROWVERSION_FIELD_ID, rowVersion_);
            Bind(statement, TRACK_FIELD_ID, track_);
            Bind(statement, TIMESTAMP_FIELD_ID, timestamp_);
            Bind(statement, FLAGS_FIELD_ID, flags_);
            Bind(statement, STATUS_FIELD_ID, status_);
            Bind(statement, LATITUDE_FIELD_ID, latitude_);
            Bind(statement, LONGITUDE_FIELD_ID, longitude_);
            Bind(statement, ALTITUDE_FIELD_ID, altitude_);
            Bind(statement, SPEED_FIELD_ID, speed_);
            Bind(statement, COURSE_FIELD_ID, course_);
            Bind(statement, RATEOFCLIMB_FIELD_ID, rateOfClimb_);
        }

        template<IO::StreamWriter StreamT>
        void WriteColumns( IO::BinaryWriter<StreamT>& destination ) const
        {
            WriteColumnValue( destination, id_);
            WriteColumnValue( destination, rowVersion_);
            WriteColumnValue( destination, track_);
            WriteColumnValue( destination, timestamp_);
            WriteColumnValue( destination, flags_);
            WriteColumnValue( destination, status_);
            WriteColumnValue( destination, latitude_);
            WriteColumnValue( destination, longitude_);
            WriteColumnValue( destination, altitude_);
            WriteColumnValue( destination, speed_);
            WriteColumnValue( destination, course_);
            WriteColumnValue( destination, rateOfClimb_);
        }
    };

    using SimpleTrackValue3DDataReader = SimpleColumnDataReader<TrackValue3DColumnData>;

    class UInt16TimeseriesValueColumnData : public BaseColumnData
    {
        Guid id_;
        Int64 rowVersion_ = 0;
        Guid timeseries_;
        DateTime timestamp_;
        DBUInt16 value_;
    public:
        using Base = BaseColumnData;

        static constexpr std::wstring_view FieldNames = L"[Id],[RowVersion],[Timeseries],[Timestamp],[Value]";
        static constexpr std::wstring_view ViewName = L"UInt16TimeseriesValueView";

        static constexpr SQLUSMALLINT ID_FIELD_ID = 1;
        static constexpr SQLUSMALLINT ROWVERSION_FIELD_ID = 2;
        static constexpr SQLUSMALLINT TIMESERIES_FIELD_ID = 3;
        static constexpr SQLUSMALLINT TIMESTAMP_FIELD_ID = 4;
        static constexpr SQLUSMALLINT VALUE_FIELD_ID = 5;

        UInt16TimeseriesValueColumnData( ) = default;

        virtual Kind GetKind() const override
        {
            return Kind::UInt16TimeseriesValue;
        }

        const Guid& Id( ) const
        {
            return id_;
        }
        void SetId( const Guid& id )
        {
            id_ = id;
        }
        Int64 RowVersion( ) const
        {
            return rowVersion_;
        }
        void SetRowVersion( const Int64& rowVersion )
        {
            rowVersion_ = rowVersion;
        }
        const Guid& Timeseries( ) const
        {
            return timeseries_;
        }
        void SetTimeseries( const Guid& timeseries )
        {
            timeseries_ = timeseries;
        }
        const DateTime& Timestamp( ) const
        {
            return timestamp_;
        }
        void SetTimestamp( const DateTime& timestamp )
        {
            timestamp_ = timestamp;
        }
        const DBUInt16& Value( ) const
        {
            return value_;
        }
        void SetValue( const DBUInt16& value )
        {
            value_ = value;
        }
        void BindColumns( const ODBC::Statement& statement )
        {
            Bind(statement, ID_FIELD_ID, id_);
            Bind(statement, ROWVERSION_FIELD_ID, rowVersion_);
            Bind(statement, TIMESERIES_FIELD_ID, timeseries_);
            Bind(statement, TIMESTAMP_FIELD_ID, timestamp_);
            Bind(statement, VALUE_FIELD_ID, value_);
        }

        template<IO::StreamWriter StreamT>
        void WriteColumns( IO::BinaryWriter<StreamT>& destination ) const
        {
            WriteColumnValue( destination, id_);
            WriteColumnValue( destination, rowVersion_);
            WriteColumnValue( destination, timeseries_);
            WriteColumnValue( destination, timestamp_);
            WriteColumnValue( destination, value_);
        }
    };

    using SimpleUInt16TimeseriesValueDataReader = SimpleColumnDataReader<UInt16TimeseriesValueColumnData>;

    class UInt32TimeseriesValueColumnData : public BaseColumnData
    {
        Guid id_;
        Int64 rowVersion_ = 0;
        Guid timeseries_;
        DateTime timestamp_;
        DBUInt32 value_;
    public:
        using Base = BaseColumnData;

        static constexpr std::wstring_view FieldNames = L"[Id],[RowVersion],[Timeseries],[Timestamp],[Value]";
        static constexpr std::wstring_view ViewName = L"UInt32TimeseriesValueView";

        static constexpr SQLUSMALLINT ID_FIELD_ID = 1;
        static constexpr SQLUSMALLINT ROWVERSION_FIELD_ID = 2;
        static constexpr SQLUSMALLINT TIMESERIES_FIELD_ID = 3;
        static constexpr SQLUSMALLINT TIMESTAMP_FIELD_ID = 4;
        static constexpr SQLUSMALLINT VALUE_FIELD_ID = 5;

        UInt32TimeseriesValueColumnData( ) = default;

        virtual Kind GetKind() const override
        {
            return Kind::UInt32TimeseriesValue;
        }

        const Guid& Id( ) const
        {
            return id_;
        }
        void SetId( const Guid& id )
        {
            id_ = id;
        }
        Int64 RowVersion( ) const
        {
            return rowVersion_;
        }
        void SetRowVersion( const Int64& rowVersion )
        {
            rowVersion_ = rowVersion;
        }
        const Guid& Timeseries( ) const
        {
            return timeseries_;
        }
        void SetTimeseries( const Guid& timeseries )
        {
            timeseries_ = timeseries;
        }
        const DateTime& Timestamp( ) const
        {
            return timestamp_;
        }
        void SetTimestamp( const DateTime& timestamp )
        {
            timestamp_ = timestamp;
        }
        const DBUInt32& Value( ) const
        {
            return value_;
        }
        void SetValue( const DBUInt32& value )
        {
            value_ = value;
        }
        void BindColumns( const ODBC::Statement& statement )
        {
            Bind(statement, ID_FIELD_ID, id_);
            Bind(statement, ROWVERSION_FIELD_ID, rowVersion_);
            Bind(statement, TIMESERIES_FIELD_ID, timeseries_);
            Bind(statement, TIMESTAMP_FIELD_ID, timestamp_);
            Bind(statement, VALUE_FIELD_ID, value_);
        }

        template<IO::StreamWriter StreamT>
        void WriteColumns( IO::BinaryWriter<StreamT>& destination ) const
        {
            WriteColumnValue( destination, id_);
            WriteColumnValue( destination, rowVersion_);
            WriteColumnValue( destination, timeseries_);
            WriteColumnValue( destination, timestamp_);
            WriteColumnValue( destination, value_);
        }
    };

    using SimpleUInt32TimeseriesValueDataReader = SimpleColumnDataReader<UInt32TimeseriesValueColumnData>;

    class UInt64TimeseriesValueColumnData : public BaseColumnData
    {
        Guid id_;
        Int64 rowVersion_ = 0;
        Guid timeseries_;
        DateTime timestamp_;
        DBInt64 value_;
    public:
        using Base = BaseColumnData;

        static constexpr std::wstring_view FieldNames = L"[Id],[RowVersion],[Timeseries],[Timestamp],[Value]";
        static constexpr std::wstring_view ViewName = L"UInt64TimeseriesValueView";

        static constexpr SQLUSMALLINT ID_FIELD_ID = 1;
        static constexpr SQLUSMALLINT ROWVERSION_FIELD_ID = 2;
        static constexpr SQLUSMALLINT TIMESERIES_FIELD_ID = 3;
        static constexpr SQLUSMALLINT TIMESTAMP_FIELD_ID = 4;
        static constexpr SQLUSMALLINT VALUE_FIELD_ID = 5;

        UInt64TimeseriesValueColumnData( ) = default;

        virtual Kind GetKind() const override
        {
            return Kind::UInt64TimeseriesValue;
        }

        const Guid& Id( ) const
        {
            return id_;
        }
        void SetId( const Guid& id )
        {
            id_ = id;
        }
        Int64 RowVersion( ) const
        {
            return rowVersion_;
        }
        void SetRowVersion( const Int64& rowVersion )
        {
            rowVersion_ = rowVersion;
        }
        const Guid& Timeseries( ) const
        {
            return timeseries_;
        }
        void SetTimeseries( const Guid& timeseries )
        {
            timeseries_ = timeseries;
        }
        const DateTime& Timestamp( ) const
        {
            return timestamp_;
        }
        void SetTimestamp( const DateTime& timestamp )
        {
            timestamp_ = timestamp;
        }
        const DBInt64& Value( ) const
        {
            return value_;
        }
        void SetValue( const DBInt64& value )
        {
            value_ = value;
        }
        void BindColumns( const ODBC::Statement& statement )
        {
            Bind(statement, ID_FIELD_ID, id_);
            Bind(statement, ROWVERSION_FIELD_ID, rowVersion_);
            Bind(statement, TIMESERIES_FIELD_ID, timeseries_);
            Bind(statement, TIMESTAMP_FIELD_ID, timestamp_);
            Bind(statement, VALUE_FIELD_ID, value_);
        }

        template<IO::StreamWriter StreamT>
        void WriteColumns( IO::BinaryWriter<StreamT>& destination ) const
        {
            WriteColumnValue( destination, id_);
            WriteColumnValue( destination, rowVersion_);
            WriteColumnValue( destination, timeseries_);
            WriteColumnValue( destination, timestamp_);
            WriteColumnValue( destination, value_);
        }
    };

    using SimpleUInt64TimeseriesValueDataReader = SimpleColumnDataReader<UInt64TimeseriesValueColumnData>;

    class VehicleTypeColumnData : public BaseColumnData
    {
        Guid id_;
        Int64 rowVersion_ = 0;
        FixedDBWideString<127> name_;
    public:
        using Base = BaseColumnData;

        static constexpr std::wstring_view FieldNames = L"[Id],[RowVersion],[Name]";
        static constexpr std::wstring_view ViewName = L"VehicleTypeView";

        static constexpr SQLUSMALLINT ID_FIELD_ID = 1;
        static constexpr SQLUSMALLINT ROWVERSION_FIELD_ID = 2;
        static constexpr SQLUSMALLINT NAME_FIELD_ID = 3;

        VehicleTypeColumnData( ) = default;

        virtual Kind GetKind() const override
        {
            return Kind::VehicleType;
        }

        const Guid& Id( ) const
        {
            return id_;
        }
        void SetId( const Guid& id )
        {
            id_ = id;
        }
        Int64 RowVersion( ) const
        {
            return rowVersion_;
        }
        void SetRowVersion( const Int64& rowVersion )
        {
            rowVersion_ = rowVersion;
        }
        const FixedDBWideString<127>& Name( ) const
        {
            return name_;
        }
        void SetName( const WideString& name )
        {
            name_ = name;
        }
        void BindColumns( const ODBC::Statement& statement )
        {
            Bind(statement, ID_FIELD_ID, id_);
            Bind(statement, ROWVERSION_FIELD_ID, rowVersion_);
            Bind(statement, NAME_FIELD_ID, name_);
        }

        template<IO::StreamWriter StreamT>
        void WriteColumns( IO::BinaryWriter<StreamT>& destination ) const
        {
            WriteColumnValue( destination, id_);
            WriteColumnValue( destination, rowVersion_);
            WriteColumnValue( destination, name_);
        }
    };

    using SimpleVehicleTypeDataReader = SimpleColumnDataReader<VehicleTypeColumnData>;

    class VesselTypeColumnData : public BaseColumnData
    {
        Guid id_;
        Int64 rowVersion_ = 0;
        FixedDBWideString<127> name_;
        Int32 code_ = 0;
    public:
        using Base = BaseColumnData;

        static constexpr std::wstring_view FieldNames = L"[Id],[RowVersion],[Name],[Code]";
        static constexpr std::wstring_view ViewName = L"VesselTypeView";

        static constexpr SQLUSMALLINT ID_FIELD_ID = 1;
        static constexpr SQLUSMALLINT ROWVERSION_FIELD_ID = 2;
        static constexpr SQLUSMALLINT NAME_FIELD_ID = 3;
        static constexpr SQLUSMALLINT CODE_FIELD_ID = 4;

        VesselTypeColumnData( ) = default;

        virtual Kind GetKind() const override
        {
            return Kind::VesselType;
        }

        const Guid& Id( ) const
        {
            return id_;
        }
        void SetId( const Guid& id )
        {
            id_ = id;
        }
        Int64 RowVersion( ) const
        {
            return rowVersion_;
        }
        void SetRowVersion( const Int64& rowVersion )
        {
            rowVersion_ = rowVersion;
        }
        const FixedDBWideString<127>& Name( ) const
        {
            return name_;
        }
        void SetName( const WideString& name )
        {
            name_ = name;
        }
        Int32 Code( ) const
        {
            return code_;
        }
        void SetCode( Int32 code )
        {
            code_ = code;
        }
        void BindColumns( const ODBC::Statement& statement )
        {
            Bind(statement, ID_FIELD_ID, id_);
            Bind(statement, ROWVERSION_FIELD_ID, rowVersion_);
            Bind(statement, NAME_FIELD_ID, name_);
            Bind(statement, CODE_FIELD_ID, code_);
        }

        template<IO::StreamWriter StreamT>
        void WriteColumns( IO::BinaryWriter<StreamT>& destination ) const
        {
            WriteColumnValue( destination, id_);
            WriteColumnValue( destination, rowVersion_);
            WriteColumnValue( destination, name_);
            WriteColumnValue( destination, code_);
        }
    };

    using SimpleVesselTypeDataReader = SimpleColumnDataReader<VesselTypeColumnData>;

    class ViewColumnData : public BaseColumnData
    {
        Guid id_;
        Int64 rowVersion_ = 0;
        FixedDBWideString<127> name_;
        Guid latitudeTimeseries_;
        Guid longitudeTimeseries_;
        Guid zoomLevelTimeseries_;
    public:
        using Base = BaseColumnData;

        static constexpr std::wstring_view FieldNames = L"[Id],[RowVersion],[Name],[LatitudeTimeseries],[LongitudeTimeseries],[ZoomLevelTimeseries]";
        static constexpr std::wstring_view ViewName = L"ViewView";

        static constexpr SQLUSMALLINT ID_FIELD_ID = 1;
        static constexpr SQLUSMALLINT ROWVERSION_FIELD_ID = 2;
        static constexpr SQLUSMALLINT NAME_FIELD_ID = 3;
        static constexpr SQLUSMALLINT LATITUDETIMESERIES_FIELD_ID = 4;
        static constexpr SQLUSMALLINT LONGITUDETIMESERIES_FIELD_ID = 5;
        static constexpr SQLUSMALLINT ZOOMLEVELTIMESERIES_FIELD_ID = 6;

        ViewColumnData( ) = default;

        virtual Kind GetKind() const override
        {
            return Kind::View;
        }

        const Guid& Id( ) const
        {
            return id_;
        }
        void SetId( const Guid& id )
        {
            id_ = id;
        }
        Int64 RowVersion( ) const
        {
            return rowVersion_;
        }
        void SetRowVersion( const Int64& rowVersion )
        {
            rowVersion_ = rowVersion;
        }
        const FixedDBWideString<127>& Name( ) const
        {
            return name_;
        }
        void SetName( const WideString& name )
        {
            name_ = name;
        }
        const Guid& LatitudeTimeseries( ) const
        {
            return latitudeTimeseries_;
        }
        void SetLatitudeTimeseries( const Guid& latitudeTimeseries )
        {
            latitudeTimeseries_ = latitudeTimeseries;
        }
        const Guid& LongitudeTimeseries( ) const
        {
            return longitudeTimeseries_;
        }
        void SetLongitudeTimeseries( const Guid& longitudeTimeseries )
        {
            longitudeTimeseries_ = longitudeTimeseries;
        }
        const Guid& ZoomLevelTimeseries( ) const
        {
            return zoomLevelTimeseries_;
        }
        void SetZoomLevelTimeseries( const Guid& zoomLevelTimeseries )
        {
            zoomLevelTimeseries_ = zoomLevelTimeseries;
        }
        void BindColumns( const ODBC::Statement& statement )
        {
            Bind(statement, ID_FIELD_ID, id_);
            Bind(statement, ROWVERSION_FIELD_ID, rowVersion_);
            Bind(statement, NAME_FIELD_ID, name_);
            Bind(statement, LATITUDETIMESERIES_FIELD_ID, latitudeTimeseries_);
            Bind(statement, LONGITUDETIMESERIES_FIELD_ID, longitudeTimeseries_);
            Bind(statement, ZOOMLEVELTIMESERIES_FIELD_ID, zoomLevelTimeseries_);
        }

        template<IO::StreamWriter StreamT>
        void WriteColumns( IO::BinaryWriter<StreamT>& destination ) const
        {
            WriteColumnValue( destination, id_);
            WriteColumnValue( destination, rowVersion_);
            WriteColumnValue( destination, name_);
            WriteColumnValue( destination, latitudeTimeseries_);
            WriteColumnValue( destination, longitudeTimeseries_);
            WriteColumnValue( destination, zoomLevelTimeseries_);
        }
    };

    using SimpleViewDataReader = SimpleColumnDataReader<ViewColumnData>;

    class ViewCameraLinkColumnData : public BaseColumnData
    {
        Guid id_;
        Int64 rowVersion_ = 0;
        Guid view_;
        Guid camera_;
        DateTime start_;
        DBDateTime end_;
    public:
        using Base = BaseColumnData;

        static constexpr std::wstring_view FieldNames = L"[Id],[RowVersion],[View],[Camera],[Start],[End]";
        static constexpr std::wstring_view ViewName = L"ViewCameraLinkView";

        static constexpr SQLUSMALLINT ID_FIELD_ID = 1;
        static constexpr SQLUSMALLINT ROWVERSION_FIELD_ID = 2;
        static constexpr SQLUSMALLINT VIEW_FIELD_ID = 3;
        static constexpr SQLUSMALLINT CAMERA_FIELD_ID = 4;
        static constexpr SQLUSMALLINT START_FIELD_ID = 5;
        static constexpr SQLUSMALLINT END_FIELD_ID = 6;

        ViewCameraLinkColumnData( ) = default;

        virtual Kind GetKind() const override
        {
            return Kind::ViewCameraLink;
        }

        const Guid& Id( ) const
        {
            return id_;
        }
        void SetId( const Guid& id )
        {
            id_ = id;
        }
        Int64 RowVersion( ) const
        {
            return rowVersion_;
        }
        void SetRowVersion( const Int64& rowVersion )
        {
            rowVersion_ = rowVersion;
        }
        const Guid& View( ) const
        {
            return view_;
        }
        void SetView( const Guid& view )
        {
            view_ = view;
        }
        const Guid& Camera( ) const
        {
            return camera_;
        }
        void SetCamera( const Guid& camera )
        {
            camera_ = camera;
        }
        const DateTime& Start( ) const
        {
            return start_;
        }
        void SetStart( const DateTime& start )
        {
            start_ = start;
        }
        const DBDateTime& End( ) const
        {
            return end_;
        }
        void SetEnd( const DBDateTime& end )
        {
            end_ = end;
        }
        void BindColumns( const ODBC::Statement& statement )
        {
            Bind(statement, ID_FIELD_ID, id_);
            Bind(statement, ROWVERSION_FIELD_ID, rowVersion_);
            Bind(statement, VIEW_FIELD_ID, view_);
            Bind(statement, CAMERA_FIELD_ID, camera_);
            Bind(statement, START_FIELD_ID, start_);
            Bind(statement, END_FIELD_ID, end_);
        }

        template<IO::StreamWriter StreamT>
        void WriteColumns( IO::BinaryWriter<StreamT>& destination ) const
        {
            WriteColumnValue( destination, id_);
            WriteColumnValue( destination, rowVersion_);
            WriteColumnValue( destination, view_);
            WriteColumnValue( destination, camera_);
            WriteColumnValue( destination, start_);
            WriteColumnValue( destination, end_);
        }
    };

    using SimpleViewCameraLinkDataReader = SimpleColumnDataReader<ViewCameraLinkColumnData>;

    class ViewTrackerLinkColumnData : public BaseColumnData
    {
        Guid id_;
        Int64 rowVersion_ = 0;
        Guid view_;
        Guid tracker_;
        DateTime start_;
        DBDateTime end_;
    public:
        using Base = BaseColumnData;

        static constexpr std::wstring_view FieldNames = L"[Id],[RowVersion],[View],[Tracker],[Start],[End]";
        static constexpr std::wstring_view ViewName = L"ViewTrackerLinkView";

        static constexpr SQLUSMALLINT ID_FIELD_ID = 1;
        static constexpr SQLUSMALLINT ROWVERSION_FIELD_ID = 2;
        static constexpr SQLUSMALLINT VIEW_FIELD_ID = 3;
        static constexpr SQLUSMALLINT TRACKER_FIELD_ID = 4;
        static constexpr SQLUSMALLINT START_FIELD_ID = 5;
        static constexpr SQLUSMALLINT END_FIELD_ID = 6;

        ViewTrackerLinkColumnData( ) = default;

        virtual Kind GetKind() const override
        {
            return Kind::ViewTrackerLink;
        }

        const Guid& Id( ) const
        {
            return id_;
        }
        void SetId( const Guid& id )
        {
            id_ = id;
        }
        Int64 RowVersion( ) const
        {
            return rowVersion_;
        }
        void SetRowVersion( const Int64& rowVersion )
        {
            rowVersion_ = rowVersion;
        }
        const Guid& View( ) const
        {
            return view_;
        }
        void SetView( const Guid& view )
        {
            view_ = view;
        }
        const Guid& Tracker( ) const
        {
            return tracker_;
        }
        void SetTracker( const Guid& tracker )
        {
            tracker_ = tracker;
        }
        const DateTime& Start( ) const
        {
            return start_;
        }
        void SetStart( const DateTime& start )
        {
            start_ = start;
        }
        const DBDateTime& End( ) const
        {
            return end_;
        }
        void SetEnd( const DBDateTime& end )
        {
            end_ = end;
        }
        void BindColumns( const ODBC::Statement& statement )
        {
            Bind(statement, ID_FIELD_ID, id_);
            Bind(statement, ROWVERSION_FIELD_ID, rowVersion_);
            Bind(statement, VIEW_FIELD_ID, view_);
            Bind(statement, TRACKER_FIELD_ID, tracker_);
            Bind(statement, START_FIELD_ID, start_);
            Bind(statement, END_FIELD_ID, end_);
        }

        template<IO::StreamWriter StreamT>
        void WriteColumns( IO::BinaryWriter<StreamT>& destination ) const
        {
            WriteColumnValue( destination, id_);
            WriteColumnValue( destination, rowVersion_);
            WriteColumnValue( destination, view_);
            WriteColumnValue( destination, tracker_);
            WriteColumnValue( destination, start_);
            WriteColumnValue( destination, end_);
        }
    };

    using SimpleViewTrackerLinkDataReader = SimpleColumnDataReader<ViewTrackerLinkColumnData>;

    class WeatherStationCommandColumnData : public BaseColumnData
    {
        Guid id_;
        Int64 rowVersion_ = 0;
        Guid weatherStation_;
        DateTime timestamp_;
        Data::DeviceCommandSourceType deviceCommandSourceType_ = Data::DeviceCommandSourceType::Unknown;
        Guid deviceCommandSourceId_;
        Guid reply_;
    public:
        using Base = BaseColumnData;

        static constexpr std::wstring_view FieldNames = L"[Id],[RowVersion],[WeatherStation],[Timestamp],[DeviceCommandSourceType],[DeviceCommandSourceId],[Reply]";
        static constexpr std::wstring_view ViewName = L"WeatherStationCommandView";

        static constexpr SQLUSMALLINT ID_FIELD_ID = 1;
        static constexpr SQLUSMALLINT ROWVERSION_FIELD_ID = 2;
        static constexpr SQLUSMALLINT WEATHERSTATION_FIELD_ID = 3;
        static constexpr SQLUSMALLINT TIMESTAMP_FIELD_ID = 4;
        static constexpr SQLUSMALLINT DEVICECOMMANDSOURCETYPE_FIELD_ID = 5;
        static constexpr SQLUSMALLINT DEVICECOMMANDSOURCEID_FIELD_ID = 6;
        static constexpr SQLUSMALLINT REPLY_FIELD_ID = 7;

        WeatherStationCommandColumnData( ) = default;

        virtual Kind GetKind() const override
        {
            return Kind::WeatherStationCommand;
        }

        const Guid& Id( ) const
        {
            return id_;
        }
        void SetId( const Guid& id )
        {
            id_ = id;
        }
        Int64 RowVersion( ) const
        {
            return rowVersion_;
        }
        void SetRowVersion( const Int64& rowVersion )
        {
            rowVersion_ = rowVersion;
        }
        const Guid& WeatherStation( ) const
        {
            return weatherStation_;
        }
        void SetWeatherStation( const Guid& weatherStation )
        {
            weatherStation_ = weatherStation;
        }
        const DateTime& Timestamp( ) const
        {
            return timestamp_;
        }
        void SetTimestamp( const DateTime& timestamp )
        {
            timestamp_ = timestamp;
        }
        Data::DeviceCommandSourceType DeviceCommandSourceType( ) const
        {
            return deviceCommandSourceType_;
        }
        void SetDeviceCommandSourceType( Data::DeviceCommandSourceType deviceCommandSourceType )
        {
            deviceCommandSourceType_ = deviceCommandSourceType;
        }
        const Guid& DeviceCommandSourceId( ) const
        {
            return deviceCommandSourceId_;
        }
        void SetDeviceCommandSourceId( const Guid& deviceCommandSourceId )
        {
            deviceCommandSourceId_ = deviceCommandSourceId;
        }
        const Guid& Reply( ) const
        {
            return reply_;
        }
        void SetReply( const Guid& reply )
        {
            reply_ = reply;
        }
        void BindColumns( const ODBC::Statement& statement )
        {
            Bind(statement, ID_FIELD_ID, id_);
            Bind(statement, ROWVERSION_FIELD_ID, rowVersion_);
            Bind(statement, WEATHERSTATION_FIELD_ID, weatherStation_);
            Bind(statement, TIMESTAMP_FIELD_ID, timestamp_);
            Bind(statement, DEVICECOMMANDSOURCETYPE_FIELD_ID, deviceCommandSourceType_);
            Bind(statement, DEVICECOMMANDSOURCEID_FIELD_ID, deviceCommandSourceId_);
            Bind(statement, REPLY_FIELD_ID, reply_);
        }

        template<IO::StreamWriter StreamT>
        void WriteColumns( IO::BinaryWriter<StreamT>& destination ) const
        {
            WriteColumnValue( destination, id_);
            WriteColumnValue( destination, rowVersion_);
            WriteColumnValue( destination, weatherStation_);
            WriteColumnValue( destination, timestamp_);
            WriteColumnValue( destination, deviceCommandSourceType_);
            WriteColumnValue( destination, deviceCommandSourceId_);
            WriteColumnValue( destination, reply_);
        }
    };

    using SimpleWeatherStationCommandDataReader = SimpleColumnDataReader<WeatherStationCommandColumnData>;

    class WeatherStationCommandReplyColumnData : public BaseColumnData
    {
        Guid id_;
        Int64 rowVersion_ = 0;
        Guid weatherStation_;
        DateTime timestamp_;
        Guid command_;
        Data::DeviceCommandReplyStatus status_ = Data::DeviceCommandReplyStatus::Unknown;
        WideString message_;
        SQLLEN messageLength_ = SQL_NULL_DATA;
    public:
        using Base = BaseColumnData;

        static constexpr std::wstring_view FieldNames = L"[Id],[RowVersion],[WeatherStation],[Timestamp],[Command],[Status],[Message]";
        static constexpr std::wstring_view ViewName = L"WeatherStationCommandReplyView";

        static constexpr SQLUSMALLINT ID_FIELD_ID = 1;
        static constexpr SQLUSMALLINT ROWVERSION_FIELD_ID = 2;
        static constexpr SQLUSMALLINT WEATHERSTATION_FIELD_ID = 3;
        static constexpr SQLUSMALLINT TIMESTAMP_FIELD_ID = 4;
        static constexpr SQLUSMALLINT COMMAND_FIELD_ID = 5;
        static constexpr SQLUSMALLINT STATUS_FIELD_ID = 6;
        static constexpr SQLUSMALLINT MESSAGE_FIELD_ID = 7;

        WeatherStationCommandReplyColumnData( ) = default;

        virtual Kind GetKind() const override
        {
            return Kind::WeatherStationCommandReply;
        }

        const Guid& Id( ) const
        {
            return id_;
        }
        void SetId( const Guid& id )
        {
            id_ = id;
        }
        Int64 RowVersion( ) const
        {
            return rowVersion_;
        }
        void SetRowVersion( const Int64& rowVersion )
        {
            rowVersion_ = rowVersion;
        }
        const Guid& WeatherStation( ) const
        {
            return weatherStation_;
        }
        void SetWeatherStation( const Guid& weatherStation )
        {
            weatherStation_ = weatherStation;
        }
        const DateTime& Timestamp( ) const
        {
            return timestamp_;
        }
        void SetTimestamp( const DateTime& timestamp )
        {
            timestamp_ = timestamp;
        }
        const Guid& Command( ) const
        {
            return command_;
        }
        void SetCommand( const Guid& command )
        {
            command_ = command;
        }
        Data::DeviceCommandReplyStatus Status( ) const
        {
            return status_;
        }
        void SetStatus( Data::DeviceCommandReplyStatus status )
        {
            status_ = status;
        }
        const WideString& Message( ) const
        {
            return message_;
        }
        void SetMessage( const WideString& message )
        {
            message_ = message;
        }
        void BindColumns( const ODBC::Statement& statement )
        {
            Bind(statement, ID_FIELD_ID, id_);
            Bind(statement, ROWVERSION_FIELD_ID, rowVersion_);
            Bind(statement, WEATHERSTATION_FIELD_ID, weatherStation_);
            Bind(statement, TIMESTAMP_FIELD_ID, timestamp_);
            Bind(statement, COMMAND_FIELD_ID, command_);
            Bind(statement, STATUS_FIELD_ID, status_);
        }

        void ReadUnboundData( const ODBC::Statement& statement )
        {
            Base::ReadUnboundData( statement );

            message_ = statement.GetWideString(MESSAGE_FIELD_ID);
        }
        template<IO::StreamWriter StreamT>
        void WriteColumns( IO::BinaryWriter<StreamT>& destination ) const
        {
            WriteColumnValue( destination, id_);
            WriteColumnValue( destination, rowVersion_);
            WriteColumnValue( destination, weatherStation_);
            WriteColumnValue( destination, timestamp_);
            WriteColumnValue( destination, command_);
            WriteColumnValue( destination, status_);
            WriteColumnValue( destination, message_);
        }
    };

    using SimpleWeatherStationCommandReplyDataReader = SimpleColumnDataReader<WeatherStationCommandReplyColumnData>;

    class WeatherStationConfigurationColumnData : public BaseColumnData
    {
        Guid id_;
        Int64 rowVersion_ = 0;
        Guid weatherStation_;
        DateTime timestamp_;
        TimeSpan noDataTimeOut_;
        TimeSpan sendInterval_;
        double latitude_ = 0.0;
        double longitude_ = 0.0;
        double gyroOffset_ = 0.0;
        bool enableAveraging_ = false;
        TimeSpan averagingInterval_;
    public:
        using Base = BaseColumnData;

        static constexpr std::wstring_view FieldNames = L"[Id],[RowVersion],[WeatherStation],[Timestamp],[NoDataTimeOut],[SendInterval],[Latitude],[Longitude],[GyroOffset],[EnableAveraging],[AveragingInterval]";
        static constexpr std::wstring_view ViewName = L"WeatherStationConfigurationView";

        static constexpr SQLUSMALLINT ID_FIELD_ID = 1;
        static constexpr SQLUSMALLINT ROWVERSION_FIELD_ID = 2;
        static constexpr SQLUSMALLINT WEATHERSTATION_FIELD_ID = 3;
        static constexpr SQLUSMALLINT TIMESTAMP_FIELD_ID = 4;
        static constexpr SQLUSMALLINT NODATATIMEOUT_FIELD_ID = 5;
        static constexpr SQLUSMALLINT SENDINTERVAL_FIELD_ID = 6;
        static constexpr SQLUSMALLINT LATITUDE_FIELD_ID = 7;
        static constexpr SQLUSMALLINT LONGITUDE_FIELD_ID = 8;
        static constexpr SQLUSMALLINT GYROOFFSET_FIELD_ID = 9;
        static constexpr SQLUSMALLINT ENABLEAVERAGING_FIELD_ID = 10;
        static constexpr SQLUSMALLINT AVERAGINGINTERVAL_FIELD_ID = 11;

        WeatherStationConfigurationColumnData( ) = default;

        virtual Kind GetKind() const override
        {
            return Kind::WeatherStationConfiguration;
        }

        const Guid& Id( ) const
        {
            return id_;
        }
        void SetId( const Guid& id )
        {
            id_ = id;
        }
        Int64 RowVersion( ) const
        {
            return rowVersion_;
        }
        void SetRowVersion( const Int64& rowVersion )
        {
            rowVersion_ = rowVersion;
        }
        const Guid& WeatherStation( ) const
        {
            return weatherStation_;
        }
        void SetWeatherStation( const Guid& weatherStation )
        {
            weatherStation_ = weatherStation;
        }
        const DateTime& Timestamp( ) const
        {
            return timestamp_;
        }
        void SetTimestamp( const DateTime& timestamp )
        {
            timestamp_ = timestamp;
        }
        const TimeSpan& NoDataTimeOut( ) const
        {
            return noDataTimeOut_;
        }
        void SetNoDataTimeOut( const TimeSpan& noDataTimeOut )
        {
            noDataTimeOut_ = noDataTimeOut;
        }
        const TimeSpan& SendInterval( ) const
        {
            return sendInterval_;
        }
        void SetSendInterval( const TimeSpan& sendInterval )
        {
            sendInterval_ = sendInterval;
        }
        double Latitude( ) const
        {
            return latitude_;
        }
        void SetLatitude( double latitude )
        {
            latitude_ = latitude;
        }
        double Longitude( ) const
        {
            return longitude_;
        }
        void SetLongitude( double longitude )
        {
            longitude_ = longitude;
        }
        double GyroOffset( ) const
        {
            return gyroOffset_;
        }
        void SetGyroOffset( double gyroOffset )
        {
            gyroOffset_ = gyroOffset;
        }
        bool EnableAveraging( ) const
        {
            return enableAveraging_;
        }
        void SetEnableAveraging( bool enableAveraging )
        {
            enableAveraging_ = enableAveraging;
        }
        const TimeSpan& AveragingInterval( ) const
        {
            return averagingInterval_;
        }
        void SetAveragingInterval( const TimeSpan& averagingInterval )
        {
            averagingInterval_ = averagingInterval;
        }
        void BindColumns( const ODBC::Statement& statement )
        {
            Bind(statement, ID_FIELD_ID, id_);
            Bind(statement, ROWVERSION_FIELD_ID, rowVersion_);
            Bind(statement, WEATHERSTATION_FIELD_ID, weatherStation_);
            Bind(statement, TIMESTAMP_FIELD_ID, timestamp_);
            Bind(statement, NODATATIMEOUT_FIELD_ID, noDataTimeOut_);
            Bind(statement, SENDINTERVAL_FIELD_ID, sendInterval_);
            Bind(statement, LATITUDE_FIELD_ID, latitude_);
            Bind(statement, LONGITUDE_FIELD_ID, longitude_);
            Bind(statement, GYROOFFSET_FIELD_ID, gyroOffset_);
            Bind(statement, ENABLEAVERAGING_FIELD_ID, enableAveraging_);
            Bind(statement, AVERAGINGINTERVAL_FIELD_ID, averagingInterval_);
        }

        template<IO::StreamWriter StreamT>
        void WriteColumns( IO::BinaryWriter<StreamT>& destination ) const
        {
            WriteColumnValue( destination, id_);
            WriteColumnValue( destination, rowVersion_);
            WriteColumnValue( destination, weatherStation_);
            WriteColumnValue( destination, timestamp_);
            WriteColumnValue( destination, noDataTimeOut_);
            WriteColumnValue( destination, sendInterval_);
            WriteColumnValue( destination, latitude_);
            WriteColumnValue( destination, longitude_);
            WriteColumnValue( destination, gyroOffset_);
            WriteColumnValue( destination, enableAveraging_);
            WriteColumnValue( destination, averagingInterval_);
        }
    };

    using SimpleWeatherStationConfigurationDataReader = SimpleColumnDataReader<WeatherStationConfigurationColumnData>;

    class ZoneColumnData : public BaseColumnData
    {
        Guid id_;
        Int64 rowVersion_ = 0;
        FixedDBWideString<127> name_;
        double longitude_ = 0.0;
        double latitude_ = 0.0;
        Data::ZoneAlarmType alarmType_ = Data::ZoneAlarmType::None;
        TimeSpan alarmTime_;
        TimeSpan radarTrackMinimumLifetime_;
        double speed_ = 0.0;
        UInt32 strokeColor_ = 0;
        UInt32 fillColor_ = 0;
    public:
        using Base = BaseColumnData;

        static constexpr std::wstring_view FieldNames = L"[Id],[RowVersion],[Name],[Longitude],[Latitude],[AlarmType],[AlarmTime],[RadarTrackMinimumLifetime],[Speed],[StrokeColor],[FillColor]";
        static constexpr std::wstring_view ViewName = L"ZoneView";

        static constexpr SQLUSMALLINT ID_FIELD_ID = 1;
        static constexpr SQLUSMALLINT ROWVERSION_FIELD_ID = 2;
        static constexpr SQLUSMALLINT NAME_FIELD_ID = 3;
        static constexpr SQLUSMALLINT LONGITUDE_FIELD_ID = 4;
        static constexpr SQLUSMALLINT LATITUDE_FIELD_ID = 5;
        static constexpr SQLUSMALLINT ALARMTYPE_FIELD_ID = 6;
        static constexpr SQLUSMALLINT ALARMTIME_FIELD_ID = 7;
        static constexpr SQLUSMALLINT RADARTRACKMINIMUMLIFETIME_FIELD_ID = 8;
        static constexpr SQLUSMALLINT SPEED_FIELD_ID = 9;
        static constexpr SQLUSMALLINT STROKECOLOR_FIELD_ID = 10;
        static constexpr SQLUSMALLINT FILLCOLOR_FIELD_ID = 11;

        ZoneColumnData( ) = default;

        virtual Kind GetKind() const override
        {
            return Kind::Zone;
        }

        const Guid& Id( ) const
        {
            return id_;
        }
        void SetId( const Guid& id )
        {
            id_ = id;
        }
        Int64 RowVersion( ) const
        {
            return rowVersion_;
        }
        void SetRowVersion( const Int64& rowVersion )
        {
            rowVersion_ = rowVersion;
        }
        const FixedDBWideString<127>& Name( ) const
        {
            return name_;
        }
        void SetName( const WideString& name )
        {
            name_ = name;
        }
        double Longitude( ) const
        {
            return longitude_;
        }
        void SetLongitude( double longitude )
        {
            longitude_ = longitude;
        }
        double Latitude( ) const
        {
            return latitude_;
        }
        void SetLatitude( double latitude )
        {
            latitude_ = latitude;
        }
        Data::ZoneAlarmType AlarmType( ) const
        {
            return alarmType_;
        }
        void SetAlarmType( Data::ZoneAlarmType alarmType )
        {
            alarmType_ = alarmType;
        }
        const TimeSpan& AlarmTime( ) const
        {
            return alarmTime_;
        }
        void SetAlarmTime( const TimeSpan& alarmTime )
        {
            alarmTime_ = alarmTime;
        }
        const TimeSpan& RadarTrackMinimumLifetime( ) const
        {
            return radarTrackMinimumLifetime_;
        }
        void SetRadarTrackMinimumLifetime( const TimeSpan& radarTrackMinimumLifetime )
        {
            radarTrackMinimumLifetime_ = radarTrackMinimumLifetime;
        }
        double Speed( ) const
        {
            return speed_;
        }
        void SetSpeed( double speed )
        {
            speed_ = speed;
        }
        UInt32 StrokeColor( ) const
        {
            return strokeColor_;
        }
        void SetStrokeColor( UInt32 strokeColor )
        {
            strokeColor_ = strokeColor;
        }
        UInt32 FillColor( ) const
        {
            return fillColor_;
        }
        void SetFillColor( UInt32 fillColor )
        {
            fillColor_ = fillColor;
        }
        void BindColumns( const ODBC::Statement& statement )
        {
            Bind(statement, ID_FIELD_ID, id_);
            Bind(statement, ROWVERSION_FIELD_ID, rowVersion_);
            Bind(statement, NAME_FIELD_ID, name_);
            Bind(statement, LONGITUDE_FIELD_ID, longitude_);
            Bind(statement, LATITUDE_FIELD_ID, latitude_);
            Bind(statement, ALARMTYPE_FIELD_ID, alarmType_);
            Bind(statement, ALARMTIME_FIELD_ID, alarmTime_);
            Bind(statement, RADARTRACKMINIMUMLIFETIME_FIELD_ID, radarTrackMinimumLifetime_);
            Bind(statement, SPEED_FIELD_ID, speed_);
            Bind(statement, STROKECOLOR_FIELD_ID, strokeColor_);
            Bind(statement, FILLCOLOR_FIELD_ID, fillColor_);
        }

        template<IO::StreamWriter StreamT>
        void WriteColumns( IO::BinaryWriter<StreamT>& destination ) const
        {
            WriteColumnValue( destination, id_);
            WriteColumnValue( destination, rowVersion_);
            WriteColumnValue( destination, name_);
            WriteColumnValue( destination, longitude_);
            WriteColumnValue( destination, latitude_);
            WriteColumnValue( destination, alarmType_);
            WriteColumnValue( destination, alarmTime_);
            WriteColumnValue( destination, radarTrackMinimumLifetime_);
            WriteColumnValue( destination, speed_);
            WriteColumnValue( destination, strokeColor_);
            WriteColumnValue( destination, fillColor_);
        }
    };

    using SimpleZoneDataReader = SimpleColumnDataReader<ZoneColumnData>;

    class CircularZoneColumnData : public ZoneColumnData
    {
        double radius_ = 0.0;
    public:
        using Base = ZoneColumnData;

        static constexpr std::wstring_view FieldNames = L"[Id],[RowVersion],[Name],[Longitude],[Latitude],[AlarmType],[AlarmTime],[RadarTrackMinimumLifetime],[Speed],[StrokeColor],[FillColor],[Radius]";
        static constexpr std::wstring_view ViewName = L"CircularZoneView";

        static constexpr SQLUSMALLINT RADIUS_FIELD_ID = 12;

        CircularZoneColumnData( ) = default;

        virtual Kind GetKind() const override
        {
            return Kind::CircularZone;
        }

        double Radius( ) const
        {
            return radius_;
        }
        void SetRadius( double radius )
        {
            radius_ = radius;
        }
        void BindColumns( const ODBC::Statement& statement )
        {
            Base::BindColumns( statement );

            Bind(statement, RADIUS_FIELD_ID, radius_);
        }

        template<IO::StreamWriter StreamT>
        void WriteColumns( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteColumns( destination );
            WriteColumnValue( destination, radius_);
        }
    };

    using SimpleCircularZoneDataReader = SimpleColumnDataReader<CircularZoneColumnData>;

    class PolygonZoneColumnData : public ZoneColumnData
    {
        Binary polygon_;
        SQLLEN polygonLength_ = SQL_NULL_DATA;
    public:
        using Base = ZoneColumnData;

        static constexpr std::wstring_view FieldNames = L"[Id],[RowVersion],[Name],[Longitude],[Latitude],[AlarmType],[AlarmTime],[RadarTrackMinimumLifetime],[Speed],[StrokeColor],[FillColor],[Polygon]";
        static constexpr std::wstring_view ViewName = L"PolygonZoneView";

        static constexpr SQLUSMALLINT POLYGON_FIELD_ID = 12;

        PolygonZoneColumnData( ) = default;

        virtual Kind GetKind() const override
        {
            return Kind::PolygonZone;
        }

        const Binary& Polygon( ) const
        {
            return polygon_;
        }
        void SetPolygon( const Binary& polygon )
        {
            polygon_ = polygon;
        }
        void BindColumns( const ODBC::Statement& statement )
        {
            Base::BindColumns( statement );

        }

        void ReadUnboundData( const ODBC::Statement& statement )
        {
            Base::ReadUnboundData( statement );

            polygon_ = statement.GetBinary(POLYGON_FIELD_ID);
        }
        template<IO::StreamWriter StreamT>
        void WriteColumns( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteColumns( destination );
            WriteColumnValue( destination, polygon_);
        }
    };

    using SimplePolygonZoneDataReader = SimpleColumnDataReader<PolygonZoneColumnData>;

    class ZoneExceptionsColumnData : public BaseColumnData
    {
        Guid id_;
        Int64 rowVersion_ = 0;
        Guid zone_;
        DateTime timestamp_;
    public:
        using Base = BaseColumnData;

        static constexpr std::wstring_view FieldNames = L"[Id],[RowVersion],[Zone],[Timestamp]";
        static constexpr std::wstring_view ViewName = L"ZoneExceptionsView";

        static constexpr SQLUSMALLINT ID_FIELD_ID = 1;
        static constexpr SQLUSMALLINT ROWVERSION_FIELD_ID = 2;
        static constexpr SQLUSMALLINT ZONE_FIELD_ID = 3;
        static constexpr SQLUSMALLINT TIMESTAMP_FIELD_ID = 4;

        ZoneExceptionsColumnData( ) = default;

        virtual Kind GetKind() const override
        {
            return Kind::ZoneExceptions;
        }

        const Guid& Id( ) const
        {
            return id_;
        }
        void SetId( const Guid& id )
        {
            id_ = id;
        }
        Int64 RowVersion( ) const
        {
            return rowVersion_;
        }
        void SetRowVersion( const Int64& rowVersion )
        {
            rowVersion_ = rowVersion;
        }
        const Guid& Zone( ) const
        {
            return zone_;
        }
        void SetZone( const Guid& zone )
        {
            zone_ = zone;
        }
        const DateTime& Timestamp( ) const
        {
            return timestamp_;
        }
        void SetTimestamp( const DateTime& timestamp )
        {
            timestamp_ = timestamp;
        }
        void BindColumns( const ODBC::Statement& statement )
        {
            Bind(statement, ID_FIELD_ID, id_);
            Bind(statement, ROWVERSION_FIELD_ID, rowVersion_);
            Bind(statement, ZONE_FIELD_ID, zone_);
            Bind(statement, TIMESTAMP_FIELD_ID, timestamp_);
        }

        template<IO::StreamWriter StreamT>
        void WriteColumns( IO::BinaryWriter<StreamT>& destination ) const
        {
            WriteColumnValue( destination, id_);
            WriteColumnValue( destination, rowVersion_);
            WriteColumnValue( destination, zone_);
            WriteColumnValue( destination, timestamp_);
        }
    };

    using SimpleZoneExceptionsDataReader = SimpleColumnDataReader<ZoneExceptionsColumnData>;

    class ZoneExceptionsVesselLinkColumnData : public BaseColumnData
    {
        Guid id_;
        Int64 rowVersion_ = 0;
        Guid zoneExceptions_;
        Guid vessel_;
    public:
        using Base = BaseColumnData;

        static constexpr std::wstring_view FieldNames = L"[Id],[RowVersion],[ZoneExceptions],[Vessel]";
        static constexpr std::wstring_view ViewName = L"ZoneExceptionsVesselLinkView";

        static constexpr SQLUSMALLINT ID_FIELD_ID = 1;
        static constexpr SQLUSMALLINT ROWVERSION_FIELD_ID = 2;
        static constexpr SQLUSMALLINT ZONEEXCEPTIONS_FIELD_ID = 3;
        static constexpr SQLUSMALLINT VESSEL_FIELD_ID = 4;

        ZoneExceptionsVesselLinkColumnData( ) = default;

        virtual Kind GetKind() const override
        {
            return Kind::ZoneExceptionsVesselLink;
        }

        const Guid& Id( ) const
        {
            return id_;
        }
        void SetId( const Guid& id )
        {
            id_ = id;
        }
        Int64 RowVersion( ) const
        {
            return rowVersion_;
        }
        void SetRowVersion( const Int64& rowVersion )
        {
            rowVersion_ = rowVersion;
        }
        const Guid& ZoneExceptions( ) const
        {
            return zoneExceptions_;
        }
        void SetZoneExceptions( const Guid& zoneExceptions )
        {
            zoneExceptions_ = zoneExceptions;
        }
        const Guid& Vessel( ) const
        {
            return vessel_;
        }
        void SetVessel( const Guid& vessel )
        {
            vessel_ = vessel;
        }
        void BindColumns( const ODBC::Statement& statement )
        {
            Bind(statement, ID_FIELD_ID, id_);
            Bind(statement, ROWVERSION_FIELD_ID, rowVersion_);
            Bind(statement, ZONEEXCEPTIONS_FIELD_ID, zoneExceptions_);
            Bind(statement, VESSEL_FIELD_ID, vessel_);
        }

        template<IO::StreamWriter StreamT>
        void WriteColumns( IO::BinaryWriter<StreamT>& destination ) const
        {
            WriteColumnValue( destination, id_);
            WriteColumnValue( destination, rowVersion_);
            WriteColumnValue( destination, zoneExceptions_);
            WriteColumnValue( destination, vessel_);
        }
    };

    using SimpleZoneExceptionsVesselLinkDataReader = SimpleColumnDataReader<ZoneExceptionsVesselLinkColumnData>;

    class ZoneTrackAlarmColumnData : public BaseColumnData
    {
        Guid id_;
        Int64 rowVersion_ = 0;
        Guid track_;
        Guid zone_;
        Guid radarTrack_;
        DateTime timestamp_;
        double latitude_ = 0.0;
        double longitude_ = 0.0;
        double speed_ = 0.0;
        DBDouble course_;
        DBDouble heading_;
        double enterLatitude_ = 0.0;
        double enterLongitude_ = 0.0;
        DBDouble leaveLatitude_;
        DBDouble leaveLongitude_;
    public:
        using Base = BaseColumnData;

        static constexpr std::wstring_view FieldNames = L"[Id],[RowVersion],[Track],[Zone],[RadarTrack],[Timestamp],[Latitude],[Longitude],[Speed],[Course],[Heading],[EnterLatitude],[EnterLongitude],[LeaveLatitude],[LeaveLongitude]";
        static constexpr std::wstring_view ViewName = L"ZoneTrackAlarmView";

        static constexpr SQLUSMALLINT ID_FIELD_ID = 1;
        static constexpr SQLUSMALLINT ROWVERSION_FIELD_ID = 2;
        static constexpr SQLUSMALLINT TRACK_FIELD_ID = 3;
        static constexpr SQLUSMALLINT ZONE_FIELD_ID = 4;
        static constexpr SQLUSMALLINT RADARTRACK_FIELD_ID = 5;
        static constexpr SQLUSMALLINT TIMESTAMP_FIELD_ID = 6;
        static constexpr SQLUSMALLINT LATITUDE_FIELD_ID = 7;
        static constexpr SQLUSMALLINT LONGITUDE_FIELD_ID = 8;
        static constexpr SQLUSMALLINT SPEED_FIELD_ID = 9;
        static constexpr SQLUSMALLINT COURSE_FIELD_ID = 10;
        static constexpr SQLUSMALLINT HEADING_FIELD_ID = 11;
        static constexpr SQLUSMALLINT ENTERLATITUDE_FIELD_ID = 12;
        static constexpr SQLUSMALLINT ENTERLONGITUDE_FIELD_ID = 13;
        static constexpr SQLUSMALLINT LEAVELATITUDE_FIELD_ID = 14;
        static constexpr SQLUSMALLINT LEAVELONGITUDE_FIELD_ID = 15;

        ZoneTrackAlarmColumnData( ) = default;

        virtual Kind GetKind() const override
        {
            return Kind::ZoneTrackAlarm;
        }

        const Guid& Id( ) const
        {
            return id_;
        }
        void SetId( const Guid& id )
        {
            id_ = id;
        }
        Int64 RowVersion( ) const
        {
            return rowVersion_;
        }
        void SetRowVersion( const Int64& rowVersion )
        {
            rowVersion_ = rowVersion;
        }
        const Guid& Track( ) const
        {
            return track_;
        }
        void SetTrack( const Guid& track )
        {
            track_ = track;
        }
        const Guid& Zone( ) const
        {
            return zone_;
        }
        void SetZone( const Guid& zone )
        {
            zone_ = zone;
        }
        const Guid& RadarTrack( ) const
        {
            return radarTrack_;
        }
        void SetRadarTrack( const Guid& radarTrack )
        {
            radarTrack_ = radarTrack;
        }
        const DateTime& Timestamp( ) const
        {
            return timestamp_;
        }
        void SetTimestamp( const DateTime& timestamp )
        {
            timestamp_ = timestamp;
        }
        double Latitude( ) const
        {
            return latitude_;
        }
        void SetLatitude( double latitude )
        {
            latitude_ = latitude;
        }
        double Longitude( ) const
        {
            return longitude_;
        }
        void SetLongitude( double longitude )
        {
            longitude_ = longitude;
        }
        double Speed( ) const
        {
            return speed_;
        }
        void SetSpeed( double speed )
        {
            speed_ = speed;
        }
        const DBDouble& Course( ) const
        {
            return course_;
        }
        void SetCourse( const DBDouble& course )
        {
            course_ = course;
        }
        const DBDouble& Heading( ) const
        {
            return heading_;
        }
        void SetHeading( const DBDouble& heading )
        {
            heading_ = heading;
        }
        double EnterLatitude( ) const
        {
            return enterLatitude_;
        }
        void SetEnterLatitude( double enterLatitude )
        {
            enterLatitude_ = enterLatitude;
        }
        double EnterLongitude( ) const
        {
            return enterLongitude_;
        }
        void SetEnterLongitude( double enterLongitude )
        {
            enterLongitude_ = enterLongitude;
        }
        const DBDouble& LeaveLatitude( ) const
        {
            return leaveLatitude_;
        }
        void SetLeaveLatitude( const DBDouble& leaveLatitude )
        {
            leaveLatitude_ = leaveLatitude;
        }
        const DBDouble& LeaveLongitude( ) const
        {
            return leaveLongitude_;
        }
        void SetLeaveLongitude( const DBDouble& leaveLongitude )
        {
            leaveLongitude_ = leaveLongitude;
        }
        void BindColumns( const ODBC::Statement& statement )
        {
            Bind(statement, ID_FIELD_ID, id_);
            Bind(statement, ROWVERSION_FIELD_ID, rowVersion_);
            Bind(statement, TRACK_FIELD_ID, track_);
            Bind(statement, ZONE_FIELD_ID, zone_);
            Bind(statement, RADARTRACK_FIELD_ID, radarTrack_);
            Bind(statement, TIMESTAMP_FIELD_ID, timestamp_);
            Bind(statement, LATITUDE_FIELD_ID, latitude_);
            Bind(statement, LONGITUDE_FIELD_ID, longitude_);
            Bind(statement, SPEED_FIELD_ID, speed_);
            Bind(statement, COURSE_FIELD_ID, course_);
            Bind(statement, HEADING_FIELD_ID, heading_);
            Bind(statement, ENTERLATITUDE_FIELD_ID, enterLatitude_);
            Bind(statement, ENTERLONGITUDE_FIELD_ID, enterLongitude_);
            Bind(statement, LEAVELATITUDE_FIELD_ID, leaveLatitude_);
            Bind(statement, LEAVELONGITUDE_FIELD_ID, leaveLongitude_);
        }

        template<IO::StreamWriter StreamT>
        void WriteColumns( IO::BinaryWriter<StreamT>& destination ) const
        {
            WriteColumnValue( destination, id_);
            WriteColumnValue( destination, rowVersion_);
            WriteColumnValue( destination, track_);
            WriteColumnValue( destination, zone_);
            WriteColumnValue( destination, radarTrack_);
            WriteColumnValue( destination, timestamp_);
            WriteColumnValue( destination, latitude_);
            WriteColumnValue( destination, longitude_);
            WriteColumnValue( destination, speed_);
            WriteColumnValue( destination, course_);
            WriteColumnValue( destination, heading_);
            WriteColumnValue( destination, enterLatitude_);
            WriteColumnValue( destination, enterLongitude_);
            WriteColumnValue( destination, leaveLatitude_);
            WriteColumnValue( destination, leaveLongitude_);
        }
    };

    using SimpleZoneTrackAlarmDataReader = SimpleColumnDataReader<ZoneTrackAlarmColumnData>;

}
#endif
