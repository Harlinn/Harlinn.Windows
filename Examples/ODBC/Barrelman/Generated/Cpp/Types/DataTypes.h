#pragma once
#ifndef TYPES_DATATYPES_H_
#define TYPES_DATATYPES_H_

#include "Enums.h"
#include <HODBC.h>
#include <HCCData.h>


namespace Barrelman::Types
{
    using namespace Harlinn;
    using namespace Harlinn::ODBC;
    using namespace Harlinn::Common::Core;

    template<typename ObjectT, typename KeyT>
        requires std::is_enum_v<ObjectT>
    using BaseData = Harlinn::Common::Core::Data::BaseData<ObjectT, KeyT>;

    BARRELMAN_EXPORT std::shared_ptr<BaseData<Kind, Guid>> DataFactory( Kind kind );

    class AircraftTypeObject : public BaseData<Kind, Guid>
    {
    public:
        using Base = BaseData<Kind, Guid>;
        static constexpr Kind KIND = Kind::AircraftType;
    private:
        Int64 rowVersion_ = 0;
        FixedDBWideString<127> name_;
    public:
        AircraftTypeObject( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(rowVersion_);
            name_.WriteTo( destination );
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(rowVersion_);
            name_.ReadFrom( source );
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<AircraftTypeObject>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<AircraftTypeObject&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const AircraftTypeObject& >( other );
                if ( dataObject.rowVersion_ != rowVersion_ )
                {
                    return false;
                }
                if ( dataObject.name_ != name_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        Int64 RowVersion( ) const
        {
            return rowVersion_;
        }
        void SetRowVersion( const Int64& rowVersion )
        {
            rowVersion_ = rowVersion;
        }
        const FixedDBWideString<127>& Name( ) const
        {
            return name_;
        }
        void SetName( const FixedDBWideString<127>& name )
        {
            name_ = name;
        }
    };
    class AisDeviceCommandObject : public BaseData<Kind, Guid>
    {
    public:
        using Base = BaseData<Kind, Guid>;
        static constexpr Kind KIND = Kind::AisDeviceCommand;
    private:
        Int64 rowVersion_ = 0;
        Guid aisDevice_;
        DateTime timestamp_;
        Types::DeviceCommandSourceType deviceCommandSourceType_ = Types::DeviceCommandSourceType::Unknown;
        Guid deviceCommandSourceId_;
        DBGuid reply_;
    public:
        AisDeviceCommandObject( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(rowVersion_);
            destination.Write(aisDevice_);
            destination.Write(timestamp_);
            destination.Write(deviceCommandSourceType_);
            destination.Write(deviceCommandSourceId_);
            reply_.WriteTo( destination );
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(rowVersion_);
            source.Read(aisDevice_);
            source.Read(timestamp_);
            source.Read(deviceCommandSourceType_);
            source.Read(deviceCommandSourceId_);
            reply_.ReadFrom( source );
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<AisDeviceCommandObject>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<AisDeviceCommandObject&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const AisDeviceCommandObject& >( other );
                if ( dataObject.rowVersion_ != rowVersion_ )
                {
                    return false;
                }
                if ( dataObject.aisDevice_ != aisDevice_ )
                {
                    return false;
                }
                if ( dataObject.timestamp_ != timestamp_ )
                {
                    return false;
                }
                if ( dataObject.deviceCommandSourceType_ != deviceCommandSourceType_ )
                {
                    return false;
                }
                if ( dataObject.deviceCommandSourceId_ != deviceCommandSourceId_ )
                {
                    return false;
                }
                if ( dataObject.reply_ != reply_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        Int64 RowVersion( ) const
        {
            return rowVersion_;
        }
        void SetRowVersion( const Int64& rowVersion )
        {
            rowVersion_ = rowVersion;
        }
        const Guid& AisDevice( ) const
        {
            return aisDevice_;
        }
        void SetAisDevice( const Guid& aisDevice )
        {
            aisDevice_ = aisDevice;
        }
        const DateTime& Timestamp( ) const
        {
            return timestamp_;
        }
        void SetTimestamp( const DateTime& timestamp )
        {
            timestamp_ = timestamp;
        }
        Types::DeviceCommandSourceType DeviceCommandSourceType( ) const
        {
            return deviceCommandSourceType_;
        }
        void SetDeviceCommandSourceType( Types::DeviceCommandSourceType deviceCommandSourceType )
        {
            deviceCommandSourceType_ = deviceCommandSourceType;
        }
        const Guid& DeviceCommandSourceId( ) const
        {
            return deviceCommandSourceId_;
        }
        void SetDeviceCommandSourceId( const Guid& deviceCommandSourceId )
        {
            deviceCommandSourceId_ = deviceCommandSourceId;
        }
        const DBGuid& Reply( ) const
        {
            return reply_;
        }
        void SetReply( const DBGuid& reply )
        {
            reply_ = reply;
        }
    };
    class AisDeviceCommandReplyObject : public BaseData<Kind, Guid>
    {
    public:
        using Base = BaseData<Kind, Guid>;
        static constexpr Kind KIND = Kind::AisDeviceCommandReply;
    private:
        Int64 rowVersion_ = 0;
        Guid aisDevice_;
        DateTime timestamp_;
        Guid command_;
        Types::DeviceCommandReplyStatus status_ = Types::DeviceCommandReplyStatus::Unknown;
        WideString message_;
        SQLLEN messageLength_ = SQL_NULL_DATA;
    public:
        AisDeviceCommandReplyObject( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(rowVersion_);
            destination.Write(aisDevice_);
            destination.Write(timestamp_);
            destination.Write(command_);
            destination.Write(status_);
            destination.Write(message_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(rowVersion_);
            source.Read(aisDevice_);
            source.Read(timestamp_);
            source.Read(command_);
            source.Read(status_);
            source.Read(message_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<AisDeviceCommandReplyObject>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<AisDeviceCommandReplyObject&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const AisDeviceCommandReplyObject& >( other );
                if ( dataObject.rowVersion_ != rowVersion_ )
                {
                    return false;
                }
                if ( dataObject.aisDevice_ != aisDevice_ )
                {
                    return false;
                }
                if ( dataObject.timestamp_ != timestamp_ )
                {
                    return false;
                }
                if ( dataObject.command_ != command_ )
                {
                    return false;
                }
                if ( dataObject.status_ != status_ )
                {
                    return false;
                }
                if ( dataObject.message_ != message_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        Int64 RowVersion( ) const
        {
            return rowVersion_;
        }
        void SetRowVersion( const Int64& rowVersion )
        {
            rowVersion_ = rowVersion;
        }
        const Guid& AisDevice( ) const
        {
            return aisDevice_;
        }
        void SetAisDevice( const Guid& aisDevice )
        {
            aisDevice_ = aisDevice;
        }
        const DateTime& Timestamp( ) const
        {
            return timestamp_;
        }
        void SetTimestamp( const DateTime& timestamp )
        {
            timestamp_ = timestamp;
        }
        const Guid& Command( ) const
        {
            return command_;
        }
        void SetCommand( const Guid& command )
        {
            command_ = command;
        }
        Types::DeviceCommandReplyStatus Status( ) const
        {
            return status_;
        }
        void SetStatus( Types::DeviceCommandReplyStatus status )
        {
            status_ = status;
        }
        const WideString& Message( ) const
        {
            return message_;
        }
        void SetMessage( const WideString& message )
        {
            message_ = message;
        }
    };
    class AisDeviceConfigurationObject : public BaseData<Kind, Guid>
    {
    public:
        using Base = BaseData<Kind, Guid>;
        static constexpr Kind KIND = Kind::AisDeviceConfiguration;
    private:
        Int64 rowVersion_ = 0;
        Guid aisDevice_;
        DateTime timestamp_;
        bool filter_ = false;
        double northWestLatitude_ = 0.0;
        double northWestLongitude_ = 0.0;
        double southEastLatitude_ = 0.0;
        double southEastLongitude_ = 0.0;
        FixedDBWideString<32> comPort_;
        Int32 baudRate_ = 0;
        FixedDBWideString<127> iPAddress_;
        Int32 port_ = 0;
        Int32 udpPort_ = 0;
        bool authenticate_ = false;
        FixedDBWideString<127> userName_;
        FixedDBWideString<127> password_;
        FixedDBWideString<127> authenticationURL_;
        Types::AisDeviceConnectionType connectionType_ = Types::AisDeviceConnectionType::Unknown;
        Int32 sourceUpdateRate_ = 0;
        FixedDBWideString<127> configurationURL_;
        bool storeReceivedSentences_ = false;
    public:
        AisDeviceConfigurationObject( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(rowVersion_);
            destination.Write(aisDevice_);
            destination.Write(timestamp_);
            destination.Write(filter_);
            destination.Write(northWestLatitude_);
            destination.Write(northWestLongitude_);
            destination.Write(southEastLatitude_);
            destination.Write(southEastLongitude_);
            comPort_.WriteTo( destination );
            destination.Write(baudRate_);
            iPAddress_.WriteTo( destination );
            destination.Write(port_);
            destination.Write(udpPort_);
            destination.Write(authenticate_);
            userName_.WriteTo( destination );
            password_.WriteTo( destination );
            authenticationURL_.WriteTo( destination );
            destination.Write(connectionType_);
            destination.Write(sourceUpdateRate_);
            configurationURL_.WriteTo( destination );
            destination.Write(storeReceivedSentences_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(rowVersion_);
            source.Read(aisDevice_);
            source.Read(timestamp_);
            source.Read(filter_);
            source.Read(northWestLatitude_);
            source.Read(northWestLongitude_);
            source.Read(southEastLatitude_);
            source.Read(southEastLongitude_);
            comPort_.ReadFrom( source );
            source.Read(baudRate_);
            iPAddress_.ReadFrom( source );
            source.Read(port_);
            source.Read(udpPort_);
            source.Read(authenticate_);
            userName_.ReadFrom( source );
            password_.ReadFrom( source );
            authenticationURL_.ReadFrom( source );
            source.Read(connectionType_);
            source.Read(sourceUpdateRate_);
            configurationURL_.ReadFrom( source );
            source.Read(storeReceivedSentences_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<AisDeviceConfigurationObject>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<AisDeviceConfigurationObject&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const AisDeviceConfigurationObject& >( other );
                if ( dataObject.rowVersion_ != rowVersion_ )
                {
                    return false;
                }
                if ( dataObject.aisDevice_ != aisDevice_ )
                {
                    return false;
                }
                if ( dataObject.timestamp_ != timestamp_ )
                {
                    return false;
                }
                if ( dataObject.filter_ != filter_ )
                {
                    return false;
                }
                if ( dataObject.northWestLatitude_ != northWestLatitude_ )
                {
                    return false;
                }
                if ( dataObject.northWestLongitude_ != northWestLongitude_ )
                {
                    return false;
                }
                if ( dataObject.southEastLatitude_ != southEastLatitude_ )
                {
                    return false;
                }
                if ( dataObject.southEastLongitude_ != southEastLongitude_ )
                {
                    return false;
                }
                if ( dataObject.comPort_ != comPort_ )
                {
                    return false;
                }
                if ( dataObject.baudRate_ != baudRate_ )
                {
                    return false;
                }
                if ( dataObject.iPAddress_ != iPAddress_ )
                {
                    return false;
                }
                if ( dataObject.port_ != port_ )
                {
                    return false;
                }
                if ( dataObject.udpPort_ != udpPort_ )
                {
                    return false;
                }
                if ( dataObject.authenticate_ != authenticate_ )
                {
                    return false;
                }
                if ( dataObject.userName_ != userName_ )
                {
                    return false;
                }
                if ( dataObject.password_ != password_ )
                {
                    return false;
                }
                if ( dataObject.authenticationURL_ != authenticationURL_ )
                {
                    return false;
                }
                if ( dataObject.connectionType_ != connectionType_ )
                {
                    return false;
                }
                if ( dataObject.sourceUpdateRate_ != sourceUpdateRate_ )
                {
                    return false;
                }
                if ( dataObject.configurationURL_ != configurationURL_ )
                {
                    return false;
                }
                if ( dataObject.storeReceivedSentences_ != storeReceivedSentences_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        Int64 RowVersion( ) const
        {
            return rowVersion_;
        }
        void SetRowVersion( const Int64& rowVersion )
        {
            rowVersion_ = rowVersion;
        }
        const Guid& AisDevice( ) const
        {
            return aisDevice_;
        }
        void SetAisDevice( const Guid& aisDevice )
        {
            aisDevice_ = aisDevice;
        }
        const DateTime& Timestamp( ) const
        {
            return timestamp_;
        }
        void SetTimestamp( const DateTime& timestamp )
        {
            timestamp_ = timestamp;
        }
        bool Filter( ) const
        {
            return filter_;
        }
        void SetFilter( bool filter )
        {
            filter_ = filter;
        }
        double NorthWestLatitude( ) const
        {
            return northWestLatitude_;
        }
        void SetNorthWestLatitude( double northWestLatitude )
        {
            northWestLatitude_ = northWestLatitude;
        }
        double NorthWestLongitude( ) const
        {
            return northWestLongitude_;
        }
        void SetNorthWestLongitude( double northWestLongitude )
        {
            northWestLongitude_ = northWestLongitude;
        }
        double SouthEastLatitude( ) const
        {
            return southEastLatitude_;
        }
        void SetSouthEastLatitude( double southEastLatitude )
        {
            southEastLatitude_ = southEastLatitude;
        }
        double SouthEastLongitude( ) const
        {
            return southEastLongitude_;
        }
        void SetSouthEastLongitude( double southEastLongitude )
        {
            southEastLongitude_ = southEastLongitude;
        }
        const FixedDBWideString<32>& ComPort( ) const
        {
            return comPort_;
        }
        void SetComPort( const FixedDBWideString<32>& comPort )
        {
            comPort_ = comPort;
        }
        Int32 BaudRate( ) const
        {
            return baudRate_;
        }
        void SetBaudRate( Int32 baudRate )
        {
            baudRate_ = baudRate;
        }
        const FixedDBWideString<127>& IPAddress( ) const
        {
            return iPAddress_;
        }
        void SetIPAddress( const FixedDBWideString<127>& iPAddress )
        {
            iPAddress_ = iPAddress;
        }
        Int32 Port( ) const
        {
            return port_;
        }
        void SetPort( Int32 port )
        {
            port_ = port;
        }
        Int32 UdpPort( ) const
        {
            return udpPort_;
        }
        void SetUdpPort( Int32 udpPort )
        {
            udpPort_ = udpPort;
        }
        bool Authenticate( ) const
        {
            return authenticate_;
        }
        void SetAuthenticate( bool authenticate )
        {
            authenticate_ = authenticate;
        }
        const FixedDBWideString<127>& UserName( ) const
        {
            return userName_;
        }
        void SetUserName( const FixedDBWideString<127>& userName )
        {
            userName_ = userName;
        }
        const FixedDBWideString<127>& Password( ) const
        {
            return password_;
        }
        void SetPassword( const FixedDBWideString<127>& password )
        {
            password_ = password;
        }
        const FixedDBWideString<127>& AuthenticationURL( ) const
        {
            return authenticationURL_;
        }
        void SetAuthenticationURL( const FixedDBWideString<127>& authenticationURL )
        {
            authenticationURL_ = authenticationURL;
        }
        Types::AisDeviceConnectionType ConnectionType( ) const
        {
            return connectionType_;
        }
        void SetConnectionType( Types::AisDeviceConnectionType connectionType )
        {
            connectionType_ = connectionType;
        }
        Int32 SourceUpdateRate( ) const
        {
            return sourceUpdateRate_;
        }
        void SetSourceUpdateRate( Int32 sourceUpdateRate )
        {
            sourceUpdateRate_ = sourceUpdateRate;
        }
        const FixedDBWideString<127>& ConfigurationURL( ) const
        {
            return configurationURL_;
        }
        void SetConfigurationURL( const FixedDBWideString<127>& configurationURL )
        {
            configurationURL_ = configurationURL;
        }
        bool StoreReceivedSentences( ) const
        {
            return storeReceivedSentences_;
        }
        void SetStoreReceivedSentences( bool storeReceivedSentences )
        {
            storeReceivedSentences_ = storeReceivedSentences;
        }
    };
    class AisDeviceRawMessageObject : public BaseData<Kind, Guid>
    {
    public:
        using Base = BaseData<Kind, Guid>;
        static constexpr Kind KIND = Kind::AisDeviceRawMessage;
    private:
        Int64 rowVersion_ = 0;
        Guid aisDevice_;
        DateTime timestamp_;
        bool isSent_ = false;
        FixedDBWideString<127> message_;
    public:
        AisDeviceRawMessageObject( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(rowVersion_);
            destination.Write(aisDevice_);
            destination.Write(timestamp_);
            destination.Write(isSent_);
            message_.WriteTo( destination );
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(rowVersion_);
            source.Read(aisDevice_);
            source.Read(timestamp_);
            source.Read(isSent_);
            message_.ReadFrom( source );
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<AisDeviceRawMessageObject>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<AisDeviceRawMessageObject&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const AisDeviceRawMessageObject& >( other );
                if ( dataObject.rowVersion_ != rowVersion_ )
                {
                    return false;
                }
                if ( dataObject.aisDevice_ != aisDevice_ )
                {
                    return false;
                }
                if ( dataObject.timestamp_ != timestamp_ )
                {
                    return false;
                }
                if ( dataObject.isSent_ != isSent_ )
                {
                    return false;
                }
                if ( dataObject.message_ != message_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        Int64 RowVersion( ) const
        {
            return rowVersion_;
        }
        void SetRowVersion( const Int64& rowVersion )
        {
            rowVersion_ = rowVersion;
        }
        const Guid& AisDevice( ) const
        {
            return aisDevice_;
        }
        void SetAisDevice( const Guid& aisDevice )
        {
            aisDevice_ = aisDevice;
        }
        const DateTime& Timestamp( ) const
        {
            return timestamp_;
        }
        void SetTimestamp( const DateTime& timestamp )
        {
            timestamp_ = timestamp;
        }
        bool IsSent( ) const
        {
            return isSent_;
        }
        void SetIsSent( bool isSent )
        {
            isSent_ = isSent;
        }
        const FixedDBWideString<127>& Message( ) const
        {
            return message_;
        }
        void SetMessage( const FixedDBWideString<127>& message )
        {
            message_ = message;
        }
    };
    class AisDeviceRawSentenceObject : public BaseData<Kind, Guid>
    {
    public:
        using Base = BaseData<Kind, Guid>;
        static constexpr Kind KIND = Kind::AisDeviceRawSentence;
    private:
        Int64 rowVersion_ = 0;
        Guid aisDevice_;
        DateTime timestamp_;
        WideString sentence_;
        SQLLEN sentenceLength_ = SQL_NULL_DATA;
    public:
        AisDeviceRawSentenceObject( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(rowVersion_);
            destination.Write(aisDevice_);
            destination.Write(timestamp_);
            destination.Write(sentence_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(rowVersion_);
            source.Read(aisDevice_);
            source.Read(timestamp_);
            source.Read(sentence_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<AisDeviceRawSentenceObject>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<AisDeviceRawSentenceObject&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const AisDeviceRawSentenceObject& >( other );
                if ( dataObject.rowVersion_ != rowVersion_ )
                {
                    return false;
                }
                if ( dataObject.aisDevice_ != aisDevice_ )
                {
                    return false;
                }
                if ( dataObject.timestamp_ != timestamp_ )
                {
                    return false;
                }
                if ( dataObject.sentence_ != sentence_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        Int64 RowVersion( ) const
        {
            return rowVersion_;
        }
        void SetRowVersion( const Int64& rowVersion )
        {
            rowVersion_ = rowVersion;
        }
        const Guid& AisDevice( ) const
        {
            return aisDevice_;
        }
        void SetAisDevice( const Guid& aisDevice )
        {
            aisDevice_ = aisDevice;
        }
        const DateTime& Timestamp( ) const
        {
            return timestamp_;
        }
        void SetTimestamp( const DateTime& timestamp )
        {
            timestamp_ = timestamp;
        }
        const WideString& Sentence( ) const
        {
            return sentence_;
        }
        void SetSentence( const WideString& sentence )
        {
            sentence_ = sentence;
        }
    };
    class AisMessageObject : public BaseData<Kind, Guid>
    {
    public:
        using Base = BaseData<Kind, Guid>;
        static constexpr Kind KIND = Kind::AisMessage;
    private:
        Int64 rowVersion_ = 0;
        Guid aisDevice_;
        DateTime receivedTimestamp_;
        Int64 messageSequenceNumber_ = 0;
        Int32 repeat_ = 0;
        Guid mmsi_;
    public:
        AisMessageObject( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(rowVersion_);
            destination.Write(aisDevice_);
            destination.Write(receivedTimestamp_);
            destination.Write(messageSequenceNumber_);
            destination.Write(repeat_);
            destination.Write(mmsi_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(rowVersion_);
            source.Read(aisDevice_);
            source.Read(receivedTimestamp_);
            source.Read(messageSequenceNumber_);
            source.Read(repeat_);
            source.Read(mmsi_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<AisMessageObject>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<AisMessageObject&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const AisMessageObject& >( other );
                if ( dataObject.rowVersion_ != rowVersion_ )
                {
                    return false;
                }
                if ( dataObject.aisDevice_ != aisDevice_ )
                {
                    return false;
                }
                if ( dataObject.receivedTimestamp_ != receivedTimestamp_ )
                {
                    return false;
                }
                if ( dataObject.messageSequenceNumber_ != messageSequenceNumber_ )
                {
                    return false;
                }
                if ( dataObject.repeat_ != repeat_ )
                {
                    return false;
                }
                if ( dataObject.mmsi_ != mmsi_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        Int64 RowVersion( ) const
        {
            return rowVersion_;
        }
        void SetRowVersion( const Int64& rowVersion )
        {
            rowVersion_ = rowVersion;
        }
        const Guid& AisDevice( ) const
        {
            return aisDevice_;
        }
        void SetAisDevice( const Guid& aisDevice )
        {
            aisDevice_ = aisDevice;
        }
        const DateTime& ReceivedTimestamp( ) const
        {
            return receivedTimestamp_;
        }
        void SetReceivedTimestamp( const DateTime& receivedTimestamp )
        {
            receivedTimestamp_ = receivedTimestamp;
        }
        Int64 MessageSequenceNumber( ) const
        {
            return messageSequenceNumber_;
        }
        void SetMessageSequenceNumber( Int64 messageSequenceNumber )
        {
            messageSequenceNumber_ = messageSequenceNumber;
        }
        Int32 Repeat( ) const
        {
            return repeat_;
        }
        void SetRepeat( Int32 repeat )
        {
            repeat_ = repeat;
        }
        const Guid& Mmsi( ) const
        {
            return mmsi_;
        }
        void SetMmsi( const Guid& mmsi )
        {
            mmsi_ = mmsi;
        }
    };
    class AidToNavigationReportMessageObject : public AisMessageObject
    {
    public:
        using Base = AisMessageObject;
        static constexpr Kind KIND = Kind::AidToNavigationReportMessage;
    private:
        Types::NavigationalAidType navigationalAidType_ = Types::NavigationalAidType::NotSpecified;
        FixedDBWideString<127> name_;
        Types::PositionAccuracy positionAccuracy_ = Types::PositionAccuracy::Low;
        double longitude_ = 0.0;
        double latitude_ = 0.0;
        Int32 dimensionToBow_ = 0;
        Int32 dimensionToStern_ = 0;
        Int32 dimensionToPort_ = 0;
        Int32 dimensionToStarboard_ = 0;
        Types::PositionFixType positionFixType_ = Types::PositionFixType::Undefined1;
        Int32 timestamp_ = 0;
        bool offPosition_ = false;
        Int32 regionalReserved_ = 0;
        Types::Raim raim_ = Types::Raim::NotInUse;
        bool virtualAid_ = false;
        bool assigned_ = false;
        Int32 spare_ = 0;
        FixedDBWideString<127> nameExtension_;
    public:
        AidToNavigationReportMessageObject( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(navigationalAidType_);
            name_.WriteTo( destination );
            destination.Write(positionAccuracy_);
            destination.Write(longitude_);
            destination.Write(latitude_);
            destination.Write(dimensionToBow_);
            destination.Write(dimensionToStern_);
            destination.Write(dimensionToPort_);
            destination.Write(dimensionToStarboard_);
            destination.Write(positionFixType_);
            destination.Write(timestamp_);
            destination.Write(offPosition_);
            destination.Write(regionalReserved_);
            destination.Write(raim_);
            destination.Write(virtualAid_);
            destination.Write(assigned_);
            destination.Write(spare_);
            nameExtension_.WriteTo( destination );
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(navigationalAidType_);
            name_.ReadFrom( source );
            source.Read(positionAccuracy_);
            source.Read(longitude_);
            source.Read(latitude_);
            source.Read(dimensionToBow_);
            source.Read(dimensionToStern_);
            source.Read(dimensionToPort_);
            source.Read(dimensionToStarboard_);
            source.Read(positionFixType_);
            source.Read(timestamp_);
            source.Read(offPosition_);
            source.Read(regionalReserved_);
            source.Read(raim_);
            source.Read(virtualAid_);
            source.Read(assigned_);
            source.Read(spare_);
            nameExtension_.ReadFrom( source );
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<AidToNavigationReportMessageObject>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<AidToNavigationReportMessageObject&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const AidToNavigationReportMessageObject& >( other );
                if ( dataObject.navigationalAidType_ != navigationalAidType_ )
                {
                    return false;
                }
                if ( dataObject.name_ != name_ )
                {
                    return false;
                }
                if ( dataObject.positionAccuracy_ != positionAccuracy_ )
                {
                    return false;
                }
                if ( dataObject.longitude_ != longitude_ )
                {
                    return false;
                }
                if ( dataObject.latitude_ != latitude_ )
                {
                    return false;
                }
                if ( dataObject.dimensionToBow_ != dimensionToBow_ )
                {
                    return false;
                }
                if ( dataObject.dimensionToStern_ != dimensionToStern_ )
                {
                    return false;
                }
                if ( dataObject.dimensionToPort_ != dimensionToPort_ )
                {
                    return false;
                }
                if ( dataObject.dimensionToStarboard_ != dimensionToStarboard_ )
                {
                    return false;
                }
                if ( dataObject.positionFixType_ != positionFixType_ )
                {
                    return false;
                }
                if ( dataObject.timestamp_ != timestamp_ )
                {
                    return false;
                }
                if ( dataObject.offPosition_ != offPosition_ )
                {
                    return false;
                }
                if ( dataObject.regionalReserved_ != regionalReserved_ )
                {
                    return false;
                }
                if ( dataObject.raim_ != raim_ )
                {
                    return false;
                }
                if ( dataObject.virtualAid_ != virtualAid_ )
                {
                    return false;
                }
                if ( dataObject.assigned_ != assigned_ )
                {
                    return false;
                }
                if ( dataObject.spare_ != spare_ )
                {
                    return false;
                }
                if ( dataObject.nameExtension_ != nameExtension_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        Types::NavigationalAidType NavigationalAidType( ) const
        {
            return navigationalAidType_;
        }
        void SetNavigationalAidType( Types::NavigationalAidType navigationalAidType )
        {
            navigationalAidType_ = navigationalAidType;
        }
        const FixedDBWideString<127>& Name( ) const
        {
            return name_;
        }
        void SetName( const FixedDBWideString<127>& name )
        {
            name_ = name;
        }
        Types::PositionAccuracy PositionAccuracy( ) const
        {
            return positionAccuracy_;
        }
        void SetPositionAccuracy( Types::PositionAccuracy positionAccuracy )
        {
            positionAccuracy_ = positionAccuracy;
        }
        double Longitude( ) const
        {
            return longitude_;
        }
        void SetLongitude( double longitude )
        {
            longitude_ = longitude;
        }
        double Latitude( ) const
        {
            return latitude_;
        }
        void SetLatitude( double latitude )
        {
            latitude_ = latitude;
        }
        Int32 DimensionToBow( ) const
        {
            return dimensionToBow_;
        }
        void SetDimensionToBow( Int32 dimensionToBow )
        {
            dimensionToBow_ = dimensionToBow;
        }
        Int32 DimensionToStern( ) const
        {
            return dimensionToStern_;
        }
        void SetDimensionToStern( Int32 dimensionToStern )
        {
            dimensionToStern_ = dimensionToStern;
        }
        Int32 DimensionToPort( ) const
        {
            return dimensionToPort_;
        }
        void SetDimensionToPort( Int32 dimensionToPort )
        {
            dimensionToPort_ = dimensionToPort;
        }
        Int32 DimensionToStarboard( ) const
        {
            return dimensionToStarboard_;
        }
        void SetDimensionToStarboard( Int32 dimensionToStarboard )
        {
            dimensionToStarboard_ = dimensionToStarboard;
        }
        Types::PositionFixType PositionFixType( ) const
        {
            return positionFixType_;
        }
        void SetPositionFixType( Types::PositionFixType positionFixType )
        {
            positionFixType_ = positionFixType;
        }
        Int32 Timestamp( ) const
        {
            return timestamp_;
        }
        void SetTimestamp( Int32 timestamp )
        {
            timestamp_ = timestamp;
        }
        bool OffPosition( ) const
        {
            return offPosition_;
        }
        void SetOffPosition( bool offPosition )
        {
            offPosition_ = offPosition;
        }
        Int32 RegionalReserved( ) const
        {
            return regionalReserved_;
        }
        void SetRegionalReserved( Int32 regionalReserved )
        {
            regionalReserved_ = regionalReserved;
        }
        Types::Raim Raim( ) const
        {
            return raim_;
        }
        void SetRaim( Types::Raim raim )
        {
            raim_ = raim;
        }
        bool VirtualAid( ) const
        {
            return virtualAid_;
        }
        void SetVirtualAid( bool virtualAid )
        {
            virtualAid_ = virtualAid;
        }
        bool Assigned( ) const
        {
            return assigned_;
        }
        void SetAssigned( bool assigned )
        {
            assigned_ = assigned;
        }
        Int32 Spare( ) const
        {
            return spare_;
        }
        void SetSpare( Int32 spare )
        {
            spare_ = spare;
        }
        const FixedDBWideString<127>& NameExtension( ) const
        {
            return nameExtension_;
        }
        void SetNameExtension( const FixedDBWideString<127>& nameExtension )
        {
            nameExtension_ = nameExtension;
        }
    };
    class AisAddressedSafetyRelatedMessageObject : public AisMessageObject
    {
    public:
        using Base = AisMessageObject;
        static constexpr Kind KIND = Kind::AisAddressedSafetyRelatedMessage;
    private:
        Int32 sequenceNumber_ = 0;
        Guid destinationMmsi_;
        bool retransmitFlag_ = false;
        Int32 spare_ = 0;
        FixedDBWideString<127> text_;
    public:
        AisAddressedSafetyRelatedMessageObject( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(sequenceNumber_);
            destination.Write(destinationMmsi_);
            destination.Write(retransmitFlag_);
            destination.Write(spare_);
            text_.WriteTo( destination );
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(sequenceNumber_);
            source.Read(destinationMmsi_);
            source.Read(retransmitFlag_);
            source.Read(spare_);
            text_.ReadFrom( source );
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<AisAddressedSafetyRelatedMessageObject>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<AisAddressedSafetyRelatedMessageObject&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const AisAddressedSafetyRelatedMessageObject& >( other );
                if ( dataObject.sequenceNumber_ != sequenceNumber_ )
                {
                    return false;
                }
                if ( dataObject.destinationMmsi_ != destinationMmsi_ )
                {
                    return false;
                }
                if ( dataObject.retransmitFlag_ != retransmitFlag_ )
                {
                    return false;
                }
                if ( dataObject.spare_ != spare_ )
                {
                    return false;
                }
                if ( dataObject.text_ != text_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        Int32 SequenceNumber( ) const
        {
            return sequenceNumber_;
        }
        void SetSequenceNumber( Int32 sequenceNumber )
        {
            sequenceNumber_ = sequenceNumber;
        }
        const Guid& DestinationMmsi( ) const
        {
            return destinationMmsi_;
        }
        void SetDestinationMmsi( const Guid& destinationMmsi )
        {
            destinationMmsi_ = destinationMmsi;
        }
        bool RetransmitFlag( ) const
        {
            return retransmitFlag_;
        }
        void SetRetransmitFlag( bool retransmitFlag )
        {
            retransmitFlag_ = retransmitFlag;
        }
        Int32 Spare( ) const
        {
            return spare_;
        }
        void SetSpare( Int32 spare )
        {
            spare_ = spare;
        }
        const FixedDBWideString<127>& Text( ) const
        {
            return text_;
        }
        void SetText( const FixedDBWideString<127>& text )
        {
            text_ = text;
        }
    };
    class AisBaseStationReportMessageObject : public AisMessageObject
    {
    public:
        using Base = AisMessageObject;
        static constexpr Kind KIND = Kind::AisBaseStationReportMessage;
    private:
        DateTime timestamp_;
        Types::PositionAccuracy positionAccuracy_ = Types::PositionAccuracy::Low;
        double longitude_ = 0.0;
        double latitude_ = 0.0;
        Types::PositionFixType positionFixType_ = Types::PositionFixType::Undefined1;
        Int32 spare_ = 0;
        Types::Raim raim_ = Types::Raim::NotInUse;
        Int32 radioStatus_ = 0;
    public:
        AisBaseStationReportMessageObject( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(timestamp_);
            destination.Write(positionAccuracy_);
            destination.Write(longitude_);
            destination.Write(latitude_);
            destination.Write(positionFixType_);
            destination.Write(spare_);
            destination.Write(raim_);
            destination.Write(radioStatus_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(timestamp_);
            source.Read(positionAccuracy_);
            source.Read(longitude_);
            source.Read(latitude_);
            source.Read(positionFixType_);
            source.Read(spare_);
            source.Read(raim_);
            source.Read(radioStatus_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<AisBaseStationReportMessageObject>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<AisBaseStationReportMessageObject&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const AisBaseStationReportMessageObject& >( other );
                if ( dataObject.timestamp_ != timestamp_ )
                {
                    return false;
                }
                if ( dataObject.positionAccuracy_ != positionAccuracy_ )
                {
                    return false;
                }
                if ( dataObject.longitude_ != longitude_ )
                {
                    return false;
                }
                if ( dataObject.latitude_ != latitude_ )
                {
                    return false;
                }
                if ( dataObject.positionFixType_ != positionFixType_ )
                {
                    return false;
                }
                if ( dataObject.spare_ != spare_ )
                {
                    return false;
                }
                if ( dataObject.raim_ != raim_ )
                {
                    return false;
                }
                if ( dataObject.radioStatus_ != radioStatus_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        const DateTime& Timestamp( ) const
        {
            return timestamp_;
        }
        void SetTimestamp( const DateTime& timestamp )
        {
            timestamp_ = timestamp;
        }
        Types::PositionAccuracy PositionAccuracy( ) const
        {
            return positionAccuracy_;
        }
        void SetPositionAccuracy( Types::PositionAccuracy positionAccuracy )
        {
            positionAccuracy_ = positionAccuracy;
        }
        double Longitude( ) const
        {
            return longitude_;
        }
        void SetLongitude( double longitude )
        {
            longitude_ = longitude;
        }
        double Latitude( ) const
        {
            return latitude_;
        }
        void SetLatitude( double latitude )
        {
            latitude_ = latitude;
        }
        Types::PositionFixType PositionFixType( ) const
        {
            return positionFixType_;
        }
        void SetPositionFixType( Types::PositionFixType positionFixType )
        {
            positionFixType_ = positionFixType;
        }
        Int32 Spare( ) const
        {
            return spare_;
        }
        void SetSpare( Int32 spare )
        {
            spare_ = spare;
        }
        Types::Raim Raim( ) const
        {
            return raim_;
        }
        void SetRaim( Types::Raim raim )
        {
            raim_ = raim;
        }
        Int32 RadioStatus( ) const
        {
            return radioStatus_;
        }
        void SetRadioStatus( Int32 radioStatus )
        {
            radioStatus_ = radioStatus;
        }
    };
    class AisBinaryAcknowledgeMessageObject : public AisMessageObject
    {
    public:
        using Base = AisMessageObject;
        static constexpr Kind KIND = Kind::AisBinaryAcknowledgeMessage;
    private:
        Int32 spare_ = 0;
        Int32 sequenceNumber1_ = 0;
        Guid mmsi1_;
        DBInt32 sequenceNumber2_;
        DBGuid mmsi2_;
        DBInt32 sequenceNumber3_;
        DBGuid mmsi3_;
        DBInt32 sequenceNumber4_;
        DBGuid mmsi4_;
    public:
        AisBinaryAcknowledgeMessageObject( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(spare_);
            destination.Write(sequenceNumber1_);
            destination.Write(mmsi1_);
            sequenceNumber2_.WriteTo( destination );
            mmsi2_.WriteTo( destination );
            sequenceNumber3_.WriteTo( destination );
            mmsi3_.WriteTo( destination );
            sequenceNumber4_.WriteTo( destination );
            mmsi4_.WriteTo( destination );
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(spare_);
            source.Read(sequenceNumber1_);
            source.Read(mmsi1_);
            sequenceNumber2_.ReadFrom( source );
            mmsi2_.ReadFrom( source );
            sequenceNumber3_.ReadFrom( source );
            mmsi3_.ReadFrom( source );
            sequenceNumber4_.ReadFrom( source );
            mmsi4_.ReadFrom( source );
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<AisBinaryAcknowledgeMessageObject>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<AisBinaryAcknowledgeMessageObject&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const AisBinaryAcknowledgeMessageObject& >( other );
                if ( dataObject.spare_ != spare_ )
                {
                    return false;
                }
                if ( dataObject.sequenceNumber1_ != sequenceNumber1_ )
                {
                    return false;
                }
                if ( dataObject.mmsi1_ != mmsi1_ )
                {
                    return false;
                }
                if ( dataObject.sequenceNumber2_ != sequenceNumber2_ )
                {
                    return false;
                }
                if ( dataObject.mmsi2_ != mmsi2_ )
                {
                    return false;
                }
                if ( dataObject.sequenceNumber3_ != sequenceNumber3_ )
                {
                    return false;
                }
                if ( dataObject.mmsi3_ != mmsi3_ )
                {
                    return false;
                }
                if ( dataObject.sequenceNumber4_ != sequenceNumber4_ )
                {
                    return false;
                }
                if ( dataObject.mmsi4_ != mmsi4_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        Int32 Spare( ) const
        {
            return spare_;
        }
        void SetSpare( Int32 spare )
        {
            spare_ = spare;
        }
        Int32 SequenceNumber1( ) const
        {
            return sequenceNumber1_;
        }
        void SetSequenceNumber1( Int32 sequenceNumber1 )
        {
            sequenceNumber1_ = sequenceNumber1;
        }
        const Guid& Mmsi1( ) const
        {
            return mmsi1_;
        }
        void SetMmsi1( const Guid& mmsi1 )
        {
            mmsi1_ = mmsi1;
        }
        const DBInt32& SequenceNumber2( ) const
        {
            return sequenceNumber2_;
        }
        void SetSequenceNumber2( const DBInt32& sequenceNumber2 )
        {
            sequenceNumber2_ = sequenceNumber2;
        }
        const DBGuid& Mmsi2( ) const
        {
            return mmsi2_;
        }
        void SetMmsi2( const DBGuid& mmsi2 )
        {
            mmsi2_ = mmsi2;
        }
        const DBInt32& SequenceNumber3( ) const
        {
            return sequenceNumber3_;
        }
        void SetSequenceNumber3( const DBInt32& sequenceNumber3 )
        {
            sequenceNumber3_ = sequenceNumber3;
        }
        const DBGuid& Mmsi3( ) const
        {
            return mmsi3_;
        }
        void SetMmsi3( const DBGuid& mmsi3 )
        {
            mmsi3_ = mmsi3;
        }
        const DBInt32& SequenceNumber4( ) const
        {
            return sequenceNumber4_;
        }
        void SetSequenceNumber4( const DBInt32& sequenceNumber4 )
        {
            sequenceNumber4_ = sequenceNumber4;
        }
        const DBGuid& Mmsi4( ) const
        {
            return mmsi4_;
        }
        void SetMmsi4( const DBGuid& mmsi4 )
        {
            mmsi4_ = mmsi4;
        }
    };
    class AisBinaryAddressedMessageObject : public AisMessageObject
    {
    public:
        using Base = AisMessageObject;
        static constexpr Kind KIND = Kind::AisBinaryAddressedMessage;
    private:
        Int32 sequenceNumber_ = 0;
        Guid destinationMmsi_;
        bool retransmitFlag_ = false;
        Int32 spare_ = 0;
        Int32 designatedAreaCode_ = 0;
        Int32 functionalId_ = 0;
        WideString data_;
        SQLLEN dataLength_ = SQL_NULL_DATA;
    public:
        AisBinaryAddressedMessageObject( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(sequenceNumber_);
            destination.Write(destinationMmsi_);
            destination.Write(retransmitFlag_);
            destination.Write(spare_);
            destination.Write(designatedAreaCode_);
            destination.Write(functionalId_);
            destination.Write(data_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(sequenceNumber_);
            source.Read(destinationMmsi_);
            source.Read(retransmitFlag_);
            source.Read(spare_);
            source.Read(designatedAreaCode_);
            source.Read(functionalId_);
            source.Read(data_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<AisBinaryAddressedMessageObject>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<AisBinaryAddressedMessageObject&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const AisBinaryAddressedMessageObject& >( other );
                if ( dataObject.sequenceNumber_ != sequenceNumber_ )
                {
                    return false;
                }
                if ( dataObject.destinationMmsi_ != destinationMmsi_ )
                {
                    return false;
                }
                if ( dataObject.retransmitFlag_ != retransmitFlag_ )
                {
                    return false;
                }
                if ( dataObject.spare_ != spare_ )
                {
                    return false;
                }
                if ( dataObject.designatedAreaCode_ != designatedAreaCode_ )
                {
                    return false;
                }
                if ( dataObject.functionalId_ != functionalId_ )
                {
                    return false;
                }
                if ( dataObject.data_ != data_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        Int32 SequenceNumber( ) const
        {
            return sequenceNumber_;
        }
        void SetSequenceNumber( Int32 sequenceNumber )
        {
            sequenceNumber_ = sequenceNumber;
        }
        const Guid& DestinationMmsi( ) const
        {
            return destinationMmsi_;
        }
        void SetDestinationMmsi( const Guid& destinationMmsi )
        {
            destinationMmsi_ = destinationMmsi;
        }
        bool RetransmitFlag( ) const
        {
            return retransmitFlag_;
        }
        void SetRetransmitFlag( bool retransmitFlag )
        {
            retransmitFlag_ = retransmitFlag;
        }
        Int32 Spare( ) const
        {
            return spare_;
        }
        void SetSpare( Int32 spare )
        {
            spare_ = spare;
        }
        Int32 DesignatedAreaCode( ) const
        {
            return designatedAreaCode_;
        }
        void SetDesignatedAreaCode( Int32 designatedAreaCode )
        {
            designatedAreaCode_ = designatedAreaCode;
        }
        Int32 FunctionalId( ) const
        {
            return functionalId_;
        }
        void SetFunctionalId( Int32 functionalId )
        {
            functionalId_ = functionalId;
        }
        const WideString& Data( ) const
        {
            return data_;
        }
        void SetData( const WideString& data )
        {
            data_ = data;
        }
    };
    class AisBinaryBroadcastMessageObject : public AisMessageObject
    {
    public:
        using Base = AisMessageObject;
        static constexpr Kind KIND = Kind::AisBinaryBroadcastMessage;
    private:
        Int32 spare_ = 0;
        Int32 designatedAreaCode_ = 0;
        Int32 functionalId_ = 0;
        WideString data_;
        SQLLEN dataLength_ = SQL_NULL_DATA;
    public:
        AisBinaryBroadcastMessageObject( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(spare_);
            destination.Write(designatedAreaCode_);
            destination.Write(functionalId_);
            destination.Write(data_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(spare_);
            source.Read(designatedAreaCode_);
            source.Read(functionalId_);
            source.Read(data_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<AisBinaryBroadcastMessageObject>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<AisBinaryBroadcastMessageObject&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const AisBinaryBroadcastMessageObject& >( other );
                if ( dataObject.spare_ != spare_ )
                {
                    return false;
                }
                if ( dataObject.designatedAreaCode_ != designatedAreaCode_ )
                {
                    return false;
                }
                if ( dataObject.functionalId_ != functionalId_ )
                {
                    return false;
                }
                if ( dataObject.data_ != data_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        Int32 Spare( ) const
        {
            return spare_;
        }
        void SetSpare( Int32 spare )
        {
            spare_ = spare;
        }
        Int32 DesignatedAreaCode( ) const
        {
            return designatedAreaCode_;
        }
        void SetDesignatedAreaCode( Int32 designatedAreaCode )
        {
            designatedAreaCode_ = designatedAreaCode;
        }
        Int32 FunctionalId( ) const
        {
            return functionalId_;
        }
        void SetFunctionalId( Int32 functionalId )
        {
            functionalId_ = functionalId;
        }
        const WideString& Data( ) const
        {
            return data_;
        }
        void SetData( const WideString& data )
        {
            data_ = data;
        }
    };
    class AisDataLinkManagementMessageObject : public AisMessageObject
    {
    public:
        using Base = AisMessageObject;
        static constexpr Kind KIND = Kind::AisDataLinkManagementMessage;
    private:
        Int32 spare_ = 0;
        Int32 offset1_ = 0;
        Int32 reservedSlots1_ = 0;
        Int32 timeout1_ = 0;
        Int32 increment1_ = 0;
        DBInt32 offset2_;
        DBInt32 reservedSlots2_;
        DBInt32 timeout2_;
        DBInt32 increment2_;
        DBInt32 offset3_;
        DBInt32 reservedSlots3_;
        DBInt32 timeout3_;
        DBInt32 increment3_;
        DBInt32 offset4_;
        DBInt32 reservedSlots4_;
        DBInt32 timeout4_;
        DBInt32 increment4_;
    public:
        AisDataLinkManagementMessageObject( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(spare_);
            destination.Write(offset1_);
            destination.Write(reservedSlots1_);
            destination.Write(timeout1_);
            destination.Write(increment1_);
            offset2_.WriteTo( destination );
            reservedSlots2_.WriteTo( destination );
            timeout2_.WriteTo( destination );
            increment2_.WriteTo( destination );
            offset3_.WriteTo( destination );
            reservedSlots3_.WriteTo( destination );
            timeout3_.WriteTo( destination );
            increment3_.WriteTo( destination );
            offset4_.WriteTo( destination );
            reservedSlots4_.WriteTo( destination );
            timeout4_.WriteTo( destination );
            increment4_.WriteTo( destination );
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(spare_);
            source.Read(offset1_);
            source.Read(reservedSlots1_);
            source.Read(timeout1_);
            source.Read(increment1_);
            offset2_.ReadFrom( source );
            reservedSlots2_.ReadFrom( source );
            timeout2_.ReadFrom( source );
            increment2_.ReadFrom( source );
            offset3_.ReadFrom( source );
            reservedSlots3_.ReadFrom( source );
            timeout3_.ReadFrom( source );
            increment3_.ReadFrom( source );
            offset4_.ReadFrom( source );
            reservedSlots4_.ReadFrom( source );
            timeout4_.ReadFrom( source );
            increment4_.ReadFrom( source );
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<AisDataLinkManagementMessageObject>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<AisDataLinkManagementMessageObject&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const AisDataLinkManagementMessageObject& >( other );
                if ( dataObject.spare_ != spare_ )
                {
                    return false;
                }
                if ( dataObject.offset1_ != offset1_ )
                {
                    return false;
                }
                if ( dataObject.reservedSlots1_ != reservedSlots1_ )
                {
                    return false;
                }
                if ( dataObject.timeout1_ != timeout1_ )
                {
                    return false;
                }
                if ( dataObject.increment1_ != increment1_ )
                {
                    return false;
                }
                if ( dataObject.offset2_ != offset2_ )
                {
                    return false;
                }
                if ( dataObject.reservedSlots2_ != reservedSlots2_ )
                {
                    return false;
                }
                if ( dataObject.timeout2_ != timeout2_ )
                {
                    return false;
                }
                if ( dataObject.increment2_ != increment2_ )
                {
                    return false;
                }
                if ( dataObject.offset3_ != offset3_ )
                {
                    return false;
                }
                if ( dataObject.reservedSlots3_ != reservedSlots3_ )
                {
                    return false;
                }
                if ( dataObject.timeout3_ != timeout3_ )
                {
                    return false;
                }
                if ( dataObject.increment3_ != increment3_ )
                {
                    return false;
                }
                if ( dataObject.offset4_ != offset4_ )
                {
                    return false;
                }
                if ( dataObject.reservedSlots4_ != reservedSlots4_ )
                {
                    return false;
                }
                if ( dataObject.timeout4_ != timeout4_ )
                {
                    return false;
                }
                if ( dataObject.increment4_ != increment4_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        Int32 Spare( ) const
        {
            return spare_;
        }
        void SetSpare( Int32 spare )
        {
            spare_ = spare;
        }
        Int32 Offset1( ) const
        {
            return offset1_;
        }
        void SetOffset1( Int32 offset1 )
        {
            offset1_ = offset1;
        }
        Int32 ReservedSlots1( ) const
        {
            return reservedSlots1_;
        }
        void SetReservedSlots1( Int32 reservedSlots1 )
        {
            reservedSlots1_ = reservedSlots1;
        }
        Int32 Timeout1( ) const
        {
            return timeout1_;
        }
        void SetTimeout1( Int32 timeout1 )
        {
            timeout1_ = timeout1;
        }
        Int32 Increment1( ) const
        {
            return increment1_;
        }
        void SetIncrement1( Int32 increment1 )
        {
            increment1_ = increment1;
        }
        const DBInt32& Offset2( ) const
        {
            return offset2_;
        }
        void SetOffset2( const DBInt32& offset2 )
        {
            offset2_ = offset2;
        }
        const DBInt32& ReservedSlots2( ) const
        {
            return reservedSlots2_;
        }
        void SetReservedSlots2( const DBInt32& reservedSlots2 )
        {
            reservedSlots2_ = reservedSlots2;
        }
        const DBInt32& Timeout2( ) const
        {
            return timeout2_;
        }
        void SetTimeout2( const DBInt32& timeout2 )
        {
            timeout2_ = timeout2;
        }
        const DBInt32& Increment2( ) const
        {
            return increment2_;
        }
        void SetIncrement2( const DBInt32& increment2 )
        {
            increment2_ = increment2;
        }
        const DBInt32& Offset3( ) const
        {
            return offset3_;
        }
        void SetOffset3( const DBInt32& offset3 )
        {
            offset3_ = offset3;
        }
        const DBInt32& ReservedSlots3( ) const
        {
            return reservedSlots3_;
        }
        void SetReservedSlots3( const DBInt32& reservedSlots3 )
        {
            reservedSlots3_ = reservedSlots3;
        }
        const DBInt32& Timeout3( ) const
        {
            return timeout3_;
        }
        void SetTimeout3( const DBInt32& timeout3 )
        {
            timeout3_ = timeout3;
        }
        const DBInt32& Increment3( ) const
        {
            return increment3_;
        }
        void SetIncrement3( const DBInt32& increment3 )
        {
            increment3_ = increment3;
        }
        const DBInt32& Offset4( ) const
        {
            return offset4_;
        }
        void SetOffset4( const DBInt32& offset4 )
        {
            offset4_ = offset4;
        }
        const DBInt32& ReservedSlots4( ) const
        {
            return reservedSlots4_;
        }
        void SetReservedSlots4( const DBInt32& reservedSlots4 )
        {
            reservedSlots4_ = reservedSlots4;
        }
        const DBInt32& Timeout4( ) const
        {
            return timeout4_;
        }
        void SetTimeout4( const DBInt32& timeout4 )
        {
            timeout4_ = timeout4;
        }
        const DBInt32& Increment4( ) const
        {
            return increment4_;
        }
        void SetIncrement4( const DBInt32& increment4 )
        {
            increment4_ = increment4;
        }
    };
    class AisExtendedClassBCsPositionReportMessageObject : public AisMessageObject
    {
    public:
        using Base = AisMessageObject;
        static constexpr Kind KIND = Kind::AisExtendedClassBCsPositionReportMessage;
    private:
        Int32 reserved_ = 0;
        double speedOverGround_ = 0.0;
        Types::PositionAccuracy positionAccuracy_ = Types::PositionAccuracy::Low;
        double longitude_ = 0.0;
        double latitude_ = 0.0;
        double courseOverGround_ = 0.0;
        DBInt32 trueHeading_;
        Int32 timestamp_ = 0;
        Int32 regionalReserved_ = 0;
        Guid name_;
        Types::ShipType shipType_ = Types::ShipType::NotAvailable;
        Int32 dimensionToBow_ = 0;
        Int32 dimensionToStern_ = 0;
        Int32 dimensionToPort_ = 0;
        Int32 dimensionToStarboard_ = 0;
        Types::PositionFixType positionFixType_ = Types::PositionFixType::Undefined1;
        Types::Raim raim_ = Types::Raim::NotInUse;
        bool dataTerminalReady_ = false;
        bool assigned_ = false;
        Int32 spare_ = 0;
    public:
        AisExtendedClassBCsPositionReportMessageObject( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(reserved_);
            destination.Write(speedOverGround_);
            destination.Write(positionAccuracy_);
            destination.Write(longitude_);
            destination.Write(latitude_);
            destination.Write(courseOverGround_);
            trueHeading_.WriteTo( destination );
            destination.Write(timestamp_);
            destination.Write(regionalReserved_);
            destination.Write(name_);
            destination.Write(shipType_);
            destination.Write(dimensionToBow_);
            destination.Write(dimensionToStern_);
            destination.Write(dimensionToPort_);
            destination.Write(dimensionToStarboard_);
            destination.Write(positionFixType_);
            destination.Write(raim_);
            destination.Write(dataTerminalReady_);
            destination.Write(assigned_);
            destination.Write(spare_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(reserved_);
            source.Read(speedOverGround_);
            source.Read(positionAccuracy_);
            source.Read(longitude_);
            source.Read(latitude_);
            source.Read(courseOverGround_);
            trueHeading_.ReadFrom( source );
            source.Read(timestamp_);
            source.Read(regionalReserved_);
            source.Read(name_);
            source.Read(shipType_);
            source.Read(dimensionToBow_);
            source.Read(dimensionToStern_);
            source.Read(dimensionToPort_);
            source.Read(dimensionToStarboard_);
            source.Read(positionFixType_);
            source.Read(raim_);
            source.Read(dataTerminalReady_);
            source.Read(assigned_);
            source.Read(spare_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<AisExtendedClassBCsPositionReportMessageObject>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<AisExtendedClassBCsPositionReportMessageObject&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const AisExtendedClassBCsPositionReportMessageObject& >( other );
                if ( dataObject.reserved_ != reserved_ )
                {
                    return false;
                }
                if ( dataObject.speedOverGround_ != speedOverGround_ )
                {
                    return false;
                }
                if ( dataObject.positionAccuracy_ != positionAccuracy_ )
                {
                    return false;
                }
                if ( dataObject.longitude_ != longitude_ )
                {
                    return false;
                }
                if ( dataObject.latitude_ != latitude_ )
                {
                    return false;
                }
                if ( dataObject.courseOverGround_ != courseOverGround_ )
                {
                    return false;
                }
                if ( dataObject.trueHeading_ != trueHeading_ )
                {
                    return false;
                }
                if ( dataObject.timestamp_ != timestamp_ )
                {
                    return false;
                }
                if ( dataObject.regionalReserved_ != regionalReserved_ )
                {
                    return false;
                }
                if ( dataObject.name_ != name_ )
                {
                    return false;
                }
                if ( dataObject.shipType_ != shipType_ )
                {
                    return false;
                }
                if ( dataObject.dimensionToBow_ != dimensionToBow_ )
                {
                    return false;
                }
                if ( dataObject.dimensionToStern_ != dimensionToStern_ )
                {
                    return false;
                }
                if ( dataObject.dimensionToPort_ != dimensionToPort_ )
                {
                    return false;
                }
                if ( dataObject.dimensionToStarboard_ != dimensionToStarboard_ )
                {
                    return false;
                }
                if ( dataObject.positionFixType_ != positionFixType_ )
                {
                    return false;
                }
                if ( dataObject.raim_ != raim_ )
                {
                    return false;
                }
                if ( dataObject.dataTerminalReady_ != dataTerminalReady_ )
                {
                    return false;
                }
                if ( dataObject.assigned_ != assigned_ )
                {
                    return false;
                }
                if ( dataObject.spare_ != spare_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        Int32 Reserved( ) const
        {
            return reserved_;
        }
        void SetReserved( Int32 reserved )
        {
            reserved_ = reserved;
        }
        double SpeedOverGround( ) const
        {
            return speedOverGround_;
        }
        void SetSpeedOverGround( double speedOverGround )
        {
            speedOverGround_ = speedOverGround;
        }
        Types::PositionAccuracy PositionAccuracy( ) const
        {
            return positionAccuracy_;
        }
        void SetPositionAccuracy( Types::PositionAccuracy positionAccuracy )
        {
            positionAccuracy_ = positionAccuracy;
        }
        double Longitude( ) const
        {
            return longitude_;
        }
        void SetLongitude( double longitude )
        {
            longitude_ = longitude;
        }
        double Latitude( ) const
        {
            return latitude_;
        }
        void SetLatitude( double latitude )
        {
            latitude_ = latitude;
        }
        double CourseOverGround( ) const
        {
            return courseOverGround_;
        }
        void SetCourseOverGround( double courseOverGround )
        {
            courseOverGround_ = courseOverGround;
        }
        const DBInt32& TrueHeading( ) const
        {
            return trueHeading_;
        }
        void SetTrueHeading( const DBInt32& trueHeading )
        {
            trueHeading_ = trueHeading;
        }
        Int32 Timestamp( ) const
        {
            return timestamp_;
        }
        void SetTimestamp( Int32 timestamp )
        {
            timestamp_ = timestamp;
        }
        Int32 RegionalReserved( ) const
        {
            return regionalReserved_;
        }
        void SetRegionalReserved( Int32 regionalReserved )
        {
            regionalReserved_ = regionalReserved;
        }
        const Guid& Name( ) const
        {
            return name_;
        }
        void SetName( const Guid& name )
        {
            name_ = name;
        }
        Types::ShipType ShipType( ) const
        {
            return shipType_;
        }
        void SetShipType( Types::ShipType shipType )
        {
            shipType_ = shipType;
        }
        Int32 DimensionToBow( ) const
        {
            return dimensionToBow_;
        }
        void SetDimensionToBow( Int32 dimensionToBow )
        {
            dimensionToBow_ = dimensionToBow;
        }
        Int32 DimensionToStern( ) const
        {
            return dimensionToStern_;
        }
        void SetDimensionToStern( Int32 dimensionToStern )
        {
            dimensionToStern_ = dimensionToStern;
        }
        Int32 DimensionToPort( ) const
        {
            return dimensionToPort_;
        }
        void SetDimensionToPort( Int32 dimensionToPort )
        {
            dimensionToPort_ = dimensionToPort;
        }
        Int32 DimensionToStarboard( ) const
        {
            return dimensionToStarboard_;
        }
        void SetDimensionToStarboard( Int32 dimensionToStarboard )
        {
            dimensionToStarboard_ = dimensionToStarboard;
        }
        Types::PositionFixType PositionFixType( ) const
        {
            return positionFixType_;
        }
        void SetPositionFixType( Types::PositionFixType positionFixType )
        {
            positionFixType_ = positionFixType;
        }
        Types::Raim Raim( ) const
        {
            return raim_;
        }
        void SetRaim( Types::Raim raim )
        {
            raim_ = raim;
        }
        bool DataTerminalReady( ) const
        {
            return dataTerminalReady_;
        }
        void SetDataTerminalReady( bool dataTerminalReady )
        {
            dataTerminalReady_ = dataTerminalReady;
        }
        bool Assigned( ) const
        {
            return assigned_;
        }
        void SetAssigned( bool assigned )
        {
            assigned_ = assigned;
        }
        Int32 Spare( ) const
        {
            return spare_;
        }
        void SetSpare( Int32 spare )
        {
            spare_ = spare;
        }
    };
    class AisInterrogationMessageObject : public AisMessageObject
    {
    public:
        using Base = AisMessageObject;
        static constexpr Kind KIND = Kind::AisInterrogationMessage;
    private:
        Guid interrogatedMmsi_;
        Types::AisMessageType firstMessageType_ = Types::AisMessageType::PositionReportClassA;
        Int32 firstSlotOffset_ = 0;
        DBEnum<Types::AisMessageType> secondMessageType_;
        DBInt32 secondSlotOffset_;
        DBGuid secondStationInterrogationMmsi_;
        DBEnum<Types::AisMessageType> secondStationFirstMessageType_;
        DBInt32 secondStationFirstSlotOffset_;
    public:
        AisInterrogationMessageObject( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(interrogatedMmsi_);
            destination.Write(firstMessageType_);
            destination.Write(firstSlotOffset_);
            secondMessageType_.WriteTo( destination );
            secondSlotOffset_.WriteTo( destination );
            secondStationInterrogationMmsi_.WriteTo( destination );
            secondStationFirstMessageType_.WriteTo( destination );
            secondStationFirstSlotOffset_.WriteTo( destination );
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(interrogatedMmsi_);
            source.Read(firstMessageType_);
            source.Read(firstSlotOffset_);
            secondMessageType_.ReadFrom( source );
            secondSlotOffset_.ReadFrom( source );
            secondStationInterrogationMmsi_.ReadFrom( source );
            secondStationFirstMessageType_.ReadFrom( source );
            secondStationFirstSlotOffset_.ReadFrom( source );
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<AisInterrogationMessageObject>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<AisInterrogationMessageObject&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const AisInterrogationMessageObject& >( other );
                if ( dataObject.interrogatedMmsi_ != interrogatedMmsi_ )
                {
                    return false;
                }
                if ( dataObject.firstMessageType_ != firstMessageType_ )
                {
                    return false;
                }
                if ( dataObject.firstSlotOffset_ != firstSlotOffset_ )
                {
                    return false;
                }
                if ( dataObject.secondMessageType_ != secondMessageType_ )
                {
                    return false;
                }
                if ( dataObject.secondSlotOffset_ != secondSlotOffset_ )
                {
                    return false;
                }
                if ( dataObject.secondStationInterrogationMmsi_ != secondStationInterrogationMmsi_ )
                {
                    return false;
                }
                if ( dataObject.secondStationFirstMessageType_ != secondStationFirstMessageType_ )
                {
                    return false;
                }
                if ( dataObject.secondStationFirstSlotOffset_ != secondStationFirstSlotOffset_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        const Guid& InterrogatedMmsi( ) const
        {
            return interrogatedMmsi_;
        }
        void SetInterrogatedMmsi( const Guid& interrogatedMmsi )
        {
            interrogatedMmsi_ = interrogatedMmsi;
        }
        Types::AisMessageType FirstMessageType( ) const
        {
            return firstMessageType_;
        }
        void SetFirstMessageType( Types::AisMessageType firstMessageType )
        {
            firstMessageType_ = firstMessageType;
        }
        Int32 FirstSlotOffset( ) const
        {
            return firstSlotOffset_;
        }
        void SetFirstSlotOffset( Int32 firstSlotOffset )
        {
            firstSlotOffset_ = firstSlotOffset;
        }
        const DBEnum<Types::AisMessageType>& SecondMessageType( ) const
        {
            return secondMessageType_;
        }
        void SetSecondMessageType( const DBEnum<Types::AisMessageType>& secondMessageType )
        {
            secondMessageType_ = secondMessageType;
        }
        const DBInt32& SecondSlotOffset( ) const
        {
            return secondSlotOffset_;
        }
        void SetSecondSlotOffset( const DBInt32& secondSlotOffset )
        {
            secondSlotOffset_ = secondSlotOffset;
        }
        const DBGuid& SecondStationInterrogationMmsi( ) const
        {
            return secondStationInterrogationMmsi_;
        }
        void SetSecondStationInterrogationMmsi( const DBGuid& secondStationInterrogationMmsi )
        {
            secondStationInterrogationMmsi_ = secondStationInterrogationMmsi;
        }
        const DBEnum<Types::AisMessageType>& SecondStationFirstMessageType( ) const
        {
            return secondStationFirstMessageType_;
        }
        void SetSecondStationFirstMessageType( const DBEnum<Types::AisMessageType>& secondStationFirstMessageType )
        {
            secondStationFirstMessageType_ = secondStationFirstMessageType;
        }
        const DBInt32& SecondStationFirstSlotOffset( ) const
        {
            return secondStationFirstSlotOffset_;
        }
        void SetSecondStationFirstSlotOffset( const DBInt32& secondStationFirstSlotOffset )
        {
            secondStationFirstSlotOffset_ = secondStationFirstSlotOffset;
        }
    };
    class AisPositionReportClassAMessageBaseObject : public AisMessageObject
    {
    public:
        using Base = AisMessageObject;
        static constexpr Kind KIND = Kind::AisPositionReportClassAMessageBase;
    private:
        Types::NavigationStatus navigationStatus_ = Types::NavigationStatus::UnderWayUsingEngine;
        DBInt32 rateOfTurn_;
        double speedOverGround_ = 0.0;
        Types::PositionAccuracy positionAccuracy_ = Types::PositionAccuracy::Low;
        double longitude_ = 0.0;
        double latitude_ = 0.0;
        double courseOverGround_ = 0.0;
        DBInt32 trueHeading_;
        Int32 timestamp_ = 0;
        Types::ManeuverIndicator maneuverIndicator_ = Types::ManeuverIndicator::NotAvailable;
        Int32 spare_ = 0;
        Types::Raim raim_ = Types::Raim::NotInUse;
        Int32 radioStatus_ = 0;
    public:
        AisPositionReportClassAMessageBaseObject( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(navigationStatus_);
            rateOfTurn_.WriteTo( destination );
            destination.Write(speedOverGround_);
            destination.Write(positionAccuracy_);
            destination.Write(longitude_);
            destination.Write(latitude_);
            destination.Write(courseOverGround_);
            trueHeading_.WriteTo( destination );
            destination.Write(timestamp_);
            destination.Write(maneuverIndicator_);
            destination.Write(spare_);
            destination.Write(raim_);
            destination.Write(radioStatus_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(navigationStatus_);
            rateOfTurn_.ReadFrom( source );
            source.Read(speedOverGround_);
            source.Read(positionAccuracy_);
            source.Read(longitude_);
            source.Read(latitude_);
            source.Read(courseOverGround_);
            trueHeading_.ReadFrom( source );
            source.Read(timestamp_);
            source.Read(maneuverIndicator_);
            source.Read(spare_);
            source.Read(raim_);
            source.Read(radioStatus_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<AisPositionReportClassAMessageBaseObject>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<AisPositionReportClassAMessageBaseObject&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const AisPositionReportClassAMessageBaseObject& >( other );
                if ( dataObject.navigationStatus_ != navigationStatus_ )
                {
                    return false;
                }
                if ( dataObject.rateOfTurn_ != rateOfTurn_ )
                {
                    return false;
                }
                if ( dataObject.speedOverGround_ != speedOverGround_ )
                {
                    return false;
                }
                if ( dataObject.positionAccuracy_ != positionAccuracy_ )
                {
                    return false;
                }
                if ( dataObject.longitude_ != longitude_ )
                {
                    return false;
                }
                if ( dataObject.latitude_ != latitude_ )
                {
                    return false;
                }
                if ( dataObject.courseOverGround_ != courseOverGround_ )
                {
                    return false;
                }
                if ( dataObject.trueHeading_ != trueHeading_ )
                {
                    return false;
                }
                if ( dataObject.timestamp_ != timestamp_ )
                {
                    return false;
                }
                if ( dataObject.maneuverIndicator_ != maneuverIndicator_ )
                {
                    return false;
                }
                if ( dataObject.spare_ != spare_ )
                {
                    return false;
                }
                if ( dataObject.raim_ != raim_ )
                {
                    return false;
                }
                if ( dataObject.radioStatus_ != radioStatus_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        Types::NavigationStatus NavigationStatus( ) const
        {
            return navigationStatus_;
        }
        void SetNavigationStatus( Types::NavigationStatus navigationStatus )
        {
            navigationStatus_ = navigationStatus;
        }
        const DBInt32& RateOfTurn( ) const
        {
            return rateOfTurn_;
        }
        void SetRateOfTurn( const DBInt32& rateOfTurn )
        {
            rateOfTurn_ = rateOfTurn;
        }
        double SpeedOverGround( ) const
        {
            return speedOverGround_;
        }
        void SetSpeedOverGround( double speedOverGround )
        {
            speedOverGround_ = speedOverGround;
        }
        Types::PositionAccuracy PositionAccuracy( ) const
        {
            return positionAccuracy_;
        }
        void SetPositionAccuracy( Types::PositionAccuracy positionAccuracy )
        {
            positionAccuracy_ = positionAccuracy;
        }
        double Longitude( ) const
        {
            return longitude_;
        }
        void SetLongitude( double longitude )
        {
            longitude_ = longitude;
        }
        double Latitude( ) const
        {
            return latitude_;
        }
        void SetLatitude( double latitude )
        {
            latitude_ = latitude;
        }
        double CourseOverGround( ) const
        {
            return courseOverGround_;
        }
        void SetCourseOverGround( double courseOverGround )
        {
            courseOverGround_ = courseOverGround;
        }
        const DBInt32& TrueHeading( ) const
        {
            return trueHeading_;
        }
        void SetTrueHeading( const DBInt32& trueHeading )
        {
            trueHeading_ = trueHeading;
        }
        Int32 Timestamp( ) const
        {
            return timestamp_;
        }
        void SetTimestamp( Int32 timestamp )
        {
            timestamp_ = timestamp;
        }
        Types::ManeuverIndicator ManeuverIndicator( ) const
        {
            return maneuverIndicator_;
        }
        void SetManeuverIndicator( Types::ManeuverIndicator maneuverIndicator )
        {
            maneuverIndicator_ = maneuverIndicator;
        }
        Int32 Spare( ) const
        {
            return spare_;
        }
        void SetSpare( Int32 spare )
        {
            spare_ = spare;
        }
        Types::Raim Raim( ) const
        {
            return raim_;
        }
        void SetRaim( Types::Raim raim )
        {
            raim_ = raim;
        }
        Int32 RadioStatus( ) const
        {
            return radioStatus_;
        }
        void SetRadioStatus( Int32 radioStatus )
        {
            radioStatus_ = radioStatus;
        }
    };
    class AisPositionReportClassAAssignedScheduleMessageObject : public AisPositionReportClassAMessageBaseObject
    {
    public:
        using Base = AisPositionReportClassAMessageBaseObject;
        static constexpr Kind KIND = Kind::AisPositionReportClassAAssignedScheduleMessage;
    private:
    public:
        AisPositionReportClassAAssignedScheduleMessageObject( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<AisPositionReportClassAAssignedScheduleMessageObject>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<AisPositionReportClassAAssignedScheduleMessageObject&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const AisPositionReportClassAAssignedScheduleMessageObject& >( other );
                return true;
            }
            return false;
        }
    };
    class AisPositionReportClassAMessageObject : public AisPositionReportClassAMessageBaseObject
    {
    public:
        using Base = AisPositionReportClassAMessageBaseObject;
        static constexpr Kind KIND = Kind::AisPositionReportClassAMessage;
    private:
    public:
        AisPositionReportClassAMessageObject( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<AisPositionReportClassAMessageObject>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<AisPositionReportClassAMessageObject&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const AisPositionReportClassAMessageObject& >( other );
                return true;
            }
            return false;
        }
    };
    class AisPositionReportClassAResponseToInterrogationMessageObject : public AisPositionReportClassAMessageBaseObject
    {
    public:
        using Base = AisPositionReportClassAMessageBaseObject;
        static constexpr Kind KIND = Kind::AisPositionReportClassAResponseToInterrogationMessage;
    private:
    public:
        AisPositionReportClassAResponseToInterrogationMessageObject( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<AisPositionReportClassAResponseToInterrogationMessageObject>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<AisPositionReportClassAResponseToInterrogationMessageObject&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const AisPositionReportClassAResponseToInterrogationMessageObject& >( other );
                return true;
            }
            return false;
        }
    };
    class AisPositionReportForLongRangeApplicationsMessageObject : public AisMessageObject
    {
    public:
        using Base = AisMessageObject;
        static constexpr Kind KIND = Kind::AisPositionReportForLongRangeApplicationsMessage;
    private:
        Types::PositionAccuracy positionAccuracy_ = Types::PositionAccuracy::Low;
        Types::Raim raim_ = Types::Raim::NotInUse;
        Types::NavigationStatus navigationStatus_ = Types::NavigationStatus::UnderWayUsingEngine;
        double longitude_ = 0.0;
        double latitude_ = 0.0;
        double speedOverGround_ = 0.0;
        double courseOverGround_ = 0.0;
        Types::GnssPositionStatus gnssPositionStatus_ = Types::GnssPositionStatus::CurrentGnssPosition;
        Int32 spare_ = 0;
    public:
        AisPositionReportForLongRangeApplicationsMessageObject( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(positionAccuracy_);
            destination.Write(raim_);
            destination.Write(navigationStatus_);
            destination.Write(longitude_);
            destination.Write(latitude_);
            destination.Write(speedOverGround_);
            destination.Write(courseOverGround_);
            destination.Write(gnssPositionStatus_);
            destination.Write(spare_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(positionAccuracy_);
            source.Read(raim_);
            source.Read(navigationStatus_);
            source.Read(longitude_);
            source.Read(latitude_);
            source.Read(speedOverGround_);
            source.Read(courseOverGround_);
            source.Read(gnssPositionStatus_);
            source.Read(spare_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<AisPositionReportForLongRangeApplicationsMessageObject>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<AisPositionReportForLongRangeApplicationsMessageObject&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const AisPositionReportForLongRangeApplicationsMessageObject& >( other );
                if ( dataObject.positionAccuracy_ != positionAccuracy_ )
                {
                    return false;
                }
                if ( dataObject.raim_ != raim_ )
                {
                    return false;
                }
                if ( dataObject.navigationStatus_ != navigationStatus_ )
                {
                    return false;
                }
                if ( dataObject.longitude_ != longitude_ )
                {
                    return false;
                }
                if ( dataObject.latitude_ != latitude_ )
                {
                    return false;
                }
                if ( dataObject.speedOverGround_ != speedOverGround_ )
                {
                    return false;
                }
                if ( dataObject.courseOverGround_ != courseOverGround_ )
                {
                    return false;
                }
                if ( dataObject.gnssPositionStatus_ != gnssPositionStatus_ )
                {
                    return false;
                }
                if ( dataObject.spare_ != spare_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        Types::PositionAccuracy PositionAccuracy( ) const
        {
            return positionAccuracy_;
        }
        void SetPositionAccuracy( Types::PositionAccuracy positionAccuracy )
        {
            positionAccuracy_ = positionAccuracy;
        }
        Types::Raim Raim( ) const
        {
            return raim_;
        }
        void SetRaim( Types::Raim raim )
        {
            raim_ = raim;
        }
        Types::NavigationStatus NavigationStatus( ) const
        {
            return navigationStatus_;
        }
        void SetNavigationStatus( Types::NavigationStatus navigationStatus )
        {
            navigationStatus_ = navigationStatus;
        }
        double Longitude( ) const
        {
            return longitude_;
        }
        void SetLongitude( double longitude )
        {
            longitude_ = longitude;
        }
        double Latitude( ) const
        {
            return latitude_;
        }
        void SetLatitude( double latitude )
        {
            latitude_ = latitude;
        }
        double SpeedOverGround( ) const
        {
            return speedOverGround_;
        }
        void SetSpeedOverGround( double speedOverGround )
        {
            speedOverGround_ = speedOverGround;
        }
        double CourseOverGround( ) const
        {
            return courseOverGround_;
        }
        void SetCourseOverGround( double courseOverGround )
        {
            courseOverGround_ = courseOverGround;
        }
        Types::GnssPositionStatus GnssPositionStatus( ) const
        {
            return gnssPositionStatus_;
        }
        void SetGnssPositionStatus( Types::GnssPositionStatus gnssPositionStatus )
        {
            gnssPositionStatus_ = gnssPositionStatus;
        }
        Int32 Spare( ) const
        {
            return spare_;
        }
        void SetSpare( Int32 spare )
        {
            spare_ = spare;
        }
    };
    class AisSafetyRelatedAcknowledgmentMessageObject : public AisMessageObject
    {
    public:
        using Base = AisMessageObject;
        static constexpr Kind KIND = Kind::AisSafetyRelatedAcknowledgmentMessage;
    private:
        Int32 spare_ = 0;
        Int32 sequenceNumber1_ = 0;
        Guid mmsi1_;
        DBInt32 sequenceNumber2_;
        DBGuid mmsi2_;
        DBInt32 sequenceNumber3_;
        DBGuid mmsi3_;
        DBInt32 sequenceNumber4_;
        DBGuid mmsi4_;
    public:
        AisSafetyRelatedAcknowledgmentMessageObject( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(spare_);
            destination.Write(sequenceNumber1_);
            destination.Write(mmsi1_);
            sequenceNumber2_.WriteTo( destination );
            mmsi2_.WriteTo( destination );
            sequenceNumber3_.WriteTo( destination );
            mmsi3_.WriteTo( destination );
            sequenceNumber4_.WriteTo( destination );
            mmsi4_.WriteTo( destination );
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(spare_);
            source.Read(sequenceNumber1_);
            source.Read(mmsi1_);
            sequenceNumber2_.ReadFrom( source );
            mmsi2_.ReadFrom( source );
            sequenceNumber3_.ReadFrom( source );
            mmsi3_.ReadFrom( source );
            sequenceNumber4_.ReadFrom( source );
            mmsi4_.ReadFrom( source );
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<AisSafetyRelatedAcknowledgmentMessageObject>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<AisSafetyRelatedAcknowledgmentMessageObject&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const AisSafetyRelatedAcknowledgmentMessageObject& >( other );
                if ( dataObject.spare_ != spare_ )
                {
                    return false;
                }
                if ( dataObject.sequenceNumber1_ != sequenceNumber1_ )
                {
                    return false;
                }
                if ( dataObject.mmsi1_ != mmsi1_ )
                {
                    return false;
                }
                if ( dataObject.sequenceNumber2_ != sequenceNumber2_ )
                {
                    return false;
                }
                if ( dataObject.mmsi2_ != mmsi2_ )
                {
                    return false;
                }
                if ( dataObject.sequenceNumber3_ != sequenceNumber3_ )
                {
                    return false;
                }
                if ( dataObject.mmsi3_ != mmsi3_ )
                {
                    return false;
                }
                if ( dataObject.sequenceNumber4_ != sequenceNumber4_ )
                {
                    return false;
                }
                if ( dataObject.mmsi4_ != mmsi4_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        Int32 Spare( ) const
        {
            return spare_;
        }
        void SetSpare( Int32 spare )
        {
            spare_ = spare;
        }
        Int32 SequenceNumber1( ) const
        {
            return sequenceNumber1_;
        }
        void SetSequenceNumber1( Int32 sequenceNumber1 )
        {
            sequenceNumber1_ = sequenceNumber1;
        }
        const Guid& Mmsi1( ) const
        {
            return mmsi1_;
        }
        void SetMmsi1( const Guid& mmsi1 )
        {
            mmsi1_ = mmsi1;
        }
        const DBInt32& SequenceNumber2( ) const
        {
            return sequenceNumber2_;
        }
        void SetSequenceNumber2( const DBInt32& sequenceNumber2 )
        {
            sequenceNumber2_ = sequenceNumber2;
        }
        const DBGuid& Mmsi2( ) const
        {
            return mmsi2_;
        }
        void SetMmsi2( const DBGuid& mmsi2 )
        {
            mmsi2_ = mmsi2;
        }
        const DBInt32& SequenceNumber3( ) const
        {
            return sequenceNumber3_;
        }
        void SetSequenceNumber3( const DBInt32& sequenceNumber3 )
        {
            sequenceNumber3_ = sequenceNumber3;
        }
        const DBGuid& Mmsi3( ) const
        {
            return mmsi3_;
        }
        void SetMmsi3( const DBGuid& mmsi3 )
        {
            mmsi3_ = mmsi3;
        }
        const DBInt32& SequenceNumber4( ) const
        {
            return sequenceNumber4_;
        }
        void SetSequenceNumber4( const DBInt32& sequenceNumber4 )
        {
            sequenceNumber4_ = sequenceNumber4;
        }
        const DBGuid& Mmsi4( ) const
        {
            return mmsi4_;
        }
        void SetMmsi4( const DBGuid& mmsi4 )
        {
            mmsi4_ = mmsi4;
        }
    };
    class AisStandardClassBCsPositionReportMessageObject : public AisMessageObject
    {
    public:
        using Base = AisMessageObject;
        static constexpr Kind KIND = Kind::AisStandardClassBCsPositionReportMessage;
    private:
        Int32 reserved_ = 0;
        double speedOverGround_ = 0.0;
        Types::PositionAccuracy positionAccuracy_ = Types::PositionAccuracy::Low;
        double longitude_ = 0.0;
        double latitude_ = 0.0;
        double courseOverGround_ = 0.0;
        DBInt32 trueHeading_;
        Int32 timestamp_ = 0;
        Int32 regionalReserved_ = 0;
        bool isCsUnit_ = false;
        bool hasDisplay_ = false;
        bool hasDscCapability_ = false;
        bool band_ = false;
        bool canAcceptMessage22_ = false;
        bool assigned_ = false;
        Types::Raim raim_ = Types::Raim::NotInUse;
        Int32 radioStatus_ = 0;
    public:
        AisStandardClassBCsPositionReportMessageObject( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(reserved_);
            destination.Write(speedOverGround_);
            destination.Write(positionAccuracy_);
            destination.Write(longitude_);
            destination.Write(latitude_);
            destination.Write(courseOverGround_);
            trueHeading_.WriteTo( destination );
            destination.Write(timestamp_);
            destination.Write(regionalReserved_);
            destination.Write(isCsUnit_);
            destination.Write(hasDisplay_);
            destination.Write(hasDscCapability_);
            destination.Write(band_);
            destination.Write(canAcceptMessage22_);
            destination.Write(assigned_);
            destination.Write(raim_);
            destination.Write(radioStatus_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(reserved_);
            source.Read(speedOverGround_);
            source.Read(positionAccuracy_);
            source.Read(longitude_);
            source.Read(latitude_);
            source.Read(courseOverGround_);
            trueHeading_.ReadFrom( source );
            source.Read(timestamp_);
            source.Read(regionalReserved_);
            source.Read(isCsUnit_);
            source.Read(hasDisplay_);
            source.Read(hasDscCapability_);
            source.Read(band_);
            source.Read(canAcceptMessage22_);
            source.Read(assigned_);
            source.Read(raim_);
            source.Read(radioStatus_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<AisStandardClassBCsPositionReportMessageObject>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<AisStandardClassBCsPositionReportMessageObject&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const AisStandardClassBCsPositionReportMessageObject& >( other );
                if ( dataObject.reserved_ != reserved_ )
                {
                    return false;
                }
                if ( dataObject.speedOverGround_ != speedOverGround_ )
                {
                    return false;
                }
                if ( dataObject.positionAccuracy_ != positionAccuracy_ )
                {
                    return false;
                }
                if ( dataObject.longitude_ != longitude_ )
                {
                    return false;
                }
                if ( dataObject.latitude_ != latitude_ )
                {
                    return false;
                }
                if ( dataObject.courseOverGround_ != courseOverGround_ )
                {
                    return false;
                }
                if ( dataObject.trueHeading_ != trueHeading_ )
                {
                    return false;
                }
                if ( dataObject.timestamp_ != timestamp_ )
                {
                    return false;
                }
                if ( dataObject.regionalReserved_ != regionalReserved_ )
                {
                    return false;
                }
                if ( dataObject.isCsUnit_ != isCsUnit_ )
                {
                    return false;
                }
                if ( dataObject.hasDisplay_ != hasDisplay_ )
                {
                    return false;
                }
                if ( dataObject.hasDscCapability_ != hasDscCapability_ )
                {
                    return false;
                }
                if ( dataObject.band_ != band_ )
                {
                    return false;
                }
                if ( dataObject.canAcceptMessage22_ != canAcceptMessage22_ )
                {
                    return false;
                }
                if ( dataObject.assigned_ != assigned_ )
                {
                    return false;
                }
                if ( dataObject.raim_ != raim_ )
                {
                    return false;
                }
                if ( dataObject.radioStatus_ != radioStatus_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        Int32 Reserved( ) const
        {
            return reserved_;
        }
        void SetReserved( Int32 reserved )
        {
            reserved_ = reserved;
        }
        double SpeedOverGround( ) const
        {
            return speedOverGround_;
        }
        void SetSpeedOverGround( double speedOverGround )
        {
            speedOverGround_ = speedOverGround;
        }
        Types::PositionAccuracy PositionAccuracy( ) const
        {
            return positionAccuracy_;
        }
        void SetPositionAccuracy( Types::PositionAccuracy positionAccuracy )
        {
            positionAccuracy_ = positionAccuracy;
        }
        double Longitude( ) const
        {
            return longitude_;
        }
        void SetLongitude( double longitude )
        {
            longitude_ = longitude;
        }
        double Latitude( ) const
        {
            return latitude_;
        }
        void SetLatitude( double latitude )
        {
            latitude_ = latitude;
        }
        double CourseOverGround( ) const
        {
            return courseOverGround_;
        }
        void SetCourseOverGround( double courseOverGround )
        {
            courseOverGround_ = courseOverGround;
        }
        const DBInt32& TrueHeading( ) const
        {
            return trueHeading_;
        }
        void SetTrueHeading( const DBInt32& trueHeading )
        {
            trueHeading_ = trueHeading;
        }
        Int32 Timestamp( ) const
        {
            return timestamp_;
        }
        void SetTimestamp( Int32 timestamp )
        {
            timestamp_ = timestamp;
        }
        Int32 RegionalReserved( ) const
        {
            return regionalReserved_;
        }
        void SetRegionalReserved( Int32 regionalReserved )
        {
            regionalReserved_ = regionalReserved;
        }
        bool IsCsUnit( ) const
        {
            return isCsUnit_;
        }
        void SetIsCsUnit( bool isCsUnit )
        {
            isCsUnit_ = isCsUnit;
        }
        bool HasDisplay( ) const
        {
            return hasDisplay_;
        }
        void SetHasDisplay( bool hasDisplay )
        {
            hasDisplay_ = hasDisplay;
        }
        bool HasDscCapability( ) const
        {
            return hasDscCapability_;
        }
        void SetHasDscCapability( bool hasDscCapability )
        {
            hasDscCapability_ = hasDscCapability;
        }
        bool Band( ) const
        {
            return band_;
        }
        void SetBand( bool band )
        {
            band_ = band;
        }
        bool CanAcceptMessage22( ) const
        {
            return canAcceptMessage22_;
        }
        void SetCanAcceptMessage22( bool canAcceptMessage22 )
        {
            canAcceptMessage22_ = canAcceptMessage22;
        }
        bool Assigned( ) const
        {
            return assigned_;
        }
        void SetAssigned( bool assigned )
        {
            assigned_ = assigned;
        }
        Types::Raim Raim( ) const
        {
            return raim_;
        }
        void SetRaim( Types::Raim raim )
        {
            raim_ = raim;
        }
        Int32 RadioStatus( ) const
        {
            return radioStatus_;
        }
        void SetRadioStatus( Int32 radioStatus )
        {
            radioStatus_ = radioStatus;
        }
    };
    class AisStandardSarAircraftPositionReportMessageObject : public AisMessageObject
    {
    public:
        using Base = AisMessageObject;
        static constexpr Kind KIND = Kind::AisStandardSarAircraftPositionReportMessage;
    private:
        Int32 altitude_ = 0;
        Int32 speedOverGround_ = 0;
        Types::PositionAccuracy positionAccuracy_ = Types::PositionAccuracy::Low;
        double longitude_ = 0.0;
        double latitude_ = 0.0;
        double courseOverGround_ = 0.0;
        Int32 timestamp_ = 0;
        Int32 reserved_ = 0;
        bool dataTerminalReady_ = false;
        Int32 spare_ = 0;
        bool assigned_ = false;
        Types::Raim raim_ = Types::Raim::NotInUse;
        Int32 radioStatus_ = 0;
    public:
        AisStandardSarAircraftPositionReportMessageObject( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(altitude_);
            destination.Write(speedOverGround_);
            destination.Write(positionAccuracy_);
            destination.Write(longitude_);
            destination.Write(latitude_);
            destination.Write(courseOverGround_);
            destination.Write(timestamp_);
            destination.Write(reserved_);
            destination.Write(dataTerminalReady_);
            destination.Write(spare_);
            destination.Write(assigned_);
            destination.Write(raim_);
            destination.Write(radioStatus_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(altitude_);
            source.Read(speedOverGround_);
            source.Read(positionAccuracy_);
            source.Read(longitude_);
            source.Read(latitude_);
            source.Read(courseOverGround_);
            source.Read(timestamp_);
            source.Read(reserved_);
            source.Read(dataTerminalReady_);
            source.Read(spare_);
            source.Read(assigned_);
            source.Read(raim_);
            source.Read(radioStatus_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<AisStandardSarAircraftPositionReportMessageObject>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<AisStandardSarAircraftPositionReportMessageObject&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const AisStandardSarAircraftPositionReportMessageObject& >( other );
                if ( dataObject.altitude_ != altitude_ )
                {
                    return false;
                }
                if ( dataObject.speedOverGround_ != speedOverGround_ )
                {
                    return false;
                }
                if ( dataObject.positionAccuracy_ != positionAccuracy_ )
                {
                    return false;
                }
                if ( dataObject.longitude_ != longitude_ )
                {
                    return false;
                }
                if ( dataObject.latitude_ != latitude_ )
                {
                    return false;
                }
                if ( dataObject.courseOverGround_ != courseOverGround_ )
                {
                    return false;
                }
                if ( dataObject.timestamp_ != timestamp_ )
                {
                    return false;
                }
                if ( dataObject.reserved_ != reserved_ )
                {
                    return false;
                }
                if ( dataObject.dataTerminalReady_ != dataTerminalReady_ )
                {
                    return false;
                }
                if ( dataObject.spare_ != spare_ )
                {
                    return false;
                }
                if ( dataObject.assigned_ != assigned_ )
                {
                    return false;
                }
                if ( dataObject.raim_ != raim_ )
                {
                    return false;
                }
                if ( dataObject.radioStatus_ != radioStatus_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        Int32 Altitude( ) const
        {
            return altitude_;
        }
        void SetAltitude( Int32 altitude )
        {
            altitude_ = altitude;
        }
        Int32 SpeedOverGround( ) const
        {
            return speedOverGround_;
        }
        void SetSpeedOverGround( Int32 speedOverGround )
        {
            speedOverGround_ = speedOverGround;
        }
        Types::PositionAccuracy PositionAccuracy( ) const
        {
            return positionAccuracy_;
        }
        void SetPositionAccuracy( Types::PositionAccuracy positionAccuracy )
        {
            positionAccuracy_ = positionAccuracy;
        }
        double Longitude( ) const
        {
            return longitude_;
        }
        void SetLongitude( double longitude )
        {
            longitude_ = longitude;
        }
        double Latitude( ) const
        {
            return latitude_;
        }
        void SetLatitude( double latitude )
        {
            latitude_ = latitude;
        }
        double CourseOverGround( ) const
        {
            return courseOverGround_;
        }
        void SetCourseOverGround( double courseOverGround )
        {
            courseOverGround_ = courseOverGround;
        }
        Int32 Timestamp( ) const
        {
            return timestamp_;
        }
        void SetTimestamp( Int32 timestamp )
        {
            timestamp_ = timestamp;
        }
        Int32 Reserved( ) const
        {
            return reserved_;
        }
        void SetReserved( Int32 reserved )
        {
            reserved_ = reserved;
        }
        bool DataTerminalReady( ) const
        {
            return dataTerminalReady_;
        }
        void SetDataTerminalReady( bool dataTerminalReady )
        {
            dataTerminalReady_ = dataTerminalReady;
        }
        Int32 Spare( ) const
        {
            return spare_;
        }
        void SetSpare( Int32 spare )
        {
            spare_ = spare;
        }
        bool Assigned( ) const
        {
            return assigned_;
        }
        void SetAssigned( bool assigned )
        {
            assigned_ = assigned;
        }
        Types::Raim Raim( ) const
        {
            return raim_;
        }
        void SetRaim( Types::Raim raim )
        {
            raim_ = raim;
        }
        Int32 RadioStatus( ) const
        {
            return radioStatus_;
        }
        void SetRadioStatus( Int32 radioStatus )
        {
            radioStatus_ = radioStatus;
        }
    };
    class AisStaticAndVoyageRelatedDataMessageObject : public AisMessageObject
    {
    public:
        using Base = AisMessageObject;
        static constexpr Kind KIND = Kind::AisStaticAndVoyageRelatedDataMessage;
    private:
        Int32 aisVersion_ = 0;
        Guid imoNumber_;
        Guid callsign_;
        Guid shipName_;
        Types::ShipType shipType_ = Types::ShipType::NotAvailable;
        Int32 dimensionToBow_ = 0;
        Int32 dimensionToStern_ = 0;
        Int32 dimensionToPort_ = 0;
        Int32 dimensionToStarboard_ = 0;
        Types::PositionFixType positionFixType_ = Types::PositionFixType::Undefined1;
        DBDateTime estimatedTimeOfArrival_;
        double draught_ = 0.0;
        FixedDBWideString<127> destination_;
        bool dataTerminalReady_ = false;
        Int32 spare_ = 0;
    public:
        AisStaticAndVoyageRelatedDataMessageObject( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(aisVersion_);
            destination.Write(imoNumber_);
            destination.Write(callsign_);
            destination.Write(shipName_);
            destination.Write(shipType_);
            destination.Write(dimensionToBow_);
            destination.Write(dimensionToStern_);
            destination.Write(dimensionToPort_);
            destination.Write(dimensionToStarboard_);
            destination.Write(positionFixType_);
            estimatedTimeOfArrival_.WriteTo( destination );
            destination.Write(draught_);
            destination_.WriteTo( destination );
            destination.Write(dataTerminalReady_);
            destination.Write(spare_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(aisVersion_);
            source.Read(imoNumber_);
            source.Read(callsign_);
            source.Read(shipName_);
            source.Read(shipType_);
            source.Read(dimensionToBow_);
            source.Read(dimensionToStern_);
            source.Read(dimensionToPort_);
            source.Read(dimensionToStarboard_);
            source.Read(positionFixType_);
            estimatedTimeOfArrival_.ReadFrom( source );
            source.Read(draught_);
            destination_.ReadFrom( source );
            source.Read(dataTerminalReady_);
            source.Read(spare_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<AisStaticAndVoyageRelatedDataMessageObject>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<AisStaticAndVoyageRelatedDataMessageObject&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const AisStaticAndVoyageRelatedDataMessageObject& >( other );
                if ( dataObject.aisVersion_ != aisVersion_ )
                {
                    return false;
                }
                if ( dataObject.imoNumber_ != imoNumber_ )
                {
                    return false;
                }
                if ( dataObject.callsign_ != callsign_ )
                {
                    return false;
                }
                if ( dataObject.shipName_ != shipName_ )
                {
                    return false;
                }
                if ( dataObject.shipType_ != shipType_ )
                {
                    return false;
                }
                if ( dataObject.dimensionToBow_ != dimensionToBow_ )
                {
                    return false;
                }
                if ( dataObject.dimensionToStern_ != dimensionToStern_ )
                {
                    return false;
                }
                if ( dataObject.dimensionToPort_ != dimensionToPort_ )
                {
                    return false;
                }
                if ( dataObject.dimensionToStarboard_ != dimensionToStarboard_ )
                {
                    return false;
                }
                if ( dataObject.positionFixType_ != positionFixType_ )
                {
                    return false;
                }
                if ( dataObject.estimatedTimeOfArrival_ != estimatedTimeOfArrival_ )
                {
                    return false;
                }
                if ( dataObject.draught_ != draught_ )
                {
                    return false;
                }
                if ( dataObject.destination_ != destination_ )
                {
                    return false;
                }
                if ( dataObject.dataTerminalReady_ != dataTerminalReady_ )
                {
                    return false;
                }
                if ( dataObject.spare_ != spare_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        Int32 AisVersion( ) const
        {
            return aisVersion_;
        }
        void SetAisVersion( Int32 aisVersion )
        {
            aisVersion_ = aisVersion;
        }
        const Guid& ImoNumber( ) const
        {
            return imoNumber_;
        }
        void SetImoNumber( const Guid& imoNumber )
        {
            imoNumber_ = imoNumber;
        }
        const Guid& Callsign( ) const
        {
            return callsign_;
        }
        void SetCallsign( const Guid& callsign )
        {
            callsign_ = callsign;
        }
        const Guid& ShipName( ) const
        {
            return shipName_;
        }
        void SetShipName( const Guid& shipName )
        {
            shipName_ = shipName;
        }
        Types::ShipType ShipType( ) const
        {
            return shipType_;
        }
        void SetShipType( Types::ShipType shipType )
        {
            shipType_ = shipType;
        }
        Int32 DimensionToBow( ) const
        {
            return dimensionToBow_;
        }
        void SetDimensionToBow( Int32 dimensionToBow )
        {
            dimensionToBow_ = dimensionToBow;
        }
        Int32 DimensionToStern( ) const
        {
            return dimensionToStern_;
        }
        void SetDimensionToStern( Int32 dimensionToStern )
        {
            dimensionToStern_ = dimensionToStern;
        }
        Int32 DimensionToPort( ) const
        {
            return dimensionToPort_;
        }
        void SetDimensionToPort( Int32 dimensionToPort )
        {
            dimensionToPort_ = dimensionToPort;
        }
        Int32 DimensionToStarboard( ) const
        {
            return dimensionToStarboard_;
        }
        void SetDimensionToStarboard( Int32 dimensionToStarboard )
        {
            dimensionToStarboard_ = dimensionToStarboard;
        }
        Types::PositionFixType PositionFixType( ) const
        {
            return positionFixType_;
        }
        void SetPositionFixType( Types::PositionFixType positionFixType )
        {
            positionFixType_ = positionFixType;
        }
        const DBDateTime& EstimatedTimeOfArrival( ) const
        {
            return estimatedTimeOfArrival_;
        }
        void SetEstimatedTimeOfArrival( const DBDateTime& estimatedTimeOfArrival )
        {
            estimatedTimeOfArrival_ = estimatedTimeOfArrival;
        }
        double Draught( ) const
        {
            return draught_;
        }
        void SetDraught( double draught )
        {
            draught_ = draught;
        }
        const FixedDBWideString<127>& Destination( ) const
        {
            return destination_;
        }
        void SetDestination( const FixedDBWideString<127>& destination )
        {
            destination_ = destination;
        }
        bool DataTerminalReady( ) const
        {
            return dataTerminalReady_;
        }
        void SetDataTerminalReady( bool dataTerminalReady )
        {
            dataTerminalReady_ = dataTerminalReady;
        }
        Int32 Spare( ) const
        {
            return spare_;
        }
        void SetSpare( Int32 spare )
        {
            spare_ = spare;
        }
    };
    class AisStaticDataReportMessageObject : public AisMessageObject
    {
    public:
        using Base = AisMessageObject;
        static constexpr Kind KIND = Kind::AisStaticDataReportMessage;
    private:
        Int32 partNumber_ = 0;
    public:
        AisStaticDataReportMessageObject( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(partNumber_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(partNumber_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<AisStaticDataReportMessageObject>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<AisStaticDataReportMessageObject&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const AisStaticDataReportMessageObject& >( other );
                if ( dataObject.partNumber_ != partNumber_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        Int32 PartNumber( ) const
        {
            return partNumber_;
        }
        void SetPartNumber( Int32 partNumber )
        {
            partNumber_ = partNumber;
        }
    };
    class AisStaticDataReportPartAMessageObject : public AisStaticDataReportMessageObject
    {
    public:
        using Base = AisStaticDataReportMessageObject;
        static constexpr Kind KIND = Kind::AisStaticDataReportPartAMessage;
    private:
        Guid shipName_;
        Int32 spare_ = 0;
    public:
        AisStaticDataReportPartAMessageObject( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(shipName_);
            destination.Write(spare_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(shipName_);
            source.Read(spare_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<AisStaticDataReportPartAMessageObject>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<AisStaticDataReportPartAMessageObject&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const AisStaticDataReportPartAMessageObject& >( other );
                if ( dataObject.shipName_ != shipName_ )
                {
                    return false;
                }
                if ( dataObject.spare_ != spare_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        const Guid& ShipName( ) const
        {
            return shipName_;
        }
        void SetShipName( const Guid& shipName )
        {
            shipName_ = shipName;
        }
        Int32 Spare( ) const
        {
            return spare_;
        }
        void SetSpare( Int32 spare )
        {
            spare_ = spare;
        }
    };
    class AisStaticDataReportPartBMessageObject : public AisStaticDataReportMessageObject
    {
    public:
        using Base = AisStaticDataReportMessageObject;
        static constexpr Kind KIND = Kind::AisStaticDataReportPartBMessage;
    private:
        Types::ShipType shipType_ = Types::ShipType::NotAvailable;
        FixedDBWideString<127> vendorId_;
        Int32 unitModelCode_ = 0;
        Int32 serialNumber_ = 0;
        Guid callsign_;
        Int32 dimensionToBow_ = 0;
        Int32 dimensionToStern_ = 0;
        Int32 dimensionToPort_ = 0;
        Int32 dimensionToStarboard_ = 0;
        DBGuid mothershipMmsi_;
        Types::PositionFixType positionFixType_ = Types::PositionFixType::Undefined1;
        Int32 spare_ = 0;
    public:
        AisStaticDataReportPartBMessageObject( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(shipType_);
            vendorId_.WriteTo( destination );
            destination.Write(unitModelCode_);
            destination.Write(serialNumber_);
            destination.Write(callsign_);
            destination.Write(dimensionToBow_);
            destination.Write(dimensionToStern_);
            destination.Write(dimensionToPort_);
            destination.Write(dimensionToStarboard_);
            mothershipMmsi_.WriteTo( destination );
            destination.Write(positionFixType_);
            destination.Write(spare_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(shipType_);
            vendorId_.ReadFrom( source );
            source.Read(unitModelCode_);
            source.Read(serialNumber_);
            source.Read(callsign_);
            source.Read(dimensionToBow_);
            source.Read(dimensionToStern_);
            source.Read(dimensionToPort_);
            source.Read(dimensionToStarboard_);
            mothershipMmsi_.ReadFrom( source );
            source.Read(positionFixType_);
            source.Read(spare_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<AisStaticDataReportPartBMessageObject>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<AisStaticDataReportPartBMessageObject&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const AisStaticDataReportPartBMessageObject& >( other );
                if ( dataObject.shipType_ != shipType_ )
                {
                    return false;
                }
                if ( dataObject.vendorId_ != vendorId_ )
                {
                    return false;
                }
                if ( dataObject.unitModelCode_ != unitModelCode_ )
                {
                    return false;
                }
                if ( dataObject.serialNumber_ != serialNumber_ )
                {
                    return false;
                }
                if ( dataObject.callsign_ != callsign_ )
                {
                    return false;
                }
                if ( dataObject.dimensionToBow_ != dimensionToBow_ )
                {
                    return false;
                }
                if ( dataObject.dimensionToStern_ != dimensionToStern_ )
                {
                    return false;
                }
                if ( dataObject.dimensionToPort_ != dimensionToPort_ )
                {
                    return false;
                }
                if ( dataObject.dimensionToStarboard_ != dimensionToStarboard_ )
                {
                    return false;
                }
                if ( dataObject.mothershipMmsi_ != mothershipMmsi_ )
                {
                    return false;
                }
                if ( dataObject.positionFixType_ != positionFixType_ )
                {
                    return false;
                }
                if ( dataObject.spare_ != spare_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        Types::ShipType ShipType( ) const
        {
            return shipType_;
        }
        void SetShipType( Types::ShipType shipType )
        {
            shipType_ = shipType;
        }
        const FixedDBWideString<127>& VendorId( ) const
        {
            return vendorId_;
        }
        void SetVendorId( const FixedDBWideString<127>& vendorId )
        {
            vendorId_ = vendorId;
        }
        Int32 UnitModelCode( ) const
        {
            return unitModelCode_;
        }
        void SetUnitModelCode( Int32 unitModelCode )
        {
            unitModelCode_ = unitModelCode;
        }
        Int32 SerialNumber( ) const
        {
            return serialNumber_;
        }
        void SetSerialNumber( Int32 serialNumber )
        {
            serialNumber_ = serialNumber;
        }
        const Guid& Callsign( ) const
        {
            return callsign_;
        }
        void SetCallsign( const Guid& callsign )
        {
            callsign_ = callsign;
        }
        Int32 DimensionToBow( ) const
        {
            return dimensionToBow_;
        }
        void SetDimensionToBow( Int32 dimensionToBow )
        {
            dimensionToBow_ = dimensionToBow;
        }
        Int32 DimensionToStern( ) const
        {
            return dimensionToStern_;
        }
        void SetDimensionToStern( Int32 dimensionToStern )
        {
            dimensionToStern_ = dimensionToStern;
        }
        Int32 DimensionToPort( ) const
        {
            return dimensionToPort_;
        }
        void SetDimensionToPort( Int32 dimensionToPort )
        {
            dimensionToPort_ = dimensionToPort;
        }
        Int32 DimensionToStarboard( ) const
        {
            return dimensionToStarboard_;
        }
        void SetDimensionToStarboard( Int32 dimensionToStarboard )
        {
            dimensionToStarboard_ = dimensionToStarboard;
        }
        const DBGuid& MothershipMmsi( ) const
        {
            return mothershipMmsi_;
        }
        void SetMothershipMmsi( const DBGuid& mothershipMmsi )
        {
            mothershipMmsi_ = mothershipMmsi;
        }
        Types::PositionFixType PositionFixType( ) const
        {
            return positionFixType_;
        }
        void SetPositionFixType( Types::PositionFixType positionFixType )
        {
            positionFixType_ = positionFixType;
        }
        Int32 Spare( ) const
        {
            return spare_;
        }
        void SetSpare( Int32 spare )
        {
            spare_ = spare;
        }
    };
    class AisUtcAndDateInquiryMessageObject : public AisMessageObject
    {
    public:
        using Base = AisMessageObject;
        static constexpr Kind KIND = Kind::AisUtcAndDateInquiryMessage;
    private:
        Int32 spare1_ = 0;
        Int32 destinationMmsi_ = 0;
        Int32 spare2_ = 0;
    public:
        AisUtcAndDateInquiryMessageObject( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(spare1_);
            destination.Write(destinationMmsi_);
            destination.Write(spare2_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(spare1_);
            source.Read(destinationMmsi_);
            source.Read(spare2_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<AisUtcAndDateInquiryMessageObject>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<AisUtcAndDateInquiryMessageObject&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const AisUtcAndDateInquiryMessageObject& >( other );
                if ( dataObject.spare1_ != spare1_ )
                {
                    return false;
                }
                if ( dataObject.destinationMmsi_ != destinationMmsi_ )
                {
                    return false;
                }
                if ( dataObject.spare2_ != spare2_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        Int32 Spare1( ) const
        {
            return spare1_;
        }
        void SetSpare1( Int32 spare1 )
        {
            spare1_ = spare1;
        }
        Int32 DestinationMmsi( ) const
        {
            return destinationMmsi_;
        }
        void SetDestinationMmsi( Int32 destinationMmsi )
        {
            destinationMmsi_ = destinationMmsi;
        }
        Int32 Spare2( ) const
        {
            return spare2_;
        }
        void SetSpare2( Int32 spare2 )
        {
            spare2_ = spare2;
        }
    };
    class AisUtcAndDateResponseMessageObject : public AisMessageObject
    {
    public:
        using Base = AisMessageObject;
        static constexpr Kind KIND = Kind::AisUtcAndDateResponseMessage;
    private:
        DateTime datetime_;
        Types::PositionAccuracy positionAccuracy_ = Types::PositionAccuracy::Low;
        double longitude_ = 0.0;
        double latitude_ = 0.0;
        Types::PositionFixType positionFixType_ = Types::PositionFixType::Undefined1;
        Int32 spare_ = 0;
        Types::Raim raim_ = Types::Raim::NotInUse;
        Int32 radioStatus_ = 0;
    public:
        AisUtcAndDateResponseMessageObject( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(datetime_);
            destination.Write(positionAccuracy_);
            destination.Write(longitude_);
            destination.Write(latitude_);
            destination.Write(positionFixType_);
            destination.Write(spare_);
            destination.Write(raim_);
            destination.Write(radioStatus_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(datetime_);
            source.Read(positionAccuracy_);
            source.Read(longitude_);
            source.Read(latitude_);
            source.Read(positionFixType_);
            source.Read(spare_);
            source.Read(raim_);
            source.Read(radioStatus_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<AisUtcAndDateResponseMessageObject>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<AisUtcAndDateResponseMessageObject&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const AisUtcAndDateResponseMessageObject& >( other );
                if ( dataObject.datetime_ != datetime_ )
                {
                    return false;
                }
                if ( dataObject.positionAccuracy_ != positionAccuracy_ )
                {
                    return false;
                }
                if ( dataObject.longitude_ != longitude_ )
                {
                    return false;
                }
                if ( dataObject.latitude_ != latitude_ )
                {
                    return false;
                }
                if ( dataObject.positionFixType_ != positionFixType_ )
                {
                    return false;
                }
                if ( dataObject.spare_ != spare_ )
                {
                    return false;
                }
                if ( dataObject.raim_ != raim_ )
                {
                    return false;
                }
                if ( dataObject.radioStatus_ != radioStatus_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        const DateTime& Datetime( ) const
        {
            return datetime_;
        }
        void SetDatetime( const DateTime& datetime )
        {
            datetime_ = datetime;
        }
        Types::PositionAccuracy PositionAccuracy( ) const
        {
            return positionAccuracy_;
        }
        void SetPositionAccuracy( Types::PositionAccuracy positionAccuracy )
        {
            positionAccuracy_ = positionAccuracy;
        }
        double Longitude( ) const
        {
            return longitude_;
        }
        void SetLongitude( double longitude )
        {
            longitude_ = longitude;
        }
        double Latitude( ) const
        {
            return latitude_;
        }
        void SetLatitude( double latitude )
        {
            latitude_ = latitude;
        }
        Types::PositionFixType PositionFixType( ) const
        {
            return positionFixType_;
        }
        void SetPositionFixType( Types::PositionFixType positionFixType )
        {
            positionFixType_ = positionFixType;
        }
        Int32 Spare( ) const
        {
            return spare_;
        }
        void SetSpare( Int32 spare )
        {
            spare_ = spare;
        }
        Types::Raim Raim( ) const
        {
            return raim_;
        }
        void SetRaim( Types::Raim raim )
        {
            raim_ = raim;
        }
        Int32 RadioStatus( ) const
        {
            return radioStatus_;
        }
        void SetRadioStatus( Int32 radioStatus )
        {
            radioStatus_ = radioStatus;
        }
    };
    class AlarmStateChangeObject : public BaseData<Kind, Guid>
    {
    public:
        using Base = BaseData<Kind, Guid>;
        static constexpr Kind KIND = Kind::AlarmStateChange;
    private:
        Int64 rowVersion_ = 0;
        Guid alarm_;
        DateTime timestamp_;
        Types::AlarmState state_ = Types::AlarmState::Unknown;
    public:
        AlarmStateChangeObject( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(rowVersion_);
            destination.Write(alarm_);
            destination.Write(timestamp_);
            destination.Write(state_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(rowVersion_);
            source.Read(alarm_);
            source.Read(timestamp_);
            source.Read(state_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<AlarmStateChangeObject>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<AlarmStateChangeObject&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const AlarmStateChangeObject& >( other );
                if ( dataObject.rowVersion_ != rowVersion_ )
                {
                    return false;
                }
                if ( dataObject.alarm_ != alarm_ )
                {
                    return false;
                }
                if ( dataObject.timestamp_ != timestamp_ )
                {
                    return false;
                }
                if ( dataObject.state_ != state_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        Int64 RowVersion( ) const
        {
            return rowVersion_;
        }
        void SetRowVersion( const Int64& rowVersion )
        {
            rowVersion_ = rowVersion;
        }
        const Guid& Alarm( ) const
        {
            return alarm_;
        }
        void SetAlarm( const Guid& alarm )
        {
            alarm_ = alarm;
        }
        const DateTime& Timestamp( ) const
        {
            return timestamp_;
        }
        void SetTimestamp( const DateTime& timestamp )
        {
            timestamp_ = timestamp;
        }
        Types::AlarmState State( ) const
        {
            return state_;
        }
        void SetState( Types::AlarmState state )
        {
            state_ = state;
        }
    };
    class BaseStationTypeObject : public BaseData<Kind, Guid>
    {
    public:
        using Base = BaseData<Kind, Guid>;
        static constexpr Kind KIND = Kind::BaseStationType;
    private:
        Int64 rowVersion_ = 0;
        FixedDBWideString<127> name_;
    public:
        BaseStationTypeObject( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(rowVersion_);
            name_.WriteTo( destination );
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(rowVersion_);
            name_.ReadFrom( source );
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<BaseStationTypeObject>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<BaseStationTypeObject&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const BaseStationTypeObject& >( other );
                if ( dataObject.rowVersion_ != rowVersion_ )
                {
                    return false;
                }
                if ( dataObject.name_ != name_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        Int64 RowVersion( ) const
        {
            return rowVersion_;
        }
        void SetRowVersion( const Int64& rowVersion )
        {
            rowVersion_ = rowVersion;
        }
        const FixedDBWideString<127>& Name( ) const
        {
            return name_;
        }
        void SetName( const FixedDBWideString<127>& name )
        {
            name_ = name;
        }
    };
    class BinaryTimeseriesValueObject : public BaseData<Kind, Guid>
    {
    public:
        using Base = BaseData<Kind, Guid>;
        static constexpr Kind KIND = Kind::BinaryTimeseriesValue;
    private:
        Int64 rowVersion_ = 0;
        Guid timeseries_;
        DateTime timestamp_;
        Binary value_;
        SQLLEN valueLength_ = SQL_NULL_DATA;
    public:
        BinaryTimeseriesValueObject( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(rowVersion_);
            destination.Write(timeseries_);
            destination.Write(timestamp_);
            destination.Write(value_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(rowVersion_);
            source.Read(timeseries_);
            source.Read(timestamp_);
            source.Read(value_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<BinaryTimeseriesValueObject>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<BinaryTimeseriesValueObject&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const BinaryTimeseriesValueObject& >( other );
                if ( dataObject.rowVersion_ != rowVersion_ )
                {
                    return false;
                }
                if ( dataObject.timeseries_ != timeseries_ )
                {
                    return false;
                }
                if ( dataObject.timestamp_ != timestamp_ )
                {
                    return false;
                }
                if ( dataObject.value_ != value_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        Int64 RowVersion( ) const
        {
            return rowVersion_;
        }
        void SetRowVersion( const Int64& rowVersion )
        {
            rowVersion_ = rowVersion;
        }
        const Guid& Timeseries( ) const
        {
            return timeseries_;
        }
        void SetTimeseries( const Guid& timeseries )
        {
            timeseries_ = timeseries;
        }
        const DateTime& Timestamp( ) const
        {
            return timestamp_;
        }
        void SetTimestamp( const DateTime& timestamp )
        {
            timestamp_ = timestamp;
        }
        const Binary& Value( ) const
        {
            return value_;
        }
        void SetValue( const Binary& value )
        {
            value_ = value;
        }
    };
    class BookmarkObject : public BaseData<Kind, Guid>
    {
    public:
        using Base = BaseData<Kind, Guid>;
        static constexpr Kind KIND = Kind::Bookmark;
    private:
        Int64 rowVersion_ = 0;
        Guid view_;
        FixedDBWideString<127> name_;
        DBDateTime timestamp_;
        double latitude_ = 0.0;
        double longitude_ = 0.0;
        double zoomLevel_ = 0.0;
    public:
        BookmarkObject( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(rowVersion_);
            destination.Write(view_);
            name_.WriteTo( destination );
            timestamp_.WriteTo( destination );
            destination.Write(latitude_);
            destination.Write(longitude_);
            destination.Write(zoomLevel_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(rowVersion_);
            source.Read(view_);
            name_.ReadFrom( source );
            timestamp_.ReadFrom( source );
            source.Read(latitude_);
            source.Read(longitude_);
            source.Read(zoomLevel_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<BookmarkObject>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<BookmarkObject&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const BookmarkObject& >( other );
                if ( dataObject.rowVersion_ != rowVersion_ )
                {
                    return false;
                }
                if ( dataObject.view_ != view_ )
                {
                    return false;
                }
                if ( dataObject.name_ != name_ )
                {
                    return false;
                }
                if ( dataObject.timestamp_ != timestamp_ )
                {
                    return false;
                }
                if ( dataObject.latitude_ != latitude_ )
                {
                    return false;
                }
                if ( dataObject.longitude_ != longitude_ )
                {
                    return false;
                }
                if ( dataObject.zoomLevel_ != zoomLevel_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        Int64 RowVersion( ) const
        {
            return rowVersion_;
        }
        void SetRowVersion( const Int64& rowVersion )
        {
            rowVersion_ = rowVersion;
        }
        const Guid& View( ) const
        {
            return view_;
        }
        void SetView( const Guid& view )
        {
            view_ = view;
        }
        const FixedDBWideString<127>& Name( ) const
        {
            return name_;
        }
        void SetName( const FixedDBWideString<127>& name )
        {
            name_ = name;
        }
        const DBDateTime& Timestamp( ) const
        {
            return timestamp_;
        }
        void SetTimestamp( const DBDateTime& timestamp )
        {
            timestamp_ = timestamp;
        }
        double Latitude( ) const
        {
            return latitude_;
        }
        void SetLatitude( double latitude )
        {
            latitude_ = latitude;
        }
        double Longitude( ) const
        {
            return longitude_;
        }
        void SetLongitude( double longitude )
        {
            longitude_ = longitude;
        }
        double ZoomLevel( ) const
        {
            return zoomLevel_;
        }
        void SetZoomLevel( double zoomLevel )
        {
            zoomLevel_ = zoomLevel;
        }
    };
    class BooleanTimeseriesValueObject : public BaseData<Kind, Guid>
    {
    public:
        using Base = BaseData<Kind, Guid>;
        static constexpr Kind KIND = Kind::BooleanTimeseriesValue;
    private:
        Int64 rowVersion_ = 0;
        Guid timeseries_;
        DateTime timestamp_;
        DBBoolean  value_;
    public:
        BooleanTimeseriesValueObject( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(rowVersion_);
            destination.Write(timeseries_);
            destination.Write(timestamp_);
            value_.WriteTo( destination );
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(rowVersion_);
            source.Read(timeseries_);
            source.Read(timestamp_);
            value_.ReadFrom( source );
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<BooleanTimeseriesValueObject>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<BooleanTimeseriesValueObject&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const BooleanTimeseriesValueObject& >( other );
                if ( dataObject.rowVersion_ != rowVersion_ )
                {
                    return false;
                }
                if ( dataObject.timeseries_ != timeseries_ )
                {
                    return false;
                }
                if ( dataObject.timestamp_ != timestamp_ )
                {
                    return false;
                }
                if ( dataObject.value_ != value_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        Int64 RowVersion( ) const
        {
            return rowVersion_;
        }
        void SetRowVersion( const Int64& rowVersion )
        {
            rowVersion_ = rowVersion;
        }
        const Guid& Timeseries( ) const
        {
            return timeseries_;
        }
        void SetTimeseries( const Guid& timeseries )
        {
            timeseries_ = timeseries;
        }
        const DateTime& Timestamp( ) const
        {
            return timestamp_;
        }
        void SetTimestamp( const DateTime& timestamp )
        {
            timestamp_ = timestamp;
        }
        const DBBoolean & Value( ) const
        {
            return value_;
        }
        void SetValue( const DBBoolean & value )
        {
            value_ = value;
        }
    };
    class ByteTimeseriesValueObject : public BaseData<Kind, Guid>
    {
    public:
        using Base = BaseData<Kind, Guid>;
        static constexpr Kind KIND = Kind::ByteTimeseriesValue;
    private:
        Int64 rowVersion_ = 0;
        Guid timeseries_;
        DateTime timestamp_;
        DBByte value_;
    public:
        ByteTimeseriesValueObject( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(rowVersion_);
            destination.Write(timeseries_);
            destination.Write(timestamp_);
            value_.WriteTo( destination );
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(rowVersion_);
            source.Read(timeseries_);
            source.Read(timestamp_);
            value_.ReadFrom( source );
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<ByteTimeseriesValueObject>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<ByteTimeseriesValueObject&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const ByteTimeseriesValueObject& >( other );
                if ( dataObject.rowVersion_ != rowVersion_ )
                {
                    return false;
                }
                if ( dataObject.timeseries_ != timeseries_ )
                {
                    return false;
                }
                if ( dataObject.timestamp_ != timestamp_ )
                {
                    return false;
                }
                if ( dataObject.value_ != value_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        Int64 RowVersion( ) const
        {
            return rowVersion_;
        }
        void SetRowVersion( const Int64& rowVersion )
        {
            rowVersion_ = rowVersion;
        }
        const Guid& Timeseries( ) const
        {
            return timeseries_;
        }
        void SetTimeseries( const Guid& timeseries )
        {
            timeseries_ = timeseries;
        }
        const DateTime& Timestamp( ) const
        {
            return timestamp_;
        }
        void SetTimestamp( const DateTime& timestamp )
        {
            timestamp_ = timestamp;
        }
        const DBByte& Value( ) const
        {
            return value_;
        }
        void SetValue( const DBByte& value )
        {
            value_ = value;
        }
    };
    class CameraCommandObject : public BaseData<Kind, Guid>
    {
    public:
        using Base = BaseData<Kind, Guid>;
        static constexpr Kind KIND = Kind::CameraCommand;
    private:
        Int64 rowVersion_ = 0;
        Guid camera_;
        DateTime timestamp_;
        Types::DeviceCommandSourceType deviceCommandSourceType_ = Types::DeviceCommandSourceType::Unknown;
        Guid deviceCommandSourceId_;
        Guid reply_;
    public:
        CameraCommandObject( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(rowVersion_);
            destination.Write(camera_);
            destination.Write(timestamp_);
            destination.Write(deviceCommandSourceType_);
            destination.Write(deviceCommandSourceId_);
            destination.Write(reply_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(rowVersion_);
            source.Read(camera_);
            source.Read(timestamp_);
            source.Read(deviceCommandSourceType_);
            source.Read(deviceCommandSourceId_);
            source.Read(reply_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<CameraCommandObject>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<CameraCommandObject&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const CameraCommandObject& >( other );
                if ( dataObject.rowVersion_ != rowVersion_ )
                {
                    return false;
                }
                if ( dataObject.camera_ != camera_ )
                {
                    return false;
                }
                if ( dataObject.timestamp_ != timestamp_ )
                {
                    return false;
                }
                if ( dataObject.deviceCommandSourceType_ != deviceCommandSourceType_ )
                {
                    return false;
                }
                if ( dataObject.deviceCommandSourceId_ != deviceCommandSourceId_ )
                {
                    return false;
                }
                if ( dataObject.reply_ != reply_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        Int64 RowVersion( ) const
        {
            return rowVersion_;
        }
        void SetRowVersion( const Int64& rowVersion )
        {
            rowVersion_ = rowVersion;
        }
        const Guid& Camera( ) const
        {
            return camera_;
        }
        void SetCamera( const Guid& camera )
        {
            camera_ = camera;
        }
        const DateTime& Timestamp( ) const
        {
            return timestamp_;
        }
        void SetTimestamp( const DateTime& timestamp )
        {
            timestamp_ = timestamp;
        }
        Types::DeviceCommandSourceType DeviceCommandSourceType( ) const
        {
            return deviceCommandSourceType_;
        }
        void SetDeviceCommandSourceType( Types::DeviceCommandSourceType deviceCommandSourceType )
        {
            deviceCommandSourceType_ = deviceCommandSourceType;
        }
        const Guid& DeviceCommandSourceId( ) const
        {
            return deviceCommandSourceId_;
        }
        void SetDeviceCommandSourceId( const Guid& deviceCommandSourceId )
        {
            deviceCommandSourceId_ = deviceCommandSourceId;
        }
        const Guid& Reply( ) const
        {
            return reply_;
        }
        void SetReply( const Guid& reply )
        {
            reply_ = reply;
        }
    };
    class CameraCommandAbsoluteMoveObject : public CameraCommandObject
    {
    public:
        using Base = CameraCommandObject;
        static constexpr Kind KIND = Kind::CameraCommandAbsoluteMove;
    private:
        Types::CameraPanTiltMode positionPanTiltMode_ = Types::CameraPanTiltMode::Unknown;
        DBDouble panAngle_;
        DBDouble tiltAngle_;
        Types::CameraFocalLengthMode positionFocalLengthMode_ = Types::CameraFocalLengthMode::Unknown;
        DBDouble focalLength_;
        Types::CameraPanTiltMode speedPanTiltMode_ = Types::CameraPanTiltMode::Unknown;
        DBDouble panSpeed_;
        DBDouble tiltSpeed_;
        Types::CameraFocalLengthMode speedFocalLengthMode_ = Types::CameraFocalLengthMode::Unknown;
        DBDouble zoomSpeed_;
    public:
        CameraCommandAbsoluteMoveObject( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(positionPanTiltMode_);
            panAngle_.WriteTo( destination );
            tiltAngle_.WriteTo( destination );
            destination.Write(positionFocalLengthMode_);
            focalLength_.WriteTo( destination );
            destination.Write(speedPanTiltMode_);
            panSpeed_.WriteTo( destination );
            tiltSpeed_.WriteTo( destination );
            destination.Write(speedFocalLengthMode_);
            zoomSpeed_.WriteTo( destination );
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(positionPanTiltMode_);
            panAngle_.ReadFrom( source );
            tiltAngle_.ReadFrom( source );
            source.Read(positionFocalLengthMode_);
            focalLength_.ReadFrom( source );
            source.Read(speedPanTiltMode_);
            panSpeed_.ReadFrom( source );
            tiltSpeed_.ReadFrom( source );
            source.Read(speedFocalLengthMode_);
            zoomSpeed_.ReadFrom( source );
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<CameraCommandAbsoluteMoveObject>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<CameraCommandAbsoluteMoveObject&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const CameraCommandAbsoluteMoveObject& >( other );
                if ( dataObject.positionPanTiltMode_ != positionPanTiltMode_ )
                {
                    return false;
                }
                if ( dataObject.panAngle_ != panAngle_ )
                {
                    return false;
                }
                if ( dataObject.tiltAngle_ != tiltAngle_ )
                {
                    return false;
                }
                if ( dataObject.positionFocalLengthMode_ != positionFocalLengthMode_ )
                {
                    return false;
                }
                if ( dataObject.focalLength_ != focalLength_ )
                {
                    return false;
                }
                if ( dataObject.speedPanTiltMode_ != speedPanTiltMode_ )
                {
                    return false;
                }
                if ( dataObject.panSpeed_ != panSpeed_ )
                {
                    return false;
                }
                if ( dataObject.tiltSpeed_ != tiltSpeed_ )
                {
                    return false;
                }
                if ( dataObject.speedFocalLengthMode_ != speedFocalLengthMode_ )
                {
                    return false;
                }
                if ( dataObject.zoomSpeed_ != zoomSpeed_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        Types::CameraPanTiltMode PositionPanTiltMode( ) const
        {
            return positionPanTiltMode_;
        }
        void SetPositionPanTiltMode( Types::CameraPanTiltMode positionPanTiltMode )
        {
            positionPanTiltMode_ = positionPanTiltMode;
        }
        const DBDouble& PanAngle( ) const
        {
            return panAngle_;
        }
        void SetPanAngle( const DBDouble& panAngle )
        {
            panAngle_ = panAngle;
        }
        const DBDouble& TiltAngle( ) const
        {
            return tiltAngle_;
        }
        void SetTiltAngle( const DBDouble& tiltAngle )
        {
            tiltAngle_ = tiltAngle;
        }
        Types::CameraFocalLengthMode PositionFocalLengthMode( ) const
        {
            return positionFocalLengthMode_;
        }
        void SetPositionFocalLengthMode( Types::CameraFocalLengthMode positionFocalLengthMode )
        {
            positionFocalLengthMode_ = positionFocalLengthMode;
        }
        const DBDouble& FocalLength( ) const
        {
            return focalLength_;
        }
        void SetFocalLength( const DBDouble& focalLength )
        {
            focalLength_ = focalLength;
        }
        Types::CameraPanTiltMode SpeedPanTiltMode( ) const
        {
            return speedPanTiltMode_;
        }
        void SetSpeedPanTiltMode( Types::CameraPanTiltMode speedPanTiltMode )
        {
            speedPanTiltMode_ = speedPanTiltMode;
        }
        const DBDouble& PanSpeed( ) const
        {
            return panSpeed_;
        }
        void SetPanSpeed( const DBDouble& panSpeed )
        {
            panSpeed_ = panSpeed;
        }
        const DBDouble& TiltSpeed( ) const
        {
            return tiltSpeed_;
        }
        void SetTiltSpeed( const DBDouble& tiltSpeed )
        {
            tiltSpeed_ = tiltSpeed;
        }
        Types::CameraFocalLengthMode SpeedFocalLengthMode( ) const
        {
            return speedFocalLengthMode_;
        }
        void SetSpeedFocalLengthMode( Types::CameraFocalLengthMode speedFocalLengthMode )
        {
            speedFocalLengthMode_ = speedFocalLengthMode;
        }
        const DBDouble& ZoomSpeed( ) const
        {
            return zoomSpeed_;
        }
        void SetZoomSpeed( const DBDouble& zoomSpeed )
        {
            zoomSpeed_ = zoomSpeed;
        }
    };
    class CameraCommandAdjustPanTiltZoomObject : public CameraCommandObject
    {
    public:
        using Base = CameraCommandObject;
        static constexpr Kind KIND = Kind::CameraCommandAdjustPanTiltZoom;
    private:
        DBDouble x_;
        DBDouble y_;
        DBDouble z_;
    public:
        CameraCommandAdjustPanTiltZoomObject( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            x_.WriteTo( destination );
            y_.WriteTo( destination );
            z_.WriteTo( destination );
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            x_.ReadFrom( source );
            y_.ReadFrom( source );
            z_.ReadFrom( source );
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<CameraCommandAdjustPanTiltZoomObject>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<CameraCommandAdjustPanTiltZoomObject&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const CameraCommandAdjustPanTiltZoomObject& >( other );
                if ( dataObject.x_ != x_ )
                {
                    return false;
                }
                if ( dataObject.y_ != y_ )
                {
                    return false;
                }
                if ( dataObject.z_ != z_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        const DBDouble& X( ) const
        {
            return x_;
        }
        void SetX( const DBDouble& x )
        {
            x_ = x;
        }
        const DBDouble& Y( ) const
        {
            return y_;
        }
        void SetY( const DBDouble& y )
        {
            y_ = y;
        }
        const DBDouble& Z( ) const
        {
            return z_;
        }
        void SetZ( const DBDouble& z )
        {
            z_ = z;
        }
    };
    class CameraCommandContinuousMoveObject : public CameraCommandObject
    {
    public:
        using Base = CameraCommandObject;
        static constexpr Kind KIND = Kind::CameraCommandContinuousMove;
    private:
        bool normalized_ = false;
        DBDouble panVelocity_;
        DBDouble tiltVelocity_;
        DBDouble zoomVelocity_;
        DBTimeSpan duration_;
    public:
        CameraCommandContinuousMoveObject( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(normalized_);
            panVelocity_.WriteTo( destination );
            tiltVelocity_.WriteTo( destination );
            zoomVelocity_.WriteTo( destination );
            duration_.WriteTo( destination );
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(normalized_);
            panVelocity_.ReadFrom( source );
            tiltVelocity_.ReadFrom( source );
            zoomVelocity_.ReadFrom( source );
            duration_.ReadFrom( source );
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<CameraCommandContinuousMoveObject>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<CameraCommandContinuousMoveObject&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const CameraCommandContinuousMoveObject& >( other );
                if ( dataObject.normalized_ != normalized_ )
                {
                    return false;
                }
                if ( dataObject.panVelocity_ != panVelocity_ )
                {
                    return false;
                }
                if ( dataObject.tiltVelocity_ != tiltVelocity_ )
                {
                    return false;
                }
                if ( dataObject.zoomVelocity_ != zoomVelocity_ )
                {
                    return false;
                }
                if ( dataObject.duration_ != duration_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        bool Normalized( ) const
        {
            return normalized_;
        }
        void SetNormalized( bool normalized )
        {
            normalized_ = normalized;
        }
        const DBDouble& PanVelocity( ) const
        {
            return panVelocity_;
        }
        void SetPanVelocity( const DBDouble& panVelocity )
        {
            panVelocity_ = panVelocity;
        }
        const DBDouble& TiltVelocity( ) const
        {
            return tiltVelocity_;
        }
        void SetTiltVelocity( const DBDouble& tiltVelocity )
        {
            tiltVelocity_ = tiltVelocity;
        }
        const DBDouble& ZoomVelocity( ) const
        {
            return zoomVelocity_;
        }
        void SetZoomVelocity( const DBDouble& zoomVelocity )
        {
            zoomVelocity_ = zoomVelocity;
        }
        const DBTimeSpan& Duration( ) const
        {
            return duration_;
        }
        void SetDuration( const DBTimeSpan& duration )
        {
            duration_ = duration;
        }
    };
    class CameraCommandGeoMoveObject : public CameraCommandObject
    {
    public:
        using Base = CameraCommandObject;
        static constexpr Kind KIND = Kind::CameraCommandGeoMove;
    private:
        double latitude_ = 0.0;
        double longitude_ = 0.0;
        DBDouble altitude_;
        DBDouble viewportWidth_;
        DBDouble viewportHeight_;
    public:
        CameraCommandGeoMoveObject( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(latitude_);
            destination.Write(longitude_);
            altitude_.WriteTo( destination );
            viewportWidth_.WriteTo( destination );
            viewportHeight_.WriteTo( destination );
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(latitude_);
            source.Read(longitude_);
            altitude_.ReadFrom( source );
            viewportWidth_.ReadFrom( source );
            viewportHeight_.ReadFrom( source );
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<CameraCommandGeoMoveObject>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<CameraCommandGeoMoveObject&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const CameraCommandGeoMoveObject& >( other );
                if ( dataObject.latitude_ != latitude_ )
                {
                    return false;
                }
                if ( dataObject.longitude_ != longitude_ )
                {
                    return false;
                }
                if ( dataObject.altitude_ != altitude_ )
                {
                    return false;
                }
                if ( dataObject.viewportWidth_ != viewportWidth_ )
                {
                    return false;
                }
                if ( dataObject.viewportHeight_ != viewportHeight_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        double Latitude( ) const
        {
            return latitude_;
        }
        void SetLatitude( double latitude )
        {
            latitude_ = latitude;
        }
        double Longitude( ) const
        {
            return longitude_;
        }
        void SetLongitude( double longitude )
        {
            longitude_ = longitude;
        }
        const DBDouble& Altitude( ) const
        {
            return altitude_;
        }
        void SetAltitude( const DBDouble& altitude )
        {
            altitude_ = altitude;
        }
        const DBDouble& ViewportWidth( ) const
        {
            return viewportWidth_;
        }
        void SetViewportWidth( const DBDouble& viewportWidth )
        {
            viewportWidth_ = viewportWidth;
        }
        const DBDouble& ViewportHeight( ) const
        {
            return viewportHeight_;
        }
        void SetViewportHeight( const DBDouble& viewportHeight )
        {
            viewportHeight_ = viewportHeight;
        }
    };
    class CameraCommandRelativeMoveObject : public CameraCommandObject
    {
    public:
        using Base = CameraCommandObject;
        static constexpr Kind KIND = Kind::CameraCommandRelativeMove;
    private:
        bool normalized_ = false;
        DBDouble panAngle_;
        DBDouble tiltAngle_;
        DBDouble focalLength_;
        DBDouble panSpeed_;
        DBDouble tiltSpeed_;
        DBDouble zoomSpeed_;
    public:
        CameraCommandRelativeMoveObject( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(normalized_);
            panAngle_.WriteTo( destination );
            tiltAngle_.WriteTo( destination );
            focalLength_.WriteTo( destination );
            panSpeed_.WriteTo( destination );
            tiltSpeed_.WriteTo( destination );
            zoomSpeed_.WriteTo( destination );
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(normalized_);
            panAngle_.ReadFrom( source );
            tiltAngle_.ReadFrom( source );
            focalLength_.ReadFrom( source );
            panSpeed_.ReadFrom( source );
            tiltSpeed_.ReadFrom( source );
            zoomSpeed_.ReadFrom( source );
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<CameraCommandRelativeMoveObject>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<CameraCommandRelativeMoveObject&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const CameraCommandRelativeMoveObject& >( other );
                if ( dataObject.normalized_ != normalized_ )
                {
                    return false;
                }
                if ( dataObject.panAngle_ != panAngle_ )
                {
                    return false;
                }
                if ( dataObject.tiltAngle_ != tiltAngle_ )
                {
                    return false;
                }
                if ( dataObject.focalLength_ != focalLength_ )
                {
                    return false;
                }
                if ( dataObject.panSpeed_ != panSpeed_ )
                {
                    return false;
                }
                if ( dataObject.tiltSpeed_ != tiltSpeed_ )
                {
                    return false;
                }
                if ( dataObject.zoomSpeed_ != zoomSpeed_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        bool Normalized( ) const
        {
            return normalized_;
        }
        void SetNormalized( bool normalized )
        {
            normalized_ = normalized;
        }
        const DBDouble& PanAngle( ) const
        {
            return panAngle_;
        }
        void SetPanAngle( const DBDouble& panAngle )
        {
            panAngle_ = panAngle;
        }
        const DBDouble& TiltAngle( ) const
        {
            return tiltAngle_;
        }
        void SetTiltAngle( const DBDouble& tiltAngle )
        {
            tiltAngle_ = tiltAngle;
        }
        const DBDouble& FocalLength( ) const
        {
            return focalLength_;
        }
        void SetFocalLength( const DBDouble& focalLength )
        {
            focalLength_ = focalLength;
        }
        const DBDouble& PanSpeed( ) const
        {
            return panSpeed_;
        }
        void SetPanSpeed( const DBDouble& panSpeed )
        {
            panSpeed_ = panSpeed;
        }
        const DBDouble& TiltSpeed( ) const
        {
            return tiltSpeed_;
        }
        void SetTiltSpeed( const DBDouble& tiltSpeed )
        {
            tiltSpeed_ = tiltSpeed;
        }
        const DBDouble& ZoomSpeed( ) const
        {
            return zoomSpeed_;
        }
        void SetZoomSpeed( const DBDouble& zoomSpeed )
        {
            zoomSpeed_ = zoomSpeed;
        }
    };
    class CameraCommandReleasePTZOwnershipObject : public CameraCommandObject
    {
    public:
        using Base = CameraCommandObject;
        static constexpr Kind KIND = Kind::CameraCommandReleasePTZOwnership;
    private:
    public:
        CameraCommandReleasePTZOwnershipObject( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<CameraCommandReleasePTZOwnershipObject>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<CameraCommandReleasePTZOwnershipObject&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const CameraCommandReleasePTZOwnershipObject& >( other );
                return true;
            }
            return false;
        }
    };
    class CameraCommandRequestPTZOwnershipObject : public CameraCommandObject
    {
    public:
        using Base = CameraCommandObject;
        static constexpr Kind KIND = Kind::CameraCommandRequestPTZOwnership;
    private:
    public:
        CameraCommandRequestPTZOwnershipObject( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<CameraCommandRequestPTZOwnershipObject>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<CameraCommandRequestPTZOwnershipObject&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const CameraCommandRequestPTZOwnershipObject& >( other );
                return true;
            }
            return false;
        }
    };
    class CameraCommandSetAutoFocusObject : public CameraCommandObject
    {
    public:
        using Base = CameraCommandObject;
        static constexpr Kind KIND = Kind::CameraCommandSetAutoFocus;
    private:
        bool enabled_ = false;
    public:
        CameraCommandSetAutoFocusObject( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(enabled_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(enabled_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<CameraCommandSetAutoFocusObject>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<CameraCommandSetAutoFocusObject&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const CameraCommandSetAutoFocusObject& >( other );
                if ( dataObject.enabled_ != enabled_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        bool Enabled( ) const
        {
            return enabled_;
        }
        void SetEnabled( bool enabled )
        {
            enabled_ = enabled;
        }
    };
    class CameraCommandSetBlackAndWhiteObject : public CameraCommandObject
    {
    public:
        using Base = CameraCommandObject;
        static constexpr Kind KIND = Kind::CameraCommandSetBlackAndWhite;
    private:
        bool enabled_ = false;
    public:
        CameraCommandSetBlackAndWhiteObject( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(enabled_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(enabled_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<CameraCommandSetBlackAndWhiteObject>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<CameraCommandSetBlackAndWhiteObject&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const CameraCommandSetBlackAndWhiteObject& >( other );
                if ( dataObject.enabled_ != enabled_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        bool Enabled( ) const
        {
            return enabled_;
        }
        void SetEnabled( bool enabled )
        {
            enabled_ = enabled;
        }
    };
    class CameraCommandSetFollowedObject : public CameraCommandObject
    {
    public:
        using Base = CameraCommandObject;
        static constexpr Kind KIND = Kind::CameraCommandSetFollowed;
    private:
        Guid trackId_;
        Types::CameraFollowReason reason_ = Types::CameraFollowReason::Alarm;
    public:
        CameraCommandSetFollowedObject( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(trackId_);
            destination.Write(reason_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(trackId_);
            source.Read(reason_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<CameraCommandSetFollowedObject>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<CameraCommandSetFollowedObject&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const CameraCommandSetFollowedObject& >( other );
                if ( dataObject.trackId_ != trackId_ )
                {
                    return false;
                }
                if ( dataObject.reason_ != reason_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        const Guid& TrackId( ) const
        {
            return trackId_;
        }
        void SetTrackId( const Guid& trackId )
        {
            trackId_ = trackId;
        }
        Types::CameraFollowReason Reason( ) const
        {
            return reason_;
        }
        void SetReason( Types::CameraFollowReason reason )
        {
            reason_ = reason;
        }
    };
    class CameraCommandSetInfraRedLampObject : public CameraCommandObject
    {
    public:
        using Base = CameraCommandObject;
        static constexpr Kind KIND = Kind::CameraCommandSetInfraRedLamp;
    private:
        bool enabled_ = false;
    public:
        CameraCommandSetInfraRedLampObject( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(enabled_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(enabled_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<CameraCommandSetInfraRedLampObject>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<CameraCommandSetInfraRedLampObject&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const CameraCommandSetInfraRedLampObject& >( other );
                if ( dataObject.enabled_ != enabled_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        bool Enabled( ) const
        {
            return enabled_;
        }
        void SetEnabled( bool enabled )
        {
            enabled_ = enabled;
        }
    };
    class CameraCommandSetWasherObject : public CameraCommandObject
    {
    public:
        using Base = CameraCommandObject;
        static constexpr Kind KIND = Kind::CameraCommandSetWasher;
    private:
        bool enabled_ = false;
    public:
        CameraCommandSetWasherObject( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(enabled_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(enabled_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<CameraCommandSetWasherObject>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<CameraCommandSetWasherObject&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const CameraCommandSetWasherObject& >( other );
                if ( dataObject.enabled_ != enabled_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        bool Enabled( ) const
        {
            return enabled_;
        }
        void SetEnabled( bool enabled )
        {
            enabled_ = enabled;
        }
    };
    class CameraCommandSetWiperObject : public CameraCommandObject
    {
    public:
        using Base = CameraCommandObject;
        static constexpr Kind KIND = Kind::CameraCommandSetWiper;
    private:
        bool enabled_ = false;
    public:
        CameraCommandSetWiperObject( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(enabled_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(enabled_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<CameraCommandSetWiperObject>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<CameraCommandSetWiperObject&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const CameraCommandSetWiperObject& >( other );
                if ( dataObject.enabled_ != enabled_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        bool Enabled( ) const
        {
            return enabled_;
        }
        void SetEnabled( bool enabled )
        {
            enabled_ = enabled;
        }
    };
    class CameraCommandStopObject : public CameraCommandObject
    {
    public:
        using Base = CameraCommandObject;
        static constexpr Kind KIND = Kind::CameraCommandStop;
    private:
        bool panTilt_ = false;
        bool zoom_ = false;
    public:
        CameraCommandStopObject( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(panTilt_);
            destination.Write(zoom_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(panTilt_);
            source.Read(zoom_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<CameraCommandStopObject>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<CameraCommandStopObject&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const CameraCommandStopObject& >( other );
                if ( dataObject.panTilt_ != panTilt_ )
                {
                    return false;
                }
                if ( dataObject.zoom_ != zoom_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        bool PanTilt( ) const
        {
            return panTilt_;
        }
        void SetPanTilt( bool panTilt )
        {
            panTilt_ = panTilt;
        }
        bool Zoom( ) const
        {
            return zoom_;
        }
        void SetZoom( bool zoom )
        {
            zoom_ = zoom;
        }
    };
    class CameraCommandReplyObject : public BaseData<Kind, Guid>
    {
    public:
        using Base = BaseData<Kind, Guid>;
        static constexpr Kind KIND = Kind::CameraCommandReply;
    private:
        Int64 rowVersion_ = 0;
        Guid camera_;
        DateTime timestamp_;
        Guid command_;
        Types::DeviceCommandReplyStatus status_ = Types::DeviceCommandReplyStatus::Unknown;
        WideString message_;
        SQLLEN messageLength_ = SQL_NULL_DATA;
        double panAngle_ = 0.0;
        double tiltAngle_ = 0.0;
        double focalLength_ = 0.0;
    public:
        CameraCommandReplyObject( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(rowVersion_);
            destination.Write(camera_);
            destination.Write(timestamp_);
            destination.Write(command_);
            destination.Write(status_);
            destination.Write(message_);
            destination.Write(panAngle_);
            destination.Write(tiltAngle_);
            destination.Write(focalLength_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(rowVersion_);
            source.Read(camera_);
            source.Read(timestamp_);
            source.Read(command_);
            source.Read(status_);
            source.Read(message_);
            source.Read(panAngle_);
            source.Read(tiltAngle_);
            source.Read(focalLength_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<CameraCommandReplyObject>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<CameraCommandReplyObject&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const CameraCommandReplyObject& >( other );
                if ( dataObject.rowVersion_ != rowVersion_ )
                {
                    return false;
                }
                if ( dataObject.camera_ != camera_ )
                {
                    return false;
                }
                if ( dataObject.timestamp_ != timestamp_ )
                {
                    return false;
                }
                if ( dataObject.command_ != command_ )
                {
                    return false;
                }
                if ( dataObject.status_ != status_ )
                {
                    return false;
                }
                if ( dataObject.message_ != message_ )
                {
                    return false;
                }
                if ( dataObject.panAngle_ != panAngle_ )
                {
                    return false;
                }
                if ( dataObject.tiltAngle_ != tiltAngle_ )
                {
                    return false;
                }
                if ( dataObject.focalLength_ != focalLength_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        Int64 RowVersion( ) const
        {
            return rowVersion_;
        }
        void SetRowVersion( const Int64& rowVersion )
        {
            rowVersion_ = rowVersion;
        }
        const Guid& Camera( ) const
        {
            return camera_;
        }
        void SetCamera( const Guid& camera )
        {
            camera_ = camera;
        }
        const DateTime& Timestamp( ) const
        {
            return timestamp_;
        }
        void SetTimestamp( const DateTime& timestamp )
        {
            timestamp_ = timestamp;
        }
        const Guid& Command( ) const
        {
            return command_;
        }
        void SetCommand( const Guid& command )
        {
            command_ = command;
        }
        Types::DeviceCommandReplyStatus Status( ) const
        {
            return status_;
        }
        void SetStatus( Types::DeviceCommandReplyStatus status )
        {
            status_ = status;
        }
        const WideString& Message( ) const
        {
            return message_;
        }
        void SetMessage( const WideString& message )
        {
            message_ = message;
        }
        double PanAngle( ) const
        {
            return panAngle_;
        }
        void SetPanAngle( double panAngle )
        {
            panAngle_ = panAngle;
        }
        double TiltAngle( ) const
        {
            return tiltAngle_;
        }
        void SetTiltAngle( double tiltAngle )
        {
            tiltAngle_ = tiltAngle;
        }
        double FocalLength( ) const
        {
            return focalLength_;
        }
        void SetFocalLength( double focalLength )
        {
            focalLength_ = focalLength;
        }
    };
    class CameraConfigurationObject : public BaseData<Kind, Guid>
    {
    public:
        using Base = BaseData<Kind, Guid>;
        static constexpr Kind KIND = Kind::CameraConfiguration;
    private:
        Int64 rowVersion_ = 0;
        Guid camera_;
        DateTime timestamp_;
        Types::CameraControlProtocol cameraControlProtocol_ = Types::CameraControlProtocol::Unknown;
        FixedDBWideString<127> cameraURL_;
        FixedDBWideString<127> configurationURL_;
        FixedDBWideString<127> userName_;
        FixedDBWideString<127> password_;
        bool useRtspUriOverride_ = false;
        FixedDBWideString<127> rtspUriOverride_;
        double latitude_ = 0.0;
        double longitude_ = 0.0;
        double altitude_ = 0.0;
        bool useRelativePosition_ = false;
        Types::CameraPanTiltMode panTiltMode_ = Types::CameraPanTiltMode::Unknown;
        double minTiltAngle_ = 0.0;
        double maxTiltAngle_ = 0.0;
        double minTiltScaleAngle_ = 0.0;
        double maxTiltScaleAngle_ = 0.0;
        bool useReverseTiltAngle_ = false;
        bool useReverseNormalizedTiltAngle_ = false;
        double minTiltVelocity_ = 0.0;
        double maxTiltVelocity_ = 0.0;
        double minTiltSpeed_ = 0.0;
        double maxTiltSpeed_ = 0.0;
        double minPanAngle_ = 0.0;
        double maxPanAngle_ = 0.0;
        double minPanScaleAngle_ = 0.0;
        double maxPanScaleAngle_ = 0.0;
        bool useReversePanAngle_ = false;
        bool useReverseNormalizedPanAngle_ = false;
        double minPanVelocity_ = 0.0;
        double maxPanVelocity_ = 0.0;
        double minPanSpeed_ = 0.0;
        double maxPanSpeed_ = 0.0;
        Types::CameraFocalLengthMode focalLengthMode_ = Types::CameraFocalLengthMode::Unknown;
        double minFocalLength_ = 0.0;
        double maxFocalLength_ = 0.0;
        double minFocalLengthScale_ = 0.0;
        double maxFocalLengthScale_ = 0.0;
        double minZoomVelocity_ = 0.0;
        double maxZoomVelocity_ = 0.0;
        double minZoomSpeed_ = 0.0;
        double maxZoomSpeed_ = 0.0;
        double imageSensorWidth_ = 0.0;
        double imageSensorHeight_ = 0.0;
        double homePanAngle_ = 0.0;
        double homeTiltAngle_ = 0.0;
        double homeFocalLength_ = 0.0;
        double panOffset_ = 0.0;
        double tiltOffset_ = 0.0;
        double aimAltitude_ = 0.0;
        double minimumTargetWidth_ = 0.0;
        TimeSpan targetLockTimeout_;
        TimeSpan updateStatusInterval_;
        TimeSpan readTimeout_;
        TimeSpan moveCommandStatusDelay_;
        FixedDBWideString<127> ptzProfileName_;
        FixedDBWideString<127> ptzConfigurationToken_;
        FixedDBWideString<127> videoSourceToken_;
    public:
        CameraConfigurationObject( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(rowVersion_);
            destination.Write(camera_);
            destination.Write(timestamp_);
            destination.Write(cameraControlProtocol_);
            cameraURL_.WriteTo( destination );
            configurationURL_.WriteTo( destination );
            userName_.WriteTo( destination );
            password_.WriteTo( destination );
            destination.Write(useRtspUriOverride_);
            rtspUriOverride_.WriteTo( destination );
            destination.Write(latitude_);
            destination.Write(longitude_);
            destination.Write(altitude_);
            destination.Write(useRelativePosition_);
            destination.Write(panTiltMode_);
            destination.Write(minTiltAngle_);
            destination.Write(maxTiltAngle_);
            destination.Write(minTiltScaleAngle_);
            destination.Write(maxTiltScaleAngle_);
            destination.Write(useReverseTiltAngle_);
            destination.Write(useReverseNormalizedTiltAngle_);
            destination.Write(minTiltVelocity_);
            destination.Write(maxTiltVelocity_);
            destination.Write(minTiltSpeed_);
            destination.Write(maxTiltSpeed_);
            destination.Write(minPanAngle_);
            destination.Write(maxPanAngle_);
            destination.Write(minPanScaleAngle_);
            destination.Write(maxPanScaleAngle_);
            destination.Write(useReversePanAngle_);
            destination.Write(useReverseNormalizedPanAngle_);
            destination.Write(minPanVelocity_);
            destination.Write(maxPanVelocity_);
            destination.Write(minPanSpeed_);
            destination.Write(maxPanSpeed_);
            destination.Write(focalLengthMode_);
            destination.Write(minFocalLength_);
            destination.Write(maxFocalLength_);
            destination.Write(minFocalLengthScale_);
            destination.Write(maxFocalLengthScale_);
            destination.Write(minZoomVelocity_);
            destination.Write(maxZoomVelocity_);
            destination.Write(minZoomSpeed_);
            destination.Write(maxZoomSpeed_);
            destination.Write(imageSensorWidth_);
            destination.Write(imageSensorHeight_);
            destination.Write(homePanAngle_);
            destination.Write(homeTiltAngle_);
            destination.Write(homeFocalLength_);
            destination.Write(panOffset_);
            destination.Write(tiltOffset_);
            destination.Write(aimAltitude_);
            destination.Write(minimumTargetWidth_);
            destination.Write(targetLockTimeout_);
            destination.Write(updateStatusInterval_);
            destination.Write(readTimeout_);
            destination.Write(moveCommandStatusDelay_);
            ptzProfileName_.WriteTo( destination );
            ptzConfigurationToken_.WriteTo( destination );
            videoSourceToken_.WriteTo( destination );
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(rowVersion_);
            source.Read(camera_);
            source.Read(timestamp_);
            source.Read(cameraControlProtocol_);
            cameraURL_.ReadFrom( source );
            configurationURL_.ReadFrom( source );
            userName_.ReadFrom( source );
            password_.ReadFrom( source );
            source.Read(useRtspUriOverride_);
            rtspUriOverride_.ReadFrom( source );
            source.Read(latitude_);
            source.Read(longitude_);
            source.Read(altitude_);
            source.Read(useRelativePosition_);
            source.Read(panTiltMode_);
            source.Read(minTiltAngle_);
            source.Read(maxTiltAngle_);
            source.Read(minTiltScaleAngle_);
            source.Read(maxTiltScaleAngle_);
            source.Read(useReverseTiltAngle_);
            source.Read(useReverseNormalizedTiltAngle_);
            source.Read(minTiltVelocity_);
            source.Read(maxTiltVelocity_);
            source.Read(minTiltSpeed_);
            source.Read(maxTiltSpeed_);
            source.Read(minPanAngle_);
            source.Read(maxPanAngle_);
            source.Read(minPanScaleAngle_);
            source.Read(maxPanScaleAngle_);
            source.Read(useReversePanAngle_);
            source.Read(useReverseNormalizedPanAngle_);
            source.Read(minPanVelocity_);
            source.Read(maxPanVelocity_);
            source.Read(minPanSpeed_);
            source.Read(maxPanSpeed_);
            source.Read(focalLengthMode_);
            source.Read(minFocalLength_);
            source.Read(maxFocalLength_);
            source.Read(minFocalLengthScale_);
            source.Read(maxFocalLengthScale_);
            source.Read(minZoomVelocity_);
            source.Read(maxZoomVelocity_);
            source.Read(minZoomSpeed_);
            source.Read(maxZoomSpeed_);
            source.Read(imageSensorWidth_);
            source.Read(imageSensorHeight_);
            source.Read(homePanAngle_);
            source.Read(homeTiltAngle_);
            source.Read(homeFocalLength_);
            source.Read(panOffset_);
            source.Read(tiltOffset_);
            source.Read(aimAltitude_);
            source.Read(minimumTargetWidth_);
            source.Read(targetLockTimeout_);
            source.Read(updateStatusInterval_);
            source.Read(readTimeout_);
            source.Read(moveCommandStatusDelay_);
            ptzProfileName_.ReadFrom( source );
            ptzConfigurationToken_.ReadFrom( source );
            videoSourceToken_.ReadFrom( source );
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<CameraConfigurationObject>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<CameraConfigurationObject&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const CameraConfigurationObject& >( other );
                if ( dataObject.rowVersion_ != rowVersion_ )
                {
                    return false;
                }
                if ( dataObject.camera_ != camera_ )
                {
                    return false;
                }
                if ( dataObject.timestamp_ != timestamp_ )
                {
                    return false;
                }
                if ( dataObject.cameraControlProtocol_ != cameraControlProtocol_ )
                {
                    return false;
                }
                if ( dataObject.cameraURL_ != cameraURL_ )
                {
                    return false;
                }
                if ( dataObject.configurationURL_ != configurationURL_ )
                {
                    return false;
                }
                if ( dataObject.userName_ != userName_ )
                {
                    return false;
                }
                if ( dataObject.password_ != password_ )
                {
                    return false;
                }
                if ( dataObject.useRtspUriOverride_ != useRtspUriOverride_ )
                {
                    return false;
                }
                if ( dataObject.rtspUriOverride_ != rtspUriOverride_ )
                {
                    return false;
                }
                if ( dataObject.latitude_ != latitude_ )
                {
                    return false;
                }
                if ( dataObject.longitude_ != longitude_ )
                {
                    return false;
                }
                if ( dataObject.altitude_ != altitude_ )
                {
                    return false;
                }
                if ( dataObject.useRelativePosition_ != useRelativePosition_ )
                {
                    return false;
                }
                if ( dataObject.panTiltMode_ != panTiltMode_ )
                {
                    return false;
                }
                if ( dataObject.minTiltAngle_ != minTiltAngle_ )
                {
                    return false;
                }
                if ( dataObject.maxTiltAngle_ != maxTiltAngle_ )
                {
                    return false;
                }
                if ( dataObject.minTiltScaleAngle_ != minTiltScaleAngle_ )
                {
                    return false;
                }
                if ( dataObject.maxTiltScaleAngle_ != maxTiltScaleAngle_ )
                {
                    return false;
                }
                if ( dataObject.useReverseTiltAngle_ != useReverseTiltAngle_ )
                {
                    return false;
                }
                if ( dataObject.useReverseNormalizedTiltAngle_ != useReverseNormalizedTiltAngle_ )
                {
                    return false;
                }
                if ( dataObject.minTiltVelocity_ != minTiltVelocity_ )
                {
                    return false;
                }
                if ( dataObject.maxTiltVelocity_ != maxTiltVelocity_ )
                {
                    return false;
                }
                if ( dataObject.minTiltSpeed_ != minTiltSpeed_ )
                {
                    return false;
                }
                if ( dataObject.maxTiltSpeed_ != maxTiltSpeed_ )
                {
                    return false;
                }
                if ( dataObject.minPanAngle_ != minPanAngle_ )
                {
                    return false;
                }
                if ( dataObject.maxPanAngle_ != maxPanAngle_ )
                {
                    return false;
                }
                if ( dataObject.minPanScaleAngle_ != minPanScaleAngle_ )
                {
                    return false;
                }
                if ( dataObject.maxPanScaleAngle_ != maxPanScaleAngle_ )
                {
                    return false;
                }
                if ( dataObject.useReversePanAngle_ != useReversePanAngle_ )
                {
                    return false;
                }
                if ( dataObject.useReverseNormalizedPanAngle_ != useReverseNormalizedPanAngle_ )
                {
                    return false;
                }
                if ( dataObject.minPanVelocity_ != minPanVelocity_ )
                {
                    return false;
                }
                if ( dataObject.maxPanVelocity_ != maxPanVelocity_ )
                {
                    return false;
                }
                if ( dataObject.minPanSpeed_ != minPanSpeed_ )
                {
                    return false;
                }
                if ( dataObject.maxPanSpeed_ != maxPanSpeed_ )
                {
                    return false;
                }
                if ( dataObject.focalLengthMode_ != focalLengthMode_ )
                {
                    return false;
                }
                if ( dataObject.minFocalLength_ != minFocalLength_ )
                {
                    return false;
                }
                if ( dataObject.maxFocalLength_ != maxFocalLength_ )
                {
                    return false;
                }
                if ( dataObject.minFocalLengthScale_ != minFocalLengthScale_ )
                {
                    return false;
                }
                if ( dataObject.maxFocalLengthScale_ != maxFocalLengthScale_ )
                {
                    return false;
                }
                if ( dataObject.minZoomVelocity_ != minZoomVelocity_ )
                {
                    return false;
                }
                if ( dataObject.maxZoomVelocity_ != maxZoomVelocity_ )
                {
                    return false;
                }
                if ( dataObject.minZoomSpeed_ != minZoomSpeed_ )
                {
                    return false;
                }
                if ( dataObject.maxZoomSpeed_ != maxZoomSpeed_ )
                {
                    return false;
                }
                if ( dataObject.imageSensorWidth_ != imageSensorWidth_ )
                {
                    return false;
                }
                if ( dataObject.imageSensorHeight_ != imageSensorHeight_ )
                {
                    return false;
                }
                if ( dataObject.homePanAngle_ != homePanAngle_ )
                {
                    return false;
                }
                if ( dataObject.homeTiltAngle_ != homeTiltAngle_ )
                {
                    return false;
                }
                if ( dataObject.homeFocalLength_ != homeFocalLength_ )
                {
                    return false;
                }
                if ( dataObject.panOffset_ != panOffset_ )
                {
                    return false;
                }
                if ( dataObject.tiltOffset_ != tiltOffset_ )
                {
                    return false;
                }
                if ( dataObject.aimAltitude_ != aimAltitude_ )
                {
                    return false;
                }
                if ( dataObject.minimumTargetWidth_ != minimumTargetWidth_ )
                {
                    return false;
                }
                if ( dataObject.targetLockTimeout_ != targetLockTimeout_ )
                {
                    return false;
                }
                if ( dataObject.updateStatusInterval_ != updateStatusInterval_ )
                {
                    return false;
                }
                if ( dataObject.readTimeout_ != readTimeout_ )
                {
                    return false;
                }
                if ( dataObject.moveCommandStatusDelay_ != moveCommandStatusDelay_ )
                {
                    return false;
                }
                if ( dataObject.ptzProfileName_ != ptzProfileName_ )
                {
                    return false;
                }
                if ( dataObject.ptzConfigurationToken_ != ptzConfigurationToken_ )
                {
                    return false;
                }
                if ( dataObject.videoSourceToken_ != videoSourceToken_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        Int64 RowVersion( ) const
        {
            return rowVersion_;
        }
        void SetRowVersion( const Int64& rowVersion )
        {
            rowVersion_ = rowVersion;
        }
        const Guid& Camera( ) const
        {
            return camera_;
        }
        void SetCamera( const Guid& camera )
        {
            camera_ = camera;
        }
        const DateTime& Timestamp( ) const
        {
            return timestamp_;
        }
        void SetTimestamp( const DateTime& timestamp )
        {
            timestamp_ = timestamp;
        }
        Types::CameraControlProtocol CameraControlProtocol( ) const
        {
            return cameraControlProtocol_;
        }
        void SetCameraControlProtocol( Types::CameraControlProtocol cameraControlProtocol )
        {
            cameraControlProtocol_ = cameraControlProtocol;
        }
        const FixedDBWideString<127>& CameraURL( ) const
        {
            return cameraURL_;
        }
        void SetCameraURL( const FixedDBWideString<127>& cameraURL )
        {
            cameraURL_ = cameraURL;
        }
        const FixedDBWideString<127>& ConfigurationURL( ) const
        {
            return configurationURL_;
        }
        void SetConfigurationURL( const FixedDBWideString<127>& configurationURL )
        {
            configurationURL_ = configurationURL;
        }
        const FixedDBWideString<127>& UserName( ) const
        {
            return userName_;
        }
        void SetUserName( const FixedDBWideString<127>& userName )
        {
            userName_ = userName;
        }
        const FixedDBWideString<127>& Password( ) const
        {
            return password_;
        }
        void SetPassword( const FixedDBWideString<127>& password )
        {
            password_ = password;
        }
        bool UseRtspUriOverride( ) const
        {
            return useRtspUriOverride_;
        }
        void SetUseRtspUriOverride( bool useRtspUriOverride )
        {
            useRtspUriOverride_ = useRtspUriOverride;
        }
        const FixedDBWideString<127>& RtspUriOverride( ) const
        {
            return rtspUriOverride_;
        }
        void SetRtspUriOverride( const FixedDBWideString<127>& rtspUriOverride )
        {
            rtspUriOverride_ = rtspUriOverride;
        }
        double Latitude( ) const
        {
            return latitude_;
        }
        void SetLatitude( double latitude )
        {
            latitude_ = latitude;
        }
        double Longitude( ) const
        {
            return longitude_;
        }
        void SetLongitude( double longitude )
        {
            longitude_ = longitude;
        }
        double Altitude( ) const
        {
            return altitude_;
        }
        void SetAltitude( double altitude )
        {
            altitude_ = altitude;
        }
        bool UseRelativePosition( ) const
        {
            return useRelativePosition_;
        }
        void SetUseRelativePosition( bool useRelativePosition )
        {
            useRelativePosition_ = useRelativePosition;
        }
        Types::CameraPanTiltMode PanTiltMode( ) const
        {
            return panTiltMode_;
        }
        void SetPanTiltMode( Types::CameraPanTiltMode panTiltMode )
        {
            panTiltMode_ = panTiltMode;
        }
        double MinTiltAngle( ) const
        {
            return minTiltAngle_;
        }
        void SetMinTiltAngle( double minTiltAngle )
        {
            minTiltAngle_ = minTiltAngle;
        }
        double MaxTiltAngle( ) const
        {
            return maxTiltAngle_;
        }
        void SetMaxTiltAngle( double maxTiltAngle )
        {
            maxTiltAngle_ = maxTiltAngle;
        }
        double MinTiltScaleAngle( ) const
        {
            return minTiltScaleAngle_;
        }
        void SetMinTiltScaleAngle( double minTiltScaleAngle )
        {
            minTiltScaleAngle_ = minTiltScaleAngle;
        }
        double MaxTiltScaleAngle( ) const
        {
            return maxTiltScaleAngle_;
        }
        void SetMaxTiltScaleAngle( double maxTiltScaleAngle )
        {
            maxTiltScaleAngle_ = maxTiltScaleAngle;
        }
        bool UseReverseTiltAngle( ) const
        {
            return useReverseTiltAngle_;
        }
        void SetUseReverseTiltAngle( bool useReverseTiltAngle )
        {
            useReverseTiltAngle_ = useReverseTiltAngle;
        }
        bool UseReverseNormalizedTiltAngle( ) const
        {
            return useReverseNormalizedTiltAngle_;
        }
        void SetUseReverseNormalizedTiltAngle( bool useReverseNormalizedTiltAngle )
        {
            useReverseNormalizedTiltAngle_ = useReverseNormalizedTiltAngle;
        }
        double MinTiltVelocity( ) const
        {
            return minTiltVelocity_;
        }
        void SetMinTiltVelocity( double minTiltVelocity )
        {
            minTiltVelocity_ = minTiltVelocity;
        }
        double MaxTiltVelocity( ) const
        {
            return maxTiltVelocity_;
        }
        void SetMaxTiltVelocity( double maxTiltVelocity )
        {
            maxTiltVelocity_ = maxTiltVelocity;
        }
        double MinTiltSpeed( ) const
        {
            return minTiltSpeed_;
        }
        void SetMinTiltSpeed( double minTiltSpeed )
        {
            minTiltSpeed_ = minTiltSpeed;
        }
        double MaxTiltSpeed( ) const
        {
            return maxTiltSpeed_;
        }
        void SetMaxTiltSpeed( double maxTiltSpeed )
        {
            maxTiltSpeed_ = maxTiltSpeed;
        }
        double MinPanAngle( ) const
        {
            return minPanAngle_;
        }
        void SetMinPanAngle( double minPanAngle )
        {
            minPanAngle_ = minPanAngle;
        }
        double MaxPanAngle( ) const
        {
            return maxPanAngle_;
        }
        void SetMaxPanAngle( double maxPanAngle )
        {
            maxPanAngle_ = maxPanAngle;
        }
        double MinPanScaleAngle( ) const
        {
            return minPanScaleAngle_;
        }
        void SetMinPanScaleAngle( double minPanScaleAngle )
        {
            minPanScaleAngle_ = minPanScaleAngle;
        }
        double MaxPanScaleAngle( ) const
        {
            return maxPanScaleAngle_;
        }
        void SetMaxPanScaleAngle( double maxPanScaleAngle )
        {
            maxPanScaleAngle_ = maxPanScaleAngle;
        }
        bool UseReversePanAngle( ) const
        {
            return useReversePanAngle_;
        }
        void SetUseReversePanAngle( bool useReversePanAngle )
        {
            useReversePanAngle_ = useReversePanAngle;
        }
        bool UseReverseNormalizedPanAngle( ) const
        {
            return useReverseNormalizedPanAngle_;
        }
        void SetUseReverseNormalizedPanAngle( bool useReverseNormalizedPanAngle )
        {
            useReverseNormalizedPanAngle_ = useReverseNormalizedPanAngle;
        }
        double MinPanVelocity( ) const
        {
            return minPanVelocity_;
        }
        void SetMinPanVelocity( double minPanVelocity )
        {
            minPanVelocity_ = minPanVelocity;
        }
        double MaxPanVelocity( ) const
        {
            return maxPanVelocity_;
        }
        void SetMaxPanVelocity( double maxPanVelocity )
        {
            maxPanVelocity_ = maxPanVelocity;
        }
        double MinPanSpeed( ) const
        {
            return minPanSpeed_;
        }
        void SetMinPanSpeed( double minPanSpeed )
        {
            minPanSpeed_ = minPanSpeed;
        }
        double MaxPanSpeed( ) const
        {
            return maxPanSpeed_;
        }
        void SetMaxPanSpeed( double maxPanSpeed )
        {
            maxPanSpeed_ = maxPanSpeed;
        }
        Types::CameraFocalLengthMode FocalLengthMode( ) const
        {
            return focalLengthMode_;
        }
        void SetFocalLengthMode( Types::CameraFocalLengthMode focalLengthMode )
        {
            focalLengthMode_ = focalLengthMode;
        }
        double MinFocalLength( ) const
        {
            return minFocalLength_;
        }
        void SetMinFocalLength( double minFocalLength )
        {
            minFocalLength_ = minFocalLength;
        }
        double MaxFocalLength( ) const
        {
            return maxFocalLength_;
        }
        void SetMaxFocalLength( double maxFocalLength )
        {
            maxFocalLength_ = maxFocalLength;
        }
        double MinFocalLengthScale( ) const
        {
            return minFocalLengthScale_;
        }
        void SetMinFocalLengthScale( double minFocalLengthScale )
        {
            minFocalLengthScale_ = minFocalLengthScale;
        }
        double MaxFocalLengthScale( ) const
        {
            return maxFocalLengthScale_;
        }
        void SetMaxFocalLengthScale( double maxFocalLengthScale )
        {
            maxFocalLengthScale_ = maxFocalLengthScale;
        }
        double MinZoomVelocity( ) const
        {
            return minZoomVelocity_;
        }
        void SetMinZoomVelocity( double minZoomVelocity )
        {
            minZoomVelocity_ = minZoomVelocity;
        }
        double MaxZoomVelocity( ) const
        {
            return maxZoomVelocity_;
        }
        void SetMaxZoomVelocity( double maxZoomVelocity )
        {
            maxZoomVelocity_ = maxZoomVelocity;
        }
        double MinZoomSpeed( ) const
        {
            return minZoomSpeed_;
        }
        void SetMinZoomSpeed( double minZoomSpeed )
        {
            minZoomSpeed_ = minZoomSpeed;
        }
        double MaxZoomSpeed( ) const
        {
            return maxZoomSpeed_;
        }
        void SetMaxZoomSpeed( double maxZoomSpeed )
        {
            maxZoomSpeed_ = maxZoomSpeed;
        }
        double ImageSensorWidth( ) const
        {
            return imageSensorWidth_;
        }
        void SetImageSensorWidth( double imageSensorWidth )
        {
            imageSensorWidth_ = imageSensorWidth;
        }
        double ImageSensorHeight( ) const
        {
            return imageSensorHeight_;
        }
        void SetImageSensorHeight( double imageSensorHeight )
        {
            imageSensorHeight_ = imageSensorHeight;
        }
        double HomePanAngle( ) const
        {
            return homePanAngle_;
        }
        void SetHomePanAngle( double homePanAngle )
        {
            homePanAngle_ = homePanAngle;
        }
        double HomeTiltAngle( ) const
        {
            return homeTiltAngle_;
        }
        void SetHomeTiltAngle( double homeTiltAngle )
        {
            homeTiltAngle_ = homeTiltAngle;
        }
        double HomeFocalLength( ) const
        {
            return homeFocalLength_;
        }
        void SetHomeFocalLength( double homeFocalLength )
        {
            homeFocalLength_ = homeFocalLength;
        }
        double PanOffset( ) const
        {
            return panOffset_;
        }
        void SetPanOffset( double panOffset )
        {
            panOffset_ = panOffset;
        }
        double TiltOffset( ) const
        {
            return tiltOffset_;
        }
        void SetTiltOffset( double tiltOffset )
        {
            tiltOffset_ = tiltOffset;
        }
        double AimAltitude( ) const
        {
            return aimAltitude_;
        }
        void SetAimAltitude( double aimAltitude )
        {
            aimAltitude_ = aimAltitude;
        }
        double MinimumTargetWidth( ) const
        {
            return minimumTargetWidth_;
        }
        void SetMinimumTargetWidth( double minimumTargetWidth )
        {
            minimumTargetWidth_ = minimumTargetWidth;
        }
        const TimeSpan& TargetLockTimeout( ) const
        {
            return targetLockTimeout_;
        }
        void SetTargetLockTimeout( const TimeSpan& targetLockTimeout )
        {
            targetLockTimeout_ = targetLockTimeout;
        }
        const TimeSpan& UpdateStatusInterval( ) const
        {
            return updateStatusInterval_;
        }
        void SetUpdateStatusInterval( const TimeSpan& updateStatusInterval )
        {
            updateStatusInterval_ = updateStatusInterval;
        }
        const TimeSpan& ReadTimeout( ) const
        {
            return readTimeout_;
        }
        void SetReadTimeout( const TimeSpan& readTimeout )
        {
            readTimeout_ = readTimeout;
        }
        const TimeSpan& MoveCommandStatusDelay( ) const
        {
            return moveCommandStatusDelay_;
        }
        void SetMoveCommandStatusDelay( const TimeSpan& moveCommandStatusDelay )
        {
            moveCommandStatusDelay_ = moveCommandStatusDelay;
        }
        const FixedDBWideString<127>& PtzProfileName( ) const
        {
            return ptzProfileName_;
        }
        void SetPtzProfileName( const FixedDBWideString<127>& ptzProfileName )
        {
            ptzProfileName_ = ptzProfileName;
        }
        const FixedDBWideString<127>& PtzConfigurationToken( ) const
        {
            return ptzConfigurationToken_;
        }
        void SetPtzConfigurationToken( const FixedDBWideString<127>& ptzConfigurationToken )
        {
            ptzConfigurationToken_ = ptzConfigurationToken;
        }
        const FixedDBWideString<127>& VideoSourceToken( ) const
        {
            return videoSourceToken_;
        }
        void SetVideoSourceToken( const FixedDBWideString<127>& videoSourceToken )
        {
            videoSourceToken_ = videoSourceToken;
        }
    };
    class CameraPanCalibrationObject : public BaseData<Kind, Guid>
    {
    public:
        using Base = BaseData<Kind, Guid>;
        static constexpr Kind KIND = Kind::CameraPanCalibration;
    private:
        Int64 rowVersion_ = 0;
        Guid camera_;
        DateTime timestamp_;
    public:
        CameraPanCalibrationObject( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(rowVersion_);
            destination.Write(camera_);
            destination.Write(timestamp_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(rowVersion_);
            source.Read(camera_);
            source.Read(timestamp_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<CameraPanCalibrationObject>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<CameraPanCalibrationObject&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const CameraPanCalibrationObject& >( other );
                if ( dataObject.rowVersion_ != rowVersion_ )
                {
                    return false;
                }
                if ( dataObject.camera_ != camera_ )
                {
                    return false;
                }
                if ( dataObject.timestamp_ != timestamp_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        Int64 RowVersion( ) const
        {
            return rowVersion_;
        }
        void SetRowVersion( const Int64& rowVersion )
        {
            rowVersion_ = rowVersion;
        }
        const Guid& Camera( ) const
        {
            return camera_;
        }
        void SetCamera( const Guid& camera )
        {
            camera_ = camera;
        }
        const DateTime& Timestamp( ) const
        {
            return timestamp_;
        }
        void SetTimestamp( const DateTime& timestamp )
        {
            timestamp_ = timestamp;
        }
    };
    class CameraPanCalibrationValueObject : public BaseData<Kind, Guid>
    {
    public:
        using Base = BaseData<Kind, Guid>;
        static constexpr Kind KIND = Kind::CameraPanCalibrationValue;
    private:
        Int64 rowVersion_ = 0;
        Guid panCalibration_;
        double panAngle_ = 0.0;
        double panOffset_ = 0.0;
    public:
        CameraPanCalibrationValueObject( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(rowVersion_);
            destination.Write(panCalibration_);
            destination.Write(panAngle_);
            destination.Write(panOffset_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(rowVersion_);
            source.Read(panCalibration_);
            source.Read(panAngle_);
            source.Read(panOffset_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<CameraPanCalibrationValueObject>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<CameraPanCalibrationValueObject&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const CameraPanCalibrationValueObject& >( other );
                if ( dataObject.rowVersion_ != rowVersion_ )
                {
                    return false;
                }
                if ( dataObject.panCalibration_ != panCalibration_ )
                {
                    return false;
                }
                if ( dataObject.panAngle_ != panAngle_ )
                {
                    return false;
                }
                if ( dataObject.panOffset_ != panOffset_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        Int64 RowVersion( ) const
        {
            return rowVersion_;
        }
        void SetRowVersion( const Int64& rowVersion )
        {
            rowVersion_ = rowVersion;
        }
        const Guid& PanCalibration( ) const
        {
            return panCalibration_;
        }
        void SetPanCalibration( const Guid& panCalibration )
        {
            panCalibration_ = panCalibration;
        }
        double PanAngle( ) const
        {
            return panAngle_;
        }
        void SetPanAngle( double panAngle )
        {
            panAngle_ = panAngle;
        }
        double PanOffset( ) const
        {
            return panOffset_;
        }
        void SetPanOffset( double panOffset )
        {
            panOffset_ = panOffset;
        }
    };
    class CameraStatusObject : public BaseData<Kind, Guid>
    {
    public:
        using Base = BaseData<Kind, Guid>;
        static constexpr Kind KIND = Kind::CameraStatus;
    private:
        Int64 rowVersion_ = 0;
        Guid camera_;
        Guid track_;
        DateTime timestamp_;
        Types::CameraPanTiltMode positionPanTiltMode_ = Types::CameraPanTiltMode::Unknown;
        double panAngle_ = 0.0;
        double tiltAngle_ = 0.0;
        Types::CameraFocalLengthMode positionFocalLengthMode_ = Types::CameraFocalLengthMode::Unknown;
        double focalLength_ = 0.0;
        Types::CameraMoveStatus panTiltMoveStatus_ = Types::CameraMoveStatus::Unknown;
        Types::CameraMoveStatus zoomMoveStatus_ = Types::CameraMoveStatus::Unknown;
        Types::CameraPanTiltMode velocityPanTiltMode_ = Types::CameraPanTiltMode::Unknown;
        DBDouble panVelocity_;
        DBDouble tiltVelocity_;
        Types::CameraFocalLengthMode velocityFocalLengthMode_ = Types::CameraFocalLengthMode::Unknown;
        DBDouble zoomVelocity_;
        Types::CameraFeatures activeFeatures_ = Types::CameraFeatures::None;
        WideString error_;
        SQLLEN errorLength_ = SQL_NULL_DATA;
    public:
        CameraStatusObject( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(rowVersion_);
            destination.Write(camera_);
            destination.Write(track_);
            destination.Write(timestamp_);
            destination.Write(positionPanTiltMode_);
            destination.Write(panAngle_);
            destination.Write(tiltAngle_);
            destination.Write(positionFocalLengthMode_);
            destination.Write(focalLength_);
            destination.Write(panTiltMoveStatus_);
            destination.Write(zoomMoveStatus_);
            destination.Write(velocityPanTiltMode_);
            panVelocity_.WriteTo( destination );
            tiltVelocity_.WriteTo( destination );
            destination.Write(velocityFocalLengthMode_);
            zoomVelocity_.WriteTo( destination );
            destination.Write(activeFeatures_);
            destination.Write(error_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(rowVersion_);
            source.Read(camera_);
            source.Read(track_);
            source.Read(timestamp_);
            source.Read(positionPanTiltMode_);
            source.Read(panAngle_);
            source.Read(tiltAngle_);
            source.Read(positionFocalLengthMode_);
            source.Read(focalLength_);
            source.Read(panTiltMoveStatus_);
            source.Read(zoomMoveStatus_);
            source.Read(velocityPanTiltMode_);
            panVelocity_.ReadFrom( source );
            tiltVelocity_.ReadFrom( source );
            source.Read(velocityFocalLengthMode_);
            zoomVelocity_.ReadFrom( source );
            source.Read(activeFeatures_);
            source.Read(error_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<CameraStatusObject>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<CameraStatusObject&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const CameraStatusObject& >( other );
                if ( dataObject.rowVersion_ != rowVersion_ )
                {
                    return false;
                }
                if ( dataObject.camera_ != camera_ )
                {
                    return false;
                }
                if ( dataObject.track_ != track_ )
                {
                    return false;
                }
                if ( dataObject.timestamp_ != timestamp_ )
                {
                    return false;
                }
                if ( dataObject.positionPanTiltMode_ != positionPanTiltMode_ )
                {
                    return false;
                }
                if ( dataObject.panAngle_ != panAngle_ )
                {
                    return false;
                }
                if ( dataObject.tiltAngle_ != tiltAngle_ )
                {
                    return false;
                }
                if ( dataObject.positionFocalLengthMode_ != positionFocalLengthMode_ )
                {
                    return false;
                }
                if ( dataObject.focalLength_ != focalLength_ )
                {
                    return false;
                }
                if ( dataObject.panTiltMoveStatus_ != panTiltMoveStatus_ )
                {
                    return false;
                }
                if ( dataObject.zoomMoveStatus_ != zoomMoveStatus_ )
                {
                    return false;
                }
                if ( dataObject.velocityPanTiltMode_ != velocityPanTiltMode_ )
                {
                    return false;
                }
                if ( dataObject.panVelocity_ != panVelocity_ )
                {
                    return false;
                }
                if ( dataObject.tiltVelocity_ != tiltVelocity_ )
                {
                    return false;
                }
                if ( dataObject.velocityFocalLengthMode_ != velocityFocalLengthMode_ )
                {
                    return false;
                }
                if ( dataObject.zoomVelocity_ != zoomVelocity_ )
                {
                    return false;
                }
                if ( dataObject.activeFeatures_ != activeFeatures_ )
                {
                    return false;
                }
                if ( dataObject.error_ != error_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        Int64 RowVersion( ) const
        {
            return rowVersion_;
        }
        void SetRowVersion( const Int64& rowVersion )
        {
            rowVersion_ = rowVersion;
        }
        const Guid& Camera( ) const
        {
            return camera_;
        }
        void SetCamera( const Guid& camera )
        {
            camera_ = camera;
        }
        const Guid& Track( ) const
        {
            return track_;
        }
        void SetTrack( const Guid& track )
        {
            track_ = track;
        }
        const DateTime& Timestamp( ) const
        {
            return timestamp_;
        }
        void SetTimestamp( const DateTime& timestamp )
        {
            timestamp_ = timestamp;
        }
        Types::CameraPanTiltMode PositionPanTiltMode( ) const
        {
            return positionPanTiltMode_;
        }
        void SetPositionPanTiltMode( Types::CameraPanTiltMode positionPanTiltMode )
        {
            positionPanTiltMode_ = positionPanTiltMode;
        }
        double PanAngle( ) const
        {
            return panAngle_;
        }
        void SetPanAngle( double panAngle )
        {
            panAngle_ = panAngle;
        }
        double TiltAngle( ) const
        {
            return tiltAngle_;
        }
        void SetTiltAngle( double tiltAngle )
        {
            tiltAngle_ = tiltAngle;
        }
        Types::CameraFocalLengthMode PositionFocalLengthMode( ) const
        {
            return positionFocalLengthMode_;
        }
        void SetPositionFocalLengthMode( Types::CameraFocalLengthMode positionFocalLengthMode )
        {
            positionFocalLengthMode_ = positionFocalLengthMode;
        }
        double FocalLength( ) const
        {
            return focalLength_;
        }
        void SetFocalLength( double focalLength )
        {
            focalLength_ = focalLength;
        }
        Types::CameraMoveStatus PanTiltMoveStatus( ) const
        {
            return panTiltMoveStatus_;
        }
        void SetPanTiltMoveStatus( Types::CameraMoveStatus panTiltMoveStatus )
        {
            panTiltMoveStatus_ = panTiltMoveStatus;
        }
        Types::CameraMoveStatus ZoomMoveStatus( ) const
        {
            return zoomMoveStatus_;
        }
        void SetZoomMoveStatus( Types::CameraMoveStatus zoomMoveStatus )
        {
            zoomMoveStatus_ = zoomMoveStatus;
        }
        Types::CameraPanTiltMode VelocityPanTiltMode( ) const
        {
            return velocityPanTiltMode_;
        }
        void SetVelocityPanTiltMode( Types::CameraPanTiltMode velocityPanTiltMode )
        {
            velocityPanTiltMode_ = velocityPanTiltMode;
        }
        const DBDouble& PanVelocity( ) const
        {
            return panVelocity_;
        }
        void SetPanVelocity( const DBDouble& panVelocity )
        {
            panVelocity_ = panVelocity;
        }
        const DBDouble& TiltVelocity( ) const
        {
            return tiltVelocity_;
        }
        void SetTiltVelocity( const DBDouble& tiltVelocity )
        {
            tiltVelocity_ = tiltVelocity;
        }
        Types::CameraFocalLengthMode VelocityFocalLengthMode( ) const
        {
            return velocityFocalLengthMode_;
        }
        void SetVelocityFocalLengthMode( Types::CameraFocalLengthMode velocityFocalLengthMode )
        {
            velocityFocalLengthMode_ = velocityFocalLengthMode;
        }
        const DBDouble& ZoomVelocity( ) const
        {
            return zoomVelocity_;
        }
        void SetZoomVelocity( const DBDouble& zoomVelocity )
        {
            zoomVelocity_ = zoomVelocity;
        }
        Types::CameraFeatures ActiveFeatures( ) const
        {
            return activeFeatures_;
        }
        void SetActiveFeatures( Types::CameraFeatures activeFeatures )
        {
            activeFeatures_ = activeFeatures;
        }
        const WideString& Error( ) const
        {
            return error_;
        }
        void SetError( const WideString& error )
        {
            error_ = error;
        }
    };
    class CameraTiltCalibrationObject : public BaseData<Kind, Guid>
    {
    public:
        using Base = BaseData<Kind, Guid>;
        static constexpr Kind KIND = Kind::CameraTiltCalibration;
    private:
        Int64 rowVersion_ = 0;
        Guid camera_;
        DateTime timestamp_;
    public:
        CameraTiltCalibrationObject( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(rowVersion_);
            destination.Write(camera_);
            destination.Write(timestamp_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(rowVersion_);
            source.Read(camera_);
            source.Read(timestamp_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<CameraTiltCalibrationObject>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<CameraTiltCalibrationObject&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const CameraTiltCalibrationObject& >( other );
                if ( dataObject.rowVersion_ != rowVersion_ )
                {
                    return false;
                }
                if ( dataObject.camera_ != camera_ )
                {
                    return false;
                }
                if ( dataObject.timestamp_ != timestamp_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        Int64 RowVersion( ) const
        {
            return rowVersion_;
        }
        void SetRowVersion( const Int64& rowVersion )
        {
            rowVersion_ = rowVersion;
        }
        const Guid& Camera( ) const
        {
            return camera_;
        }
        void SetCamera( const Guid& camera )
        {
            camera_ = camera;
        }
        const DateTime& Timestamp( ) const
        {
            return timestamp_;
        }
        void SetTimestamp( const DateTime& timestamp )
        {
            timestamp_ = timestamp;
        }
    };
    class CameraTiltCalibrationValueObject : public BaseData<Kind, Guid>
    {
    public:
        using Base = BaseData<Kind, Guid>;
        static constexpr Kind KIND = Kind::CameraTiltCalibrationValue;
    private:
        Int64 rowVersion_ = 0;
        Guid tiltCalibration_;
        double panAngle_ = 0.0;
        double tiltOffset_ = 0.0;
    public:
        CameraTiltCalibrationValueObject( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(rowVersion_);
            destination.Write(tiltCalibration_);
            destination.Write(panAngle_);
            destination.Write(tiltOffset_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(rowVersion_);
            source.Read(tiltCalibration_);
            source.Read(panAngle_);
            source.Read(tiltOffset_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<CameraTiltCalibrationValueObject>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<CameraTiltCalibrationValueObject&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const CameraTiltCalibrationValueObject& >( other );
                if ( dataObject.rowVersion_ != rowVersion_ )
                {
                    return false;
                }
                if ( dataObject.tiltCalibration_ != tiltCalibration_ )
                {
                    return false;
                }
                if ( dataObject.panAngle_ != panAngle_ )
                {
                    return false;
                }
                if ( dataObject.tiltOffset_ != tiltOffset_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        Int64 RowVersion( ) const
        {
            return rowVersion_;
        }
        void SetRowVersion( const Int64& rowVersion )
        {
            rowVersion_ = rowVersion;
        }
        const Guid& TiltCalibration( ) const
        {
            return tiltCalibration_;
        }
        void SetTiltCalibration( const Guid& tiltCalibration )
        {
            tiltCalibration_ = tiltCalibration;
        }
        double PanAngle( ) const
        {
            return panAngle_;
        }
        void SetPanAngle( double panAngle )
        {
            panAngle_ = panAngle;
        }
        double TiltOffset( ) const
        {
            return tiltOffset_;
        }
        void SetTiltOffset( double tiltOffset )
        {
            tiltOffset_ = tiltOffset;
        }
    };
    class CameraZoomCalibrationObject : public BaseData<Kind, Guid>
    {
    public:
        using Base = BaseData<Kind, Guid>;
        static constexpr Kind KIND = Kind::CameraZoomCalibration;
    private:
        Int64 rowVersion_ = 0;
        Guid camera_;
        DateTime timestamp_;
    public:
        CameraZoomCalibrationObject( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(rowVersion_);
            destination.Write(camera_);
            destination.Write(timestamp_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(rowVersion_);
            source.Read(camera_);
            source.Read(timestamp_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<CameraZoomCalibrationObject>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<CameraZoomCalibrationObject&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const CameraZoomCalibrationObject& >( other );
                if ( dataObject.rowVersion_ != rowVersion_ )
                {
                    return false;
                }
                if ( dataObject.camera_ != camera_ )
                {
                    return false;
                }
                if ( dataObject.timestamp_ != timestamp_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        Int64 RowVersion( ) const
        {
            return rowVersion_;
        }
        void SetRowVersion( const Int64& rowVersion )
        {
            rowVersion_ = rowVersion;
        }
        const Guid& Camera( ) const
        {
            return camera_;
        }
        void SetCamera( const Guid& camera )
        {
            camera_ = camera;
        }
        const DateTime& Timestamp( ) const
        {
            return timestamp_;
        }
        void SetTimestamp( const DateTime& timestamp )
        {
            timestamp_ = timestamp;
        }
    };
    class CameraZoomCalibrationValueObject : public BaseData<Kind, Guid>
    {
    public:
        using Base = BaseData<Kind, Guid>;
        static constexpr Kind KIND = Kind::CameraZoomCalibrationValue;
    private:
        Int64 rowVersion_ = 0;
        Guid zoomCalibration_;
        double focalLength_ = 0.0;
        double focalLengthOffset_ = 0.0;
    public:
        CameraZoomCalibrationValueObject( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(rowVersion_);
            destination.Write(zoomCalibration_);
            destination.Write(focalLength_);
            destination.Write(focalLengthOffset_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(rowVersion_);
            source.Read(zoomCalibration_);
            source.Read(focalLength_);
            source.Read(focalLengthOffset_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<CameraZoomCalibrationValueObject>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<CameraZoomCalibrationValueObject&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const CameraZoomCalibrationValueObject& >( other );
                if ( dataObject.rowVersion_ != rowVersion_ )
                {
                    return false;
                }
                if ( dataObject.zoomCalibration_ != zoomCalibration_ )
                {
                    return false;
                }
                if ( dataObject.focalLength_ != focalLength_ )
                {
                    return false;
                }
                if ( dataObject.focalLengthOffset_ != focalLengthOffset_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        Int64 RowVersion( ) const
        {
            return rowVersion_;
        }
        void SetRowVersion( const Int64& rowVersion )
        {
            rowVersion_ = rowVersion;
        }
        const Guid& ZoomCalibration( ) const
        {
            return zoomCalibration_;
        }
        void SetZoomCalibration( const Guid& zoomCalibration )
        {
            zoomCalibration_ = zoomCalibration;
        }
        double FocalLength( ) const
        {
            return focalLength_;
        }
        void SetFocalLength( double focalLength )
        {
            focalLength_ = focalLength;
        }
        double FocalLengthOffset( ) const
        {
            return focalLengthOffset_;
        }
        void SetFocalLengthOffset( double focalLengthOffset )
        {
            focalLengthOffset_ = focalLengthOffset;
        }
    };
    class CatalogElementObject : public BaseData<Kind, Guid>
    {
    public:
        using Base = BaseData<Kind, Guid>;
        static constexpr Kind KIND = Kind::CatalogElement;
    private:
        Int64 rowVersion_ = 0;
        Guid catalog_;
        FixedDBWideString<127> name_;
    public:
        CatalogElementObject( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(rowVersion_);
            destination.Write(catalog_);
            name_.WriteTo( destination );
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(rowVersion_);
            source.Read(catalog_);
            name_.ReadFrom( source );
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<CatalogElementObject>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<CatalogElementObject&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const CatalogElementObject& >( other );
                if ( dataObject.rowVersion_ != rowVersion_ )
                {
                    return false;
                }
                if ( dataObject.catalog_ != catalog_ )
                {
                    return false;
                }
                if ( dataObject.name_ != name_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        Int64 RowVersion( ) const
        {
            return rowVersion_;
        }
        void SetRowVersion( const Int64& rowVersion )
        {
            rowVersion_ = rowVersion;
        }
        const Guid& Catalog( ) const
        {
            return catalog_;
        }
        void SetCatalog( const Guid& catalog )
        {
            catalog_ = catalog;
        }
        const FixedDBWideString<127>& Name( ) const
        {
            return name_;
        }
        void SetName( const FixedDBWideString<127>& name )
        {
            name_ = name;
        }
    };
    class CatalogObject : public CatalogElementObject
    {
    public:
        using Base = CatalogElementObject;
        static constexpr Kind KIND = Kind::Catalog;
    private:
    public:
        CatalogObject( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<CatalogObject>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<CatalogObject&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const CatalogObject& >( other );
                return true;
            }
            return false;
        }
    };
    class ElementObject : public CatalogElementObject
    {
    public:
        using Base = CatalogElementObject;
        static constexpr Kind KIND = Kind::Element;
    private:
        Guid elementType_;
    public:
        ElementObject( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(elementType_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(elementType_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<ElementObject>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<ElementObject&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const ElementObject& >( other );
                if ( dataObject.elementType_ != elementType_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        const Guid& ElementType( ) const
        {
            return elementType_;
        }
        void SetElementType( const Guid& elementType )
        {
            elementType_ = elementType;
        }
    };
    class CollectionInfoObject : public BaseData<Kind, Guid>
    {
    public:
        using Base = BaseData<Kind, Guid>;
        static constexpr Kind KIND = Kind::CollectionInfo;
    private:
        Int64 rowVersion_ = 0;
        Int64 count_ = 0;
    public:
        CollectionInfoObject( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(rowVersion_);
            destination.Write(count_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(rowVersion_);
            source.Read(count_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<CollectionInfoObject>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<CollectionInfoObject&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const CollectionInfoObject& >( other );
                if ( dataObject.rowVersion_ != rowVersion_ )
                {
                    return false;
                }
                if ( dataObject.count_ != count_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        Int64 RowVersion( ) const
        {
            return rowVersion_;
        }
        void SetRowVersion( const Int64& rowVersion )
        {
            rowVersion_ = rowVersion;
        }
        Int64 Count( ) const
        {
            return count_;
        }
        void SetCount( Int64 count )
        {
            count_ = count;
        }
    };
    class CountryObject : public BaseData<Kind, Guid>
    {
    public:
        using Base = BaseData<Kind, Guid>;
        static constexpr Kind KIND = Kind::Country;
    private:
        Int64 rowVersion_ = 0;
        FixedDBWideString<127> name_;
        Int32 code_ = 0;
        FixedDBWideString<2> alpha2_;
        FixedDBWideString<3> alpha3_;
    public:
        CountryObject( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(rowVersion_);
            name_.WriteTo( destination );
            destination.Write(code_);
            alpha2_.WriteTo( destination );
            alpha3_.WriteTo( destination );
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(rowVersion_);
            name_.ReadFrom( source );
            source.Read(code_);
            alpha2_.ReadFrom( source );
            alpha3_.ReadFrom( source );
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<CountryObject>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<CountryObject&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const CountryObject& >( other );
                if ( dataObject.rowVersion_ != rowVersion_ )
                {
                    return false;
                }
                if ( dataObject.name_ != name_ )
                {
                    return false;
                }
                if ( dataObject.code_ != code_ )
                {
                    return false;
                }
                if ( dataObject.alpha2_ != alpha2_ )
                {
                    return false;
                }
                if ( dataObject.alpha3_ != alpha3_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        Int64 RowVersion( ) const
        {
            return rowVersion_;
        }
        void SetRowVersion( const Int64& rowVersion )
        {
            rowVersion_ = rowVersion;
        }
        const FixedDBWideString<127>& Name( ) const
        {
            return name_;
        }
        void SetName( const FixedDBWideString<127>& name )
        {
            name_ = name;
        }
        Int32 Code( ) const
        {
            return code_;
        }
        void SetCode( Int32 code )
        {
            code_ = code;
        }
        const FixedDBWideString<2>& Alpha2( ) const
        {
            return alpha2_;
        }
        void SetAlpha2( const FixedDBWideString<2>& alpha2 )
        {
            alpha2_ = alpha2;
        }
        const FixedDBWideString<3>& Alpha3( ) const
        {
            return alpha3_;
        }
        void SetAlpha3( const FixedDBWideString<3>& alpha3 )
        {
            alpha3_ = alpha3;
        }
    };
    class CursorInfoObject : public BaseData<Kind, Guid>
    {
    public:
        using Base = BaseData<Kind, Guid>;
        static constexpr Kind KIND = Kind::CursorInfo;
    private:
        Int64 rowVersion_ = 0;
        Int32 typeCode_ = 0;
    public:
        CursorInfoObject( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(rowVersion_);
            destination.Write(typeCode_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(rowVersion_);
            source.Read(typeCode_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<CursorInfoObject>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<CursorInfoObject&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const CursorInfoObject& >( other );
                if ( dataObject.rowVersion_ != rowVersion_ )
                {
                    return false;
                }
                if ( dataObject.typeCode_ != typeCode_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        Int64 RowVersion( ) const
        {
            return rowVersion_;
        }
        void SetRowVersion( const Int64& rowVersion )
        {
            rowVersion_ = rowVersion;
        }
        Int32 TypeCode( ) const
        {
            return typeCode_;
        }
        void SetTypeCode( Int32 typeCode )
        {
            typeCode_ = typeCode;
        }
    };
    class DateTimeTimeseriesValueObject : public BaseData<Kind, Guid>
    {
    public:
        using Base = BaseData<Kind, Guid>;
        static constexpr Kind KIND = Kind::DateTimeTimeseriesValue;
    private:
        Int64 rowVersion_ = 0;
        Guid timeseries_;
        DateTime timestamp_;
        DBDateTime value_;
    public:
        DateTimeTimeseriesValueObject( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(rowVersion_);
            destination.Write(timeseries_);
            destination.Write(timestamp_);
            value_.WriteTo( destination );
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(rowVersion_);
            source.Read(timeseries_);
            source.Read(timestamp_);
            value_.ReadFrom( source );
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<DateTimeTimeseriesValueObject>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<DateTimeTimeseriesValueObject&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const DateTimeTimeseriesValueObject& >( other );
                if ( dataObject.rowVersion_ != rowVersion_ )
                {
                    return false;
                }
                if ( dataObject.timeseries_ != timeseries_ )
                {
                    return false;
                }
                if ( dataObject.timestamp_ != timestamp_ )
                {
                    return false;
                }
                if ( dataObject.value_ != value_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        Int64 RowVersion( ) const
        {
            return rowVersion_;
        }
        void SetRowVersion( const Int64& rowVersion )
        {
            rowVersion_ = rowVersion;
        }
        const Guid& Timeseries( ) const
        {
            return timeseries_;
        }
        void SetTimeseries( const Guid& timeseries )
        {
            timeseries_ = timeseries;
        }
        const DateTime& Timestamp( ) const
        {
            return timestamp_;
        }
        void SetTimestamp( const DateTime& timestamp )
        {
            timestamp_ = timestamp;
        }
        const DBDateTime& Value( ) const
        {
            return value_;
        }
        void SetValue( const DBDateTime& value )
        {
            value_ = value;
        }
    };
    class DeviceHostObject : public BaseData<Kind, Guid>
    {
    public:
        using Base = BaseData<Kind, Guid>;
        static constexpr Kind KIND = Kind::DeviceHost;
    private:
        Int64 rowVersion_ = 0;
        FixedDBWideString<127> name_;
    public:
        DeviceHostObject( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(rowVersion_);
            name_.WriteTo( destination );
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(rowVersion_);
            name_.ReadFrom( source );
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<DeviceHostObject>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<DeviceHostObject&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const DeviceHostObject& >( other );
                if ( dataObject.rowVersion_ != rowVersion_ )
                {
                    return false;
                }
                if ( dataObject.name_ != name_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        Int64 RowVersion( ) const
        {
            return rowVersion_;
        }
        void SetRowVersion( const Int64& rowVersion )
        {
            rowVersion_ = rowVersion;
        }
        const FixedDBWideString<127>& Name( ) const
        {
            return name_;
        }
        void SetName( const FixedDBWideString<127>& name )
        {
            name_ = name;
        }
    };
    class DeviceHostConfigurationObject : public BaseData<Kind, Guid>
    {
    public:
        using Base = BaseData<Kind, Guid>;
        static constexpr Kind KIND = Kind::DeviceHostConfiguration;
    private:
        Int64 rowVersion_ = 0;
        Guid host_;
        DateTime timestamp_;
        FixedDBWideString<127> hostname_;
        Int32 port_ = 0;
        FixedDBWideString<127> queueName_;
    public:
        DeviceHostConfigurationObject( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(rowVersion_);
            destination.Write(host_);
            destination.Write(timestamp_);
            hostname_.WriteTo( destination );
            destination.Write(port_);
            queueName_.WriteTo( destination );
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(rowVersion_);
            source.Read(host_);
            source.Read(timestamp_);
            hostname_.ReadFrom( source );
            source.Read(port_);
            queueName_.ReadFrom( source );
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<DeviceHostConfigurationObject>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<DeviceHostConfigurationObject&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const DeviceHostConfigurationObject& >( other );
                if ( dataObject.rowVersion_ != rowVersion_ )
                {
                    return false;
                }
                if ( dataObject.host_ != host_ )
                {
                    return false;
                }
                if ( dataObject.timestamp_ != timestamp_ )
                {
                    return false;
                }
                if ( dataObject.hostname_ != hostname_ )
                {
                    return false;
                }
                if ( dataObject.port_ != port_ )
                {
                    return false;
                }
                if ( dataObject.queueName_ != queueName_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        Int64 RowVersion( ) const
        {
            return rowVersion_;
        }
        void SetRowVersion( const Int64& rowVersion )
        {
            rowVersion_ = rowVersion;
        }
        const Guid& Host( ) const
        {
            return host_;
        }
        void SetHost( const Guid& host )
        {
            host_ = host;
        }
        const DateTime& Timestamp( ) const
        {
            return timestamp_;
        }
        void SetTimestamp( const DateTime& timestamp )
        {
            timestamp_ = timestamp;
        }
        const FixedDBWideString<127>& Hostname( ) const
        {
            return hostname_;
        }
        void SetHostname( const FixedDBWideString<127>& hostname )
        {
            hostname_ = hostname;
        }
        Int32 Port( ) const
        {
            return port_;
        }
        void SetPort( Int32 port )
        {
            port_ = port;
        }
        const FixedDBWideString<127>& QueueName( ) const
        {
            return queueName_;
        }
        void SetQueueName( const FixedDBWideString<127>& queueName )
        {
            queueName_ = queueName;
        }
    };
    class DoubleTimeseriesValueObject : public BaseData<Kind, Guid>
    {
    public:
        using Base = BaseData<Kind, Guid>;
        static constexpr Kind KIND = Kind::DoubleTimeseriesValue;
    private:
        Int64 rowVersion_ = 0;
        Guid timeseries_;
        DateTime timestamp_;
        DBDouble value_;
    public:
        DoubleTimeseriesValueObject( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(rowVersion_);
            destination.Write(timeseries_);
            destination.Write(timestamp_);
            value_.WriteTo( destination );
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(rowVersion_);
            source.Read(timeseries_);
            source.Read(timestamp_);
            value_.ReadFrom( source );
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<DoubleTimeseriesValueObject>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<DoubleTimeseriesValueObject&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const DoubleTimeseriesValueObject& >( other );
                if ( dataObject.rowVersion_ != rowVersion_ )
                {
                    return false;
                }
                if ( dataObject.timeseries_ != timeseries_ )
                {
                    return false;
                }
                if ( dataObject.timestamp_ != timestamp_ )
                {
                    return false;
                }
                if ( dataObject.value_ != value_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        Int64 RowVersion( ) const
        {
            return rowVersion_;
        }
        void SetRowVersion( const Int64& rowVersion )
        {
            rowVersion_ = rowVersion;
        }
        const Guid& Timeseries( ) const
        {
            return timeseries_;
        }
        void SetTimeseries( const Guid& timeseries )
        {
            timeseries_ = timeseries;
        }
        const DateTime& Timestamp( ) const
        {
            return timestamp_;
        }
        void SetTimestamp( const DateTime& timestamp )
        {
            timestamp_ = timestamp;
        }
        const DBDouble& Value( ) const
        {
            return value_;
        }
        void SetValue( const DBDouble& value )
        {
            value_ = value;
        }
    };
    class FacilityTypeObject : public BaseData<Kind, Guid>
    {
    public:
        using Base = BaseData<Kind, Guid>;
        static constexpr Kind KIND = Kind::FacilityType;
    private:
        Int64 rowVersion_ = 0;
        FixedDBWideString<127> name_;
    public:
        FacilityTypeObject( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(rowVersion_);
            name_.WriteTo( destination );
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(rowVersion_);
            name_.ReadFrom( source );
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<FacilityTypeObject>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<FacilityTypeObject&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const FacilityTypeObject& >( other );
                if ( dataObject.rowVersion_ != rowVersion_ )
                {
                    return false;
                }
                if ( dataObject.name_ != name_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        Int64 RowVersion( ) const
        {
            return rowVersion_;
        }
        void SetRowVersion( const Int64& rowVersion )
        {
            rowVersion_ = rowVersion;
        }
        const FixedDBWideString<127>& Name( ) const
        {
            return name_;
        }
        void SetName( const FixedDBWideString<127>& name )
        {
            name_ = name;
        }
    };
    class GeoPosition2DTimeseriesValueObject : public BaseData<Kind, Guid>
    {
    public:
        using Base = BaseData<Kind, Guid>;
        static constexpr Kind KIND = Kind::GeoPosition2DTimeseriesValue;
    private:
        Int64 rowVersion_ = 0;
        Guid timeseries_;
        DateTime timestamp_;
        DBDouble latitude_;
        DBDouble longitude_;
    public:
        GeoPosition2DTimeseriesValueObject( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(rowVersion_);
            destination.Write(timeseries_);
            destination.Write(timestamp_);
            latitude_.WriteTo( destination );
            longitude_.WriteTo( destination );
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(rowVersion_);
            source.Read(timeseries_);
            source.Read(timestamp_);
            latitude_.ReadFrom( source );
            longitude_.ReadFrom( source );
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<GeoPosition2DTimeseriesValueObject>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<GeoPosition2DTimeseriesValueObject&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const GeoPosition2DTimeseriesValueObject& >( other );
                if ( dataObject.rowVersion_ != rowVersion_ )
                {
                    return false;
                }
                if ( dataObject.timeseries_ != timeseries_ )
                {
                    return false;
                }
                if ( dataObject.timestamp_ != timestamp_ )
                {
                    return false;
                }
                if ( dataObject.latitude_ != latitude_ )
                {
                    return false;
                }
                if ( dataObject.longitude_ != longitude_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        Int64 RowVersion( ) const
        {
            return rowVersion_;
        }
        void SetRowVersion( const Int64& rowVersion )
        {
            rowVersion_ = rowVersion;
        }
        const Guid& Timeseries( ) const
        {
            return timeseries_;
        }
        void SetTimeseries( const Guid& timeseries )
        {
            timeseries_ = timeseries;
        }
        const DateTime& Timestamp( ) const
        {
            return timestamp_;
        }
        void SetTimestamp( const DateTime& timestamp )
        {
            timestamp_ = timestamp;
        }
        const DBDouble& Latitude( ) const
        {
            return latitude_;
        }
        void SetLatitude( const DBDouble& latitude )
        {
            latitude_ = latitude;
        }
        const DBDouble& Longitude( ) const
        {
            return longitude_;
        }
        void SetLongitude( const DBDouble& longitude )
        {
            longitude_ = longitude;
        }
    };
    class GeoPosition3DTimeseriesValueObject : public BaseData<Kind, Guid>
    {
    public:
        using Base = BaseData<Kind, Guid>;
        static constexpr Kind KIND = Kind::GeoPosition3DTimeseriesValue;
    private:
        Int64 rowVersion_ = 0;
        Guid timeseries_;
        DateTime timestamp_;
        DBDouble latitude_;
        DBDouble longitude_;
        DBDouble altitude_;
    public:
        GeoPosition3DTimeseriesValueObject( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(rowVersion_);
            destination.Write(timeseries_);
            destination.Write(timestamp_);
            latitude_.WriteTo( destination );
            longitude_.WriteTo( destination );
            altitude_.WriteTo( destination );
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(rowVersion_);
            source.Read(timeseries_);
            source.Read(timestamp_);
            latitude_.ReadFrom( source );
            longitude_.ReadFrom( source );
            altitude_.ReadFrom( source );
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<GeoPosition3DTimeseriesValueObject>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<GeoPosition3DTimeseriesValueObject&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const GeoPosition3DTimeseriesValueObject& >( other );
                if ( dataObject.rowVersion_ != rowVersion_ )
                {
                    return false;
                }
                if ( dataObject.timeseries_ != timeseries_ )
                {
                    return false;
                }
                if ( dataObject.timestamp_ != timestamp_ )
                {
                    return false;
                }
                if ( dataObject.latitude_ != latitude_ )
                {
                    return false;
                }
                if ( dataObject.longitude_ != longitude_ )
                {
                    return false;
                }
                if ( dataObject.altitude_ != altitude_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        Int64 RowVersion( ) const
        {
            return rowVersion_;
        }
        void SetRowVersion( const Int64& rowVersion )
        {
            rowVersion_ = rowVersion;
        }
        const Guid& Timeseries( ) const
        {
            return timeseries_;
        }
        void SetTimeseries( const Guid& timeseries )
        {
            timeseries_ = timeseries;
        }
        const DateTime& Timestamp( ) const
        {
            return timestamp_;
        }
        void SetTimestamp( const DateTime& timestamp )
        {
            timestamp_ = timestamp;
        }
        const DBDouble& Latitude( ) const
        {
            return latitude_;
        }
        void SetLatitude( const DBDouble& latitude )
        {
            latitude_ = latitude;
        }
        const DBDouble& Longitude( ) const
        {
            return longitude_;
        }
        void SetLongitude( const DBDouble& longitude )
        {
            longitude_ = longitude;
        }
        const DBDouble& Altitude( ) const
        {
            return altitude_;
        }
        void SetAltitude( const DBDouble& altitude )
        {
            altitude_ = altitude;
        }
    };
    class GNSSDeviceCommandObject : public BaseData<Kind, Guid>
    {
    public:
        using Base = BaseData<Kind, Guid>;
        static constexpr Kind KIND = Kind::GNSSDeviceCommand;
    private:
        Int64 rowVersion_ = 0;
        Guid gNSSDevice_;
        DateTime timestamp_;
        Types::DeviceCommandSourceType deviceCommandSourceType_ = Types::DeviceCommandSourceType::Unknown;
        Guid deviceCommandSourceId_;
        Guid reply_;
    public:
        GNSSDeviceCommandObject( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(rowVersion_);
            destination.Write(gNSSDevice_);
            destination.Write(timestamp_);
            destination.Write(deviceCommandSourceType_);
            destination.Write(deviceCommandSourceId_);
            destination.Write(reply_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(rowVersion_);
            source.Read(gNSSDevice_);
            source.Read(timestamp_);
            source.Read(deviceCommandSourceType_);
            source.Read(deviceCommandSourceId_);
            source.Read(reply_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<GNSSDeviceCommandObject>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<GNSSDeviceCommandObject&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const GNSSDeviceCommandObject& >( other );
                if ( dataObject.rowVersion_ != rowVersion_ )
                {
                    return false;
                }
                if ( dataObject.gNSSDevice_ != gNSSDevice_ )
                {
                    return false;
                }
                if ( dataObject.timestamp_ != timestamp_ )
                {
                    return false;
                }
                if ( dataObject.deviceCommandSourceType_ != deviceCommandSourceType_ )
                {
                    return false;
                }
                if ( dataObject.deviceCommandSourceId_ != deviceCommandSourceId_ )
                {
                    return false;
                }
                if ( dataObject.reply_ != reply_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        Int64 RowVersion( ) const
        {
            return rowVersion_;
        }
        void SetRowVersion( const Int64& rowVersion )
        {
            rowVersion_ = rowVersion;
        }
        const Guid& GNSSDevice( ) const
        {
            return gNSSDevice_;
        }
        void SetGNSSDevice( const Guid& gNSSDevice )
        {
            gNSSDevice_ = gNSSDevice;
        }
        const DateTime& Timestamp( ) const
        {
            return timestamp_;
        }
        void SetTimestamp( const DateTime& timestamp )
        {
            timestamp_ = timestamp;
        }
        Types::DeviceCommandSourceType DeviceCommandSourceType( ) const
        {
            return deviceCommandSourceType_;
        }
        void SetDeviceCommandSourceType( Types::DeviceCommandSourceType deviceCommandSourceType )
        {
            deviceCommandSourceType_ = deviceCommandSourceType;
        }
        const Guid& DeviceCommandSourceId( ) const
        {
            return deviceCommandSourceId_;
        }
        void SetDeviceCommandSourceId( const Guid& deviceCommandSourceId )
        {
            deviceCommandSourceId_ = deviceCommandSourceId;
        }
        const Guid& Reply( ) const
        {
            return reply_;
        }
        void SetReply( const Guid& reply )
        {
            reply_ = reply;
        }
    };
    class GNSSDeviceCommandReplyObject : public BaseData<Kind, Guid>
    {
    public:
        using Base = BaseData<Kind, Guid>;
        static constexpr Kind KIND = Kind::GNSSDeviceCommandReply;
    private:
        Int64 rowVersion_ = 0;
        Guid gNSSDevice_;
        DateTime timestamp_;
        Guid command_;
        Types::DeviceCommandReplyStatus status_ = Types::DeviceCommandReplyStatus::Unknown;
        WideString message_;
        SQLLEN messageLength_ = SQL_NULL_DATA;
    public:
        GNSSDeviceCommandReplyObject( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(rowVersion_);
            destination.Write(gNSSDevice_);
            destination.Write(timestamp_);
            destination.Write(command_);
            destination.Write(status_);
            destination.Write(message_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(rowVersion_);
            source.Read(gNSSDevice_);
            source.Read(timestamp_);
            source.Read(command_);
            source.Read(status_);
            source.Read(message_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<GNSSDeviceCommandReplyObject>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<GNSSDeviceCommandReplyObject&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const GNSSDeviceCommandReplyObject& >( other );
                if ( dataObject.rowVersion_ != rowVersion_ )
                {
                    return false;
                }
                if ( dataObject.gNSSDevice_ != gNSSDevice_ )
                {
                    return false;
                }
                if ( dataObject.timestamp_ != timestamp_ )
                {
                    return false;
                }
                if ( dataObject.command_ != command_ )
                {
                    return false;
                }
                if ( dataObject.status_ != status_ )
                {
                    return false;
                }
                if ( dataObject.message_ != message_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        Int64 RowVersion( ) const
        {
            return rowVersion_;
        }
        void SetRowVersion( const Int64& rowVersion )
        {
            rowVersion_ = rowVersion;
        }
        const Guid& GNSSDevice( ) const
        {
            return gNSSDevice_;
        }
        void SetGNSSDevice( const Guid& gNSSDevice )
        {
            gNSSDevice_ = gNSSDevice;
        }
        const DateTime& Timestamp( ) const
        {
            return timestamp_;
        }
        void SetTimestamp( const DateTime& timestamp )
        {
            timestamp_ = timestamp;
        }
        const Guid& Command( ) const
        {
            return command_;
        }
        void SetCommand( const Guid& command )
        {
            command_ = command;
        }
        Types::DeviceCommandReplyStatus Status( ) const
        {
            return status_;
        }
        void SetStatus( Types::DeviceCommandReplyStatus status )
        {
            status_ = status;
        }
        const WideString& Message( ) const
        {
            return message_;
        }
        void SetMessage( const WideString& message )
        {
            message_ = message;
        }
    };
    class GNSSDeviceConfigurationObject : public BaseData<Kind, Guid>
    {
    public:
        using Base = BaseData<Kind, Guid>;
        static constexpr Kind KIND = Kind::GNSSDeviceConfiguration;
    private:
        Int64 rowVersion_ = 0;
        Guid gNSSDevice_;
        DateTime timestamp_;
        double defaultLatitude_ = 0.0;
        double defaultLongitude_ = 0.0;
        double defaultAltitude_ = 0.0;
        double latitudeOffset_ = 0.0;
        double longitudeOffset_ = 0.0;
        double altitudeOffset_ = 0.0;
    public:
        GNSSDeviceConfigurationObject( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(rowVersion_);
            destination.Write(gNSSDevice_);
            destination.Write(timestamp_);
            destination.Write(defaultLatitude_);
            destination.Write(defaultLongitude_);
            destination.Write(defaultAltitude_);
            destination.Write(latitudeOffset_);
            destination.Write(longitudeOffset_);
            destination.Write(altitudeOffset_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(rowVersion_);
            source.Read(gNSSDevice_);
            source.Read(timestamp_);
            source.Read(defaultLatitude_);
            source.Read(defaultLongitude_);
            source.Read(defaultAltitude_);
            source.Read(latitudeOffset_);
            source.Read(longitudeOffset_);
            source.Read(altitudeOffset_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<GNSSDeviceConfigurationObject>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<GNSSDeviceConfigurationObject&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const GNSSDeviceConfigurationObject& >( other );
                if ( dataObject.rowVersion_ != rowVersion_ )
                {
                    return false;
                }
                if ( dataObject.gNSSDevice_ != gNSSDevice_ )
                {
                    return false;
                }
                if ( dataObject.timestamp_ != timestamp_ )
                {
                    return false;
                }
                if ( dataObject.defaultLatitude_ != defaultLatitude_ )
                {
                    return false;
                }
                if ( dataObject.defaultLongitude_ != defaultLongitude_ )
                {
                    return false;
                }
                if ( dataObject.defaultAltitude_ != defaultAltitude_ )
                {
                    return false;
                }
                if ( dataObject.latitudeOffset_ != latitudeOffset_ )
                {
                    return false;
                }
                if ( dataObject.longitudeOffset_ != longitudeOffset_ )
                {
                    return false;
                }
                if ( dataObject.altitudeOffset_ != altitudeOffset_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        Int64 RowVersion( ) const
        {
            return rowVersion_;
        }
        void SetRowVersion( const Int64& rowVersion )
        {
            rowVersion_ = rowVersion;
        }
        const Guid& GNSSDevice( ) const
        {
            return gNSSDevice_;
        }
        void SetGNSSDevice( const Guid& gNSSDevice )
        {
            gNSSDevice_ = gNSSDevice;
        }
        const DateTime& Timestamp( ) const
        {
            return timestamp_;
        }
        void SetTimestamp( const DateTime& timestamp )
        {
            timestamp_ = timestamp;
        }
        double DefaultLatitude( ) const
        {
            return defaultLatitude_;
        }
        void SetDefaultLatitude( double defaultLatitude )
        {
            defaultLatitude_ = defaultLatitude;
        }
        double DefaultLongitude( ) const
        {
            return defaultLongitude_;
        }
        void SetDefaultLongitude( double defaultLongitude )
        {
            defaultLongitude_ = defaultLongitude;
        }
        double DefaultAltitude( ) const
        {
            return defaultAltitude_;
        }
        void SetDefaultAltitude( double defaultAltitude )
        {
            defaultAltitude_ = defaultAltitude;
        }
        double LatitudeOffset( ) const
        {
            return latitudeOffset_;
        }
        void SetLatitudeOffset( double latitudeOffset )
        {
            latitudeOffset_ = latitudeOffset;
        }
        double LongitudeOffset( ) const
        {
            return longitudeOffset_;
        }
        void SetLongitudeOffset( double longitudeOffset )
        {
            longitudeOffset_ = longitudeOffset;
        }
        double AltitudeOffset( ) const
        {
            return altitudeOffset_;
        }
        void SetAltitudeOffset( double altitudeOffset )
        {
            altitudeOffset_ = altitudeOffset;
        }
    };
    class GuidTimeseriesValueObject : public BaseData<Kind, Guid>
    {
    public:
        using Base = BaseData<Kind, Guid>;
        static constexpr Kind KIND = Kind::GuidTimeseriesValue;
    private:
        Int64 rowVersion_ = 0;
        Guid timeseries_;
        DateTime timestamp_;
        DBGuid value_;
    public:
        GuidTimeseriesValueObject( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(rowVersion_);
            destination.Write(timeseries_);
            destination.Write(timestamp_);
            value_.WriteTo( destination );
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(rowVersion_);
            source.Read(timeseries_);
            source.Read(timestamp_);
            value_.ReadFrom( source );
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<GuidTimeseriesValueObject>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<GuidTimeseriesValueObject&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const GuidTimeseriesValueObject& >( other );
                if ( dataObject.rowVersion_ != rowVersion_ )
                {
                    return false;
                }
                if ( dataObject.timeseries_ != timeseries_ )
                {
                    return false;
                }
                if ( dataObject.timestamp_ != timestamp_ )
                {
                    return false;
                }
                if ( dataObject.value_ != value_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        Int64 RowVersion( ) const
        {
            return rowVersion_;
        }
        void SetRowVersion( const Int64& rowVersion )
        {
            rowVersion_ = rowVersion;
        }
        const Guid& Timeseries( ) const
        {
            return timeseries_;
        }
        void SetTimeseries( const Guid& timeseries )
        {
            timeseries_ = timeseries;
        }
        const DateTime& Timestamp( ) const
        {
            return timestamp_;
        }
        void SetTimestamp( const DateTime& timestamp )
        {
            timestamp_ = timestamp;
        }
        const DBGuid& Value( ) const
        {
            return value_;
        }
        void SetValue( const DBGuid& value )
        {
            value_ = value;
        }
    };
    class GyroDeviceCommandObject : public BaseData<Kind, Guid>
    {
    public:
        using Base = BaseData<Kind, Guid>;
        static constexpr Kind KIND = Kind::GyroDeviceCommand;
    private:
        Int64 rowVersion_ = 0;
        Guid gyroDevice_;
        DateTime timestamp_;
        Types::DeviceCommandSourceType deviceCommandSourceType_ = Types::DeviceCommandSourceType::Unknown;
        Guid deviceCommandSourceId_;
        Guid reply_;
    public:
        GyroDeviceCommandObject( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(rowVersion_);
            destination.Write(gyroDevice_);
            destination.Write(timestamp_);
            destination.Write(deviceCommandSourceType_);
            destination.Write(deviceCommandSourceId_);
            destination.Write(reply_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(rowVersion_);
            source.Read(gyroDevice_);
            source.Read(timestamp_);
            source.Read(deviceCommandSourceType_);
            source.Read(deviceCommandSourceId_);
            source.Read(reply_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<GyroDeviceCommandObject>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<GyroDeviceCommandObject&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const GyroDeviceCommandObject& >( other );
                if ( dataObject.rowVersion_ != rowVersion_ )
                {
                    return false;
                }
                if ( dataObject.gyroDevice_ != gyroDevice_ )
                {
                    return false;
                }
                if ( dataObject.timestamp_ != timestamp_ )
                {
                    return false;
                }
                if ( dataObject.deviceCommandSourceType_ != deviceCommandSourceType_ )
                {
                    return false;
                }
                if ( dataObject.deviceCommandSourceId_ != deviceCommandSourceId_ )
                {
                    return false;
                }
                if ( dataObject.reply_ != reply_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        Int64 RowVersion( ) const
        {
            return rowVersion_;
        }
        void SetRowVersion( const Int64& rowVersion )
        {
            rowVersion_ = rowVersion;
        }
        const Guid& GyroDevice( ) const
        {
            return gyroDevice_;
        }
        void SetGyroDevice( const Guid& gyroDevice )
        {
            gyroDevice_ = gyroDevice;
        }
        const DateTime& Timestamp( ) const
        {
            return timestamp_;
        }
        void SetTimestamp( const DateTime& timestamp )
        {
            timestamp_ = timestamp;
        }
        Types::DeviceCommandSourceType DeviceCommandSourceType( ) const
        {
            return deviceCommandSourceType_;
        }
        void SetDeviceCommandSourceType( Types::DeviceCommandSourceType deviceCommandSourceType )
        {
            deviceCommandSourceType_ = deviceCommandSourceType;
        }
        const Guid& DeviceCommandSourceId( ) const
        {
            return deviceCommandSourceId_;
        }
        void SetDeviceCommandSourceId( const Guid& deviceCommandSourceId )
        {
            deviceCommandSourceId_ = deviceCommandSourceId;
        }
        const Guid& Reply( ) const
        {
            return reply_;
        }
        void SetReply( const Guid& reply )
        {
            reply_ = reply;
        }
    };
    class GyroDeviceCommandReplyObject : public BaseData<Kind, Guid>
    {
    public:
        using Base = BaseData<Kind, Guid>;
        static constexpr Kind KIND = Kind::GyroDeviceCommandReply;
    private:
        Int64 rowVersion_ = 0;
        Guid gyroDevice_;
        DateTime timestamp_;
        Guid command_;
        Types::DeviceCommandReplyStatus status_ = Types::DeviceCommandReplyStatus::Unknown;
        WideString message_;
        SQLLEN messageLength_ = SQL_NULL_DATA;
    public:
        GyroDeviceCommandReplyObject( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(rowVersion_);
            destination.Write(gyroDevice_);
            destination.Write(timestamp_);
            destination.Write(command_);
            destination.Write(status_);
            destination.Write(message_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(rowVersion_);
            source.Read(gyroDevice_);
            source.Read(timestamp_);
            source.Read(command_);
            source.Read(status_);
            source.Read(message_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<GyroDeviceCommandReplyObject>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<GyroDeviceCommandReplyObject&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const GyroDeviceCommandReplyObject& >( other );
                if ( dataObject.rowVersion_ != rowVersion_ )
                {
                    return false;
                }
                if ( dataObject.gyroDevice_ != gyroDevice_ )
                {
                    return false;
                }
                if ( dataObject.timestamp_ != timestamp_ )
                {
                    return false;
                }
                if ( dataObject.command_ != command_ )
                {
                    return false;
                }
                if ( dataObject.status_ != status_ )
                {
                    return false;
                }
                if ( dataObject.message_ != message_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        Int64 RowVersion( ) const
        {
            return rowVersion_;
        }
        void SetRowVersion( const Int64& rowVersion )
        {
            rowVersion_ = rowVersion;
        }
        const Guid& GyroDevice( ) const
        {
            return gyroDevice_;
        }
        void SetGyroDevice( const Guid& gyroDevice )
        {
            gyroDevice_ = gyroDevice;
        }
        const DateTime& Timestamp( ) const
        {
            return timestamp_;
        }
        void SetTimestamp( const DateTime& timestamp )
        {
            timestamp_ = timestamp;
        }
        const Guid& Command( ) const
        {
            return command_;
        }
        void SetCommand( const Guid& command )
        {
            command_ = command;
        }
        Types::DeviceCommandReplyStatus Status( ) const
        {
            return status_;
        }
        void SetStatus( Types::DeviceCommandReplyStatus status )
        {
            status_ = status;
        }
        const WideString& Message( ) const
        {
            return message_;
        }
        void SetMessage( const WideString& message )
        {
            message_ = message;
        }
    };
    class GyroDeviceConfigurationObject : public BaseData<Kind, Guid>
    {
    public:
        using Base = BaseData<Kind, Guid>;
        static constexpr Kind KIND = Kind::GyroDeviceConfiguration;
    private:
        Int64 rowVersion_ = 0;
        Guid gyroDevice_;
        DateTime timestamp_;
        double defaultHeadingTrueNorth_ = 0.0;
        double defaultMagneticTrueNorth_ = 0.0;
        double headingTrueNorthOffset_ = 0.0;
        double headingMagneticNorthOffset_ = 0.0;
        FixedDBWideString<64> pitchTransducerName_;
        FixedDBWideString<64> rollTransducerName_;
    public:
        GyroDeviceConfigurationObject( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(rowVersion_);
            destination.Write(gyroDevice_);
            destination.Write(timestamp_);
            destination.Write(defaultHeadingTrueNorth_);
            destination.Write(defaultMagneticTrueNorth_);
            destination.Write(headingTrueNorthOffset_);
            destination.Write(headingMagneticNorthOffset_);
            pitchTransducerName_.WriteTo( destination );
            rollTransducerName_.WriteTo( destination );
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(rowVersion_);
            source.Read(gyroDevice_);
            source.Read(timestamp_);
            source.Read(defaultHeadingTrueNorth_);
            source.Read(defaultMagneticTrueNorth_);
            source.Read(headingTrueNorthOffset_);
            source.Read(headingMagneticNorthOffset_);
            pitchTransducerName_.ReadFrom( source );
            rollTransducerName_.ReadFrom( source );
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<GyroDeviceConfigurationObject>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<GyroDeviceConfigurationObject&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const GyroDeviceConfigurationObject& >( other );
                if ( dataObject.rowVersion_ != rowVersion_ )
                {
                    return false;
                }
                if ( dataObject.gyroDevice_ != gyroDevice_ )
                {
                    return false;
                }
                if ( dataObject.timestamp_ != timestamp_ )
                {
                    return false;
                }
                if ( dataObject.defaultHeadingTrueNorth_ != defaultHeadingTrueNorth_ )
                {
                    return false;
                }
                if ( dataObject.defaultMagneticTrueNorth_ != defaultMagneticTrueNorth_ )
                {
                    return false;
                }
                if ( dataObject.headingTrueNorthOffset_ != headingTrueNorthOffset_ )
                {
                    return false;
                }
                if ( dataObject.headingMagneticNorthOffset_ != headingMagneticNorthOffset_ )
                {
                    return false;
                }
                if ( dataObject.pitchTransducerName_ != pitchTransducerName_ )
                {
                    return false;
                }
                if ( dataObject.rollTransducerName_ != rollTransducerName_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        Int64 RowVersion( ) const
        {
            return rowVersion_;
        }
        void SetRowVersion( const Int64& rowVersion )
        {
            rowVersion_ = rowVersion;
        }
        const Guid& GyroDevice( ) const
        {
            return gyroDevice_;
        }
        void SetGyroDevice( const Guid& gyroDevice )
        {
            gyroDevice_ = gyroDevice;
        }
        const DateTime& Timestamp( ) const
        {
            return timestamp_;
        }
        void SetTimestamp( const DateTime& timestamp )
        {
            timestamp_ = timestamp;
        }
        double DefaultHeadingTrueNorth( ) const
        {
            return defaultHeadingTrueNorth_;
        }
        void SetDefaultHeadingTrueNorth( double defaultHeadingTrueNorth )
        {
            defaultHeadingTrueNorth_ = defaultHeadingTrueNorth;
        }
        double DefaultMagneticTrueNorth( ) const
        {
            return defaultMagneticTrueNorth_;
        }
        void SetDefaultMagneticTrueNorth( double defaultMagneticTrueNorth )
        {
            defaultMagneticTrueNorth_ = defaultMagneticTrueNorth;
        }
        double HeadingTrueNorthOffset( ) const
        {
            return headingTrueNorthOffset_;
        }
        void SetHeadingTrueNorthOffset( double headingTrueNorthOffset )
        {
            headingTrueNorthOffset_ = headingTrueNorthOffset;
        }
        double HeadingMagneticNorthOffset( ) const
        {
            return headingMagneticNorthOffset_;
        }
        void SetHeadingMagneticNorthOffset( double headingMagneticNorthOffset )
        {
            headingMagneticNorthOffset_ = headingMagneticNorthOffset;
        }
        const FixedDBWideString<64>& PitchTransducerName( ) const
        {
            return pitchTransducerName_;
        }
        void SetPitchTransducerName( const FixedDBWideString<64>& pitchTransducerName )
        {
            pitchTransducerName_ = pitchTransducerName;
        }
        const FixedDBWideString<64>& RollTransducerName( ) const
        {
            return rollTransducerName_;
        }
        void SetRollTransducerName( const FixedDBWideString<64>& rollTransducerName )
        {
            rollTransducerName_ = rollTransducerName;
        }
    };
    class IdentityObject : public BaseData<Kind, Guid>
    {
    public:
        using Base = BaseData<Kind, Guid>;
        static constexpr Kind KIND = Kind::Identity;
    private:
        Int64 rowVersion_ = 0;
    public:
        IdentityObject( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(rowVersion_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(rowVersion_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<IdentityObject>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<IdentityObject&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const IdentityObject& >( other );
                if ( dataObject.rowVersion_ != rowVersion_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        Int64 RowVersion( ) const
        {
            return rowVersion_;
        }
        void SetRowVersion( const Int64& rowVersion )
        {
            rowVersion_ = rowVersion;
        }
    };
    class CallsignObject : public IdentityObject
    {
    public:
        using Base = IdentityObject;
        static constexpr Kind KIND = Kind::Callsign;
    private:
        FixedDBWideString<127> identifier_;
    public:
        CallsignObject( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            identifier_.WriteTo( destination );
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            identifier_.ReadFrom( source );
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<CallsignObject>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<CallsignObject&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const CallsignObject& >( other );
                if ( dataObject.identifier_ != identifier_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        const FixedDBWideString<127>& Identifier( ) const
        {
            return identifier_;
        }
        void SetIdentifier( const FixedDBWideString<127>& identifier )
        {
            identifier_ = identifier;
        }
    };
    class InternationalMaritimeOrganizationNumberObject : public IdentityObject
    {
    public:
        using Base = IdentityObject;
        static constexpr Kind KIND = Kind::InternationalMaritimeOrganizationNumber;
    private:
        Int64 identifier_ = 0;
    public:
        InternationalMaritimeOrganizationNumberObject( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(identifier_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(identifier_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<InternationalMaritimeOrganizationNumberObject>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<InternationalMaritimeOrganizationNumberObject&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const InternationalMaritimeOrganizationNumberObject& >( other );
                if ( dataObject.identifier_ != identifier_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        Int64 Identifier( ) const
        {
            return identifier_;
        }
        void SetIdentifier( Int64 identifier )
        {
            identifier_ = identifier;
        }
    };
    class MaritimeMobileServiceIdentityObject : public IdentityObject
    {
    public:
        using Base = IdentityObject;
        static constexpr Kind KIND = Kind::MaritimeMobileServiceIdentity;
    private:
        Int64 identifier_ = 0;
    public:
        MaritimeMobileServiceIdentityObject( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(identifier_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(identifier_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<MaritimeMobileServiceIdentityObject>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<MaritimeMobileServiceIdentityObject&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const MaritimeMobileServiceIdentityObject& >( other );
                if ( dataObject.identifier_ != identifier_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        Int64 Identifier( ) const
        {
            return identifier_;
        }
        void SetIdentifier( Int64 identifier )
        {
            identifier_ = identifier;
        }
    };
    class NameObject : public IdentityObject
    {
    public:
        using Base = IdentityObject;
        static constexpr Kind KIND = Kind::Name;
    private:
        FixedDBWideString<127> text_;
    public:
        NameObject( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            text_.WriteTo( destination );
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            text_.ReadFrom( source );
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<NameObject>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<NameObject&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const NameObject& >( other );
                if ( dataObject.text_ != text_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        const FixedDBWideString<127>& Text( ) const
        {
            return text_;
        }
        void SetText( const FixedDBWideString<127>& text )
        {
            text_ = text;
        }
    };
    class Int16TimeseriesValueObject : public BaseData<Kind, Guid>
    {
    public:
        using Base = BaseData<Kind, Guid>;
        static constexpr Kind KIND = Kind::Int16TimeseriesValue;
    private:
        Int64 rowVersion_ = 0;
        Guid timeseries_;
        DateTime timestamp_;
        DBInt16 value_;
    public:
        Int16TimeseriesValueObject( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(rowVersion_);
            destination.Write(timeseries_);
            destination.Write(timestamp_);
            value_.WriteTo( destination );
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(rowVersion_);
            source.Read(timeseries_);
            source.Read(timestamp_);
            value_.ReadFrom( source );
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<Int16TimeseriesValueObject>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<Int16TimeseriesValueObject&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const Int16TimeseriesValueObject& >( other );
                if ( dataObject.rowVersion_ != rowVersion_ )
                {
                    return false;
                }
                if ( dataObject.timeseries_ != timeseries_ )
                {
                    return false;
                }
                if ( dataObject.timestamp_ != timestamp_ )
                {
                    return false;
                }
                if ( dataObject.value_ != value_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        Int64 RowVersion( ) const
        {
            return rowVersion_;
        }
        void SetRowVersion( const Int64& rowVersion )
        {
            rowVersion_ = rowVersion;
        }
        const Guid& Timeseries( ) const
        {
            return timeseries_;
        }
        void SetTimeseries( const Guid& timeseries )
        {
            timeseries_ = timeseries;
        }
        const DateTime& Timestamp( ) const
        {
            return timestamp_;
        }
        void SetTimestamp( const DateTime& timestamp )
        {
            timestamp_ = timestamp;
        }
        const DBInt16& Value( ) const
        {
            return value_;
        }
        void SetValue( const DBInt16& value )
        {
            value_ = value;
        }
    };
    class Int32TimeseriesValueObject : public BaseData<Kind, Guid>
    {
    public:
        using Base = BaseData<Kind, Guid>;
        static constexpr Kind KIND = Kind::Int32TimeseriesValue;
    private:
        Int64 rowVersion_ = 0;
        Guid timeseries_;
        DateTime timestamp_;
        DBInt32 value_;
    public:
        Int32TimeseriesValueObject( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(rowVersion_);
            destination.Write(timeseries_);
            destination.Write(timestamp_);
            value_.WriteTo( destination );
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(rowVersion_);
            source.Read(timeseries_);
            source.Read(timestamp_);
            value_.ReadFrom( source );
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<Int32TimeseriesValueObject>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<Int32TimeseriesValueObject&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const Int32TimeseriesValueObject& >( other );
                if ( dataObject.rowVersion_ != rowVersion_ )
                {
                    return false;
                }
                if ( dataObject.timeseries_ != timeseries_ )
                {
                    return false;
                }
                if ( dataObject.timestamp_ != timestamp_ )
                {
                    return false;
                }
                if ( dataObject.value_ != value_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        Int64 RowVersion( ) const
        {
            return rowVersion_;
        }
        void SetRowVersion( const Int64& rowVersion )
        {
            rowVersion_ = rowVersion;
        }
        const Guid& Timeseries( ) const
        {
            return timeseries_;
        }
        void SetTimeseries( const Guid& timeseries )
        {
            timeseries_ = timeseries;
        }
        const DateTime& Timestamp( ) const
        {
            return timestamp_;
        }
        void SetTimestamp( const DateTime& timestamp )
        {
            timestamp_ = timestamp;
        }
        const DBInt32& Value( ) const
        {
            return value_;
        }
        void SetValue( const DBInt32& value )
        {
            value_ = value;
        }
    };
    class Int64TimeseriesValueObject : public BaseData<Kind, Guid>
    {
    public:
        using Base = BaseData<Kind, Guid>;
        static constexpr Kind KIND = Kind::Int64TimeseriesValue;
    private:
        Int64 rowVersion_ = 0;
        Guid timeseries_;
        DateTime timestamp_;
        DBInt64 value_;
    public:
        Int64TimeseriesValueObject( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(rowVersion_);
            destination.Write(timeseries_);
            destination.Write(timestamp_);
            value_.WriteTo( destination );
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(rowVersion_);
            source.Read(timeseries_);
            source.Read(timestamp_);
            value_.ReadFrom( source );
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<Int64TimeseriesValueObject>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<Int64TimeseriesValueObject&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const Int64TimeseriesValueObject& >( other );
                if ( dataObject.rowVersion_ != rowVersion_ )
                {
                    return false;
                }
                if ( dataObject.timeseries_ != timeseries_ )
                {
                    return false;
                }
                if ( dataObject.timestamp_ != timestamp_ )
                {
                    return false;
                }
                if ( dataObject.value_ != value_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        Int64 RowVersion( ) const
        {
            return rowVersion_;
        }
        void SetRowVersion( const Int64& rowVersion )
        {
            rowVersion_ = rowVersion;
        }
        const Guid& Timeseries( ) const
        {
            return timeseries_;
        }
        void SetTimeseries( const Guid& timeseries )
        {
            timeseries_ = timeseries;
        }
        const DateTime& Timestamp( ) const
        {
            return timestamp_;
        }
        void SetTimestamp( const DateTime& timestamp )
        {
            timestamp_ = timestamp;
        }
        const DBInt64& Value( ) const
        {
            return value_;
        }
        void SetValue( const DBInt64& value )
        {
            value_ = value;
        }
    };
    class ItemObject : public BaseData<Kind, Guid>
    {
    public:
        using Base = BaseData<Kind, Guid>;
        static constexpr Kind KIND = Kind::Item;
    private:
        Int64 rowVersion_ = 0;
    public:
        ItemObject( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(rowVersion_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(rowVersion_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<ItemObject>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<ItemObject&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const ItemObject& >( other );
                if ( dataObject.rowVersion_ != rowVersion_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        Int64 RowVersion( ) const
        {
            return rowVersion_;
        }
        void SetRowVersion( const Int64& rowVersion )
        {
            rowVersion_ = rowVersion;
        }
    };
    class BaseStationObject : public ItemObject
    {
    public:
        using Base = ItemObject;
        static constexpr Kind KIND = Kind::BaseStation;
    private:
        FixedDBWideString<127> name_;
        Guid type_;
    public:
        BaseStationObject( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            name_.WriteTo( destination );
            destination.Write(type_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            name_.ReadFrom( source );
            source.Read(type_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<BaseStationObject>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<BaseStationObject&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const BaseStationObject& >( other );
                if ( dataObject.name_ != name_ )
                {
                    return false;
                }
                if ( dataObject.type_ != type_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        const FixedDBWideString<127>& Name( ) const
        {
            return name_;
        }
        void SetName( const FixedDBWideString<127>& name )
        {
            name_ = name;
        }
        const Guid& Type( ) const
        {
            return type_;
        }
        void SetType( const Guid& type )
        {
            type_ = type;
        }
    };
    class DeviceObject : public ItemObject
    {
    public:
        using Base = ItemObject;
        static constexpr Kind KIND = Kind::Device;
    private:
        Guid host_;
        FixedDBWideString<127> name_;
        WideString description_;
        SQLLEN descriptionLength_ = SQL_NULL_DATA;
        Guid enabledTimeseries_;
    public:
        DeviceObject( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(host_);
            name_.WriteTo( destination );
            destination.Write(description_);
            destination.Write(enabledTimeseries_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(host_);
            name_.ReadFrom( source );
            source.Read(description_);
            source.Read(enabledTimeseries_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<DeviceObject>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<DeviceObject&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const DeviceObject& >( other );
                if ( dataObject.host_ != host_ )
                {
                    return false;
                }
                if ( dataObject.name_ != name_ )
                {
                    return false;
                }
                if ( dataObject.description_ != description_ )
                {
                    return false;
                }
                if ( dataObject.enabledTimeseries_ != enabledTimeseries_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        const Guid& Host( ) const
        {
            return host_;
        }
        void SetHost( const Guid& host )
        {
            host_ = host;
        }
        const FixedDBWideString<127>& Name( ) const
        {
            return name_;
        }
        void SetName( const FixedDBWideString<127>& name )
        {
            name_ = name;
        }
        const WideString& Description( ) const
        {
            return description_;
        }
        void SetDescription( const WideString& description )
        {
            description_ = description;
        }
        const Guid& EnabledTimeseries( ) const
        {
            return enabledTimeseries_;
        }
        void SetEnabledTimeseries( const Guid& enabledTimeseries )
        {
            enabledTimeseries_ = enabledTimeseries;
        }
    };
    class CameraDeviceObject : public DeviceObject
    {
    public:
        using Base = DeviceObject;
        static constexpr Kind KIND = Kind::CameraDevice;
    private:
    public:
        CameraDeviceObject( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<CameraDeviceObject>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<CameraDeviceObject&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const CameraDeviceObject& >( other );
                return true;
            }
            return false;
        }
    };
    class GNSSDeviceObject : public DeviceObject
    {
    public:
        using Base = DeviceObject;
        static constexpr Kind KIND = Kind::GNSSDevice;
    private:
        Guid latitudeTimeseries_;
        Guid longitudeTimeseries_;
        Guid altitudeTimeseries_;
    public:
        GNSSDeviceObject( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(latitudeTimeseries_);
            destination.Write(longitudeTimeseries_);
            destination.Write(altitudeTimeseries_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(latitudeTimeseries_);
            source.Read(longitudeTimeseries_);
            source.Read(altitudeTimeseries_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<GNSSDeviceObject>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<GNSSDeviceObject&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const GNSSDeviceObject& >( other );
                if ( dataObject.latitudeTimeseries_ != latitudeTimeseries_ )
                {
                    return false;
                }
                if ( dataObject.longitudeTimeseries_ != longitudeTimeseries_ )
                {
                    return false;
                }
                if ( dataObject.altitudeTimeseries_ != altitudeTimeseries_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        const Guid& LatitudeTimeseries( ) const
        {
            return latitudeTimeseries_;
        }
        void SetLatitudeTimeseries( const Guid& latitudeTimeseries )
        {
            latitudeTimeseries_ = latitudeTimeseries;
        }
        const Guid& LongitudeTimeseries( ) const
        {
            return longitudeTimeseries_;
        }
        void SetLongitudeTimeseries( const Guid& longitudeTimeseries )
        {
            longitudeTimeseries_ = longitudeTimeseries;
        }
        const Guid& AltitudeTimeseries( ) const
        {
            return altitudeTimeseries_;
        }
        void SetAltitudeTimeseries( const Guid& altitudeTimeseries )
        {
            altitudeTimeseries_ = altitudeTimeseries;
        }
    };
    class GyroDeviceObject : public DeviceObject
    {
    public:
        using Base = DeviceObject;
        static constexpr Kind KIND = Kind::GyroDevice;
    private:
        Guid headingTrueNorthTimeseries_;
        Guid headingMagneticNorthTimeseries_;
        Guid pitchTimeseries_;
        Guid rateOfTurnTimeseries_;
        Guid rollTimeseries_;
        Guid courseTimeseries_;
        Guid speedTimeseries_;
        Guid gNSSDevice_;
    public:
        GyroDeviceObject( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(headingTrueNorthTimeseries_);
            destination.Write(headingMagneticNorthTimeseries_);
            destination.Write(pitchTimeseries_);
            destination.Write(rateOfTurnTimeseries_);
            destination.Write(rollTimeseries_);
            destination.Write(courseTimeseries_);
            destination.Write(speedTimeseries_);
            destination.Write(gNSSDevice_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(headingTrueNorthTimeseries_);
            source.Read(headingMagneticNorthTimeseries_);
            source.Read(pitchTimeseries_);
            source.Read(rateOfTurnTimeseries_);
            source.Read(rollTimeseries_);
            source.Read(courseTimeseries_);
            source.Read(speedTimeseries_);
            source.Read(gNSSDevice_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<GyroDeviceObject>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<GyroDeviceObject&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const GyroDeviceObject& >( other );
                if ( dataObject.headingTrueNorthTimeseries_ != headingTrueNorthTimeseries_ )
                {
                    return false;
                }
                if ( dataObject.headingMagneticNorthTimeseries_ != headingMagneticNorthTimeseries_ )
                {
                    return false;
                }
                if ( dataObject.pitchTimeseries_ != pitchTimeseries_ )
                {
                    return false;
                }
                if ( dataObject.rateOfTurnTimeseries_ != rateOfTurnTimeseries_ )
                {
                    return false;
                }
                if ( dataObject.rollTimeseries_ != rollTimeseries_ )
                {
                    return false;
                }
                if ( dataObject.courseTimeseries_ != courseTimeseries_ )
                {
                    return false;
                }
                if ( dataObject.speedTimeseries_ != speedTimeseries_ )
                {
                    return false;
                }
                if ( dataObject.gNSSDevice_ != gNSSDevice_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        const Guid& HeadingTrueNorthTimeseries( ) const
        {
            return headingTrueNorthTimeseries_;
        }
        void SetHeadingTrueNorthTimeseries( const Guid& headingTrueNorthTimeseries )
        {
            headingTrueNorthTimeseries_ = headingTrueNorthTimeseries;
        }
        const Guid& HeadingMagneticNorthTimeseries( ) const
        {
            return headingMagneticNorthTimeseries_;
        }
        void SetHeadingMagneticNorthTimeseries( const Guid& headingMagneticNorthTimeseries )
        {
            headingMagneticNorthTimeseries_ = headingMagneticNorthTimeseries;
        }
        const Guid& PitchTimeseries( ) const
        {
            return pitchTimeseries_;
        }
        void SetPitchTimeseries( const Guid& pitchTimeseries )
        {
            pitchTimeseries_ = pitchTimeseries;
        }
        const Guid& RateOfTurnTimeseries( ) const
        {
            return rateOfTurnTimeseries_;
        }
        void SetRateOfTurnTimeseries( const Guid& rateOfTurnTimeseries )
        {
            rateOfTurnTimeseries_ = rateOfTurnTimeseries;
        }
        const Guid& RollTimeseries( ) const
        {
            return rollTimeseries_;
        }
        void SetRollTimeseries( const Guid& rollTimeseries )
        {
            rollTimeseries_ = rollTimeseries;
        }
        const Guid& CourseTimeseries( ) const
        {
            return courseTimeseries_;
        }
        void SetCourseTimeseries( const Guid& courseTimeseries )
        {
            courseTimeseries_ = courseTimeseries;
        }
        const Guid& SpeedTimeseries( ) const
        {
            return speedTimeseries_;
        }
        void SetSpeedTimeseries( const Guid& speedTimeseries )
        {
            speedTimeseries_ = speedTimeseries;
        }
        const Guid& GNSSDevice( ) const
        {
            return gNSSDevice_;
        }
        void SetGNSSDevice( const Guid& gNSSDevice )
        {
            gNSSDevice_ = gNSSDevice;
        }
    };
    class LineInputDeviceObject : public DeviceObject
    {
    public:
        using Base = DeviceObject;
        static constexpr Kind KIND = Kind::LineInputDevice;
    private:
    public:
        LineInputDeviceObject( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<LineInputDeviceObject>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<LineInputDeviceObject&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const LineInputDeviceObject& >( other );
                return true;
            }
            return false;
        }
    };
    class OilSpillDetectorDeviceObject : public DeviceObject
    {
    public:
        using Base = DeviceObject;
        static constexpr Kind KIND = Kind::OilSpillDetectorDevice;
    private:
    public:
        OilSpillDetectorDeviceObject( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<OilSpillDetectorDeviceObject>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<OilSpillDetectorDeviceObject&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const OilSpillDetectorDeviceObject& >( other );
                return true;
            }
            return false;
        }
    };
    class RadioDeviceObject : public DeviceObject
    {
    public:
        using Base = DeviceObject;
        static constexpr Kind KIND = Kind::RadioDevice;
    private:
    public:
        RadioDeviceObject( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<RadioDeviceObject>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<RadioDeviceObject&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const RadioDeviceObject& >( other );
                return true;
            }
            return false;
        }
    };
    class RadomeDeviceObject : public DeviceObject
    {
    public:
        using Base = DeviceObject;
        static constexpr Kind KIND = Kind::RadomeDevice;
    private:
        DBGuid radar_;
        Guid pressureTimeseries_;
        Guid temperatureTimeseries_;
        Guid dewPointTimeseries_;
        Guid statusTimeseries_;
    public:
        RadomeDeviceObject( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            radar_.WriteTo( destination );
            destination.Write(pressureTimeseries_);
            destination.Write(temperatureTimeseries_);
            destination.Write(dewPointTimeseries_);
            destination.Write(statusTimeseries_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            radar_.ReadFrom( source );
            source.Read(pressureTimeseries_);
            source.Read(temperatureTimeseries_);
            source.Read(dewPointTimeseries_);
            source.Read(statusTimeseries_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<RadomeDeviceObject>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<RadomeDeviceObject&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const RadomeDeviceObject& >( other );
                if ( dataObject.radar_ != radar_ )
                {
                    return false;
                }
                if ( dataObject.pressureTimeseries_ != pressureTimeseries_ )
                {
                    return false;
                }
                if ( dataObject.temperatureTimeseries_ != temperatureTimeseries_ )
                {
                    return false;
                }
                if ( dataObject.dewPointTimeseries_ != dewPointTimeseries_ )
                {
                    return false;
                }
                if ( dataObject.statusTimeseries_ != statusTimeseries_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        const DBGuid& Radar( ) const
        {
            return radar_;
        }
        void SetRadar( const DBGuid& radar )
        {
            radar_ = radar;
        }
        const Guid& PressureTimeseries( ) const
        {
            return pressureTimeseries_;
        }
        void SetPressureTimeseries( const Guid& pressureTimeseries )
        {
            pressureTimeseries_ = pressureTimeseries;
        }
        const Guid& TemperatureTimeseries( ) const
        {
            return temperatureTimeseries_;
        }
        void SetTemperatureTimeseries( const Guid& temperatureTimeseries )
        {
            temperatureTimeseries_ = temperatureTimeseries;
        }
        const Guid& DewPointTimeseries( ) const
        {
            return dewPointTimeseries_;
        }
        void SetDewPointTimeseries( const Guid& dewPointTimeseries )
        {
            dewPointTimeseries_ = dewPointTimeseries;
        }
        const Guid& StatusTimeseries( ) const
        {
            return statusTimeseries_;
        }
        void SetStatusTimeseries( const Guid& statusTimeseries )
        {
            statusTimeseries_ = statusTimeseries;
        }
    };
    class TrackerDeviceObject : public DeviceObject
    {
    public:
        using Base = DeviceObject;
        static constexpr Kind KIND = Kind::TrackerDevice;
    private:
    public:
        TrackerDeviceObject( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<TrackerDeviceObject>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<TrackerDeviceObject&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const TrackerDeviceObject& >( other );
                return true;
            }
            return false;
        }
    };
    class AisDeviceObject : public TrackerDeviceObject
    {
    public:
        using Base = TrackerDeviceObject;
        static constexpr Kind KIND = Kind::AisDevice;
    private:
    public:
        AisDeviceObject( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<AisDeviceObject>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<AisDeviceObject&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const AisDeviceObject& >( other );
                return true;
            }
            return false;
        }
    };
    class RadarDeviceObject : public TrackerDeviceObject
    {
    public:
        using Base = TrackerDeviceObject;
        static constexpr Kind KIND = Kind::RadarDevice;
    private:
        Guid saveSettingsTimeseries_;
        Guid powerOnTimeseries_;
        Guid trackingOnTimeseries_;
        Guid radarPulseTimeseries_;
        Guid tuningTimeseries_;
        Guid blankSector1Timeseries_;
        Guid sector1StartTimeseries_;
        Guid sector1EndTimeseries_;
        Guid blankSector2Timeseries_;
        Guid sector2StartTimeseries_;
        Guid sector2EndTimeseries_;
        Guid enableAutomaticFrequencyControlTimeseries_;
        Guid azimuthOffsetTimeseries_;
        Guid enableSensitivityTimeControlTimeseries_;
        Guid automaticSensitivityTimeControlTimeseries_;
        Guid sensitivityTimeControlLevelTimeseries_;
        Guid enableFastTimeConstantTimeseries_;
        Guid fastTimeConstantLevelTimeseries_;
        Guid fastTimeConstantModeTimeseries_;
        Guid latitudeTimeseries_;
        Guid longitudeTimeseries_;
        DBGuid radome_;
        DBGuid gNSSDevice_;
    public:
        RadarDeviceObject( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(saveSettingsTimeseries_);
            destination.Write(powerOnTimeseries_);
            destination.Write(trackingOnTimeseries_);
            destination.Write(radarPulseTimeseries_);
            destination.Write(tuningTimeseries_);
            destination.Write(blankSector1Timeseries_);
            destination.Write(sector1StartTimeseries_);
            destination.Write(sector1EndTimeseries_);
            destination.Write(blankSector2Timeseries_);
            destination.Write(sector2StartTimeseries_);
            destination.Write(sector2EndTimeseries_);
            destination.Write(enableAutomaticFrequencyControlTimeseries_);
            destination.Write(azimuthOffsetTimeseries_);
            destination.Write(enableSensitivityTimeControlTimeseries_);
            destination.Write(automaticSensitivityTimeControlTimeseries_);
            destination.Write(sensitivityTimeControlLevelTimeseries_);
            destination.Write(enableFastTimeConstantTimeseries_);
            destination.Write(fastTimeConstantLevelTimeseries_);
            destination.Write(fastTimeConstantModeTimeseries_);
            destination.Write(latitudeTimeseries_);
            destination.Write(longitudeTimeseries_);
            radome_.WriteTo( destination );
            gNSSDevice_.WriteTo( destination );
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(saveSettingsTimeseries_);
            source.Read(powerOnTimeseries_);
            source.Read(trackingOnTimeseries_);
            source.Read(radarPulseTimeseries_);
            source.Read(tuningTimeseries_);
            source.Read(blankSector1Timeseries_);
            source.Read(sector1StartTimeseries_);
            source.Read(sector1EndTimeseries_);
            source.Read(blankSector2Timeseries_);
            source.Read(sector2StartTimeseries_);
            source.Read(sector2EndTimeseries_);
            source.Read(enableAutomaticFrequencyControlTimeseries_);
            source.Read(azimuthOffsetTimeseries_);
            source.Read(enableSensitivityTimeControlTimeseries_);
            source.Read(automaticSensitivityTimeControlTimeseries_);
            source.Read(sensitivityTimeControlLevelTimeseries_);
            source.Read(enableFastTimeConstantTimeseries_);
            source.Read(fastTimeConstantLevelTimeseries_);
            source.Read(fastTimeConstantModeTimeseries_);
            source.Read(latitudeTimeseries_);
            source.Read(longitudeTimeseries_);
            radome_.ReadFrom( source );
            gNSSDevice_.ReadFrom( source );
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<RadarDeviceObject>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<RadarDeviceObject&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const RadarDeviceObject& >( other );
                if ( dataObject.saveSettingsTimeseries_ != saveSettingsTimeseries_ )
                {
                    return false;
                }
                if ( dataObject.powerOnTimeseries_ != powerOnTimeseries_ )
                {
                    return false;
                }
                if ( dataObject.trackingOnTimeseries_ != trackingOnTimeseries_ )
                {
                    return false;
                }
                if ( dataObject.radarPulseTimeseries_ != radarPulseTimeseries_ )
                {
                    return false;
                }
                if ( dataObject.tuningTimeseries_ != tuningTimeseries_ )
                {
                    return false;
                }
                if ( dataObject.blankSector1Timeseries_ != blankSector1Timeseries_ )
                {
                    return false;
                }
                if ( dataObject.sector1StartTimeseries_ != sector1StartTimeseries_ )
                {
                    return false;
                }
                if ( dataObject.sector1EndTimeseries_ != sector1EndTimeseries_ )
                {
                    return false;
                }
                if ( dataObject.blankSector2Timeseries_ != blankSector2Timeseries_ )
                {
                    return false;
                }
                if ( dataObject.sector2StartTimeseries_ != sector2StartTimeseries_ )
                {
                    return false;
                }
                if ( dataObject.sector2EndTimeseries_ != sector2EndTimeseries_ )
                {
                    return false;
                }
                if ( dataObject.enableAutomaticFrequencyControlTimeseries_ != enableAutomaticFrequencyControlTimeseries_ )
                {
                    return false;
                }
                if ( dataObject.azimuthOffsetTimeseries_ != azimuthOffsetTimeseries_ )
                {
                    return false;
                }
                if ( dataObject.enableSensitivityTimeControlTimeseries_ != enableSensitivityTimeControlTimeseries_ )
                {
                    return false;
                }
                if ( dataObject.automaticSensitivityTimeControlTimeseries_ != automaticSensitivityTimeControlTimeseries_ )
                {
                    return false;
                }
                if ( dataObject.sensitivityTimeControlLevelTimeseries_ != sensitivityTimeControlLevelTimeseries_ )
                {
                    return false;
                }
                if ( dataObject.enableFastTimeConstantTimeseries_ != enableFastTimeConstantTimeseries_ )
                {
                    return false;
                }
                if ( dataObject.fastTimeConstantLevelTimeseries_ != fastTimeConstantLevelTimeseries_ )
                {
                    return false;
                }
                if ( dataObject.fastTimeConstantModeTimeseries_ != fastTimeConstantModeTimeseries_ )
                {
                    return false;
                }
                if ( dataObject.latitudeTimeseries_ != latitudeTimeseries_ )
                {
                    return false;
                }
                if ( dataObject.longitudeTimeseries_ != longitudeTimeseries_ )
                {
                    return false;
                }
                if ( dataObject.radome_ != radome_ )
                {
                    return false;
                }
                if ( dataObject.gNSSDevice_ != gNSSDevice_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        const Guid& SaveSettingsTimeseries( ) const
        {
            return saveSettingsTimeseries_;
        }
        void SetSaveSettingsTimeseries( const Guid& saveSettingsTimeseries )
        {
            saveSettingsTimeseries_ = saveSettingsTimeseries;
        }
        const Guid& PowerOnTimeseries( ) const
        {
            return powerOnTimeseries_;
        }
        void SetPowerOnTimeseries( const Guid& powerOnTimeseries )
        {
            powerOnTimeseries_ = powerOnTimeseries;
        }
        const Guid& TrackingOnTimeseries( ) const
        {
            return trackingOnTimeseries_;
        }
        void SetTrackingOnTimeseries( const Guid& trackingOnTimeseries )
        {
            trackingOnTimeseries_ = trackingOnTimeseries;
        }
        const Guid& RadarPulseTimeseries( ) const
        {
            return radarPulseTimeseries_;
        }
        void SetRadarPulseTimeseries( const Guid& radarPulseTimeseries )
        {
            radarPulseTimeseries_ = radarPulseTimeseries;
        }
        const Guid& TuningTimeseries( ) const
        {
            return tuningTimeseries_;
        }
        void SetTuningTimeseries( const Guid& tuningTimeseries )
        {
            tuningTimeseries_ = tuningTimeseries;
        }
        const Guid& BlankSector1Timeseries( ) const
        {
            return blankSector1Timeseries_;
        }
        void SetBlankSector1Timeseries( const Guid& blankSector1Timeseries )
        {
            blankSector1Timeseries_ = blankSector1Timeseries;
        }
        const Guid& Sector1StartTimeseries( ) const
        {
            return sector1StartTimeseries_;
        }
        void SetSector1StartTimeseries( const Guid& sector1StartTimeseries )
        {
            sector1StartTimeseries_ = sector1StartTimeseries;
        }
        const Guid& Sector1EndTimeseries( ) const
        {
            return sector1EndTimeseries_;
        }
        void SetSector1EndTimeseries( const Guid& sector1EndTimeseries )
        {
            sector1EndTimeseries_ = sector1EndTimeseries;
        }
        const Guid& BlankSector2Timeseries( ) const
        {
            return blankSector2Timeseries_;
        }
        void SetBlankSector2Timeseries( const Guid& blankSector2Timeseries )
        {
            blankSector2Timeseries_ = blankSector2Timeseries;
        }
        const Guid& Sector2StartTimeseries( ) const
        {
            return sector2StartTimeseries_;
        }
        void SetSector2StartTimeseries( const Guid& sector2StartTimeseries )
        {
            sector2StartTimeseries_ = sector2StartTimeseries;
        }
        const Guid& Sector2EndTimeseries( ) const
        {
            return sector2EndTimeseries_;
        }
        void SetSector2EndTimeseries( const Guid& sector2EndTimeseries )
        {
            sector2EndTimeseries_ = sector2EndTimeseries;
        }
        const Guid& EnableAutomaticFrequencyControlTimeseries( ) const
        {
            return enableAutomaticFrequencyControlTimeseries_;
        }
        void SetEnableAutomaticFrequencyControlTimeseries( const Guid& enableAutomaticFrequencyControlTimeseries )
        {
            enableAutomaticFrequencyControlTimeseries_ = enableAutomaticFrequencyControlTimeseries;
        }
        const Guid& AzimuthOffsetTimeseries( ) const
        {
            return azimuthOffsetTimeseries_;
        }
        void SetAzimuthOffsetTimeseries( const Guid& azimuthOffsetTimeseries )
        {
            azimuthOffsetTimeseries_ = azimuthOffsetTimeseries;
        }
        const Guid& EnableSensitivityTimeControlTimeseries( ) const
        {
            return enableSensitivityTimeControlTimeseries_;
        }
        void SetEnableSensitivityTimeControlTimeseries( const Guid& enableSensitivityTimeControlTimeseries )
        {
            enableSensitivityTimeControlTimeseries_ = enableSensitivityTimeControlTimeseries;
        }
        const Guid& AutomaticSensitivityTimeControlTimeseries( ) const
        {
            return automaticSensitivityTimeControlTimeseries_;
        }
        void SetAutomaticSensitivityTimeControlTimeseries( const Guid& automaticSensitivityTimeControlTimeseries )
        {
            automaticSensitivityTimeControlTimeseries_ = automaticSensitivityTimeControlTimeseries;
        }
        const Guid& SensitivityTimeControlLevelTimeseries( ) const
        {
            return sensitivityTimeControlLevelTimeseries_;
        }
        void SetSensitivityTimeControlLevelTimeseries( const Guid& sensitivityTimeControlLevelTimeseries )
        {
            sensitivityTimeControlLevelTimeseries_ = sensitivityTimeControlLevelTimeseries;
        }
        const Guid& EnableFastTimeConstantTimeseries( ) const
        {
            return enableFastTimeConstantTimeseries_;
        }
        void SetEnableFastTimeConstantTimeseries( const Guid& enableFastTimeConstantTimeseries )
        {
            enableFastTimeConstantTimeseries_ = enableFastTimeConstantTimeseries;
        }
        const Guid& FastTimeConstantLevelTimeseries( ) const
        {
            return fastTimeConstantLevelTimeseries_;
        }
        void SetFastTimeConstantLevelTimeseries( const Guid& fastTimeConstantLevelTimeseries )
        {
            fastTimeConstantLevelTimeseries_ = fastTimeConstantLevelTimeseries;
        }
        const Guid& FastTimeConstantModeTimeseries( ) const
        {
            return fastTimeConstantModeTimeseries_;
        }
        void SetFastTimeConstantModeTimeseries( const Guid& fastTimeConstantModeTimeseries )
        {
            fastTimeConstantModeTimeseries_ = fastTimeConstantModeTimeseries;
        }
        const Guid& LatitudeTimeseries( ) const
        {
            return latitudeTimeseries_;
        }
        void SetLatitudeTimeseries( const Guid& latitudeTimeseries )
        {
            latitudeTimeseries_ = latitudeTimeseries;
        }
        const Guid& LongitudeTimeseries( ) const
        {
            return longitudeTimeseries_;
        }
        void SetLongitudeTimeseries( const Guid& longitudeTimeseries )
        {
            longitudeTimeseries_ = longitudeTimeseries;
        }
        const DBGuid& Radome( ) const
        {
            return radome_;
        }
        void SetRadome( const DBGuid& radome )
        {
            radome_ = radome;
        }
        const DBGuid& GNSSDevice( ) const
        {
            return gNSSDevice_;
        }
        void SetGNSSDevice( const DBGuid& gNSSDevice )
        {
            gNSSDevice_ = gNSSDevice;
        }
    };
    class WeatherStationDeviceObject : public DeviceObject
    {
    public:
        using Base = DeviceObject;
        static constexpr Kind KIND = Kind::WeatherStationDevice;
    private:
        Guid barometricPressureTimeseries_;
        Guid airTemperatureTimeseries_;
        Guid waterTemperatureTimeseries_;
        Guid relativeHumidityTimeseries_;
        Guid absoluteHumidityTimeseries_;
        Guid dewPointTimeseries_;
        Guid windDirectionTimeseries_;
        Guid windSpeedTimeseries_;
        Guid gyro_;
    public:
        WeatherStationDeviceObject( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(barometricPressureTimeseries_);
            destination.Write(airTemperatureTimeseries_);
            destination.Write(waterTemperatureTimeseries_);
            destination.Write(relativeHumidityTimeseries_);
            destination.Write(absoluteHumidityTimeseries_);
            destination.Write(dewPointTimeseries_);
            destination.Write(windDirectionTimeseries_);
            destination.Write(windSpeedTimeseries_);
            destination.Write(gyro_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(barometricPressureTimeseries_);
            source.Read(airTemperatureTimeseries_);
            source.Read(waterTemperatureTimeseries_);
            source.Read(relativeHumidityTimeseries_);
            source.Read(absoluteHumidityTimeseries_);
            source.Read(dewPointTimeseries_);
            source.Read(windDirectionTimeseries_);
            source.Read(windSpeedTimeseries_);
            source.Read(gyro_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<WeatherStationDeviceObject>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<WeatherStationDeviceObject&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const WeatherStationDeviceObject& >( other );
                if ( dataObject.barometricPressureTimeseries_ != barometricPressureTimeseries_ )
                {
                    return false;
                }
                if ( dataObject.airTemperatureTimeseries_ != airTemperatureTimeseries_ )
                {
                    return false;
                }
                if ( dataObject.waterTemperatureTimeseries_ != waterTemperatureTimeseries_ )
                {
                    return false;
                }
                if ( dataObject.relativeHumidityTimeseries_ != relativeHumidityTimeseries_ )
                {
                    return false;
                }
                if ( dataObject.absoluteHumidityTimeseries_ != absoluteHumidityTimeseries_ )
                {
                    return false;
                }
                if ( dataObject.dewPointTimeseries_ != dewPointTimeseries_ )
                {
                    return false;
                }
                if ( dataObject.windDirectionTimeseries_ != windDirectionTimeseries_ )
                {
                    return false;
                }
                if ( dataObject.windSpeedTimeseries_ != windSpeedTimeseries_ )
                {
                    return false;
                }
                if ( dataObject.gyro_ != gyro_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        const Guid& BarometricPressureTimeseries( ) const
        {
            return barometricPressureTimeseries_;
        }
        void SetBarometricPressureTimeseries( const Guid& barometricPressureTimeseries )
        {
            barometricPressureTimeseries_ = barometricPressureTimeseries;
        }
        const Guid& AirTemperatureTimeseries( ) const
        {
            return airTemperatureTimeseries_;
        }
        void SetAirTemperatureTimeseries( const Guid& airTemperatureTimeseries )
        {
            airTemperatureTimeseries_ = airTemperatureTimeseries;
        }
        const Guid& WaterTemperatureTimeseries( ) const
        {
            return waterTemperatureTimeseries_;
        }
        void SetWaterTemperatureTimeseries( const Guid& waterTemperatureTimeseries )
        {
            waterTemperatureTimeseries_ = waterTemperatureTimeseries;
        }
        const Guid& RelativeHumidityTimeseries( ) const
        {
            return relativeHumidityTimeseries_;
        }
        void SetRelativeHumidityTimeseries( const Guid& relativeHumidityTimeseries )
        {
            relativeHumidityTimeseries_ = relativeHumidityTimeseries;
        }
        const Guid& AbsoluteHumidityTimeseries( ) const
        {
            return absoluteHumidityTimeseries_;
        }
        void SetAbsoluteHumidityTimeseries( const Guid& absoluteHumidityTimeseries )
        {
            absoluteHumidityTimeseries_ = absoluteHumidityTimeseries;
        }
        const Guid& DewPointTimeseries( ) const
        {
            return dewPointTimeseries_;
        }
        void SetDewPointTimeseries( const Guid& dewPointTimeseries )
        {
            dewPointTimeseries_ = dewPointTimeseries;
        }
        const Guid& WindDirectionTimeseries( ) const
        {
            return windDirectionTimeseries_;
        }
        void SetWindDirectionTimeseries( const Guid& windDirectionTimeseries )
        {
            windDirectionTimeseries_ = windDirectionTimeseries;
        }
        const Guid& WindSpeedTimeseries( ) const
        {
            return windSpeedTimeseries_;
        }
        void SetWindSpeedTimeseries( const Guid& windSpeedTimeseries )
        {
            windSpeedTimeseries_ = windSpeedTimeseries;
        }
        const Guid& Gyro( ) const
        {
            return gyro_;
        }
        void SetGyro( const Guid& gyro )
        {
            gyro_ = gyro;
        }
    };
    class FacilityObject : public ItemObject
    {
    public:
        using Base = ItemObject;
        static constexpr Kind KIND = Kind::Facility;
    private:
        FixedDBWideString<127> name_;
        Guid type_;
        double longitude_ = 0.0;
        double latitude_ = 0.0;
        double altitude_ = 0.0;
    public:
        FacilityObject( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            name_.WriteTo( destination );
            destination.Write(type_);
            destination.Write(longitude_);
            destination.Write(latitude_);
            destination.Write(altitude_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            name_.ReadFrom( source );
            source.Read(type_);
            source.Read(longitude_);
            source.Read(latitude_);
            source.Read(altitude_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<FacilityObject>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<FacilityObject&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const FacilityObject& >( other );
                if ( dataObject.name_ != name_ )
                {
                    return false;
                }
                if ( dataObject.type_ != type_ )
                {
                    return false;
                }
                if ( dataObject.longitude_ != longitude_ )
                {
                    return false;
                }
                if ( dataObject.latitude_ != latitude_ )
                {
                    return false;
                }
                if ( dataObject.altitude_ != altitude_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        const FixedDBWideString<127>& Name( ) const
        {
            return name_;
        }
        void SetName( const FixedDBWideString<127>& name )
        {
            name_ = name;
        }
        const Guid& Type( ) const
        {
            return type_;
        }
        void SetType( const Guid& type )
        {
            type_ = type;
        }
        double Longitude( ) const
        {
            return longitude_;
        }
        void SetLongitude( double longitude )
        {
            longitude_ = longitude;
        }
        double Latitude( ) const
        {
            return latitude_;
        }
        void SetLatitude( double latitude )
        {
            latitude_ = latitude;
        }
        double Altitude( ) const
        {
            return altitude_;
        }
        void SetAltitude( double altitude )
        {
            altitude_ = altitude;
        }
    };
    class TrackableItemObject : public ItemObject
    {
    public:
        using Base = ItemObject;
        static constexpr Kind KIND = Kind::TrackableItem;
    private:
    public:
        TrackableItemObject( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<TrackableItemObject>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<TrackableItemObject&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const TrackableItemObject& >( other );
                return true;
            }
            return false;
        }
    };
    class AircraftObject : public TrackableItemObject
    {
    public:
        using Base = TrackableItemObject;
        static constexpr Kind KIND = Kind::Aircraft;
    private:
        FixedDBWideString<127> name_;
        Guid type_;
    public:
        AircraftObject( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            name_.WriteTo( destination );
            destination.Write(type_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            name_.ReadFrom( source );
            source.Read(type_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<AircraftObject>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<AircraftObject&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const AircraftObject& >( other );
                if ( dataObject.name_ != name_ )
                {
                    return false;
                }
                if ( dataObject.type_ != type_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        const FixedDBWideString<127>& Name( ) const
        {
            return name_;
        }
        void SetName( const FixedDBWideString<127>& name )
        {
            name_ = name;
        }
        const Guid& Type( ) const
        {
            return type_;
        }
        void SetType( const Guid& type )
        {
            type_ = type;
        }
    };
    class AisAidToNavigationObject : public TrackableItemObject
    {
    public:
        using Base = TrackableItemObject;
        static constexpr Kind KIND = Kind::AisAidToNavigation;
    private:
        FixedDBWideString<127> name_;
        Guid mMSI_;
        Types::NavigationalAidType navigationalAidType_ = Types::NavigationalAidType::NotSpecified;
        Guid position_;
        bool isVirtual_ = false;
        Int32 toBow_ = 0;
        Int32 toStern_ = 0;
        Int32 toPort_ = 0;
        Int32 toStarboard_ = 0;
        Guid offPositionTimeseries_;
    public:
        AisAidToNavigationObject( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            name_.WriteTo( destination );
            destination.Write(mMSI_);
            destination.Write(navigationalAidType_);
            destination.Write(position_);
            destination.Write(isVirtual_);
            destination.Write(toBow_);
            destination.Write(toStern_);
            destination.Write(toPort_);
            destination.Write(toStarboard_);
            destination.Write(offPositionTimeseries_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            name_.ReadFrom( source );
            source.Read(mMSI_);
            source.Read(navigationalAidType_);
            source.Read(position_);
            source.Read(isVirtual_);
            source.Read(toBow_);
            source.Read(toStern_);
            source.Read(toPort_);
            source.Read(toStarboard_);
            source.Read(offPositionTimeseries_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<AisAidToNavigationObject>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<AisAidToNavigationObject&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const AisAidToNavigationObject& >( other );
                if ( dataObject.name_ != name_ )
                {
                    return false;
                }
                if ( dataObject.mMSI_ != mMSI_ )
                {
                    return false;
                }
                if ( dataObject.navigationalAidType_ != navigationalAidType_ )
                {
                    return false;
                }
                if ( dataObject.position_ != position_ )
                {
                    return false;
                }
                if ( dataObject.isVirtual_ != isVirtual_ )
                {
                    return false;
                }
                if ( dataObject.toBow_ != toBow_ )
                {
                    return false;
                }
                if ( dataObject.toStern_ != toStern_ )
                {
                    return false;
                }
                if ( dataObject.toPort_ != toPort_ )
                {
                    return false;
                }
                if ( dataObject.toStarboard_ != toStarboard_ )
                {
                    return false;
                }
                if ( dataObject.offPositionTimeseries_ != offPositionTimeseries_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        const FixedDBWideString<127>& Name( ) const
        {
            return name_;
        }
        void SetName( const FixedDBWideString<127>& name )
        {
            name_ = name;
        }
        const Guid& MMSI( ) const
        {
            return mMSI_;
        }
        void SetMMSI( const Guid& mMSI )
        {
            mMSI_ = mMSI;
        }
        Types::NavigationalAidType NavigationalAidType( ) const
        {
            return navigationalAidType_;
        }
        void SetNavigationalAidType( Types::NavigationalAidType navigationalAidType )
        {
            navigationalAidType_ = navigationalAidType;
        }
        const Guid& Position( ) const
        {
            return position_;
        }
        void SetPosition( const Guid& position )
        {
            position_ = position;
        }
        bool IsVirtual( ) const
        {
            return isVirtual_;
        }
        void SetIsVirtual( bool isVirtual )
        {
            isVirtual_ = isVirtual;
        }
        Int32 ToBow( ) const
        {
            return toBow_;
        }
        void SetToBow( Int32 toBow )
        {
            toBow_ = toBow;
        }
        Int32 ToStern( ) const
        {
            return toStern_;
        }
        void SetToStern( Int32 toStern )
        {
            toStern_ = toStern;
        }
        Int32 ToPort( ) const
        {
            return toPort_;
        }
        void SetToPort( Int32 toPort )
        {
            toPort_ = toPort;
        }
        Int32 ToStarboard( ) const
        {
            return toStarboard_;
        }
        void SetToStarboard( Int32 toStarboard )
        {
            toStarboard_ = toStarboard;
        }
        const Guid& OffPositionTimeseries( ) const
        {
            return offPositionTimeseries_;
        }
        void SetOffPositionTimeseries( const Guid& offPositionTimeseries )
        {
            offPositionTimeseries_ = offPositionTimeseries;
        }
    };
    class VehicleObject : public TrackableItemObject
    {
    public:
        using Base = TrackableItemObject;
        static constexpr Kind KIND = Kind::Vehicle;
    private:
        FixedDBWideString<127> name_;
        Guid type_;
    public:
        VehicleObject( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            name_.WriteTo( destination );
            destination.Write(type_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            name_.ReadFrom( source );
            source.Read(type_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<VehicleObject>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<VehicleObject&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const VehicleObject& >( other );
                if ( dataObject.name_ != name_ )
                {
                    return false;
                }
                if ( dataObject.type_ != type_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        const FixedDBWideString<127>& Name( ) const
        {
            return name_;
        }
        void SetName( const FixedDBWideString<127>& name )
        {
            name_ = name;
        }
        const Guid& Type( ) const
        {
            return type_;
        }
        void SetType( const Guid& type )
        {
            type_ = type;
        }
    };
    class VesselObject : public TrackableItemObject
    {
    public:
        using Base = TrackableItemObject;
        static constexpr Kind KIND = Kind::Vessel;
    private:
        FixedDBWideString<127> name_;
        Guid type_;
        Int32 toBow_ = 0;
        Int32 toStern_ = 0;
        Int32 toPort_ = 0;
        Int32 toStarboard_ = 0;
        Guid draughtTimeseries_;
        Guid personsOnBoardTimeseries_;
    public:
        VesselObject( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            name_.WriteTo( destination );
            destination.Write(type_);
            destination.Write(toBow_);
            destination.Write(toStern_);
            destination.Write(toPort_);
            destination.Write(toStarboard_);
            destination.Write(draughtTimeseries_);
            destination.Write(personsOnBoardTimeseries_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            name_.ReadFrom( source );
            source.Read(type_);
            source.Read(toBow_);
            source.Read(toStern_);
            source.Read(toPort_);
            source.Read(toStarboard_);
            source.Read(draughtTimeseries_);
            source.Read(personsOnBoardTimeseries_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<VesselObject>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<VesselObject&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const VesselObject& >( other );
                if ( dataObject.name_ != name_ )
                {
                    return false;
                }
                if ( dataObject.type_ != type_ )
                {
                    return false;
                }
                if ( dataObject.toBow_ != toBow_ )
                {
                    return false;
                }
                if ( dataObject.toStern_ != toStern_ )
                {
                    return false;
                }
                if ( dataObject.toPort_ != toPort_ )
                {
                    return false;
                }
                if ( dataObject.toStarboard_ != toStarboard_ )
                {
                    return false;
                }
                if ( dataObject.draughtTimeseries_ != draughtTimeseries_ )
                {
                    return false;
                }
                if ( dataObject.personsOnBoardTimeseries_ != personsOnBoardTimeseries_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        const FixedDBWideString<127>& Name( ) const
        {
            return name_;
        }
        void SetName( const FixedDBWideString<127>& name )
        {
            name_ = name;
        }
        const Guid& Type( ) const
        {
            return type_;
        }
        void SetType( const Guid& type )
        {
            type_ = type;
        }
        Int32 ToBow( ) const
        {
            return toBow_;
        }
        void SetToBow( Int32 toBow )
        {
            toBow_ = toBow;
        }
        Int32 ToStern( ) const
        {
            return toStern_;
        }
        void SetToStern( Int32 toStern )
        {
            toStern_ = toStern;
        }
        Int32 ToPort( ) const
        {
            return toPort_;
        }
        void SetToPort( Int32 toPort )
        {
            toPort_ = toPort;
        }
        Int32 ToStarboard( ) const
        {
            return toStarboard_;
        }
        void SetToStarboard( Int32 toStarboard )
        {
            toStarboard_ = toStarboard;
        }
        const Guid& DraughtTimeseries( ) const
        {
            return draughtTimeseries_;
        }
        void SetDraughtTimeseries( const Guid& draughtTimeseries )
        {
            draughtTimeseries_ = draughtTimeseries;
        }
        const Guid& PersonsOnBoardTimeseries( ) const
        {
            return personsOnBoardTimeseries_;
        }
        void SetPersonsOnBoardTimeseries( const Guid& personsOnBoardTimeseries )
        {
            personsOnBoardTimeseries_ = personsOnBoardTimeseries;
        }
    };
    class ItemIdentityLinkObject : public BaseData<Kind, Guid>
    {
    public:
        using Base = BaseData<Kind, Guid>;
        static constexpr Kind KIND = Kind::ItemIdentityLink;
    private:
        Int64 rowVersion_ = 0;
        Guid item_;
        Guid identity_;
        DateTime start_;
        DBDateTime end_;
    public:
        ItemIdentityLinkObject( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(rowVersion_);
            destination.Write(item_);
            destination.Write(identity_);
            destination.Write(start_);
            end_.WriteTo( destination );
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(rowVersion_);
            source.Read(item_);
            source.Read(identity_);
            source.Read(start_);
            end_.ReadFrom( source );
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<ItemIdentityLinkObject>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<ItemIdentityLinkObject&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const ItemIdentityLinkObject& >( other );
                if ( dataObject.rowVersion_ != rowVersion_ )
                {
                    return false;
                }
                if ( dataObject.item_ != item_ )
                {
                    return false;
                }
                if ( dataObject.identity_ != identity_ )
                {
                    return false;
                }
                if ( dataObject.start_ != start_ )
                {
                    return false;
                }
                if ( dataObject.end_ != end_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        Int64 RowVersion( ) const
        {
            return rowVersion_;
        }
        void SetRowVersion( const Int64& rowVersion )
        {
            rowVersion_ = rowVersion;
        }
        const Guid& Item( ) const
        {
            return item_;
        }
        void SetItem( const Guid& item )
        {
            item_ = item;
        }
        const Guid& Identity( ) const
        {
            return identity_;
        }
        void SetIdentity( const Guid& identity )
        {
            identity_ = identity;
        }
        const DateTime& Start( ) const
        {
            return start_;
        }
        void SetStart( const DateTime& start )
        {
            start_ = start;
        }
        const DBDateTime& End( ) const
        {
            return end_;
        }
        void SetEnd( const DBDateTime& end )
        {
            end_ = end;
        }
    };
    class ItemParentChildLinkObject : public BaseData<Kind, Guid>
    {
    public:
        using Base = BaseData<Kind, Guid>;
        static constexpr Kind KIND = Kind::ItemParentChildLink;
    private:
        Int64 rowVersion_ = 0;
        Guid parent_;
        Guid child_;
        DateTime timestamp_;
    public:
        ItemParentChildLinkObject( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(rowVersion_);
            destination.Write(parent_);
            destination.Write(child_);
            destination.Write(timestamp_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(rowVersion_);
            source.Read(parent_);
            source.Read(child_);
            source.Read(timestamp_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<ItemParentChildLinkObject>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<ItemParentChildLinkObject&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const ItemParentChildLinkObject& >( other );
                if ( dataObject.rowVersion_ != rowVersion_ )
                {
                    return false;
                }
                if ( dataObject.parent_ != parent_ )
                {
                    return false;
                }
                if ( dataObject.child_ != child_ )
                {
                    return false;
                }
                if ( dataObject.timestamp_ != timestamp_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        Int64 RowVersion( ) const
        {
            return rowVersion_;
        }
        void SetRowVersion( const Int64& rowVersion )
        {
            rowVersion_ = rowVersion;
        }
        const Guid& Parent( ) const
        {
            return parent_;
        }
        void SetParent( const Guid& parent )
        {
            parent_ = parent;
        }
        const Guid& Child( ) const
        {
            return child_;
        }
        void SetChild( const Guid& child )
        {
            child_ = child;
        }
        const DateTime& Timestamp( ) const
        {
            return timestamp_;
        }
        void SetTimestamp( const DateTime& timestamp )
        {
            timestamp_ = timestamp;
        }
    };
    class LineInputDeviceCommandObject : public BaseData<Kind, Guid>
    {
    public:
        using Base = BaseData<Kind, Guid>;
        static constexpr Kind KIND = Kind::LineInputDeviceCommand;
    private:
        Int64 rowVersion_ = 0;
        Guid lineInputDevice_;
        DateTime timestamp_;
        Types::DeviceCommandSourceType deviceCommandSourceType_ = Types::DeviceCommandSourceType::Unknown;
        Guid deviceCommandSourceId_;
        Guid reply_;
    public:
        LineInputDeviceCommandObject( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(rowVersion_);
            destination.Write(lineInputDevice_);
            destination.Write(timestamp_);
            destination.Write(deviceCommandSourceType_);
            destination.Write(deviceCommandSourceId_);
            destination.Write(reply_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(rowVersion_);
            source.Read(lineInputDevice_);
            source.Read(timestamp_);
            source.Read(deviceCommandSourceType_);
            source.Read(deviceCommandSourceId_);
            source.Read(reply_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<LineInputDeviceCommandObject>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<LineInputDeviceCommandObject&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const LineInputDeviceCommandObject& >( other );
                if ( dataObject.rowVersion_ != rowVersion_ )
                {
                    return false;
                }
                if ( dataObject.lineInputDevice_ != lineInputDevice_ )
                {
                    return false;
                }
                if ( dataObject.timestamp_ != timestamp_ )
                {
                    return false;
                }
                if ( dataObject.deviceCommandSourceType_ != deviceCommandSourceType_ )
                {
                    return false;
                }
                if ( dataObject.deviceCommandSourceId_ != deviceCommandSourceId_ )
                {
                    return false;
                }
                if ( dataObject.reply_ != reply_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        Int64 RowVersion( ) const
        {
            return rowVersion_;
        }
        void SetRowVersion( const Int64& rowVersion )
        {
            rowVersion_ = rowVersion;
        }
        const Guid& LineInputDevice( ) const
        {
            return lineInputDevice_;
        }
        void SetLineInputDevice( const Guid& lineInputDevice )
        {
            lineInputDevice_ = lineInputDevice;
        }
        const DateTime& Timestamp( ) const
        {
            return timestamp_;
        }
        void SetTimestamp( const DateTime& timestamp )
        {
            timestamp_ = timestamp;
        }
        Types::DeviceCommandSourceType DeviceCommandSourceType( ) const
        {
            return deviceCommandSourceType_;
        }
        void SetDeviceCommandSourceType( Types::DeviceCommandSourceType deviceCommandSourceType )
        {
            deviceCommandSourceType_ = deviceCommandSourceType;
        }
        const Guid& DeviceCommandSourceId( ) const
        {
            return deviceCommandSourceId_;
        }
        void SetDeviceCommandSourceId( const Guid& deviceCommandSourceId )
        {
            deviceCommandSourceId_ = deviceCommandSourceId;
        }
        const Guid& Reply( ) const
        {
            return reply_;
        }
        void SetReply( const Guid& reply )
        {
            reply_ = reply;
        }
    };
    class LineInputDeviceCommandReplyObject : public BaseData<Kind, Guid>
    {
    public:
        using Base = BaseData<Kind, Guid>;
        static constexpr Kind KIND = Kind::LineInputDeviceCommandReply;
    private:
        Int64 rowVersion_ = 0;
        Guid lineInputDevice_;
        DateTime timestamp_;
        Guid command_;
        Types::DeviceCommandReplyStatus status_ = Types::DeviceCommandReplyStatus::Unknown;
        WideString message_;
        SQLLEN messageLength_ = SQL_NULL_DATA;
    public:
        LineInputDeviceCommandReplyObject( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(rowVersion_);
            destination.Write(lineInputDevice_);
            destination.Write(timestamp_);
            destination.Write(command_);
            destination.Write(status_);
            destination.Write(message_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(rowVersion_);
            source.Read(lineInputDevice_);
            source.Read(timestamp_);
            source.Read(command_);
            source.Read(status_);
            source.Read(message_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<LineInputDeviceCommandReplyObject>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<LineInputDeviceCommandReplyObject&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const LineInputDeviceCommandReplyObject& >( other );
                if ( dataObject.rowVersion_ != rowVersion_ )
                {
                    return false;
                }
                if ( dataObject.lineInputDevice_ != lineInputDevice_ )
                {
                    return false;
                }
                if ( dataObject.timestamp_ != timestamp_ )
                {
                    return false;
                }
                if ( dataObject.command_ != command_ )
                {
                    return false;
                }
                if ( dataObject.status_ != status_ )
                {
                    return false;
                }
                if ( dataObject.message_ != message_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        Int64 RowVersion( ) const
        {
            return rowVersion_;
        }
        void SetRowVersion( const Int64& rowVersion )
        {
            rowVersion_ = rowVersion;
        }
        const Guid& LineInputDevice( ) const
        {
            return lineInputDevice_;
        }
        void SetLineInputDevice( const Guid& lineInputDevice )
        {
            lineInputDevice_ = lineInputDevice;
        }
        const DateTime& Timestamp( ) const
        {
            return timestamp_;
        }
        void SetTimestamp( const DateTime& timestamp )
        {
            timestamp_ = timestamp;
        }
        const Guid& Command( ) const
        {
            return command_;
        }
        void SetCommand( const Guid& command )
        {
            command_ = command;
        }
        Types::DeviceCommandReplyStatus Status( ) const
        {
            return status_;
        }
        void SetStatus( Types::DeviceCommandReplyStatus status )
        {
            status_ = status;
        }
        const WideString& Message( ) const
        {
            return message_;
        }
        void SetMessage( const WideString& message )
        {
            message_ = message;
        }
    };
    class LineInputDeviceConfigurationObject : public BaseData<Kind, Guid>
    {
    public:
        using Base = BaseData<Kind, Guid>;
        static constexpr Kind KIND = Kind::LineInputDeviceConfiguration;
    private:
        Int64 rowVersion_ = 0;
        Guid lineInputDevice_;
        DateTime timestamp_;
        bool storeReceivedSentences_ = false;
        bool storeSentMessages_ = false;
        bool storeUnsentMessages_ = false;
        bool nMEA_ = false;
        bool strictNMEA_ = false;
        Types::LineInputDeviceConnectionType connectionType_ = Types::LineInputDeviceConnectionType::Unknown;
        Int32 udpReceivePort_ = 0;
        FixedDBWideString<127> udpSendHostname_;
        Int32 udpSendPort_ = 0;
        FixedDBWideString<127> tcpHostname_;
        Int32 tcpPort_ = 0;
        bool useHttpLogin_ = false;
        FixedDBWideString<127> loginHostname_;
        Int32 loginPort_ = 0;
        FixedDBWideString<127> userName_;
        FixedDBWideString<127> password_;
        FixedDBWideString<127> comPort_;
        Int32 baudRate_ = 0;
        Int32 dataBits_ = 0;
        bool discardNull_ = false;
        bool dtrEnable_ = false;
        Types::Handshake handshake_ = Types::Handshake::None;
        FixedDBWideString<127> newLine_;
        Types::Parity parity_ = Types::Parity::None;
        Byte parityReplace_ = 0;
        Int32 readBufferSize_ = 0;
        TimeSpan readTimeout_;
        Int32 receivedBytesThreshold_ = 0;
        bool rtsEnable_ = false;
        Types::StopBits stopBits_ = Types::StopBits::None;
        Int32 writeBufferSize_ = 0;
        TimeSpan writeTimeout_;
        FixedDBWideString<127> pairedComPort_;
    public:
        LineInputDeviceConfigurationObject( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(rowVersion_);
            destination.Write(lineInputDevice_);
            destination.Write(timestamp_);
            destination.Write(storeReceivedSentences_);
            destination.Write(storeSentMessages_);
            destination.Write(storeUnsentMessages_);
            destination.Write(nMEA_);
            destination.Write(strictNMEA_);
            destination.Write(connectionType_);
            destination.Write(udpReceivePort_);
            udpSendHostname_.WriteTo( destination );
            destination.Write(udpSendPort_);
            tcpHostname_.WriteTo( destination );
            destination.Write(tcpPort_);
            destination.Write(useHttpLogin_);
            loginHostname_.WriteTo( destination );
            destination.Write(loginPort_);
            userName_.WriteTo( destination );
            password_.WriteTo( destination );
            comPort_.WriteTo( destination );
            destination.Write(baudRate_);
            destination.Write(dataBits_);
            destination.Write(discardNull_);
            destination.Write(dtrEnable_);
            destination.Write(handshake_);
            newLine_.WriteTo( destination );
            destination.Write(parity_);
            destination.Write(parityReplace_);
            destination.Write(readBufferSize_);
            destination.Write(readTimeout_);
            destination.Write(receivedBytesThreshold_);
            destination.Write(rtsEnable_);
            destination.Write(stopBits_);
            destination.Write(writeBufferSize_);
            destination.Write(writeTimeout_);
            pairedComPort_.WriteTo( destination );
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(rowVersion_);
            source.Read(lineInputDevice_);
            source.Read(timestamp_);
            source.Read(storeReceivedSentences_);
            source.Read(storeSentMessages_);
            source.Read(storeUnsentMessages_);
            source.Read(nMEA_);
            source.Read(strictNMEA_);
            source.Read(connectionType_);
            source.Read(udpReceivePort_);
            udpSendHostname_.ReadFrom( source );
            source.Read(udpSendPort_);
            tcpHostname_.ReadFrom( source );
            source.Read(tcpPort_);
            source.Read(useHttpLogin_);
            loginHostname_.ReadFrom( source );
            source.Read(loginPort_);
            userName_.ReadFrom( source );
            password_.ReadFrom( source );
            comPort_.ReadFrom( source );
            source.Read(baudRate_);
            source.Read(dataBits_);
            source.Read(discardNull_);
            source.Read(dtrEnable_);
            source.Read(handshake_);
            newLine_.ReadFrom( source );
            source.Read(parity_);
            source.Read(parityReplace_);
            source.Read(readBufferSize_);
            source.Read(readTimeout_);
            source.Read(receivedBytesThreshold_);
            source.Read(rtsEnable_);
            source.Read(stopBits_);
            source.Read(writeBufferSize_);
            source.Read(writeTimeout_);
            pairedComPort_.ReadFrom( source );
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<LineInputDeviceConfigurationObject>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<LineInputDeviceConfigurationObject&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const LineInputDeviceConfigurationObject& >( other );
                if ( dataObject.rowVersion_ != rowVersion_ )
                {
                    return false;
                }
                if ( dataObject.lineInputDevice_ != lineInputDevice_ )
                {
                    return false;
                }
                if ( dataObject.timestamp_ != timestamp_ )
                {
                    return false;
                }
                if ( dataObject.storeReceivedSentences_ != storeReceivedSentences_ )
                {
                    return false;
                }
                if ( dataObject.storeSentMessages_ != storeSentMessages_ )
                {
                    return false;
                }
                if ( dataObject.storeUnsentMessages_ != storeUnsentMessages_ )
                {
                    return false;
                }
                if ( dataObject.nMEA_ != nMEA_ )
                {
                    return false;
                }
                if ( dataObject.strictNMEA_ != strictNMEA_ )
                {
                    return false;
                }
                if ( dataObject.connectionType_ != connectionType_ )
                {
                    return false;
                }
                if ( dataObject.udpReceivePort_ != udpReceivePort_ )
                {
                    return false;
                }
                if ( dataObject.udpSendHostname_ != udpSendHostname_ )
                {
                    return false;
                }
                if ( dataObject.udpSendPort_ != udpSendPort_ )
                {
                    return false;
                }
                if ( dataObject.tcpHostname_ != tcpHostname_ )
                {
                    return false;
                }
                if ( dataObject.tcpPort_ != tcpPort_ )
                {
                    return false;
                }
                if ( dataObject.useHttpLogin_ != useHttpLogin_ )
                {
                    return false;
                }
                if ( dataObject.loginHostname_ != loginHostname_ )
                {
                    return false;
                }
                if ( dataObject.loginPort_ != loginPort_ )
                {
                    return false;
                }
                if ( dataObject.userName_ != userName_ )
                {
                    return false;
                }
                if ( dataObject.password_ != password_ )
                {
                    return false;
                }
                if ( dataObject.comPort_ != comPort_ )
                {
                    return false;
                }
                if ( dataObject.baudRate_ != baudRate_ )
                {
                    return false;
                }
                if ( dataObject.dataBits_ != dataBits_ )
                {
                    return false;
                }
                if ( dataObject.discardNull_ != discardNull_ )
                {
                    return false;
                }
                if ( dataObject.dtrEnable_ != dtrEnable_ )
                {
                    return false;
                }
                if ( dataObject.handshake_ != handshake_ )
                {
                    return false;
                }
                if ( dataObject.newLine_ != newLine_ )
                {
                    return false;
                }
                if ( dataObject.parity_ != parity_ )
                {
                    return false;
                }
                if ( dataObject.parityReplace_ != parityReplace_ )
                {
                    return false;
                }
                if ( dataObject.readBufferSize_ != readBufferSize_ )
                {
                    return false;
                }
                if ( dataObject.readTimeout_ != readTimeout_ )
                {
                    return false;
                }
                if ( dataObject.receivedBytesThreshold_ != receivedBytesThreshold_ )
                {
                    return false;
                }
                if ( dataObject.rtsEnable_ != rtsEnable_ )
                {
                    return false;
                }
                if ( dataObject.stopBits_ != stopBits_ )
                {
                    return false;
                }
                if ( dataObject.writeBufferSize_ != writeBufferSize_ )
                {
                    return false;
                }
                if ( dataObject.writeTimeout_ != writeTimeout_ )
                {
                    return false;
                }
                if ( dataObject.pairedComPort_ != pairedComPort_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        Int64 RowVersion( ) const
        {
            return rowVersion_;
        }
        void SetRowVersion( const Int64& rowVersion )
        {
            rowVersion_ = rowVersion;
        }
        const Guid& LineInputDevice( ) const
        {
            return lineInputDevice_;
        }
        void SetLineInputDevice( const Guid& lineInputDevice )
        {
            lineInputDevice_ = lineInputDevice;
        }
        const DateTime& Timestamp( ) const
        {
            return timestamp_;
        }
        void SetTimestamp( const DateTime& timestamp )
        {
            timestamp_ = timestamp;
        }
        bool StoreReceivedSentences( ) const
        {
            return storeReceivedSentences_;
        }
        void SetStoreReceivedSentences( bool storeReceivedSentences )
        {
            storeReceivedSentences_ = storeReceivedSentences;
        }
        bool StoreSentMessages( ) const
        {
            return storeSentMessages_;
        }
        void SetStoreSentMessages( bool storeSentMessages )
        {
            storeSentMessages_ = storeSentMessages;
        }
        bool StoreUnsentMessages( ) const
        {
            return storeUnsentMessages_;
        }
        void SetStoreUnsentMessages( bool storeUnsentMessages )
        {
            storeUnsentMessages_ = storeUnsentMessages;
        }
        bool NMEA( ) const
        {
            return nMEA_;
        }
        void SetNMEA( bool nMEA )
        {
            nMEA_ = nMEA;
        }
        bool StrictNMEA( ) const
        {
            return strictNMEA_;
        }
        void SetStrictNMEA( bool strictNMEA )
        {
            strictNMEA_ = strictNMEA;
        }
        Types::LineInputDeviceConnectionType ConnectionType( ) const
        {
            return connectionType_;
        }
        void SetConnectionType( Types::LineInputDeviceConnectionType connectionType )
        {
            connectionType_ = connectionType;
        }
        Int32 UdpReceivePort( ) const
        {
            return udpReceivePort_;
        }
        void SetUdpReceivePort( Int32 udpReceivePort )
        {
            udpReceivePort_ = udpReceivePort;
        }
        const FixedDBWideString<127>& UdpSendHostname( ) const
        {
            return udpSendHostname_;
        }
        void SetUdpSendHostname( const FixedDBWideString<127>& udpSendHostname )
        {
            udpSendHostname_ = udpSendHostname;
        }
        Int32 UdpSendPort( ) const
        {
            return udpSendPort_;
        }
        void SetUdpSendPort( Int32 udpSendPort )
        {
            udpSendPort_ = udpSendPort;
        }
        const FixedDBWideString<127>& TcpHostname( ) const
        {
            return tcpHostname_;
        }
        void SetTcpHostname( const FixedDBWideString<127>& tcpHostname )
        {
            tcpHostname_ = tcpHostname;
        }
        Int32 TcpPort( ) const
        {
            return tcpPort_;
        }
        void SetTcpPort( Int32 tcpPort )
        {
            tcpPort_ = tcpPort;
        }
        bool UseHttpLogin( ) const
        {
            return useHttpLogin_;
        }
        void SetUseHttpLogin( bool useHttpLogin )
        {
            useHttpLogin_ = useHttpLogin;
        }
        const FixedDBWideString<127>& LoginHostname( ) const
        {
            return loginHostname_;
        }
        void SetLoginHostname( const FixedDBWideString<127>& loginHostname )
        {
            loginHostname_ = loginHostname;
        }
        Int32 LoginPort( ) const
        {
            return loginPort_;
        }
        void SetLoginPort( Int32 loginPort )
        {
            loginPort_ = loginPort;
        }
        const FixedDBWideString<127>& UserName( ) const
        {
            return userName_;
        }
        void SetUserName( const FixedDBWideString<127>& userName )
        {
            userName_ = userName;
        }
        const FixedDBWideString<127>& Password( ) const
        {
            return password_;
        }
        void SetPassword( const FixedDBWideString<127>& password )
        {
            password_ = password;
        }
        const FixedDBWideString<127>& ComPort( ) const
        {
            return comPort_;
        }
        void SetComPort( const FixedDBWideString<127>& comPort )
        {
            comPort_ = comPort;
        }
        Int32 BaudRate( ) const
        {
            return baudRate_;
        }
        void SetBaudRate( Int32 baudRate )
        {
            baudRate_ = baudRate;
        }
        Int32 DataBits( ) const
        {
            return dataBits_;
        }
        void SetDataBits( Int32 dataBits )
        {
            dataBits_ = dataBits;
        }
        bool DiscardNull( ) const
        {
            return discardNull_;
        }
        void SetDiscardNull( bool discardNull )
        {
            discardNull_ = discardNull;
        }
        bool DtrEnable( ) const
        {
            return dtrEnable_;
        }
        void SetDtrEnable( bool dtrEnable )
        {
            dtrEnable_ = dtrEnable;
        }
        Types::Handshake Handshake( ) const
        {
            return handshake_;
        }
        void SetHandshake( Types::Handshake handshake )
        {
            handshake_ = handshake;
        }
        const FixedDBWideString<127>& NewLine( ) const
        {
            return newLine_;
        }
        void SetNewLine( const FixedDBWideString<127>& newLine )
        {
            newLine_ = newLine;
        }
        Types::Parity Parity( ) const
        {
            return parity_;
        }
        void SetParity( Types::Parity parity )
        {
            parity_ = parity;
        }
        Byte ParityReplace( ) const
        {
            return parityReplace_;
        }
        void SetParityReplace( Byte parityReplace )
        {
            parityReplace_ = parityReplace;
        }
        Int32 ReadBufferSize( ) const
        {
            return readBufferSize_;
        }
        void SetReadBufferSize( Int32 readBufferSize )
        {
            readBufferSize_ = readBufferSize;
        }
        const TimeSpan& ReadTimeout( ) const
        {
            return readTimeout_;
        }
        void SetReadTimeout( const TimeSpan& readTimeout )
        {
            readTimeout_ = readTimeout;
        }
        Int32 ReceivedBytesThreshold( ) const
        {
            return receivedBytesThreshold_;
        }
        void SetReceivedBytesThreshold( Int32 receivedBytesThreshold )
        {
            receivedBytesThreshold_ = receivedBytesThreshold;
        }
        bool RtsEnable( ) const
        {
            return rtsEnable_;
        }
        void SetRtsEnable( bool rtsEnable )
        {
            rtsEnable_ = rtsEnable;
        }
        Types::StopBits StopBits( ) const
        {
            return stopBits_;
        }
        void SetStopBits( Types::StopBits stopBits )
        {
            stopBits_ = stopBits;
        }
        Int32 WriteBufferSize( ) const
        {
            return writeBufferSize_;
        }
        void SetWriteBufferSize( Int32 writeBufferSize )
        {
            writeBufferSize_ = writeBufferSize;
        }
        const TimeSpan& WriteTimeout( ) const
        {
            return writeTimeout_;
        }
        void SetWriteTimeout( const TimeSpan& writeTimeout )
        {
            writeTimeout_ = writeTimeout;
        }
        const FixedDBWideString<127>& PairedComPort( ) const
        {
            return pairedComPort_;
        }
        void SetPairedComPort( const FixedDBWideString<127>& pairedComPort )
        {
            pairedComPort_ = pairedComPort;
        }
    };
    class LineInputMessageRoutingObject : public BaseData<Kind, Guid>
    {
    public:
        using Base = BaseData<Kind, Guid>;
        static constexpr Kind KIND = Kind::LineInputMessageRouting;
    private:
        Int64 rowVersion_ = 0;
        Guid lineInputDevice_;
        FixedDBWideString<127> type_;
    public:
        LineInputMessageRoutingObject( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(rowVersion_);
            destination.Write(lineInputDevice_);
            type_.WriteTo( destination );
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(rowVersion_);
            source.Read(lineInputDevice_);
            type_.ReadFrom( source );
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<LineInputMessageRoutingObject>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<LineInputMessageRoutingObject&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const LineInputMessageRoutingObject& >( other );
                if ( dataObject.rowVersion_ != rowVersion_ )
                {
                    return false;
                }
                if ( dataObject.lineInputDevice_ != lineInputDevice_ )
                {
                    return false;
                }
                if ( dataObject.type_ != type_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        Int64 RowVersion( ) const
        {
            return rowVersion_;
        }
        void SetRowVersion( const Int64& rowVersion )
        {
            rowVersion_ = rowVersion;
        }
        const Guid& LineInputDevice( ) const
        {
            return lineInputDevice_;
        }
        void SetLineInputDevice( const Guid& lineInputDevice )
        {
            lineInputDevice_ = lineInputDevice;
        }
        const FixedDBWideString<127>& Type( ) const
        {
            return type_;
        }
        void SetType( const FixedDBWideString<127>& type )
        {
            type_ = type;
        }
    };
    class LineInputMessageRoutingDestinationObject : public BaseData<Kind, Guid>
    {
    public:
        using Base = BaseData<Kind, Guid>;
        static constexpr Kind KIND = Kind::LineInputMessageRoutingDestination;
    private:
        Int64 rowVersion_ = 0;
        Guid routing_;
        Guid listener_;
    public:
        LineInputMessageRoutingDestinationObject( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(rowVersion_);
            destination.Write(routing_);
            destination.Write(listener_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(rowVersion_);
            source.Read(routing_);
            source.Read(listener_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<LineInputMessageRoutingDestinationObject>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<LineInputMessageRoutingDestinationObject&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const LineInputMessageRoutingDestinationObject& >( other );
                if ( dataObject.rowVersion_ != rowVersion_ )
                {
                    return false;
                }
                if ( dataObject.routing_ != routing_ )
                {
                    return false;
                }
                if ( dataObject.listener_ != listener_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        Int64 RowVersion( ) const
        {
            return rowVersion_;
        }
        void SetRowVersion( const Int64& rowVersion )
        {
            rowVersion_ = rowVersion;
        }
        const Guid& Routing( ) const
        {
            return routing_;
        }
        void SetRouting( const Guid& routing )
        {
            routing_ = routing;
        }
        const Guid& Listener( ) const
        {
            return listener_;
        }
        void SetListener( const Guid& listener )
        {
            listener_ = listener;
        }
    };
    class LineInputWhiteListEntryObject : public BaseData<Kind, Guid>
    {
    public:
        using Base = BaseData<Kind, Guid>;
        static constexpr Kind KIND = Kind::LineInputWhiteListEntry;
    private:
        Int64 rowVersion_ = 0;
        Guid lineInputDevice_;
        FixedDBWideString<128> hostName_;
        Int32 port_ = 0;
    public:
        LineInputWhiteListEntryObject( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(rowVersion_);
            destination.Write(lineInputDevice_);
            hostName_.WriteTo( destination );
            destination.Write(port_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(rowVersion_);
            source.Read(lineInputDevice_);
            hostName_.ReadFrom( source );
            source.Read(port_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<LineInputWhiteListEntryObject>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<LineInputWhiteListEntryObject&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const LineInputWhiteListEntryObject& >( other );
                if ( dataObject.rowVersion_ != rowVersion_ )
                {
                    return false;
                }
                if ( dataObject.lineInputDevice_ != lineInputDevice_ )
                {
                    return false;
                }
                if ( dataObject.hostName_ != hostName_ )
                {
                    return false;
                }
                if ( dataObject.port_ != port_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        Int64 RowVersion( ) const
        {
            return rowVersion_;
        }
        void SetRowVersion( const Int64& rowVersion )
        {
            rowVersion_ = rowVersion;
        }
        const Guid& LineInputDevice( ) const
        {
            return lineInputDevice_;
        }
        void SetLineInputDevice( const Guid& lineInputDevice )
        {
            lineInputDevice_ = lineInputDevice;
        }
        const FixedDBWideString<128>& HostName( ) const
        {
            return hostName_;
        }
        void SetHostName( const FixedDBWideString<128>& hostName )
        {
            hostName_ = hostName;
        }
        Int32 Port( ) const
        {
            return port_;
        }
        void SetPort( Int32 port )
        {
            port_ = port;
        }
    };
    class LogApplicationObject : public BaseData<Kind, Guid>
    {
    public:
        using Base = BaseData<Kind, Guid>;
        static constexpr Kind KIND = Kind::LogApplication;
    private:
        Int64 rowVersion_ = 0;
        FixedDBWideString<127> name_;
        WideString description_;
        SQLLEN descriptionLength_ = SQL_NULL_DATA;
    public:
        LogApplicationObject( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(rowVersion_);
            name_.WriteTo( destination );
            destination.Write(description_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(rowVersion_);
            name_.ReadFrom( source );
            source.Read(description_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<LogApplicationObject>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<LogApplicationObject&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const LogApplicationObject& >( other );
                if ( dataObject.rowVersion_ != rowVersion_ )
                {
                    return false;
                }
                if ( dataObject.name_ != name_ )
                {
                    return false;
                }
                if ( dataObject.description_ != description_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        Int64 RowVersion( ) const
        {
            return rowVersion_;
        }
        void SetRowVersion( const Int64& rowVersion )
        {
            rowVersion_ = rowVersion;
        }
        const FixedDBWideString<127>& Name( ) const
        {
            return name_;
        }
        void SetName( const FixedDBWideString<127>& name )
        {
            name_ = name;
        }
        const WideString& Description( ) const
        {
            return description_;
        }
        void SetDescription( const WideString& description )
        {
            description_ = description;
        }
    };
    class LogApplicationConfigurationObject : public BaseData<Kind, Guid>
    {
    public:
        using Base = BaseData<Kind, Guid>;
        static constexpr Kind KIND = Kind::LogApplicationConfiguration;
    private:
        Int64 rowVersion_ = 0;
        Guid application_;
        DateTime timestamp_;
        bool finest_ = false;
        bool finer_ = false;
        bool fine_ = false;
        bool info_ = false;
        bool notice_ = false;
        bool warn_ = false;
        bool error_ = false;
        bool severe_ = false;
        bool critical_ = false;
        bool alert_ = false;
        bool fatal_ = false;
        bool emergency_ = false;
    public:
        LogApplicationConfigurationObject( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(rowVersion_);
            destination.Write(application_);
            destination.Write(timestamp_);
            destination.Write(finest_);
            destination.Write(finer_);
            destination.Write(fine_);
            destination.Write(info_);
            destination.Write(notice_);
            destination.Write(warn_);
            destination.Write(error_);
            destination.Write(severe_);
            destination.Write(critical_);
            destination.Write(alert_);
            destination.Write(fatal_);
            destination.Write(emergency_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(rowVersion_);
            source.Read(application_);
            source.Read(timestamp_);
            source.Read(finest_);
            source.Read(finer_);
            source.Read(fine_);
            source.Read(info_);
            source.Read(notice_);
            source.Read(warn_);
            source.Read(error_);
            source.Read(severe_);
            source.Read(critical_);
            source.Read(alert_);
            source.Read(fatal_);
            source.Read(emergency_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<LogApplicationConfigurationObject>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<LogApplicationConfigurationObject&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const LogApplicationConfigurationObject& >( other );
                if ( dataObject.rowVersion_ != rowVersion_ )
                {
                    return false;
                }
                if ( dataObject.application_ != application_ )
                {
                    return false;
                }
                if ( dataObject.timestamp_ != timestamp_ )
                {
                    return false;
                }
                if ( dataObject.finest_ != finest_ )
                {
                    return false;
                }
                if ( dataObject.finer_ != finer_ )
                {
                    return false;
                }
                if ( dataObject.fine_ != fine_ )
                {
                    return false;
                }
                if ( dataObject.info_ != info_ )
                {
                    return false;
                }
                if ( dataObject.notice_ != notice_ )
                {
                    return false;
                }
                if ( dataObject.warn_ != warn_ )
                {
                    return false;
                }
                if ( dataObject.error_ != error_ )
                {
                    return false;
                }
                if ( dataObject.severe_ != severe_ )
                {
                    return false;
                }
                if ( dataObject.critical_ != critical_ )
                {
                    return false;
                }
                if ( dataObject.alert_ != alert_ )
                {
                    return false;
                }
                if ( dataObject.fatal_ != fatal_ )
                {
                    return false;
                }
                if ( dataObject.emergency_ != emergency_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        Int64 RowVersion( ) const
        {
            return rowVersion_;
        }
        void SetRowVersion( const Int64& rowVersion )
        {
            rowVersion_ = rowVersion;
        }
        const Guid& Application( ) const
        {
            return application_;
        }
        void SetApplication( const Guid& application )
        {
            application_ = application;
        }
        const DateTime& Timestamp( ) const
        {
            return timestamp_;
        }
        void SetTimestamp( const DateTime& timestamp )
        {
            timestamp_ = timestamp;
        }
        bool Finest( ) const
        {
            return finest_;
        }
        void SetFinest( bool finest )
        {
            finest_ = finest;
        }
        bool Finer( ) const
        {
            return finer_;
        }
        void SetFiner( bool finer )
        {
            finer_ = finer;
        }
        bool Fine( ) const
        {
            return fine_;
        }
        void SetFine( bool fine )
        {
            fine_ = fine;
        }
        bool Info( ) const
        {
            return info_;
        }
        void SetInfo( bool info )
        {
            info_ = info;
        }
        bool Notice( ) const
        {
            return notice_;
        }
        void SetNotice( bool notice )
        {
            notice_ = notice;
        }
        bool Warn( ) const
        {
            return warn_;
        }
        void SetWarn( bool warn )
        {
            warn_ = warn;
        }
        bool Error( ) const
        {
            return error_;
        }
        void SetError( bool error )
        {
            error_ = error;
        }
        bool Severe( ) const
        {
            return severe_;
        }
        void SetSevere( bool severe )
        {
            severe_ = severe;
        }
        bool Critical( ) const
        {
            return critical_;
        }
        void SetCritical( bool critical )
        {
            critical_ = critical;
        }
        bool Alert( ) const
        {
            return alert_;
        }
        void SetAlert( bool alert )
        {
            alert_ = alert;
        }
        bool Fatal( ) const
        {
            return fatal_;
        }
        void SetFatal( bool fatal )
        {
            fatal_ = fatal;
        }
        bool Emergency( ) const
        {
            return emergency_;
        }
        void SetEmergency( bool emergency )
        {
            emergency_ = emergency;
        }
    };
    class LogHostObject : public BaseData<Kind, Guid>
    {
    public:
        using Base = BaseData<Kind, Guid>;
        static constexpr Kind KIND = Kind::LogHost;
    private:
        Int64 rowVersion_ = 0;
        FixedDBWideString<127> computerName_;
        WideString description_;
        SQLLEN descriptionLength_ = SQL_NULL_DATA;
    public:
        LogHostObject( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(rowVersion_);
            computerName_.WriteTo( destination );
            destination.Write(description_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(rowVersion_);
            computerName_.ReadFrom( source );
            source.Read(description_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<LogHostObject>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<LogHostObject&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const LogHostObject& >( other );
                if ( dataObject.rowVersion_ != rowVersion_ )
                {
                    return false;
                }
                if ( dataObject.computerName_ != computerName_ )
                {
                    return false;
                }
                if ( dataObject.description_ != description_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        Int64 RowVersion( ) const
        {
            return rowVersion_;
        }
        void SetRowVersion( const Int64& rowVersion )
        {
            rowVersion_ = rowVersion;
        }
        const FixedDBWideString<127>& ComputerName( ) const
        {
            return computerName_;
        }
        void SetComputerName( const FixedDBWideString<127>& computerName )
        {
            computerName_ = computerName;
        }
        const WideString& Description( ) const
        {
            return description_;
        }
        void SetDescription( const WideString& description )
        {
            description_ = description;
        }
    };
    class LogHostConfigurationObject : public BaseData<Kind, Guid>
    {
    public:
        using Base = BaseData<Kind, Guid>;
        static constexpr Kind KIND = Kind::LogHostConfiguration;
    private:
        Int64 rowVersion_ = 0;
        Guid host_;
        DateTime timestamp_;
        bool finest_ = false;
        bool finer_ = false;
        bool fine_ = false;
        bool info_ = false;
        bool notice_ = false;
        bool warn_ = false;
        bool error_ = false;
        bool severe_ = false;
        bool critical_ = false;
        bool alert_ = false;
        bool fatal_ = false;
        bool emergency_ = false;
    public:
        LogHostConfigurationObject( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(rowVersion_);
            destination.Write(host_);
            destination.Write(timestamp_);
            destination.Write(finest_);
            destination.Write(finer_);
            destination.Write(fine_);
            destination.Write(info_);
            destination.Write(notice_);
            destination.Write(warn_);
            destination.Write(error_);
            destination.Write(severe_);
            destination.Write(critical_);
            destination.Write(alert_);
            destination.Write(fatal_);
            destination.Write(emergency_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(rowVersion_);
            source.Read(host_);
            source.Read(timestamp_);
            source.Read(finest_);
            source.Read(finer_);
            source.Read(fine_);
            source.Read(info_);
            source.Read(notice_);
            source.Read(warn_);
            source.Read(error_);
            source.Read(severe_);
            source.Read(critical_);
            source.Read(alert_);
            source.Read(fatal_);
            source.Read(emergency_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<LogHostConfigurationObject>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<LogHostConfigurationObject&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const LogHostConfigurationObject& >( other );
                if ( dataObject.rowVersion_ != rowVersion_ )
                {
                    return false;
                }
                if ( dataObject.host_ != host_ )
                {
                    return false;
                }
                if ( dataObject.timestamp_ != timestamp_ )
                {
                    return false;
                }
                if ( dataObject.finest_ != finest_ )
                {
                    return false;
                }
                if ( dataObject.finer_ != finer_ )
                {
                    return false;
                }
                if ( dataObject.fine_ != fine_ )
                {
                    return false;
                }
                if ( dataObject.info_ != info_ )
                {
                    return false;
                }
                if ( dataObject.notice_ != notice_ )
                {
                    return false;
                }
                if ( dataObject.warn_ != warn_ )
                {
                    return false;
                }
                if ( dataObject.error_ != error_ )
                {
                    return false;
                }
                if ( dataObject.severe_ != severe_ )
                {
                    return false;
                }
                if ( dataObject.critical_ != critical_ )
                {
                    return false;
                }
                if ( dataObject.alert_ != alert_ )
                {
                    return false;
                }
                if ( dataObject.fatal_ != fatal_ )
                {
                    return false;
                }
                if ( dataObject.emergency_ != emergency_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        Int64 RowVersion( ) const
        {
            return rowVersion_;
        }
        void SetRowVersion( const Int64& rowVersion )
        {
            rowVersion_ = rowVersion;
        }
        const Guid& Host( ) const
        {
            return host_;
        }
        void SetHost( const Guid& host )
        {
            host_ = host;
        }
        const DateTime& Timestamp( ) const
        {
            return timestamp_;
        }
        void SetTimestamp( const DateTime& timestamp )
        {
            timestamp_ = timestamp;
        }
        bool Finest( ) const
        {
            return finest_;
        }
        void SetFinest( bool finest )
        {
            finest_ = finest;
        }
        bool Finer( ) const
        {
            return finer_;
        }
        void SetFiner( bool finer )
        {
            finer_ = finer;
        }
        bool Fine( ) const
        {
            return fine_;
        }
        void SetFine( bool fine )
        {
            fine_ = fine;
        }
        bool Info( ) const
        {
            return info_;
        }
        void SetInfo( bool info )
        {
            info_ = info;
        }
        bool Notice( ) const
        {
            return notice_;
        }
        void SetNotice( bool notice )
        {
            notice_ = notice;
        }
        bool Warn( ) const
        {
            return warn_;
        }
        void SetWarn( bool warn )
        {
            warn_ = warn;
        }
        bool Error( ) const
        {
            return error_;
        }
        void SetError( bool error )
        {
            error_ = error;
        }
        bool Severe( ) const
        {
            return severe_;
        }
        void SetSevere( bool severe )
        {
            severe_ = severe;
        }
        bool Critical( ) const
        {
            return critical_;
        }
        void SetCritical( bool critical )
        {
            critical_ = critical;
        }
        bool Alert( ) const
        {
            return alert_;
        }
        void SetAlert( bool alert )
        {
            alert_ = alert;
        }
        bool Fatal( ) const
        {
            return fatal_;
        }
        void SetFatal( bool fatal )
        {
            fatal_ = fatal;
        }
        bool Emergency( ) const
        {
            return emergency_;
        }
        void SetEmergency( bool emergency )
        {
            emergency_ = emergency;
        }
    };
    class LogLocationObject : public BaseData<Kind, Guid>
    {
    public:
        using Base = BaseData<Kind, Guid>;
        static constexpr Kind KIND = Kind::LogLocation;
    private:
        Int64 rowVersion_ = 0;
        FixedDBWideString<260> fileName_;
        Int32 lineNumber_ = 0;
        WideString namespace_;
        SQLLEN namespaceLength_ = SQL_NULL_DATA;
        WideString className_;
        SQLLEN classNameLength_ = SQL_NULL_DATA;
        FixedDBWideString<255> methodName_;
    public:
        LogLocationObject( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(rowVersion_);
            fileName_.WriteTo( destination );
            destination.Write(lineNumber_);
            destination.Write(namespace_);
            destination.Write(className_);
            methodName_.WriteTo( destination );
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(rowVersion_);
            fileName_.ReadFrom( source );
            source.Read(lineNumber_);
            source.Read(namespace_);
            source.Read(className_);
            methodName_.ReadFrom( source );
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<LogLocationObject>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<LogLocationObject&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const LogLocationObject& >( other );
                if ( dataObject.rowVersion_ != rowVersion_ )
                {
                    return false;
                }
                if ( dataObject.fileName_ != fileName_ )
                {
                    return false;
                }
                if ( dataObject.lineNumber_ != lineNumber_ )
                {
                    return false;
                }
                if ( dataObject.namespace_ != namespace_ )
                {
                    return false;
                }
                if ( dataObject.className_ != className_ )
                {
                    return false;
                }
                if ( dataObject.methodName_ != methodName_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        Int64 RowVersion( ) const
        {
            return rowVersion_;
        }
        void SetRowVersion( const Int64& rowVersion )
        {
            rowVersion_ = rowVersion;
        }
        const FixedDBWideString<260>& FileName( ) const
        {
            return fileName_;
        }
        void SetFileName( const FixedDBWideString<260>& fileName )
        {
            fileName_ = fileName;
        }
        Int32 LineNumber( ) const
        {
            return lineNumber_;
        }
        void SetLineNumber( Int32 lineNumber )
        {
            lineNumber_ = lineNumber;
        }
        const WideString& Namespace( ) const
        {
            return namespace_;
        }
        void SetNamespace( const WideString& namespace__ )
        {
            namespace_ = namespace__;
        }
        const WideString& ClassName( ) const
        {
            return className_;
        }
        void SetClassName( const WideString& className )
        {
            className_ = className;
        }
        const FixedDBWideString<255>& MethodName( ) const
        {
            return methodName_;
        }
        void SetMethodName( const FixedDBWideString<255>& methodName )
        {
            methodName_ = methodName;
        }
    };
    class LogProcessObject : public BaseData<Kind, Guid>
    {
    public:
        using Base = BaseData<Kind, Guid>;
        static constexpr Kind KIND = Kind::LogProcess;
    private:
        Int64 rowVersion_ = 0;
        Guid application_;
        Guid host_;
        DateTime started_;
        DBDateTime stopped_;
        Int64 processId_ = 0;
        WideString path_;
        SQLLEN pathLength_ = SQL_NULL_DATA;
        FixedDBWideString<127> identity_;
    public:
        LogProcessObject( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(rowVersion_);
            destination.Write(application_);
            destination.Write(host_);
            destination.Write(started_);
            stopped_.WriteTo( destination );
            destination.Write(processId_);
            destination.Write(path_);
            identity_.WriteTo( destination );
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(rowVersion_);
            source.Read(application_);
            source.Read(host_);
            source.Read(started_);
            stopped_.ReadFrom( source );
            source.Read(processId_);
            source.Read(path_);
            identity_.ReadFrom( source );
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<LogProcessObject>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<LogProcessObject&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const LogProcessObject& >( other );
                if ( dataObject.rowVersion_ != rowVersion_ )
                {
                    return false;
                }
                if ( dataObject.application_ != application_ )
                {
                    return false;
                }
                if ( dataObject.host_ != host_ )
                {
                    return false;
                }
                if ( dataObject.started_ != started_ )
                {
                    return false;
                }
                if ( dataObject.stopped_ != stopped_ )
                {
                    return false;
                }
                if ( dataObject.processId_ != processId_ )
                {
                    return false;
                }
                if ( dataObject.path_ != path_ )
                {
                    return false;
                }
                if ( dataObject.identity_ != identity_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        Int64 RowVersion( ) const
        {
            return rowVersion_;
        }
        void SetRowVersion( const Int64& rowVersion )
        {
            rowVersion_ = rowVersion;
        }
        const Guid& Application( ) const
        {
            return application_;
        }
        void SetApplication( const Guid& application )
        {
            application_ = application;
        }
        const Guid& Host( ) const
        {
            return host_;
        }
        void SetHost( const Guid& host )
        {
            host_ = host;
        }
        const DateTime& Started( ) const
        {
            return started_;
        }
        void SetStarted( const DateTime& started )
        {
            started_ = started;
        }
        const DBDateTime& Stopped( ) const
        {
            return stopped_;
        }
        void SetStopped( const DBDateTime& stopped )
        {
            stopped_ = stopped;
        }
        Int64 ProcessId( ) const
        {
            return processId_;
        }
        void SetProcessId( Int64 processId )
        {
            processId_ = processId;
        }
        const WideString& Path( ) const
        {
            return path_;
        }
        void SetPath( const WideString& path )
        {
            path_ = path;
        }
        const FixedDBWideString<127>& Identity( ) const
        {
            return identity_;
        }
        void SetIdentity( const FixedDBWideString<127>& identity )
        {
            identity_ = identity;
        }
    };
    class LogRecordObject : public BaseData<Kind, Guid>
    {
    public:
        using Base = BaseData<Kind, Guid>;
        static constexpr Kind KIND = Kind::LogRecord;
    private:
        Int64 rowVersion_ = 0;
        Guid thread_;
        Int64 sequenceNumber_ = 0;
        Types::LogLevel level_ = Types::LogLevel::Unknown;
        DateTime timestamp_;
        Int32 depth_ = 0;
        Guid location_;
        WideString message_;
        SQLLEN messageLength_ = SQL_NULL_DATA;
        WideString exceptionString_;
        SQLLEN exceptionStringLength_ = SQL_NULL_DATA;
        Binary propertiesData_;
        SQLLEN propertiesDataLength_ = SQL_NULL_DATA;
    public:
        LogRecordObject( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(rowVersion_);
            destination.Write(thread_);
            destination.Write(sequenceNumber_);
            destination.Write(level_);
            destination.Write(timestamp_);
            destination.Write(depth_);
            destination.Write(location_);
            destination.Write(message_);
            destination.Write(exceptionString_);
            destination.Write(propertiesData_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(rowVersion_);
            source.Read(thread_);
            source.Read(sequenceNumber_);
            source.Read(level_);
            source.Read(timestamp_);
            source.Read(depth_);
            source.Read(location_);
            source.Read(message_);
            source.Read(exceptionString_);
            source.Read(propertiesData_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<LogRecordObject>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<LogRecordObject&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const LogRecordObject& >( other );
                if ( dataObject.rowVersion_ != rowVersion_ )
                {
                    return false;
                }
                if ( dataObject.thread_ != thread_ )
                {
                    return false;
                }
                if ( dataObject.sequenceNumber_ != sequenceNumber_ )
                {
                    return false;
                }
                if ( dataObject.level_ != level_ )
                {
                    return false;
                }
                if ( dataObject.timestamp_ != timestamp_ )
                {
                    return false;
                }
                if ( dataObject.depth_ != depth_ )
                {
                    return false;
                }
                if ( dataObject.location_ != location_ )
                {
                    return false;
                }
                if ( dataObject.message_ != message_ )
                {
                    return false;
                }
                if ( dataObject.exceptionString_ != exceptionString_ )
                {
                    return false;
                }
                if ( dataObject.propertiesData_ != propertiesData_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        Int64 RowVersion( ) const
        {
            return rowVersion_;
        }
        void SetRowVersion( const Int64& rowVersion )
        {
            rowVersion_ = rowVersion;
        }
        const Guid& Thread( ) const
        {
            return thread_;
        }
        void SetThread( const Guid& thread )
        {
            thread_ = thread;
        }
        Int64 SequenceNumber( ) const
        {
            return sequenceNumber_;
        }
        void SetSequenceNumber( Int64 sequenceNumber )
        {
            sequenceNumber_ = sequenceNumber;
        }
        Types::LogLevel Level( ) const
        {
            return level_;
        }
        void SetLevel( Types::LogLevel level )
        {
            level_ = level;
        }
        const DateTime& Timestamp( ) const
        {
            return timestamp_;
        }
        void SetTimestamp( const DateTime& timestamp )
        {
            timestamp_ = timestamp;
        }
        Int32 Depth( ) const
        {
            return depth_;
        }
        void SetDepth( Int32 depth )
        {
            depth_ = depth;
        }
        const Guid& Location( ) const
        {
            return location_;
        }
        void SetLocation( const Guid& location )
        {
            location_ = location;
        }
        const WideString& Message( ) const
        {
            return message_;
        }
        void SetMessage( const WideString& message )
        {
            message_ = message;
        }
        const WideString& ExceptionString( ) const
        {
            return exceptionString_;
        }
        void SetExceptionString( const WideString& exceptionString )
        {
            exceptionString_ = exceptionString;
        }
        const Binary& PropertiesData( ) const
        {
            return propertiesData_;
        }
        void SetPropertiesData( const Binary& propertiesData )
        {
            propertiesData_ = propertiesData;
        }
    };
    class LogThreadObject : public BaseData<Kind, Guid>
    {
    public:
        using Base = BaseData<Kind, Guid>;
        static constexpr Kind KIND = Kind::LogThread;
    private:
        Int64 rowVersion_ = 0;
        Guid process_;
        DateTime started_;
        DBDateTime stopped_;
        Int64 threadId_ = 0;
        FixedDBWideString<127> name_;
    public:
        LogThreadObject( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(rowVersion_);
            destination.Write(process_);
            destination.Write(started_);
            stopped_.WriteTo( destination );
            destination.Write(threadId_);
            name_.WriteTo( destination );
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(rowVersion_);
            source.Read(process_);
            source.Read(started_);
            stopped_.ReadFrom( source );
            source.Read(threadId_);
            name_.ReadFrom( source );
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<LogThreadObject>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<LogThreadObject&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const LogThreadObject& >( other );
                if ( dataObject.rowVersion_ != rowVersion_ )
                {
                    return false;
                }
                if ( dataObject.process_ != process_ )
                {
                    return false;
                }
                if ( dataObject.started_ != started_ )
                {
                    return false;
                }
                if ( dataObject.stopped_ != stopped_ )
                {
                    return false;
                }
                if ( dataObject.threadId_ != threadId_ )
                {
                    return false;
                }
                if ( dataObject.name_ != name_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        Int64 RowVersion( ) const
        {
            return rowVersion_;
        }
        void SetRowVersion( const Int64& rowVersion )
        {
            rowVersion_ = rowVersion;
        }
        const Guid& Process( ) const
        {
            return process_;
        }
        void SetProcess( const Guid& process )
        {
            process_ = process;
        }
        const DateTime& Started( ) const
        {
            return started_;
        }
        void SetStarted( const DateTime& started )
        {
            started_ = started;
        }
        const DBDateTime& Stopped( ) const
        {
            return stopped_;
        }
        void SetStopped( const DBDateTime& stopped )
        {
            stopped_ = stopped;
        }
        Int64 ThreadId( ) const
        {
            return threadId_;
        }
        void SetThreadId( Int64 threadId )
        {
            threadId_ = threadId;
        }
        const FixedDBWideString<127>& Name( ) const
        {
            return name_;
        }
        void SetName( const FixedDBWideString<127>& name )
        {
            name_ = name;
        }
    };
    class LogTraceEntryObject : public BaseData<Kind, Guid>
    {
    public:
        using Base = BaseData<Kind, Guid>;
        static constexpr Kind KIND = Kind::LogTraceEntry;
    private:
        Int64 rowVersion_ = 0;
        Guid thread_;
        Int64 sequenceNumber_ = 0;
        Guid location_;
        Int32 depth_ = 0;
        DateTime entered_;
        DBDateTime ended_;
    public:
        LogTraceEntryObject( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(rowVersion_);
            destination.Write(thread_);
            destination.Write(sequenceNumber_);
            destination.Write(location_);
            destination.Write(depth_);
            destination.Write(entered_);
            ended_.WriteTo( destination );
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(rowVersion_);
            source.Read(thread_);
            source.Read(sequenceNumber_);
            source.Read(location_);
            source.Read(depth_);
            source.Read(entered_);
            ended_.ReadFrom( source );
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<LogTraceEntryObject>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<LogTraceEntryObject&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const LogTraceEntryObject& >( other );
                if ( dataObject.rowVersion_ != rowVersion_ )
                {
                    return false;
                }
                if ( dataObject.thread_ != thread_ )
                {
                    return false;
                }
                if ( dataObject.sequenceNumber_ != sequenceNumber_ )
                {
                    return false;
                }
                if ( dataObject.location_ != location_ )
                {
                    return false;
                }
                if ( dataObject.depth_ != depth_ )
                {
                    return false;
                }
                if ( dataObject.entered_ != entered_ )
                {
                    return false;
                }
                if ( dataObject.ended_ != ended_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        Int64 RowVersion( ) const
        {
            return rowVersion_;
        }
        void SetRowVersion( const Int64& rowVersion )
        {
            rowVersion_ = rowVersion;
        }
        const Guid& Thread( ) const
        {
            return thread_;
        }
        void SetThread( const Guid& thread )
        {
            thread_ = thread;
        }
        Int64 SequenceNumber( ) const
        {
            return sequenceNumber_;
        }
        void SetSequenceNumber( Int64 sequenceNumber )
        {
            sequenceNumber_ = sequenceNumber;
        }
        const Guid& Location( ) const
        {
            return location_;
        }
        void SetLocation( const Guid& location )
        {
            location_ = location;
        }
        Int32 Depth( ) const
        {
            return depth_;
        }
        void SetDepth( Int32 depth )
        {
            depth_ = depth;
        }
        const DateTime& Entered( ) const
        {
            return entered_;
        }
        void SetEntered( const DateTime& entered )
        {
            entered_ = entered;
        }
        const DBDateTime& Ended( ) const
        {
            return ended_;
        }
        void SetEnded( const DBDateTime& ended )
        {
            ended_ = ended;
        }
    };
    class MapElementObject : public BaseData<Kind, Guid>
    {
    public:
        using Base = BaseData<Kind, Guid>;
        static constexpr Kind KIND = Kind::MapElement;
    private:
        Int64 rowVersion_ = 0;
        Guid item_;
        Types::MapElementType elementType_ = Types::MapElementType::Unknown;
        double latitude_ = 0.0;
        double longitude_ = 0.0;
        double angle_ = 0.0;
        double left_ = 0.0;
        double top_ = 0.0;
        double width_ = 0.0;
        double height_ = 0.0;
        FixedDBWideString<127> label_;
        Binary data_;
        SQLLEN dataLength_ = SQL_NULL_DATA;
    public:
        MapElementObject( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(rowVersion_);
            destination.Write(item_);
            destination.Write(elementType_);
            destination.Write(latitude_);
            destination.Write(longitude_);
            destination.Write(angle_);
            destination.Write(left_);
            destination.Write(top_);
            destination.Write(width_);
            destination.Write(height_);
            label_.WriteTo( destination );
            destination.Write(data_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(rowVersion_);
            source.Read(item_);
            source.Read(elementType_);
            source.Read(latitude_);
            source.Read(longitude_);
            source.Read(angle_);
            source.Read(left_);
            source.Read(top_);
            source.Read(width_);
            source.Read(height_);
            label_.ReadFrom( source );
            source.Read(data_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<MapElementObject>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<MapElementObject&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const MapElementObject& >( other );
                if ( dataObject.rowVersion_ != rowVersion_ )
                {
                    return false;
                }
                if ( dataObject.item_ != item_ )
                {
                    return false;
                }
                if ( dataObject.elementType_ != elementType_ )
                {
                    return false;
                }
                if ( dataObject.latitude_ != latitude_ )
                {
                    return false;
                }
                if ( dataObject.longitude_ != longitude_ )
                {
                    return false;
                }
                if ( dataObject.angle_ != angle_ )
                {
                    return false;
                }
                if ( dataObject.left_ != left_ )
                {
                    return false;
                }
                if ( dataObject.top_ != top_ )
                {
                    return false;
                }
                if ( dataObject.width_ != width_ )
                {
                    return false;
                }
                if ( dataObject.height_ != height_ )
                {
                    return false;
                }
                if ( dataObject.label_ != label_ )
                {
                    return false;
                }
                if ( dataObject.data_ != data_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        Int64 RowVersion( ) const
        {
            return rowVersion_;
        }
        void SetRowVersion( const Int64& rowVersion )
        {
            rowVersion_ = rowVersion;
        }
        const Guid& Item( ) const
        {
            return item_;
        }
        void SetItem( const Guid& item )
        {
            item_ = item;
        }
        Types::MapElementType ElementType( ) const
        {
            return elementType_;
        }
        void SetElementType( Types::MapElementType elementType )
        {
            elementType_ = elementType;
        }
        double Latitude( ) const
        {
            return latitude_;
        }
        void SetLatitude( double latitude )
        {
            latitude_ = latitude;
        }
        double Longitude( ) const
        {
            return longitude_;
        }
        void SetLongitude( double longitude )
        {
            longitude_ = longitude;
        }
        double Angle( ) const
        {
            return angle_;
        }
        void SetAngle( double angle )
        {
            angle_ = angle;
        }
        double Left( ) const
        {
            return left_;
        }
        void SetLeft( double left )
        {
            left_ = left;
        }
        double Top( ) const
        {
            return top_;
        }
        void SetTop( double top )
        {
            top_ = top;
        }
        double Width( ) const
        {
            return width_;
        }
        void SetWidth( double width )
        {
            width_ = width;
        }
        double Height( ) const
        {
            return height_;
        }
        void SetHeight( double height )
        {
            height_ = height;
        }
        const FixedDBWideString<127>& Label( ) const
        {
            return label_;
        }
        void SetLabel( const FixedDBWideString<127>& label )
        {
            label_ = label;
        }
        const Binary& Data( ) const
        {
            return data_;
        }
        void SetData( const Binary& data )
        {
            data_ = data;
        }
    };
    class MapInfoObject : public BaseData<Kind, Guid>
    {
    public:
        using Base = BaseData<Kind, Guid>;
        static constexpr Kind KIND = Kind::MapInfo;
    private:
        Int64 rowVersion_ = 0;
        Int32 scale_ = 0;
        double latitude_ = 0.0;
        double longitude_ = 0.0;
        double northWestLatitude_ = 0.0;
        double northWestLongitude_ = 0.0;
        double southEastLatitude_ = 0.0;
        double southEastLongitude_ = 0.0;
        Binary image_;
        SQLLEN imageLength_ = SQL_NULL_DATA;
    public:
        MapInfoObject( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(rowVersion_);
            destination.Write(scale_);
            destination.Write(latitude_);
            destination.Write(longitude_);
            destination.Write(northWestLatitude_);
            destination.Write(northWestLongitude_);
            destination.Write(southEastLatitude_);
            destination.Write(southEastLongitude_);
            destination.Write(image_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(rowVersion_);
            source.Read(scale_);
            source.Read(latitude_);
            source.Read(longitude_);
            source.Read(northWestLatitude_);
            source.Read(northWestLongitude_);
            source.Read(southEastLatitude_);
            source.Read(southEastLongitude_);
            source.Read(image_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<MapInfoObject>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<MapInfoObject&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const MapInfoObject& >( other );
                if ( dataObject.rowVersion_ != rowVersion_ )
                {
                    return false;
                }
                if ( dataObject.scale_ != scale_ )
                {
                    return false;
                }
                if ( dataObject.latitude_ != latitude_ )
                {
                    return false;
                }
                if ( dataObject.longitude_ != longitude_ )
                {
                    return false;
                }
                if ( dataObject.northWestLatitude_ != northWestLatitude_ )
                {
                    return false;
                }
                if ( dataObject.northWestLongitude_ != northWestLongitude_ )
                {
                    return false;
                }
                if ( dataObject.southEastLatitude_ != southEastLatitude_ )
                {
                    return false;
                }
                if ( dataObject.southEastLongitude_ != southEastLongitude_ )
                {
                    return false;
                }
                if ( dataObject.image_ != image_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        Int64 RowVersion( ) const
        {
            return rowVersion_;
        }
        void SetRowVersion( const Int64& rowVersion )
        {
            rowVersion_ = rowVersion;
        }
        Int32 Scale( ) const
        {
            return scale_;
        }
        void SetScale( Int32 scale )
        {
            scale_ = scale;
        }
        double Latitude( ) const
        {
            return latitude_;
        }
        void SetLatitude( double latitude )
        {
            latitude_ = latitude;
        }
        double Longitude( ) const
        {
            return longitude_;
        }
        void SetLongitude( double longitude )
        {
            longitude_ = longitude;
        }
        double NorthWestLatitude( ) const
        {
            return northWestLatitude_;
        }
        void SetNorthWestLatitude( double northWestLatitude )
        {
            northWestLatitude_ = northWestLatitude;
        }
        double NorthWestLongitude( ) const
        {
            return northWestLongitude_;
        }
        void SetNorthWestLongitude( double northWestLongitude )
        {
            northWestLongitude_ = northWestLongitude;
        }
        double SouthEastLatitude( ) const
        {
            return southEastLatitude_;
        }
        void SetSouthEastLatitude( double southEastLatitude )
        {
            southEastLatitude_ = southEastLatitude;
        }
        double SouthEastLongitude( ) const
        {
            return southEastLongitude_;
        }
        void SetSouthEastLongitude( double southEastLongitude )
        {
            southEastLongitude_ = southEastLongitude;
        }
        const Binary& Image( ) const
        {
            return image_;
        }
        void SetImage( const Binary& image )
        {
            image_ = image;
        }
    };
    class MapServiceOptionsObject : public BaseData<Kind, Guid>
    {
    public:
        using Base = BaseData<Kind, Guid>;
        static constexpr Kind KIND = Kind::MapServiceOptions;
    private:
        Int64 rowVersion_ = 0;
        DateTime timestamp_;
        FixedDBWideString<127> ipAddress_;
        Int32 port_ = 0;
        double imageScaleFactorX_ = 0.0;
        double imageOffsetX_ = 0.0;
        double imageScaleFactorY_ = 0.0;
        double imageOffsetY_ = 0.0;
    public:
        MapServiceOptionsObject( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(rowVersion_);
            destination.Write(timestamp_);
            ipAddress_.WriteTo( destination );
            destination.Write(port_);
            destination.Write(imageScaleFactorX_);
            destination.Write(imageOffsetX_);
            destination.Write(imageScaleFactorY_);
            destination.Write(imageOffsetY_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(rowVersion_);
            source.Read(timestamp_);
            ipAddress_.ReadFrom( source );
            source.Read(port_);
            source.Read(imageScaleFactorX_);
            source.Read(imageOffsetX_);
            source.Read(imageScaleFactorY_);
            source.Read(imageOffsetY_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<MapServiceOptionsObject>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<MapServiceOptionsObject&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const MapServiceOptionsObject& >( other );
                if ( dataObject.rowVersion_ != rowVersion_ )
                {
                    return false;
                }
                if ( dataObject.timestamp_ != timestamp_ )
                {
                    return false;
                }
                if ( dataObject.ipAddress_ != ipAddress_ )
                {
                    return false;
                }
                if ( dataObject.port_ != port_ )
                {
                    return false;
                }
                if ( dataObject.imageScaleFactorX_ != imageScaleFactorX_ )
                {
                    return false;
                }
                if ( dataObject.imageOffsetX_ != imageOffsetX_ )
                {
                    return false;
                }
                if ( dataObject.imageScaleFactorY_ != imageScaleFactorY_ )
                {
                    return false;
                }
                if ( dataObject.imageOffsetY_ != imageOffsetY_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        Int64 RowVersion( ) const
        {
            return rowVersion_;
        }
        void SetRowVersion( const Int64& rowVersion )
        {
            rowVersion_ = rowVersion;
        }
        const DateTime& Timestamp( ) const
        {
            return timestamp_;
        }
        void SetTimestamp( const DateTime& timestamp )
        {
            timestamp_ = timestamp;
        }
        const FixedDBWideString<127>& IpAddress( ) const
        {
            return ipAddress_;
        }
        void SetIpAddress( const FixedDBWideString<127>& ipAddress )
        {
            ipAddress_ = ipAddress;
        }
        Int32 Port( ) const
        {
            return port_;
        }
        void SetPort( Int32 port )
        {
            port_ = port;
        }
        double ImageScaleFactorX( ) const
        {
            return imageScaleFactorX_;
        }
        void SetImageScaleFactorX( double imageScaleFactorX )
        {
            imageScaleFactorX_ = imageScaleFactorX;
        }
        double ImageOffsetX( ) const
        {
            return imageOffsetX_;
        }
        void SetImageOffsetX( double imageOffsetX )
        {
            imageOffsetX_ = imageOffsetX;
        }
        double ImageScaleFactorY( ) const
        {
            return imageScaleFactorY_;
        }
        void SetImageScaleFactorY( double imageScaleFactorY )
        {
            imageScaleFactorY_ = imageScaleFactorY;
        }
        double ImageOffsetY( ) const
        {
            return imageOffsetY_;
        }
        void SetImageOffsetY( double imageOffsetY )
        {
            imageOffsetY_ = imageOffsetY;
        }
    };
    class MaritimeIdentificationDigitsObject : public BaseData<Kind, Guid>
    {
    public:
        using Base = BaseData<Kind, Guid>;
        static constexpr Kind KIND = Kind::MaritimeIdentificationDigits;
    private:
        Int64 rowVersion_ = 0;
        Int32 code_ = 0;
        Guid country_;
    public:
        MaritimeIdentificationDigitsObject( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(rowVersion_);
            destination.Write(code_);
            destination.Write(country_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(rowVersion_);
            source.Read(code_);
            source.Read(country_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<MaritimeIdentificationDigitsObject>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<MaritimeIdentificationDigitsObject&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const MaritimeIdentificationDigitsObject& >( other );
                if ( dataObject.rowVersion_ != rowVersion_ )
                {
                    return false;
                }
                if ( dataObject.code_ != code_ )
                {
                    return false;
                }
                if ( dataObject.country_ != country_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        Int64 RowVersion( ) const
        {
            return rowVersion_;
        }
        void SetRowVersion( const Int64& rowVersion )
        {
            rowVersion_ = rowVersion;
        }
        Int32 Code( ) const
        {
            return code_;
        }
        void SetCode( Int32 code )
        {
            code_ = code;
        }
        const Guid& Country( ) const
        {
            return country_;
        }
        void SetCountry( const Guid& country )
        {
            country_ = country;
        }
    };
    class MediaProxySessionObject : public BaseData<Kind, Guid>
    {
    public:
        using Base = BaseData<Kind, Guid>;
        static constexpr Kind KIND = Kind::MediaProxySession;
    private:
        Int64 rowVersion_ = 0;
        Guid service_;
        FixedDBWideString<128> name_;
        Guid enabledTimeseries_;
    public:
        MediaProxySessionObject( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(rowVersion_);
            destination.Write(service_);
            name_.WriteTo( destination );
            destination.Write(enabledTimeseries_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(rowVersion_);
            source.Read(service_);
            name_.ReadFrom( source );
            source.Read(enabledTimeseries_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<MediaProxySessionObject>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<MediaProxySessionObject&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const MediaProxySessionObject& >( other );
                if ( dataObject.rowVersion_ != rowVersion_ )
                {
                    return false;
                }
                if ( dataObject.service_ != service_ )
                {
                    return false;
                }
                if ( dataObject.name_ != name_ )
                {
                    return false;
                }
                if ( dataObject.enabledTimeseries_ != enabledTimeseries_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        Int64 RowVersion( ) const
        {
            return rowVersion_;
        }
        void SetRowVersion( const Int64& rowVersion )
        {
            rowVersion_ = rowVersion;
        }
        const Guid& Service( ) const
        {
            return service_;
        }
        void SetService( const Guid& service )
        {
            service_ = service;
        }
        const FixedDBWideString<128>& Name( ) const
        {
            return name_;
        }
        void SetName( const FixedDBWideString<128>& name )
        {
            name_ = name;
        }
        const Guid& EnabledTimeseries( ) const
        {
            return enabledTimeseries_;
        }
        void SetEnabledTimeseries( const Guid& enabledTimeseries )
        {
            enabledTimeseries_ = enabledTimeseries;
        }
    };
    class MediaProxySessionFileObject : public BaseData<Kind, Guid>
    {
    public:
        using Base = BaseData<Kind, Guid>;
        static constexpr Kind KIND = Kind::MediaProxySessionFile;
    private:
        Int64 rowVersion_ = 0;
        Guid proxySession_;
        DateTime timestamp_;
        FixedDBWideString<127> streamName_;
    public:
        MediaProxySessionFileObject( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(rowVersion_);
            destination.Write(proxySession_);
            destination.Write(timestamp_);
            streamName_.WriteTo( destination );
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(rowVersion_);
            source.Read(proxySession_);
            source.Read(timestamp_);
            streamName_.ReadFrom( source );
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<MediaProxySessionFileObject>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<MediaProxySessionFileObject&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const MediaProxySessionFileObject& >( other );
                if ( dataObject.rowVersion_ != rowVersion_ )
                {
                    return false;
                }
                if ( dataObject.proxySession_ != proxySession_ )
                {
                    return false;
                }
                if ( dataObject.timestamp_ != timestamp_ )
                {
                    return false;
                }
                if ( dataObject.streamName_ != streamName_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        Int64 RowVersion( ) const
        {
            return rowVersion_;
        }
        void SetRowVersion( const Int64& rowVersion )
        {
            rowVersion_ = rowVersion;
        }
        const Guid& ProxySession( ) const
        {
            return proxySession_;
        }
        void SetProxySession( const Guid& proxySession )
        {
            proxySession_ = proxySession;
        }
        const DateTime& Timestamp( ) const
        {
            return timestamp_;
        }
        void SetTimestamp( const DateTime& timestamp )
        {
            timestamp_ = timestamp;
        }
        const FixedDBWideString<127>& StreamName( ) const
        {
            return streamName_;
        }
        void SetStreamName( const FixedDBWideString<127>& streamName )
        {
            streamName_ = streamName;
        }
    };
    class MediaProxySessionOptionsObject : public BaseData<Kind, Guid>
    {
    public:
        using Base = BaseData<Kind, Guid>;
        static constexpr Kind KIND = Kind::MediaProxySessionOptions;
    private:
        Int64 rowVersion_ = 0;
        Guid proxySession_;
        DateTime timestamp_;
        FixedDBWideString<255> sourceStreamUrl_;
        FixedDBWideString<255> streamName_;
        Types::MediaProxySessionMode mode_ = Types::MediaProxySessionMode::Unknown;
        Int32 tunnelOverHTTPPortNumber_ = 0;
        FixedDBWideString<128> username_;
        FixedDBWideString<128> password_;
        Int32 recorderPortNumber_ = 0;
        Types::MediaProxySessionType sessionType_ = Types::MediaProxySessionType::Unknown;
        TimeSpan maxFileTime_;
        TimeSpan maxFileRetention_;
        FixedDBWideString<260> videoDirectory_;
    public:
        MediaProxySessionOptionsObject( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(rowVersion_);
            destination.Write(proxySession_);
            destination.Write(timestamp_);
            sourceStreamUrl_.WriteTo( destination );
            streamName_.WriteTo( destination );
            destination.Write(mode_);
            destination.Write(tunnelOverHTTPPortNumber_);
            username_.WriteTo( destination );
            password_.WriteTo( destination );
            destination.Write(recorderPortNumber_);
            destination.Write(sessionType_);
            destination.Write(maxFileTime_);
            destination.Write(maxFileRetention_);
            videoDirectory_.WriteTo( destination );
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(rowVersion_);
            source.Read(proxySession_);
            source.Read(timestamp_);
            sourceStreamUrl_.ReadFrom( source );
            streamName_.ReadFrom( source );
            source.Read(mode_);
            source.Read(tunnelOverHTTPPortNumber_);
            username_.ReadFrom( source );
            password_.ReadFrom( source );
            source.Read(recorderPortNumber_);
            source.Read(sessionType_);
            source.Read(maxFileTime_);
            source.Read(maxFileRetention_);
            videoDirectory_.ReadFrom( source );
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<MediaProxySessionOptionsObject>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<MediaProxySessionOptionsObject&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const MediaProxySessionOptionsObject& >( other );
                if ( dataObject.rowVersion_ != rowVersion_ )
                {
                    return false;
                }
                if ( dataObject.proxySession_ != proxySession_ )
                {
                    return false;
                }
                if ( dataObject.timestamp_ != timestamp_ )
                {
                    return false;
                }
                if ( dataObject.sourceStreamUrl_ != sourceStreamUrl_ )
                {
                    return false;
                }
                if ( dataObject.streamName_ != streamName_ )
                {
                    return false;
                }
                if ( dataObject.mode_ != mode_ )
                {
                    return false;
                }
                if ( dataObject.tunnelOverHTTPPortNumber_ != tunnelOverHTTPPortNumber_ )
                {
                    return false;
                }
                if ( dataObject.username_ != username_ )
                {
                    return false;
                }
                if ( dataObject.password_ != password_ )
                {
                    return false;
                }
                if ( dataObject.recorderPortNumber_ != recorderPortNumber_ )
                {
                    return false;
                }
                if ( dataObject.sessionType_ != sessionType_ )
                {
                    return false;
                }
                if ( dataObject.maxFileTime_ != maxFileTime_ )
                {
                    return false;
                }
                if ( dataObject.maxFileRetention_ != maxFileRetention_ )
                {
                    return false;
                }
                if ( dataObject.videoDirectory_ != videoDirectory_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        Int64 RowVersion( ) const
        {
            return rowVersion_;
        }
        void SetRowVersion( const Int64& rowVersion )
        {
            rowVersion_ = rowVersion;
        }
        const Guid& ProxySession( ) const
        {
            return proxySession_;
        }
        void SetProxySession( const Guid& proxySession )
        {
            proxySession_ = proxySession;
        }
        const DateTime& Timestamp( ) const
        {
            return timestamp_;
        }
        void SetTimestamp( const DateTime& timestamp )
        {
            timestamp_ = timestamp;
        }
        const FixedDBWideString<255>& SourceStreamUrl( ) const
        {
            return sourceStreamUrl_;
        }
        void SetSourceStreamUrl( const FixedDBWideString<255>& sourceStreamUrl )
        {
            sourceStreamUrl_ = sourceStreamUrl;
        }
        const FixedDBWideString<255>& StreamName( ) const
        {
            return streamName_;
        }
        void SetStreamName( const FixedDBWideString<255>& streamName )
        {
            streamName_ = streamName;
        }
        Types::MediaProxySessionMode Mode( ) const
        {
            return mode_;
        }
        void SetMode( Types::MediaProxySessionMode mode )
        {
            mode_ = mode;
        }
        Int32 TunnelOverHTTPPortNumber( ) const
        {
            return tunnelOverHTTPPortNumber_;
        }
        void SetTunnelOverHTTPPortNumber( Int32 tunnelOverHTTPPortNumber )
        {
            tunnelOverHTTPPortNumber_ = tunnelOverHTTPPortNumber;
        }
        const FixedDBWideString<128>& Username( ) const
        {
            return username_;
        }
        void SetUsername( const FixedDBWideString<128>& username )
        {
            username_ = username;
        }
        const FixedDBWideString<128>& Password( ) const
        {
            return password_;
        }
        void SetPassword( const FixedDBWideString<128>& password )
        {
            password_ = password;
        }
        Int32 RecorderPortNumber( ) const
        {
            return recorderPortNumber_;
        }
        void SetRecorderPortNumber( Int32 recorderPortNumber )
        {
            recorderPortNumber_ = recorderPortNumber;
        }
        Types::MediaProxySessionType SessionType( ) const
        {
            return sessionType_;
        }
        void SetSessionType( Types::MediaProxySessionType sessionType )
        {
            sessionType_ = sessionType;
        }
        const TimeSpan& MaxFileTime( ) const
        {
            return maxFileTime_;
        }
        void SetMaxFileTime( const TimeSpan& maxFileTime )
        {
            maxFileTime_ = maxFileTime;
        }
        const TimeSpan& MaxFileRetention( ) const
        {
            return maxFileRetention_;
        }
        void SetMaxFileRetention( const TimeSpan& maxFileRetention )
        {
            maxFileRetention_ = maxFileRetention;
        }
        const FixedDBWideString<260>& VideoDirectory( ) const
        {
            return videoDirectory_;
        }
        void SetVideoDirectory( const FixedDBWideString<260>& videoDirectory )
        {
            videoDirectory_ = videoDirectory;
        }
    };
    class MediaServiceObject : public BaseData<Kind, Guid>
    {
    public:
        using Base = BaseData<Kind, Guid>;
        static constexpr Kind KIND = Kind::MediaService;
    private:
        Int64 rowVersion_ = 0;
        Guid enabledTimeseries_;
    public:
        MediaServiceObject( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(rowVersion_);
            destination.Write(enabledTimeseries_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(rowVersion_);
            source.Read(enabledTimeseries_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<MediaServiceObject>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<MediaServiceObject&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const MediaServiceObject& >( other );
                if ( dataObject.rowVersion_ != rowVersion_ )
                {
                    return false;
                }
                if ( dataObject.enabledTimeseries_ != enabledTimeseries_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        Int64 RowVersion( ) const
        {
            return rowVersion_;
        }
        void SetRowVersion( const Int64& rowVersion )
        {
            rowVersion_ = rowVersion;
        }
        const Guid& EnabledTimeseries( ) const
        {
            return enabledTimeseries_;
        }
        void SetEnabledTimeseries( const Guid& enabledTimeseries )
        {
            enabledTimeseries_ = enabledTimeseries;
        }
    };
    class MediaServiceOptionsObject : public BaseData<Kind, Guid>
    {
    public:
        using Base = BaseData<Kind, Guid>;
        static constexpr Kind KIND = Kind::MediaServiceOptions;
    private:
        Int64 rowVersion_ = 0;
        Guid mediaService_;
        DateTime timestamp_;
        Int32 rtspPortNumber_ = 0;
        Int32 httpPortNumber_ = 0;
    public:
        MediaServiceOptionsObject( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(rowVersion_);
            destination.Write(mediaService_);
            destination.Write(timestamp_);
            destination.Write(rtspPortNumber_);
            destination.Write(httpPortNumber_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(rowVersion_);
            source.Read(mediaService_);
            source.Read(timestamp_);
            source.Read(rtspPortNumber_);
            source.Read(httpPortNumber_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<MediaServiceOptionsObject>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<MediaServiceOptionsObject&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const MediaServiceOptionsObject& >( other );
                if ( dataObject.rowVersion_ != rowVersion_ )
                {
                    return false;
                }
                if ( dataObject.mediaService_ != mediaService_ )
                {
                    return false;
                }
                if ( dataObject.timestamp_ != timestamp_ )
                {
                    return false;
                }
                if ( dataObject.rtspPortNumber_ != rtspPortNumber_ )
                {
                    return false;
                }
                if ( dataObject.httpPortNumber_ != httpPortNumber_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        Int64 RowVersion( ) const
        {
            return rowVersion_;
        }
        void SetRowVersion( const Int64& rowVersion )
        {
            rowVersion_ = rowVersion;
        }
        const Guid& MediaService( ) const
        {
            return mediaService_;
        }
        void SetMediaService( const Guid& mediaService )
        {
            mediaService_ = mediaService;
        }
        const DateTime& Timestamp( ) const
        {
            return timestamp_;
        }
        void SetTimestamp( const DateTime& timestamp )
        {
            timestamp_ = timestamp;
        }
        Int32 RtspPortNumber( ) const
        {
            return rtspPortNumber_;
        }
        void SetRtspPortNumber( Int32 rtspPortNumber )
        {
            rtspPortNumber_ = rtspPortNumber;
        }
        Int32 HttpPortNumber( ) const
        {
            return httpPortNumber_;
        }
        void SetHttpPortNumber( Int32 httpPortNumber )
        {
            httpPortNumber_ = httpPortNumber;
        }
    };
    class NamespaceElementObject : public BaseData<Kind, Guid>
    {
    public:
        using Base = BaseData<Kind, Guid>;
        static constexpr Kind KIND = Kind::NamespaceElement;
    private:
        Int64 rowVersion_ = 0;
        Guid namespace_;
        FixedDBWideString<127> name_;
        WideString description_;
        SQLLEN descriptionLength_ = SQL_NULL_DATA;
    public:
        NamespaceElementObject( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(rowVersion_);
            destination.Write(namespace_);
            name_.WriteTo( destination );
            destination.Write(description_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(rowVersion_);
            source.Read(namespace_);
            name_.ReadFrom( source );
            source.Read(description_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<NamespaceElementObject>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<NamespaceElementObject&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const NamespaceElementObject& >( other );
                if ( dataObject.rowVersion_ != rowVersion_ )
                {
                    return false;
                }
                if ( dataObject.namespace_ != namespace_ )
                {
                    return false;
                }
                if ( dataObject.name_ != name_ )
                {
                    return false;
                }
                if ( dataObject.description_ != description_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        Int64 RowVersion( ) const
        {
            return rowVersion_;
        }
        void SetRowVersion( const Int64& rowVersion )
        {
            rowVersion_ = rowVersion;
        }
        const Guid& Namespace( ) const
        {
            return namespace_;
        }
        void SetNamespace( const Guid& namespace__ )
        {
            namespace_ = namespace__;
        }
        const FixedDBWideString<127>& Name( ) const
        {
            return name_;
        }
        void SetName( const FixedDBWideString<127>& name )
        {
            name_ = name;
        }
        const WideString& Description( ) const
        {
            return description_;
        }
        void SetDescription( const WideString& description )
        {
            description_ = description;
        }
    };
    class ElementTypeObject : public NamespaceElementObject
    {
    public:
        using Base = NamespaceElementObject;
        static constexpr Kind KIND = Kind::ElementType;
    private:
    public:
        ElementTypeObject( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<ElementTypeObject>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<ElementTypeObject&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const ElementTypeObject& >( other );
                return true;
            }
            return false;
        }
    };
    class NamespaceObject : public NamespaceElementObject
    {
    public:
        using Base = NamespaceElementObject;
        static constexpr Kind KIND = Kind::Namespace;
    private:
    public:
        NamespaceObject( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<NamespaceObject>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<NamespaceObject&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const NamespaceObject& >( other );
                return true;
            }
            return false;
        }
    };
    class OilSpillObject : public BaseData<Kind, Guid>
    {
    public:
        using Base = BaseData<Kind, Guid>;
        static constexpr Kind KIND = Kind::OilSpill;
    private:
        Int64 rowVersion_ = 0;
        Guid oilSpillDetector_;
        DateTime timestamp_;
        double oilArea_ = 0.0;
        Binary shape_;
        SQLLEN shapeLength_ = SQL_NULL_DATA;
        Binary bSI_;
        SQLLEN bSILength_ = SQL_NULL_DATA;
        Binary oil_;
        SQLLEN oilLength_ = SQL_NULL_DATA;
        Binary trace_;
        SQLLEN traceLength_ = SQL_NULL_DATA;
    public:
        OilSpillObject( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(rowVersion_);
            destination.Write(oilSpillDetector_);
            destination.Write(timestamp_);
            destination.Write(oilArea_);
            destination.Write(shape_);
            destination.Write(bSI_);
            destination.Write(oil_);
            destination.Write(trace_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(rowVersion_);
            source.Read(oilSpillDetector_);
            source.Read(timestamp_);
            source.Read(oilArea_);
            source.Read(shape_);
            source.Read(bSI_);
            source.Read(oil_);
            source.Read(trace_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<OilSpillObject>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<OilSpillObject&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const OilSpillObject& >( other );
                if ( dataObject.rowVersion_ != rowVersion_ )
                {
                    return false;
                }
                if ( dataObject.oilSpillDetector_ != oilSpillDetector_ )
                {
                    return false;
                }
                if ( dataObject.timestamp_ != timestamp_ )
                {
                    return false;
                }
                if ( dataObject.oilArea_ != oilArea_ )
                {
                    return false;
                }
                if ( dataObject.shape_ != shape_ )
                {
                    return false;
                }
                if ( dataObject.bSI_ != bSI_ )
                {
                    return false;
                }
                if ( dataObject.oil_ != oil_ )
                {
                    return false;
                }
                if ( dataObject.trace_ != trace_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        Int64 RowVersion( ) const
        {
            return rowVersion_;
        }
        void SetRowVersion( const Int64& rowVersion )
        {
            rowVersion_ = rowVersion;
        }
        const Guid& OilSpillDetector( ) const
        {
            return oilSpillDetector_;
        }
        void SetOilSpillDetector( const Guid& oilSpillDetector )
        {
            oilSpillDetector_ = oilSpillDetector;
        }
        const DateTime& Timestamp( ) const
        {
            return timestamp_;
        }
        void SetTimestamp( const DateTime& timestamp )
        {
            timestamp_ = timestamp;
        }
        double OilArea( ) const
        {
            return oilArea_;
        }
        void SetOilArea( double oilArea )
        {
            oilArea_ = oilArea;
        }
        const Binary& Shape( ) const
        {
            return shape_;
        }
        void SetShape( const Binary& shape )
        {
            shape_ = shape;
        }
        const Binary& BSI( ) const
        {
            return bSI_;
        }
        void SetBSI( const Binary& bSI )
        {
            bSI_ = bSI;
        }
        const Binary& Oil( ) const
        {
            return oil_;
        }
        void SetOil( const Binary& oil )
        {
            oil_ = oil;
        }
        const Binary& Trace( ) const
        {
            return trace_;
        }
        void SetTrace( const Binary& trace )
        {
            trace_ = trace;
        }
    };
    class OilSpillDetectorCommandObject : public BaseData<Kind, Guid>
    {
    public:
        using Base = BaseData<Kind, Guid>;
        static constexpr Kind KIND = Kind::OilSpillDetectorCommand;
    private:
        Int64 rowVersion_ = 0;
        Guid oilSpillDetector_;
        DateTime timestamp_;
        Types::DeviceCommandSourceType deviceCommandSourceType_ = Types::DeviceCommandSourceType::Unknown;
        Guid deviceCommandSourceId_;
        Guid reply_;
    public:
        OilSpillDetectorCommandObject( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(rowVersion_);
            destination.Write(oilSpillDetector_);
            destination.Write(timestamp_);
            destination.Write(deviceCommandSourceType_);
            destination.Write(deviceCommandSourceId_);
            destination.Write(reply_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(rowVersion_);
            source.Read(oilSpillDetector_);
            source.Read(timestamp_);
            source.Read(deviceCommandSourceType_);
            source.Read(deviceCommandSourceId_);
            source.Read(reply_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<OilSpillDetectorCommandObject>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<OilSpillDetectorCommandObject&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const OilSpillDetectorCommandObject& >( other );
                if ( dataObject.rowVersion_ != rowVersion_ )
                {
                    return false;
                }
                if ( dataObject.oilSpillDetector_ != oilSpillDetector_ )
                {
                    return false;
                }
                if ( dataObject.timestamp_ != timestamp_ )
                {
                    return false;
                }
                if ( dataObject.deviceCommandSourceType_ != deviceCommandSourceType_ )
                {
                    return false;
                }
                if ( dataObject.deviceCommandSourceId_ != deviceCommandSourceId_ )
                {
                    return false;
                }
                if ( dataObject.reply_ != reply_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        Int64 RowVersion( ) const
        {
            return rowVersion_;
        }
        void SetRowVersion( const Int64& rowVersion )
        {
            rowVersion_ = rowVersion;
        }
        const Guid& OilSpillDetector( ) const
        {
            return oilSpillDetector_;
        }
        void SetOilSpillDetector( const Guid& oilSpillDetector )
        {
            oilSpillDetector_ = oilSpillDetector;
        }
        const DateTime& Timestamp( ) const
        {
            return timestamp_;
        }
        void SetTimestamp( const DateTime& timestamp )
        {
            timestamp_ = timestamp;
        }
        Types::DeviceCommandSourceType DeviceCommandSourceType( ) const
        {
            return deviceCommandSourceType_;
        }
        void SetDeviceCommandSourceType( Types::DeviceCommandSourceType deviceCommandSourceType )
        {
            deviceCommandSourceType_ = deviceCommandSourceType;
        }
        const Guid& DeviceCommandSourceId( ) const
        {
            return deviceCommandSourceId_;
        }
        void SetDeviceCommandSourceId( const Guid& deviceCommandSourceId )
        {
            deviceCommandSourceId_ = deviceCommandSourceId;
        }
        const Guid& Reply( ) const
        {
            return reply_;
        }
        void SetReply( const Guid& reply )
        {
            reply_ = reply;
        }
    };
    class OilSpillDetectorCommandReplyObject : public BaseData<Kind, Guid>
    {
    public:
        using Base = BaseData<Kind, Guid>;
        static constexpr Kind KIND = Kind::OilSpillDetectorCommandReply;
    private:
        Int64 rowVersion_ = 0;
        Guid oilSpillDetector_;
        DateTime timestamp_;
        Guid command_;
        Types::DeviceCommandReplyStatus status_ = Types::DeviceCommandReplyStatus::Unknown;
        WideString message_;
        SQLLEN messageLength_ = SQL_NULL_DATA;
    public:
        OilSpillDetectorCommandReplyObject( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(rowVersion_);
            destination.Write(oilSpillDetector_);
            destination.Write(timestamp_);
            destination.Write(command_);
            destination.Write(status_);
            destination.Write(message_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(rowVersion_);
            source.Read(oilSpillDetector_);
            source.Read(timestamp_);
            source.Read(command_);
            source.Read(status_);
            source.Read(message_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<OilSpillDetectorCommandReplyObject>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<OilSpillDetectorCommandReplyObject&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const OilSpillDetectorCommandReplyObject& >( other );
                if ( dataObject.rowVersion_ != rowVersion_ )
                {
                    return false;
                }
                if ( dataObject.oilSpillDetector_ != oilSpillDetector_ )
                {
                    return false;
                }
                if ( dataObject.timestamp_ != timestamp_ )
                {
                    return false;
                }
                if ( dataObject.command_ != command_ )
                {
                    return false;
                }
                if ( dataObject.status_ != status_ )
                {
                    return false;
                }
                if ( dataObject.message_ != message_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        Int64 RowVersion( ) const
        {
            return rowVersion_;
        }
        void SetRowVersion( const Int64& rowVersion )
        {
            rowVersion_ = rowVersion;
        }
        const Guid& OilSpillDetector( ) const
        {
            return oilSpillDetector_;
        }
        void SetOilSpillDetector( const Guid& oilSpillDetector )
        {
            oilSpillDetector_ = oilSpillDetector;
        }
        const DateTime& Timestamp( ) const
        {
            return timestamp_;
        }
        void SetTimestamp( const DateTime& timestamp )
        {
            timestamp_ = timestamp;
        }
        const Guid& Command( ) const
        {
            return command_;
        }
        void SetCommand( const Guid& command )
        {
            command_ = command;
        }
        Types::DeviceCommandReplyStatus Status( ) const
        {
            return status_;
        }
        void SetStatus( Types::DeviceCommandReplyStatus status )
        {
            status_ = status;
        }
        const WideString& Message( ) const
        {
            return message_;
        }
        void SetMessage( const WideString& message )
        {
            message_ = message;
        }
    };
    class OilSpillDetectorConfigurationObject : public BaseData<Kind, Guid>
    {
    public:
        using Base = BaseData<Kind, Guid>;
        static constexpr Kind KIND = Kind::OilSpillDetectorConfiguration;
    private:
        Int64 rowVersion_ = 0;
        Guid oilSpillDetector_;
        DateTime timestamp_;
        double range_ = 0.0;
        double startAngle_ = 0.0;
        double endAngle_ = 0.0;
        double startRange_ = 0.0;
        double endRange_ = 0.0;
        Int32 updateRate_ = 0;
        TimeSpan statusSendTime_;
        bool drawBorder_ = false;
        Binary colors_;
        SQLLEN colorsLength_ = SQL_NULL_DATA;
        bool sendToServer_ = false;
        FixedDBWideString<260> directory_;
        bool transparentWater_ = false;
        bool savePictures_ = false;
        bool sendAsTarget_ = false;
        bool writeLog_ = false;
        FixedDBWideString<127> targetFilePrefix_;
        Guid targetMMSI_;
        double latitude_ = 0.0;
        double longitude_ = 0.0;
        bool testSourceEnabled_ = false;
        FixedDBWideString<127> proxyServer_;
        bool useProxyServer_ = false;
    public:
        OilSpillDetectorConfigurationObject( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(rowVersion_);
            destination.Write(oilSpillDetector_);
            destination.Write(timestamp_);
            destination.Write(range_);
            destination.Write(startAngle_);
            destination.Write(endAngle_);
            destination.Write(startRange_);
            destination.Write(endRange_);
            destination.Write(updateRate_);
            destination.Write(statusSendTime_);
            destination.Write(drawBorder_);
            destination.Write(colors_);
            destination.Write(sendToServer_);
            directory_.WriteTo( destination );
            destination.Write(transparentWater_);
            destination.Write(savePictures_);
            destination.Write(sendAsTarget_);
            destination.Write(writeLog_);
            targetFilePrefix_.WriteTo( destination );
            destination.Write(targetMMSI_);
            destination.Write(latitude_);
            destination.Write(longitude_);
            destination.Write(testSourceEnabled_);
            proxyServer_.WriteTo( destination );
            destination.Write(useProxyServer_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(rowVersion_);
            source.Read(oilSpillDetector_);
            source.Read(timestamp_);
            source.Read(range_);
            source.Read(startAngle_);
            source.Read(endAngle_);
            source.Read(startRange_);
            source.Read(endRange_);
            source.Read(updateRate_);
            source.Read(statusSendTime_);
            source.Read(drawBorder_);
            source.Read(colors_);
            source.Read(sendToServer_);
            directory_.ReadFrom( source );
            source.Read(transparentWater_);
            source.Read(savePictures_);
            source.Read(sendAsTarget_);
            source.Read(writeLog_);
            targetFilePrefix_.ReadFrom( source );
            source.Read(targetMMSI_);
            source.Read(latitude_);
            source.Read(longitude_);
            source.Read(testSourceEnabled_);
            proxyServer_.ReadFrom( source );
            source.Read(useProxyServer_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<OilSpillDetectorConfigurationObject>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<OilSpillDetectorConfigurationObject&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const OilSpillDetectorConfigurationObject& >( other );
                if ( dataObject.rowVersion_ != rowVersion_ )
                {
                    return false;
                }
                if ( dataObject.oilSpillDetector_ != oilSpillDetector_ )
                {
                    return false;
                }
                if ( dataObject.timestamp_ != timestamp_ )
                {
                    return false;
                }
                if ( dataObject.range_ != range_ )
                {
                    return false;
                }
                if ( dataObject.startAngle_ != startAngle_ )
                {
                    return false;
                }
                if ( dataObject.endAngle_ != endAngle_ )
                {
                    return false;
                }
                if ( dataObject.startRange_ != startRange_ )
                {
                    return false;
                }
                if ( dataObject.endRange_ != endRange_ )
                {
                    return false;
                }
                if ( dataObject.updateRate_ != updateRate_ )
                {
                    return false;
                }
                if ( dataObject.statusSendTime_ != statusSendTime_ )
                {
                    return false;
                }
                if ( dataObject.drawBorder_ != drawBorder_ )
                {
                    return false;
                }
                if ( dataObject.colors_ != colors_ )
                {
                    return false;
                }
                if ( dataObject.sendToServer_ != sendToServer_ )
                {
                    return false;
                }
                if ( dataObject.directory_ != directory_ )
                {
                    return false;
                }
                if ( dataObject.transparentWater_ != transparentWater_ )
                {
                    return false;
                }
                if ( dataObject.savePictures_ != savePictures_ )
                {
                    return false;
                }
                if ( dataObject.sendAsTarget_ != sendAsTarget_ )
                {
                    return false;
                }
                if ( dataObject.writeLog_ != writeLog_ )
                {
                    return false;
                }
                if ( dataObject.targetFilePrefix_ != targetFilePrefix_ )
                {
                    return false;
                }
                if ( dataObject.targetMMSI_ != targetMMSI_ )
                {
                    return false;
                }
                if ( dataObject.latitude_ != latitude_ )
                {
                    return false;
                }
                if ( dataObject.longitude_ != longitude_ )
                {
                    return false;
                }
                if ( dataObject.testSourceEnabled_ != testSourceEnabled_ )
                {
                    return false;
                }
                if ( dataObject.proxyServer_ != proxyServer_ )
                {
                    return false;
                }
                if ( dataObject.useProxyServer_ != useProxyServer_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        Int64 RowVersion( ) const
        {
            return rowVersion_;
        }
        void SetRowVersion( const Int64& rowVersion )
        {
            rowVersion_ = rowVersion;
        }
        const Guid& OilSpillDetector( ) const
        {
            return oilSpillDetector_;
        }
        void SetOilSpillDetector( const Guid& oilSpillDetector )
        {
            oilSpillDetector_ = oilSpillDetector;
        }
        const DateTime& Timestamp( ) const
        {
            return timestamp_;
        }
        void SetTimestamp( const DateTime& timestamp )
        {
            timestamp_ = timestamp;
        }
        double Range( ) const
        {
            return range_;
        }
        void SetRange( double range )
        {
            range_ = range;
        }
        double StartAngle( ) const
        {
            return startAngle_;
        }
        void SetStartAngle( double startAngle )
        {
            startAngle_ = startAngle;
        }
        double EndAngle( ) const
        {
            return endAngle_;
        }
        void SetEndAngle( double endAngle )
        {
            endAngle_ = endAngle;
        }
        double StartRange( ) const
        {
            return startRange_;
        }
        void SetStartRange( double startRange )
        {
            startRange_ = startRange;
        }
        double EndRange( ) const
        {
            return endRange_;
        }
        void SetEndRange( double endRange )
        {
            endRange_ = endRange;
        }
        Int32 UpdateRate( ) const
        {
            return updateRate_;
        }
        void SetUpdateRate( Int32 updateRate )
        {
            updateRate_ = updateRate;
        }
        const TimeSpan& StatusSendTime( ) const
        {
            return statusSendTime_;
        }
        void SetStatusSendTime( const TimeSpan& statusSendTime )
        {
            statusSendTime_ = statusSendTime;
        }
        bool DrawBorder( ) const
        {
            return drawBorder_;
        }
        void SetDrawBorder( bool drawBorder )
        {
            drawBorder_ = drawBorder;
        }
        const Binary& Colors( ) const
        {
            return colors_;
        }
        void SetColors( const Binary& colors )
        {
            colors_ = colors;
        }
        bool SendToServer( ) const
        {
            return sendToServer_;
        }
        void SetSendToServer( bool sendToServer )
        {
            sendToServer_ = sendToServer;
        }
        const FixedDBWideString<260>& Directory( ) const
        {
            return directory_;
        }
        void SetDirectory( const FixedDBWideString<260>& directory )
        {
            directory_ = directory;
        }
        bool TransparentWater( ) const
        {
            return transparentWater_;
        }
        void SetTransparentWater( bool transparentWater )
        {
            transparentWater_ = transparentWater;
        }
        bool SavePictures( ) const
        {
            return savePictures_;
        }
        void SetSavePictures( bool savePictures )
        {
            savePictures_ = savePictures;
        }
        bool SendAsTarget( ) const
        {
            return sendAsTarget_;
        }
        void SetSendAsTarget( bool sendAsTarget )
        {
            sendAsTarget_ = sendAsTarget;
        }
        bool WriteLog( ) const
        {
            return writeLog_;
        }
        void SetWriteLog( bool writeLog )
        {
            writeLog_ = writeLog;
        }
        const FixedDBWideString<127>& TargetFilePrefix( ) const
        {
            return targetFilePrefix_;
        }
        void SetTargetFilePrefix( const FixedDBWideString<127>& targetFilePrefix )
        {
            targetFilePrefix_ = targetFilePrefix;
        }
        const Guid& TargetMMSI( ) const
        {
            return targetMMSI_;
        }
        void SetTargetMMSI( const Guid& targetMMSI )
        {
            targetMMSI_ = targetMMSI;
        }
        double Latitude( ) const
        {
            return latitude_;
        }
        void SetLatitude( double latitude )
        {
            latitude_ = latitude;
        }
        double Longitude( ) const
        {
            return longitude_;
        }
        void SetLongitude( double longitude )
        {
            longitude_ = longitude;
        }
        bool TestSourceEnabled( ) const
        {
            return testSourceEnabled_;
        }
        void SetTestSourceEnabled( bool testSourceEnabled )
        {
            testSourceEnabled_ = testSourceEnabled;
        }
        const FixedDBWideString<127>& ProxyServer( ) const
        {
            return proxyServer_;
        }
        void SetProxyServer( const FixedDBWideString<127>& proxyServer )
        {
            proxyServer_ = proxyServer;
        }
        bool UseProxyServer( ) const
        {
            return useProxyServer_;
        }
        void SetUseProxyServer( bool useProxyServer )
        {
            useProxyServer_ = useProxyServer;
        }
    };
    class Position2DTimeseriesValueObject : public BaseData<Kind, Guid>
    {
    public:
        using Base = BaseData<Kind, Guid>;
        static constexpr Kind KIND = Kind::Position2DTimeseriesValue;
    private:
        Int64 rowVersion_ = 0;
        Guid timeseries_;
        DateTime timestamp_;
        DBDouble x_;
        DBDouble y_;
    public:
        Position2DTimeseriesValueObject( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(rowVersion_);
            destination.Write(timeseries_);
            destination.Write(timestamp_);
            x_.WriteTo( destination );
            y_.WriteTo( destination );
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(rowVersion_);
            source.Read(timeseries_);
            source.Read(timestamp_);
            x_.ReadFrom( source );
            y_.ReadFrom( source );
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<Position2DTimeseriesValueObject>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<Position2DTimeseriesValueObject&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const Position2DTimeseriesValueObject& >( other );
                if ( dataObject.rowVersion_ != rowVersion_ )
                {
                    return false;
                }
                if ( dataObject.timeseries_ != timeseries_ )
                {
                    return false;
                }
                if ( dataObject.timestamp_ != timestamp_ )
                {
                    return false;
                }
                if ( dataObject.x_ != x_ )
                {
                    return false;
                }
                if ( dataObject.y_ != y_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        Int64 RowVersion( ) const
        {
            return rowVersion_;
        }
        void SetRowVersion( const Int64& rowVersion )
        {
            rowVersion_ = rowVersion;
        }
        const Guid& Timeseries( ) const
        {
            return timeseries_;
        }
        void SetTimeseries( const Guid& timeseries )
        {
            timeseries_ = timeseries;
        }
        const DateTime& Timestamp( ) const
        {
            return timestamp_;
        }
        void SetTimestamp( const DateTime& timestamp )
        {
            timestamp_ = timestamp;
        }
        const DBDouble& X( ) const
        {
            return x_;
        }
        void SetX( const DBDouble& x )
        {
            x_ = x;
        }
        const DBDouble& Y( ) const
        {
            return y_;
        }
        void SetY( const DBDouble& y )
        {
            y_ = y;
        }
    };
    class Position3DTimeseriesValueObject : public BaseData<Kind, Guid>
    {
    public:
        using Base = BaseData<Kind, Guid>;
        static constexpr Kind KIND = Kind::Position3DTimeseriesValue;
    private:
        Int64 rowVersion_ = 0;
        Guid timeseries_;
        DateTime timestamp_;
        DBDouble x_;
        DBDouble y_;
        DBDouble z_;
    public:
        Position3DTimeseriesValueObject( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(rowVersion_);
            destination.Write(timeseries_);
            destination.Write(timestamp_);
            x_.WriteTo( destination );
            y_.WriteTo( destination );
            z_.WriteTo( destination );
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(rowVersion_);
            source.Read(timeseries_);
            source.Read(timestamp_);
            x_.ReadFrom( source );
            y_.ReadFrom( source );
            z_.ReadFrom( source );
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<Position3DTimeseriesValueObject>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<Position3DTimeseriesValueObject&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const Position3DTimeseriesValueObject& >( other );
                if ( dataObject.rowVersion_ != rowVersion_ )
                {
                    return false;
                }
                if ( dataObject.timeseries_ != timeseries_ )
                {
                    return false;
                }
                if ( dataObject.timestamp_ != timestamp_ )
                {
                    return false;
                }
                if ( dataObject.x_ != x_ )
                {
                    return false;
                }
                if ( dataObject.y_ != y_ )
                {
                    return false;
                }
                if ( dataObject.z_ != z_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        Int64 RowVersion( ) const
        {
            return rowVersion_;
        }
        void SetRowVersion( const Int64& rowVersion )
        {
            rowVersion_ = rowVersion;
        }
        const Guid& Timeseries( ) const
        {
            return timeseries_;
        }
        void SetTimeseries( const Guid& timeseries )
        {
            timeseries_ = timeseries;
        }
        const DateTime& Timestamp( ) const
        {
            return timestamp_;
        }
        void SetTimestamp( const DateTime& timestamp )
        {
            timestamp_ = timestamp;
        }
        const DBDouble& X( ) const
        {
            return x_;
        }
        void SetX( const DBDouble& x )
        {
            x_ = x;
        }
        const DBDouble& Y( ) const
        {
            return y_;
        }
        void SetY( const DBDouble& y )
        {
            y_ = y;
        }
        const DBDouble& Z( ) const
        {
            return z_;
        }
        void SetZ( const DBDouble& z )
        {
            z_ = z;
        }
    };
    class ProcessTrackValueResultObject : public BaseData<Kind, Guid>
    {
    public:
        using Base = BaseData<Kind, Guid>;
        static constexpr Kind KIND = Kind::ProcessTrackValueResult;
    private:
        Int64 rowVersion_ = 0;
        bool createdNewTrack_ = false;
        Guid trackId_;
    public:
        ProcessTrackValueResultObject( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(rowVersion_);
            destination.Write(createdNewTrack_);
            destination.Write(trackId_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(rowVersion_);
            source.Read(createdNewTrack_);
            source.Read(trackId_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<ProcessTrackValueResultObject>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<ProcessTrackValueResultObject&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const ProcessTrackValueResultObject& >( other );
                if ( dataObject.rowVersion_ != rowVersion_ )
                {
                    return false;
                }
                if ( dataObject.createdNewTrack_ != createdNewTrack_ )
                {
                    return false;
                }
                if ( dataObject.trackId_ != trackId_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        Int64 RowVersion( ) const
        {
            return rowVersion_;
        }
        void SetRowVersion( const Int64& rowVersion )
        {
            rowVersion_ = rowVersion;
        }
        bool CreatedNewTrack( ) const
        {
            return createdNewTrack_;
        }
        void SetCreatedNewTrack( bool createdNewTrack )
        {
            createdNewTrack_ = createdNewTrack;
        }
        const Guid& TrackId( ) const
        {
            return trackId_;
        }
        void SetTrackId( const Guid& trackId )
        {
            trackId_ = trackId;
        }
    };
    class PropertyObject : public BaseData<Kind, Guid>
    {
    public:
        using Base = BaseData<Kind, Guid>;
        static constexpr Kind KIND = Kind::Property;
    private:
        Int64 rowVersion_ = 0;
        Guid element_;
        Guid definition_;
    public:
        PropertyObject( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(rowVersion_);
            destination.Write(element_);
            destination.Write(definition_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(rowVersion_);
            source.Read(element_);
            source.Read(definition_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<PropertyObject>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<PropertyObject&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const PropertyObject& >( other );
                if ( dataObject.rowVersion_ != rowVersion_ )
                {
                    return false;
                }
                if ( dataObject.element_ != element_ )
                {
                    return false;
                }
                if ( dataObject.definition_ != definition_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        Int64 RowVersion( ) const
        {
            return rowVersion_;
        }
        void SetRowVersion( const Int64& rowVersion )
        {
            rowVersion_ = rowVersion;
        }
        const Guid& Element( ) const
        {
            return element_;
        }
        void SetElement( const Guid& element )
        {
            element_ = element;
        }
        const Guid& Definition( ) const
        {
            return definition_;
        }
        void SetDefinition( const Guid& definition )
        {
            definition_ = definition;
        }
    };
    class BinaryPropertyObject : public PropertyObject
    {
    public:
        using Base = PropertyObject;
        static constexpr Kind KIND = Kind::BinaryProperty;
    private:
        Binary value_;
        SQLLEN valueLength_ = SQL_NULL_DATA;
    public:
        BinaryPropertyObject( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(value_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(value_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<BinaryPropertyObject>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<BinaryPropertyObject&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const BinaryPropertyObject& >( other );
                if ( dataObject.value_ != value_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        const Binary& Value( ) const
        {
            return value_;
        }
        void SetValue( const Binary& value )
        {
            value_ = value;
        }
    };
    class BooleanPropertyObject : public PropertyObject
    {
    public:
        using Base = PropertyObject;
        static constexpr Kind KIND = Kind::BooleanProperty;
    private:
        bool value_ = false;
    public:
        BooleanPropertyObject( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(value_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(value_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<BooleanPropertyObject>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<BooleanPropertyObject&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const BooleanPropertyObject& >( other );
                if ( dataObject.value_ != value_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        bool Value( ) const
        {
            return value_;
        }
        void SetValue( bool value )
        {
            value_ = value;
        }
    };
    class BytePropertyObject : public PropertyObject
    {
    public:
        using Base = PropertyObject;
        static constexpr Kind KIND = Kind::ByteProperty;
    private:
        Byte value_ = 0;
    public:
        BytePropertyObject( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(value_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(value_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<BytePropertyObject>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<BytePropertyObject&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const BytePropertyObject& >( other );
                if ( dataObject.value_ != value_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        Byte Value( ) const
        {
            return value_;
        }
        void SetValue( Byte value )
        {
            value_ = value;
        }
    };
    class DateTimePropertyObject : public PropertyObject
    {
    public:
        using Base = PropertyObject;
        static constexpr Kind KIND = Kind::DateTimeProperty;
    private:
        DateTime value_;
    public:
        DateTimePropertyObject( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(value_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(value_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<DateTimePropertyObject>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<DateTimePropertyObject&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const DateTimePropertyObject& >( other );
                if ( dataObject.value_ != value_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        const DateTime& Value( ) const
        {
            return value_;
        }
        void SetValue( const DateTime& value )
        {
            value_ = value;
        }
    };
    class DoublePropertyObject : public PropertyObject
    {
    public:
        using Base = PropertyObject;
        static constexpr Kind KIND = Kind::DoubleProperty;
    private:
        double value_ = 0.0;
    public:
        DoublePropertyObject( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(value_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(value_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<DoublePropertyObject>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<DoublePropertyObject&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const DoublePropertyObject& >( other );
                if ( dataObject.value_ != value_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        double Value( ) const
        {
            return value_;
        }
        void SetValue( double value )
        {
            value_ = value;
        }
    };
    class GuidPropertyObject : public PropertyObject
    {
    public:
        using Base = PropertyObject;
        static constexpr Kind KIND = Kind::GuidProperty;
    private:
        Guid value_;
    public:
        GuidPropertyObject( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(value_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(value_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<GuidPropertyObject>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<GuidPropertyObject&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const GuidPropertyObject& >( other );
                if ( dataObject.value_ != value_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        const Guid& Value( ) const
        {
            return value_;
        }
        void SetValue( const Guid& value )
        {
            value_ = value;
        }
    };
    class Int16PropertyObject : public PropertyObject
    {
    public:
        using Base = PropertyObject;
        static constexpr Kind KIND = Kind::Int16Property;
    private:
        Int16 value_ = 0;
    public:
        Int16PropertyObject( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(value_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(value_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<Int16PropertyObject>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<Int16PropertyObject&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const Int16PropertyObject& >( other );
                if ( dataObject.value_ != value_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        Int16 Value( ) const
        {
            return value_;
        }
        void SetValue( Int16 value )
        {
            value_ = value;
        }
    };
    class Int32PropertyObject : public PropertyObject
    {
    public:
        using Base = PropertyObject;
        static constexpr Kind KIND = Kind::Int32Property;
    private:
        Int32 value_ = 0;
    public:
        Int32PropertyObject( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(value_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(value_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<Int32PropertyObject>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<Int32PropertyObject&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const Int32PropertyObject& >( other );
                if ( dataObject.value_ != value_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        Int32 Value( ) const
        {
            return value_;
        }
        void SetValue( Int32 value )
        {
            value_ = value;
        }
    };
    class Int64PropertyObject : public PropertyObject
    {
    public:
        using Base = PropertyObject;
        static constexpr Kind KIND = Kind::Int64Property;
    private:
        Int64 value_ = 0;
    public:
        Int64PropertyObject( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(value_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(value_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<Int64PropertyObject>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<Int64PropertyObject&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const Int64PropertyObject& >( other );
                if ( dataObject.value_ != value_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        Int64 Value( ) const
        {
            return value_;
        }
        void SetValue( Int64 value )
        {
            value_ = value;
        }
    };
    class ReferencePropertyObject : public PropertyObject
    {
    public:
        using Base = PropertyObject;
        static constexpr Kind KIND = Kind::ReferenceProperty;
    private:
        Guid value_;
    public:
        ReferencePropertyObject( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(value_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(value_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<ReferencePropertyObject>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<ReferencePropertyObject&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const ReferencePropertyObject& >( other );
                if ( dataObject.value_ != value_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        const Guid& Value( ) const
        {
            return value_;
        }
        void SetValue( const Guid& value )
        {
            value_ = value;
        }
    };
    class SBytePropertyObject : public PropertyObject
    {
    public:
        using Base = PropertyObject;
        static constexpr Kind KIND = Kind::SByteProperty;
    private:
        SByte value_ = 0;
    public:
        SBytePropertyObject( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(value_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(value_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<SBytePropertyObject>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<SBytePropertyObject&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const SBytePropertyObject& >( other );
                if ( dataObject.value_ != value_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        SByte Value( ) const
        {
            return value_;
        }
        void SetValue( SByte value )
        {
            value_ = value;
        }
    };
    class SinglePropertyObject : public PropertyObject
    {
    public:
        using Base = PropertyObject;
        static constexpr Kind KIND = Kind::SingleProperty;
    private:
        float value_ = 0.0f;
    public:
        SinglePropertyObject( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(value_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(value_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<SinglePropertyObject>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<SinglePropertyObject&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const SinglePropertyObject& >( other );
                if ( dataObject.value_ != value_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        float Value( ) const
        {
            return value_;
        }
        void SetValue( float value )
        {
            value_ = value;
        }
    };
    class StringPropertyObject : public PropertyObject
    {
    public:
        using Base = PropertyObject;
        static constexpr Kind KIND = Kind::StringProperty;
    private:
        FixedDBWideString<127> value_;
    public:
        StringPropertyObject( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            value_.WriteTo( destination );
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            value_.ReadFrom( source );
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<StringPropertyObject>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<StringPropertyObject&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const StringPropertyObject& >( other );
                if ( dataObject.value_ != value_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        const FixedDBWideString<127>& Value( ) const
        {
            return value_;
        }
        void SetValue( const FixedDBWideString<127>& value )
        {
            value_ = value;
        }
    };
    class TimeseriesPropertyObject : public PropertyObject
    {
    public:
        using Base = PropertyObject;
        static constexpr Kind KIND = Kind::TimeseriesProperty;
    private:
    public:
        TimeseriesPropertyObject( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<TimeseriesPropertyObject>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<TimeseriesPropertyObject&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const TimeseriesPropertyObject& >( other );
                return true;
            }
            return false;
        }
    };
    class BinaryTimeseriesPropertyObject : public TimeseriesPropertyObject
    {
    public:
        using Base = TimeseriesPropertyObject;
        static constexpr Kind KIND = Kind::BinaryTimeseriesProperty;
    private:
        Guid timeseries_;
    public:
        BinaryTimeseriesPropertyObject( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(timeseries_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(timeseries_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<BinaryTimeseriesPropertyObject>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<BinaryTimeseriesPropertyObject&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const BinaryTimeseriesPropertyObject& >( other );
                if ( dataObject.timeseries_ != timeseries_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        const Guid& Timeseries( ) const
        {
            return timeseries_;
        }
        void SetTimeseries( const Guid& timeseries )
        {
            timeseries_ = timeseries;
        }
    };
    class BooleanTimeseriesPropertyObject : public TimeseriesPropertyObject
    {
    public:
        using Base = TimeseriesPropertyObject;
        static constexpr Kind KIND = Kind::BooleanTimeseriesProperty;
    private:
        Guid timeseries_;
    public:
        BooleanTimeseriesPropertyObject( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(timeseries_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(timeseries_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<BooleanTimeseriesPropertyObject>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<BooleanTimeseriesPropertyObject&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const BooleanTimeseriesPropertyObject& >( other );
                if ( dataObject.timeseries_ != timeseries_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        const Guid& Timeseries( ) const
        {
            return timeseries_;
        }
        void SetTimeseries( const Guid& timeseries )
        {
            timeseries_ = timeseries;
        }
    };
    class ByteTimeseriesPropertyObject : public TimeseriesPropertyObject
    {
    public:
        using Base = TimeseriesPropertyObject;
        static constexpr Kind KIND = Kind::ByteTimeseriesProperty;
    private:
        Guid timeseries_;
    public:
        ByteTimeseriesPropertyObject( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(timeseries_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(timeseries_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<ByteTimeseriesPropertyObject>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<ByteTimeseriesPropertyObject&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const ByteTimeseriesPropertyObject& >( other );
                if ( dataObject.timeseries_ != timeseries_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        const Guid& Timeseries( ) const
        {
            return timeseries_;
        }
        void SetTimeseries( const Guid& timeseries )
        {
            timeseries_ = timeseries;
        }
    };
    class DateTimeTimeseriesPropertyObject : public TimeseriesPropertyObject
    {
    public:
        using Base = TimeseriesPropertyObject;
        static constexpr Kind KIND = Kind::DateTimeTimeseriesProperty;
    private:
        Guid timeseries_;
    public:
        DateTimeTimeseriesPropertyObject( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(timeseries_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(timeseries_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<DateTimeTimeseriesPropertyObject>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<DateTimeTimeseriesPropertyObject&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const DateTimeTimeseriesPropertyObject& >( other );
                if ( dataObject.timeseries_ != timeseries_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        const Guid& Timeseries( ) const
        {
            return timeseries_;
        }
        void SetTimeseries( const Guid& timeseries )
        {
            timeseries_ = timeseries;
        }
    };
    class DoubleTimeseriesPropertyObject : public TimeseriesPropertyObject
    {
    public:
        using Base = TimeseriesPropertyObject;
        static constexpr Kind KIND = Kind::DoubleTimeseriesProperty;
    private:
        Guid timeseries_;
    public:
        DoubleTimeseriesPropertyObject( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(timeseries_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(timeseries_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<DoubleTimeseriesPropertyObject>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<DoubleTimeseriesPropertyObject&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const DoubleTimeseriesPropertyObject& >( other );
                if ( dataObject.timeseries_ != timeseries_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        const Guid& Timeseries( ) const
        {
            return timeseries_;
        }
        void SetTimeseries( const Guid& timeseries )
        {
            timeseries_ = timeseries;
        }
    };
    class GuidTimeseriesPropertyObject : public TimeseriesPropertyObject
    {
    public:
        using Base = TimeseriesPropertyObject;
        static constexpr Kind KIND = Kind::GuidTimeseriesProperty;
    private:
        Guid timeseries_;
    public:
        GuidTimeseriesPropertyObject( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(timeseries_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(timeseries_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<GuidTimeseriesPropertyObject>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<GuidTimeseriesPropertyObject&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const GuidTimeseriesPropertyObject& >( other );
                if ( dataObject.timeseries_ != timeseries_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        const Guid& Timeseries( ) const
        {
            return timeseries_;
        }
        void SetTimeseries( const Guid& timeseries )
        {
            timeseries_ = timeseries;
        }
    };
    class Int16TimeseriesPropertyObject : public TimeseriesPropertyObject
    {
    public:
        using Base = TimeseriesPropertyObject;
        static constexpr Kind KIND = Kind::Int16TimeseriesProperty;
    private:
        Guid timeseries_;
    public:
        Int16TimeseriesPropertyObject( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(timeseries_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(timeseries_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<Int16TimeseriesPropertyObject>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<Int16TimeseriesPropertyObject&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const Int16TimeseriesPropertyObject& >( other );
                if ( dataObject.timeseries_ != timeseries_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        const Guid& Timeseries( ) const
        {
            return timeseries_;
        }
        void SetTimeseries( const Guid& timeseries )
        {
            timeseries_ = timeseries;
        }
    };
    class Int32TimeseriesPropertyObject : public TimeseriesPropertyObject
    {
    public:
        using Base = TimeseriesPropertyObject;
        static constexpr Kind KIND = Kind::Int32TimeseriesProperty;
    private:
        Guid timeseries_;
    public:
        Int32TimeseriesPropertyObject( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(timeseries_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(timeseries_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<Int32TimeseriesPropertyObject>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<Int32TimeseriesPropertyObject&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const Int32TimeseriesPropertyObject& >( other );
                if ( dataObject.timeseries_ != timeseries_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        const Guid& Timeseries( ) const
        {
            return timeseries_;
        }
        void SetTimeseries( const Guid& timeseries )
        {
            timeseries_ = timeseries;
        }
    };
    class Int64TimeseriesPropertyObject : public TimeseriesPropertyObject
    {
    public:
        using Base = TimeseriesPropertyObject;
        static constexpr Kind KIND = Kind::Int64TimeseriesProperty;
    private:
        Guid timeseries_;
    public:
        Int64TimeseriesPropertyObject( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(timeseries_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(timeseries_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<Int64TimeseriesPropertyObject>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<Int64TimeseriesPropertyObject&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const Int64TimeseriesPropertyObject& >( other );
                if ( dataObject.timeseries_ != timeseries_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        const Guid& Timeseries( ) const
        {
            return timeseries_;
        }
        void SetTimeseries( const Guid& timeseries )
        {
            timeseries_ = timeseries;
        }
    };
    class ReferenceTimeseriesPropertyObject : public TimeseriesPropertyObject
    {
    public:
        using Base = TimeseriesPropertyObject;
        static constexpr Kind KIND = Kind::ReferenceTimeseriesProperty;
    private:
        Guid timeseries_;
    public:
        ReferenceTimeseriesPropertyObject( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(timeseries_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(timeseries_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<ReferenceTimeseriesPropertyObject>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<ReferenceTimeseriesPropertyObject&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const ReferenceTimeseriesPropertyObject& >( other );
                if ( dataObject.timeseries_ != timeseries_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        const Guid& Timeseries( ) const
        {
            return timeseries_;
        }
        void SetTimeseries( const Guid& timeseries )
        {
            timeseries_ = timeseries;
        }
    };
    class SByteTimeseriesPropertyObject : public TimeseriesPropertyObject
    {
    public:
        using Base = TimeseriesPropertyObject;
        static constexpr Kind KIND = Kind::SByteTimeseriesProperty;
    private:
        Guid timeseries_;
    public:
        SByteTimeseriesPropertyObject( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(timeseries_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(timeseries_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<SByteTimeseriesPropertyObject>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<SByteTimeseriesPropertyObject&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const SByteTimeseriesPropertyObject& >( other );
                if ( dataObject.timeseries_ != timeseries_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        const Guid& Timeseries( ) const
        {
            return timeseries_;
        }
        void SetTimeseries( const Guid& timeseries )
        {
            timeseries_ = timeseries;
        }
    };
    class SingleTimeseriesPropertyObject : public TimeseriesPropertyObject
    {
    public:
        using Base = TimeseriesPropertyObject;
        static constexpr Kind KIND = Kind::SingleTimeseriesProperty;
    private:
        Guid timeseries_;
    public:
        SingleTimeseriesPropertyObject( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(timeseries_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(timeseries_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<SingleTimeseriesPropertyObject>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<SingleTimeseriesPropertyObject&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const SingleTimeseriesPropertyObject& >( other );
                if ( dataObject.timeseries_ != timeseries_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        const Guid& Timeseries( ) const
        {
            return timeseries_;
        }
        void SetTimeseries( const Guid& timeseries )
        {
            timeseries_ = timeseries;
        }
    };
    class StringTimeseriesPropertyObject : public TimeseriesPropertyObject
    {
    public:
        using Base = TimeseriesPropertyObject;
        static constexpr Kind KIND = Kind::StringTimeseriesProperty;
    private:
        Guid timeseries_;
    public:
        StringTimeseriesPropertyObject( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(timeseries_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(timeseries_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<StringTimeseriesPropertyObject>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<StringTimeseriesPropertyObject&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const StringTimeseriesPropertyObject& >( other );
                if ( dataObject.timeseries_ != timeseries_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        const Guid& Timeseries( ) const
        {
            return timeseries_;
        }
        void SetTimeseries( const Guid& timeseries )
        {
            timeseries_ = timeseries;
        }
    };
    class TimeSpanTimeseriesPropertyObject : public TimeseriesPropertyObject
    {
    public:
        using Base = TimeseriesPropertyObject;
        static constexpr Kind KIND = Kind::TimeSpanTimeseriesProperty;
    private:
        Guid timeseries_;
    public:
        TimeSpanTimeseriesPropertyObject( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(timeseries_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(timeseries_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<TimeSpanTimeseriesPropertyObject>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<TimeSpanTimeseriesPropertyObject&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const TimeSpanTimeseriesPropertyObject& >( other );
                if ( dataObject.timeseries_ != timeseries_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        const Guid& Timeseries( ) const
        {
            return timeseries_;
        }
        void SetTimeseries( const Guid& timeseries )
        {
            timeseries_ = timeseries;
        }
    };
    class UInt16TimeseriesPropertyObject : public TimeseriesPropertyObject
    {
    public:
        using Base = TimeseriesPropertyObject;
        static constexpr Kind KIND = Kind::UInt16TimeseriesProperty;
    private:
        Guid timeseries_;
    public:
        UInt16TimeseriesPropertyObject( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(timeseries_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(timeseries_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<UInt16TimeseriesPropertyObject>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<UInt16TimeseriesPropertyObject&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const UInt16TimeseriesPropertyObject& >( other );
                if ( dataObject.timeseries_ != timeseries_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        const Guid& Timeseries( ) const
        {
            return timeseries_;
        }
        void SetTimeseries( const Guid& timeseries )
        {
            timeseries_ = timeseries;
        }
    };
    class UInt32TimeseriesPropertyObject : public TimeseriesPropertyObject
    {
    public:
        using Base = TimeseriesPropertyObject;
        static constexpr Kind KIND = Kind::UInt32TimeseriesProperty;
    private:
        Guid timeseries_;
    public:
        UInt32TimeseriesPropertyObject( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(timeseries_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(timeseries_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<UInt32TimeseriesPropertyObject>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<UInt32TimeseriesPropertyObject&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const UInt32TimeseriesPropertyObject& >( other );
                if ( dataObject.timeseries_ != timeseries_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        const Guid& Timeseries( ) const
        {
            return timeseries_;
        }
        void SetTimeseries( const Guid& timeseries )
        {
            timeseries_ = timeseries;
        }
    };
    class UInt64TimeseriesPropertyObject : public TimeseriesPropertyObject
    {
    public:
        using Base = TimeseriesPropertyObject;
        static constexpr Kind KIND = Kind::UInt64TimeseriesProperty;
    private:
        Guid timeseries_;
    public:
        UInt64TimeseriesPropertyObject( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(timeseries_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(timeseries_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<UInt64TimeseriesPropertyObject>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<UInt64TimeseriesPropertyObject&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const UInt64TimeseriesPropertyObject& >( other );
                if ( dataObject.timeseries_ != timeseries_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        const Guid& Timeseries( ) const
        {
            return timeseries_;
        }
        void SetTimeseries( const Guid& timeseries )
        {
            timeseries_ = timeseries;
        }
    };
    class TimeSpanPropertyObject : public PropertyObject
    {
    public:
        using Base = PropertyObject;
        static constexpr Kind KIND = Kind::TimeSpanProperty;
    private:
        TimeSpan value_;
    public:
        TimeSpanPropertyObject( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(value_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(value_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<TimeSpanPropertyObject>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<TimeSpanPropertyObject&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const TimeSpanPropertyObject& >( other );
                if ( dataObject.value_ != value_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        const TimeSpan& Value( ) const
        {
            return value_;
        }
        void SetValue( const TimeSpan& value )
        {
            value_ = value;
        }
    };
    class UInt16PropertyObject : public PropertyObject
    {
    public:
        using Base = PropertyObject;
        static constexpr Kind KIND = Kind::UInt16Property;
    private:
        UInt16 value_ = 0;
    public:
        UInt16PropertyObject( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(value_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(value_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<UInt16PropertyObject>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<UInt16PropertyObject&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const UInt16PropertyObject& >( other );
                if ( dataObject.value_ != value_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        UInt16 Value( ) const
        {
            return value_;
        }
        void SetValue( UInt16 value )
        {
            value_ = value;
        }
    };
    class UInt32PropertyObject : public PropertyObject
    {
    public:
        using Base = PropertyObject;
        static constexpr Kind KIND = Kind::UInt32Property;
    private:
        UInt32 value_ = 0;
    public:
        UInt32PropertyObject( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(value_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(value_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<UInt32PropertyObject>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<UInt32PropertyObject&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const UInt32PropertyObject& >( other );
                if ( dataObject.value_ != value_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        UInt32 Value( ) const
        {
            return value_;
        }
        void SetValue( UInt32 value )
        {
            value_ = value;
        }
    };
    class UInt64PropertyObject : public PropertyObject
    {
    public:
        using Base = PropertyObject;
        static constexpr Kind KIND = Kind::UInt64Property;
    private:
        Int64 value_ = 0;
    public:
        UInt64PropertyObject( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(value_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(value_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<UInt64PropertyObject>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<UInt64PropertyObject&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const UInt64PropertyObject& >( other );
                if ( dataObject.value_ != value_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        Int64 Value( ) const
        {
            return value_;
        }
        void SetValue( Int64 value )
        {
            value_ = value;
        }
    };
    class PropertyDefinitionObject : public BaseData<Kind, Guid>
    {
    public:
        using Base = BaseData<Kind, Guid>;
        static constexpr Kind KIND = Kind::PropertyDefinition;
    private:
        Int64 rowVersion_ = 0;
        Guid elementType_;
        FixedDBWideString<127> name_;
        WideString description_;
        SQLLEN descriptionLength_ = SQL_NULL_DATA;
    public:
        PropertyDefinitionObject( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(rowVersion_);
            destination.Write(elementType_);
            name_.WriteTo( destination );
            destination.Write(description_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(rowVersion_);
            source.Read(elementType_);
            name_.ReadFrom( source );
            source.Read(description_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<PropertyDefinitionObject>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<PropertyDefinitionObject&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const PropertyDefinitionObject& >( other );
                if ( dataObject.rowVersion_ != rowVersion_ )
                {
                    return false;
                }
                if ( dataObject.elementType_ != elementType_ )
                {
                    return false;
                }
                if ( dataObject.name_ != name_ )
                {
                    return false;
                }
                if ( dataObject.description_ != description_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        Int64 RowVersion( ) const
        {
            return rowVersion_;
        }
        void SetRowVersion( const Int64& rowVersion )
        {
            rowVersion_ = rowVersion;
        }
        const Guid& ElementType( ) const
        {
            return elementType_;
        }
        void SetElementType( const Guid& elementType )
        {
            elementType_ = elementType;
        }
        const FixedDBWideString<127>& Name( ) const
        {
            return name_;
        }
        void SetName( const FixedDBWideString<127>& name )
        {
            name_ = name;
        }
        const WideString& Description( ) const
        {
            return description_;
        }
        void SetDescription( const WideString& description )
        {
            description_ = description;
        }
    };
    class BinaryPropertyDefinitionObject : public PropertyDefinitionObject
    {
    public:
        using Base = PropertyDefinitionObject;
        static constexpr Kind KIND = Kind::BinaryPropertyDefinition;
    private:
        Binary defaultValue_;
        SQLLEN defaultValueLength_ = SQL_NULL_DATA;
    public:
        BinaryPropertyDefinitionObject( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(defaultValue_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(defaultValue_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<BinaryPropertyDefinitionObject>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<BinaryPropertyDefinitionObject&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const BinaryPropertyDefinitionObject& >( other );
                if ( dataObject.defaultValue_ != defaultValue_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        const Binary& DefaultValue( ) const
        {
            return defaultValue_;
        }
        void SetDefaultValue( const Binary& defaultValue )
        {
            defaultValue_ = defaultValue;
        }
    };
    class BooleanPropertyDefinitionObject : public PropertyDefinitionObject
    {
    public:
        using Base = PropertyDefinitionObject;
        static constexpr Kind KIND = Kind::BooleanPropertyDefinition;
    private:
        bool defaultValue_ = false;
    public:
        BooleanPropertyDefinitionObject( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(defaultValue_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(defaultValue_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<BooleanPropertyDefinitionObject>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<BooleanPropertyDefinitionObject&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const BooleanPropertyDefinitionObject& >( other );
                if ( dataObject.defaultValue_ != defaultValue_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        bool DefaultValue( ) const
        {
            return defaultValue_;
        }
        void SetDefaultValue( bool defaultValue )
        {
            defaultValue_ = defaultValue;
        }
    };
    class BytePropertyDefinitionObject : public PropertyDefinitionObject
    {
    public:
        using Base = PropertyDefinitionObject;
        static constexpr Kind KIND = Kind::BytePropertyDefinition;
    private:
        Byte defaultValue_ = 0;
        Byte minValue_ = 0;
        Byte maxValue_ = 0;
    public:
        BytePropertyDefinitionObject( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(defaultValue_);
            destination.Write(minValue_);
            destination.Write(maxValue_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(defaultValue_);
            source.Read(minValue_);
            source.Read(maxValue_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<BytePropertyDefinitionObject>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<BytePropertyDefinitionObject&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const BytePropertyDefinitionObject& >( other );
                if ( dataObject.defaultValue_ != defaultValue_ )
                {
                    return false;
                }
                if ( dataObject.minValue_ != minValue_ )
                {
                    return false;
                }
                if ( dataObject.maxValue_ != maxValue_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        Byte DefaultValue( ) const
        {
            return defaultValue_;
        }
        void SetDefaultValue( Byte defaultValue )
        {
            defaultValue_ = defaultValue;
        }
        Byte MinValue( ) const
        {
            return minValue_;
        }
        void SetMinValue( Byte minValue )
        {
            minValue_ = minValue;
        }
        Byte MaxValue( ) const
        {
            return maxValue_;
        }
        void SetMaxValue( Byte maxValue )
        {
            maxValue_ = maxValue;
        }
    };
    class DateTimePropertyDefinitionObject : public PropertyDefinitionObject
    {
    public:
        using Base = PropertyDefinitionObject;
        static constexpr Kind KIND = Kind::DateTimePropertyDefinition;
    private:
        FixedDBWideString<127> defaultValue_;
        FixedDBWideString<127> minValue_;
        FixedDBWideString<127> maxValue_;
    public:
        DateTimePropertyDefinitionObject( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            defaultValue_.WriteTo( destination );
            minValue_.WriteTo( destination );
            maxValue_.WriteTo( destination );
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            defaultValue_.ReadFrom( source );
            minValue_.ReadFrom( source );
            maxValue_.ReadFrom( source );
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<DateTimePropertyDefinitionObject>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<DateTimePropertyDefinitionObject&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const DateTimePropertyDefinitionObject& >( other );
                if ( dataObject.defaultValue_ != defaultValue_ )
                {
                    return false;
                }
                if ( dataObject.minValue_ != minValue_ )
                {
                    return false;
                }
                if ( dataObject.maxValue_ != maxValue_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        const FixedDBWideString<127>& DefaultValue( ) const
        {
            return defaultValue_;
        }
        void SetDefaultValue( const FixedDBWideString<127>& defaultValue )
        {
            defaultValue_ = defaultValue;
        }
        const FixedDBWideString<127>& MinValue( ) const
        {
            return minValue_;
        }
        void SetMinValue( const FixedDBWideString<127>& minValue )
        {
            minValue_ = minValue;
        }
        const FixedDBWideString<127>& MaxValue( ) const
        {
            return maxValue_;
        }
        void SetMaxValue( const FixedDBWideString<127>& maxValue )
        {
            maxValue_ = maxValue;
        }
    };
    class DoublePropertyDefinitionObject : public PropertyDefinitionObject
    {
    public:
        using Base = PropertyDefinitionObject;
        static constexpr Kind KIND = Kind::DoublePropertyDefinition;
    private:
        double defaultValue_ = 0.0;
        double minValue_ = 0.0;
        double maxValue_ = 0.0;
    public:
        DoublePropertyDefinitionObject( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(defaultValue_);
            destination.Write(minValue_);
            destination.Write(maxValue_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(defaultValue_);
            source.Read(minValue_);
            source.Read(maxValue_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<DoublePropertyDefinitionObject>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<DoublePropertyDefinitionObject&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const DoublePropertyDefinitionObject& >( other );
                if ( dataObject.defaultValue_ != defaultValue_ )
                {
                    return false;
                }
                if ( dataObject.minValue_ != minValue_ )
                {
                    return false;
                }
                if ( dataObject.maxValue_ != maxValue_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        double DefaultValue( ) const
        {
            return defaultValue_;
        }
        void SetDefaultValue( double defaultValue )
        {
            defaultValue_ = defaultValue;
        }
        double MinValue( ) const
        {
            return minValue_;
        }
        void SetMinValue( double minValue )
        {
            minValue_ = minValue;
        }
        double MaxValue( ) const
        {
            return maxValue_;
        }
        void SetMaxValue( double maxValue )
        {
            maxValue_ = maxValue;
        }
    };
    class GuidPropertyDefinitionObject : public PropertyDefinitionObject
    {
    public:
        using Base = PropertyDefinitionObject;
        static constexpr Kind KIND = Kind::GuidPropertyDefinition;
    private:
        Guid defaultValue_;
    public:
        GuidPropertyDefinitionObject( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(defaultValue_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(defaultValue_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<GuidPropertyDefinitionObject>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<GuidPropertyDefinitionObject&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const GuidPropertyDefinitionObject& >( other );
                if ( dataObject.defaultValue_ != defaultValue_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        const Guid& DefaultValue( ) const
        {
            return defaultValue_;
        }
        void SetDefaultValue( const Guid& defaultValue )
        {
            defaultValue_ = defaultValue;
        }
    };
    class Int16PropertyDefinitionObject : public PropertyDefinitionObject
    {
    public:
        using Base = PropertyDefinitionObject;
        static constexpr Kind KIND = Kind::Int16PropertyDefinition;
    private:
        Int16 defaultValue_ = 0;
        Int16 minValue_ = 0;
        Int16 maxValue_ = 0;
    public:
        Int16PropertyDefinitionObject( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(defaultValue_);
            destination.Write(minValue_);
            destination.Write(maxValue_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(defaultValue_);
            source.Read(minValue_);
            source.Read(maxValue_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<Int16PropertyDefinitionObject>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<Int16PropertyDefinitionObject&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const Int16PropertyDefinitionObject& >( other );
                if ( dataObject.defaultValue_ != defaultValue_ )
                {
                    return false;
                }
                if ( dataObject.minValue_ != minValue_ )
                {
                    return false;
                }
                if ( dataObject.maxValue_ != maxValue_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        Int16 DefaultValue( ) const
        {
            return defaultValue_;
        }
        void SetDefaultValue( Int16 defaultValue )
        {
            defaultValue_ = defaultValue;
        }
        Int16 MinValue( ) const
        {
            return minValue_;
        }
        void SetMinValue( Int16 minValue )
        {
            minValue_ = minValue;
        }
        Int16 MaxValue( ) const
        {
            return maxValue_;
        }
        void SetMaxValue( Int16 maxValue )
        {
            maxValue_ = maxValue;
        }
    };
    class Int32PropertyDefinitionObject : public PropertyDefinitionObject
    {
    public:
        using Base = PropertyDefinitionObject;
        static constexpr Kind KIND = Kind::Int32PropertyDefinition;
    private:
        Int32 defaultValue_ = 0;
        Int32 minValue_ = 0;
        Int32 maxValue_ = 0;
    public:
        Int32PropertyDefinitionObject( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(defaultValue_);
            destination.Write(minValue_);
            destination.Write(maxValue_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(defaultValue_);
            source.Read(minValue_);
            source.Read(maxValue_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<Int32PropertyDefinitionObject>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<Int32PropertyDefinitionObject&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const Int32PropertyDefinitionObject& >( other );
                if ( dataObject.defaultValue_ != defaultValue_ )
                {
                    return false;
                }
                if ( dataObject.minValue_ != minValue_ )
                {
                    return false;
                }
                if ( dataObject.maxValue_ != maxValue_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        Int32 DefaultValue( ) const
        {
            return defaultValue_;
        }
        void SetDefaultValue( Int32 defaultValue )
        {
            defaultValue_ = defaultValue;
        }
        Int32 MinValue( ) const
        {
            return minValue_;
        }
        void SetMinValue( Int32 minValue )
        {
            minValue_ = minValue;
        }
        Int32 MaxValue( ) const
        {
            return maxValue_;
        }
        void SetMaxValue( Int32 maxValue )
        {
            maxValue_ = maxValue;
        }
    };
    class Int64PropertyDefinitionObject : public PropertyDefinitionObject
    {
    public:
        using Base = PropertyDefinitionObject;
        static constexpr Kind KIND = Kind::Int64PropertyDefinition;
    private:
        Int64 defaultValue_ = 0;
        Int64 minValue_ = 0;
        Int64 maxValue_ = 0;
    public:
        Int64PropertyDefinitionObject( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(defaultValue_);
            destination.Write(minValue_);
            destination.Write(maxValue_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(defaultValue_);
            source.Read(minValue_);
            source.Read(maxValue_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<Int64PropertyDefinitionObject>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<Int64PropertyDefinitionObject&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const Int64PropertyDefinitionObject& >( other );
                if ( dataObject.defaultValue_ != defaultValue_ )
                {
                    return false;
                }
                if ( dataObject.minValue_ != minValue_ )
                {
                    return false;
                }
                if ( dataObject.maxValue_ != maxValue_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        Int64 DefaultValue( ) const
        {
            return defaultValue_;
        }
        void SetDefaultValue( Int64 defaultValue )
        {
            defaultValue_ = defaultValue;
        }
        Int64 MinValue( ) const
        {
            return minValue_;
        }
        void SetMinValue( Int64 minValue )
        {
            minValue_ = minValue;
        }
        Int64 MaxValue( ) const
        {
            return maxValue_;
        }
        void SetMaxValue( Int64 maxValue )
        {
            maxValue_ = maxValue;
        }
    };
    class ReferencePropertyDefinitionObject : public PropertyDefinitionObject
    {
    public:
        using Base = PropertyDefinitionObject;
        static constexpr Kind KIND = Kind::ReferencePropertyDefinition;
    private:
        Guid defaultValue_;
        Guid referencedElementType_;
    public:
        ReferencePropertyDefinitionObject( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(defaultValue_);
            destination.Write(referencedElementType_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(defaultValue_);
            source.Read(referencedElementType_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<ReferencePropertyDefinitionObject>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<ReferencePropertyDefinitionObject&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const ReferencePropertyDefinitionObject& >( other );
                if ( dataObject.defaultValue_ != defaultValue_ )
                {
                    return false;
                }
                if ( dataObject.referencedElementType_ != referencedElementType_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        const Guid& DefaultValue( ) const
        {
            return defaultValue_;
        }
        void SetDefaultValue( const Guid& defaultValue )
        {
            defaultValue_ = defaultValue;
        }
        const Guid& ReferencedElementType( ) const
        {
            return referencedElementType_;
        }
        void SetReferencedElementType( const Guid& referencedElementType )
        {
            referencedElementType_ = referencedElementType;
        }
    };
    class SBytePropertyDefinitionObject : public PropertyDefinitionObject
    {
    public:
        using Base = PropertyDefinitionObject;
        static constexpr Kind KIND = Kind::SBytePropertyDefinition;
    private:
        SByte defaultValue_ = 0;
        SByte minValue_ = 0;
        SByte maxValue_ = 0;
    public:
        SBytePropertyDefinitionObject( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(defaultValue_);
            destination.Write(minValue_);
            destination.Write(maxValue_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(defaultValue_);
            source.Read(minValue_);
            source.Read(maxValue_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<SBytePropertyDefinitionObject>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<SBytePropertyDefinitionObject&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const SBytePropertyDefinitionObject& >( other );
                if ( dataObject.defaultValue_ != defaultValue_ )
                {
                    return false;
                }
                if ( dataObject.minValue_ != minValue_ )
                {
                    return false;
                }
                if ( dataObject.maxValue_ != maxValue_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        SByte DefaultValue( ) const
        {
            return defaultValue_;
        }
        void SetDefaultValue( SByte defaultValue )
        {
            defaultValue_ = defaultValue;
        }
        SByte MinValue( ) const
        {
            return minValue_;
        }
        void SetMinValue( SByte minValue )
        {
            minValue_ = minValue;
        }
        SByte MaxValue( ) const
        {
            return maxValue_;
        }
        void SetMaxValue( SByte maxValue )
        {
            maxValue_ = maxValue;
        }
    };
    class SinglePropertyDefinitionObject : public PropertyDefinitionObject
    {
    public:
        using Base = PropertyDefinitionObject;
        static constexpr Kind KIND = Kind::SinglePropertyDefinition;
    private:
        float defaultValue_ = 0.0f;
        float minValue_ = 0.0f;
        float maxValue_ = 0.0f;
    public:
        SinglePropertyDefinitionObject( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(defaultValue_);
            destination.Write(minValue_);
            destination.Write(maxValue_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(defaultValue_);
            source.Read(minValue_);
            source.Read(maxValue_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<SinglePropertyDefinitionObject>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<SinglePropertyDefinitionObject&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const SinglePropertyDefinitionObject& >( other );
                if ( dataObject.defaultValue_ != defaultValue_ )
                {
                    return false;
                }
                if ( dataObject.minValue_ != minValue_ )
                {
                    return false;
                }
                if ( dataObject.maxValue_ != maxValue_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        float DefaultValue( ) const
        {
            return defaultValue_;
        }
        void SetDefaultValue( float defaultValue )
        {
            defaultValue_ = defaultValue;
        }
        float MinValue( ) const
        {
            return minValue_;
        }
        void SetMinValue( float minValue )
        {
            minValue_ = minValue;
        }
        float MaxValue( ) const
        {
            return maxValue_;
        }
        void SetMaxValue( float maxValue )
        {
            maxValue_ = maxValue;
        }
    };
    class StringPropertyDefinitionObject : public PropertyDefinitionObject
    {
    public:
        using Base = PropertyDefinitionObject;
        static constexpr Kind KIND = Kind::StringPropertyDefinition;
    private:
        FixedDBWideString<127> defaultValue_;
        FixedDBWideString<127> pattern_;
    public:
        StringPropertyDefinitionObject( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            defaultValue_.WriteTo( destination );
            pattern_.WriteTo( destination );
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            defaultValue_.ReadFrom( source );
            pattern_.ReadFrom( source );
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<StringPropertyDefinitionObject>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<StringPropertyDefinitionObject&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const StringPropertyDefinitionObject& >( other );
                if ( dataObject.defaultValue_ != defaultValue_ )
                {
                    return false;
                }
                if ( dataObject.pattern_ != pattern_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        const FixedDBWideString<127>& DefaultValue( ) const
        {
            return defaultValue_;
        }
        void SetDefaultValue( const FixedDBWideString<127>& defaultValue )
        {
            defaultValue_ = defaultValue;
        }
        const FixedDBWideString<127>& Pattern( ) const
        {
            return pattern_;
        }
        void SetPattern( const FixedDBWideString<127>& pattern )
        {
            pattern_ = pattern;
        }
    };
    class TimeseriesPropertyDefinitionObject : public PropertyDefinitionObject
    {
    public:
        using Base = PropertyDefinitionObject;
        static constexpr Kind KIND = Kind::TimeseriesPropertyDefinition;
    private:
    public:
        TimeseriesPropertyDefinitionObject( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<TimeseriesPropertyDefinitionObject>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<TimeseriesPropertyDefinitionObject&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const TimeseriesPropertyDefinitionObject& >( other );
                return true;
            }
            return false;
        }
    };
    class BinaryTimeseriesPropertyDefinitionObject : public TimeseriesPropertyDefinitionObject
    {
    public:
        using Base = TimeseriesPropertyDefinitionObject;
        static constexpr Kind KIND = Kind::BinaryTimeseriesPropertyDefinition;
    private:
    public:
        BinaryTimeseriesPropertyDefinitionObject( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<BinaryTimeseriesPropertyDefinitionObject>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<BinaryTimeseriesPropertyDefinitionObject&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const BinaryTimeseriesPropertyDefinitionObject& >( other );
                return true;
            }
            return false;
        }
    };
    class BooleanTimeseriesPropertyDefinitionObject : public TimeseriesPropertyDefinitionObject
    {
    public:
        using Base = TimeseriesPropertyDefinitionObject;
        static constexpr Kind KIND = Kind::BooleanTimeseriesPropertyDefinition;
    private:
    public:
        BooleanTimeseriesPropertyDefinitionObject( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<BooleanTimeseriesPropertyDefinitionObject>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<BooleanTimeseriesPropertyDefinitionObject&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const BooleanTimeseriesPropertyDefinitionObject& >( other );
                return true;
            }
            return false;
        }
    };
    class ByteTimeseriesPropertyDefinitionObject : public TimeseriesPropertyDefinitionObject
    {
    public:
        using Base = TimeseriesPropertyDefinitionObject;
        static constexpr Kind KIND = Kind::ByteTimeseriesPropertyDefinition;
    private:
        Byte minValue_ = 0;
        Byte maxValue_ = 0;
    public:
        ByteTimeseriesPropertyDefinitionObject( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(minValue_);
            destination.Write(maxValue_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(minValue_);
            source.Read(maxValue_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<ByteTimeseriesPropertyDefinitionObject>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<ByteTimeseriesPropertyDefinitionObject&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const ByteTimeseriesPropertyDefinitionObject& >( other );
                if ( dataObject.minValue_ != minValue_ )
                {
                    return false;
                }
                if ( dataObject.maxValue_ != maxValue_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        Byte MinValue( ) const
        {
            return minValue_;
        }
        void SetMinValue( Byte minValue )
        {
            minValue_ = minValue;
        }
        Byte MaxValue( ) const
        {
            return maxValue_;
        }
        void SetMaxValue( Byte maxValue )
        {
            maxValue_ = maxValue;
        }
    };
    class DateTimeTimeseriesPropertyDefinitionObject : public TimeseriesPropertyDefinitionObject
    {
    public:
        using Base = TimeseriesPropertyDefinitionObject;
        static constexpr Kind KIND = Kind::DateTimeTimeseriesPropertyDefinition;
    private:
        FixedDBWideString<127> minValue_;
        FixedDBWideString<127> maxValue_;
    public:
        DateTimeTimeseriesPropertyDefinitionObject( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            minValue_.WriteTo( destination );
            maxValue_.WriteTo( destination );
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            minValue_.ReadFrom( source );
            maxValue_.ReadFrom( source );
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<DateTimeTimeseriesPropertyDefinitionObject>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<DateTimeTimeseriesPropertyDefinitionObject&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const DateTimeTimeseriesPropertyDefinitionObject& >( other );
                if ( dataObject.minValue_ != minValue_ )
                {
                    return false;
                }
                if ( dataObject.maxValue_ != maxValue_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        const FixedDBWideString<127>& MinValue( ) const
        {
            return minValue_;
        }
        void SetMinValue( const FixedDBWideString<127>& minValue )
        {
            minValue_ = minValue;
        }
        const FixedDBWideString<127>& MaxValue( ) const
        {
            return maxValue_;
        }
        void SetMaxValue( const FixedDBWideString<127>& maxValue )
        {
            maxValue_ = maxValue;
        }
    };
    class DoubleTimeseriesPropertyDefinitionObject : public TimeseriesPropertyDefinitionObject
    {
    public:
        using Base = TimeseriesPropertyDefinitionObject;
        static constexpr Kind KIND = Kind::DoubleTimeseriesPropertyDefinition;
    private:
        double minValue_ = 0.0;
        double maxValue_ = 0.0;
    public:
        DoubleTimeseriesPropertyDefinitionObject( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(minValue_);
            destination.Write(maxValue_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(minValue_);
            source.Read(maxValue_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<DoubleTimeseriesPropertyDefinitionObject>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<DoubleTimeseriesPropertyDefinitionObject&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const DoubleTimeseriesPropertyDefinitionObject& >( other );
                if ( dataObject.minValue_ != minValue_ )
                {
                    return false;
                }
                if ( dataObject.maxValue_ != maxValue_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        double MinValue( ) const
        {
            return minValue_;
        }
        void SetMinValue( double minValue )
        {
            minValue_ = minValue;
        }
        double MaxValue( ) const
        {
            return maxValue_;
        }
        void SetMaxValue( double maxValue )
        {
            maxValue_ = maxValue;
        }
    };
    class GuidTimeseriesPropertyDefinitionObject : public TimeseriesPropertyDefinitionObject
    {
    public:
        using Base = TimeseriesPropertyDefinitionObject;
        static constexpr Kind KIND = Kind::GuidTimeseriesPropertyDefinition;
    private:
    public:
        GuidTimeseriesPropertyDefinitionObject( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<GuidTimeseriesPropertyDefinitionObject>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<GuidTimeseriesPropertyDefinitionObject&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const GuidTimeseriesPropertyDefinitionObject& >( other );
                return true;
            }
            return false;
        }
    };
    class Int16TimeseriesPropertyDefinitionObject : public TimeseriesPropertyDefinitionObject
    {
    public:
        using Base = TimeseriesPropertyDefinitionObject;
        static constexpr Kind KIND = Kind::Int16TimeseriesPropertyDefinition;
    private:
        Int16 minValue_ = 0;
        Int16 maxValue_ = 0;
    public:
        Int16TimeseriesPropertyDefinitionObject( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(minValue_);
            destination.Write(maxValue_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(minValue_);
            source.Read(maxValue_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<Int16TimeseriesPropertyDefinitionObject>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<Int16TimeseriesPropertyDefinitionObject&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const Int16TimeseriesPropertyDefinitionObject& >( other );
                if ( dataObject.minValue_ != minValue_ )
                {
                    return false;
                }
                if ( dataObject.maxValue_ != maxValue_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        Int16 MinValue( ) const
        {
            return minValue_;
        }
        void SetMinValue( Int16 minValue )
        {
            minValue_ = minValue;
        }
        Int16 MaxValue( ) const
        {
            return maxValue_;
        }
        void SetMaxValue( Int16 maxValue )
        {
            maxValue_ = maxValue;
        }
    };
    class Int32TimeseriesPropertyDefinitionObject : public TimeseriesPropertyDefinitionObject
    {
    public:
        using Base = TimeseriesPropertyDefinitionObject;
        static constexpr Kind KIND = Kind::Int32TimeseriesPropertyDefinition;
    private:
        Int32 minValue_ = 0;
        Int32 maxValue_ = 0;
    public:
        Int32TimeseriesPropertyDefinitionObject( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(minValue_);
            destination.Write(maxValue_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(minValue_);
            source.Read(maxValue_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<Int32TimeseriesPropertyDefinitionObject>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<Int32TimeseriesPropertyDefinitionObject&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const Int32TimeseriesPropertyDefinitionObject& >( other );
                if ( dataObject.minValue_ != minValue_ )
                {
                    return false;
                }
                if ( dataObject.maxValue_ != maxValue_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        Int32 MinValue( ) const
        {
            return minValue_;
        }
        void SetMinValue( Int32 minValue )
        {
            minValue_ = minValue;
        }
        Int32 MaxValue( ) const
        {
            return maxValue_;
        }
        void SetMaxValue( Int32 maxValue )
        {
            maxValue_ = maxValue;
        }
    };
    class Int64TimeseriesPropertyDefinitionObject : public TimeseriesPropertyDefinitionObject
    {
    public:
        using Base = TimeseriesPropertyDefinitionObject;
        static constexpr Kind KIND = Kind::Int64TimeseriesPropertyDefinition;
    private:
        Int64 minValue_ = 0;
        Int64 maxValue_ = 0;
    public:
        Int64TimeseriesPropertyDefinitionObject( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(minValue_);
            destination.Write(maxValue_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(minValue_);
            source.Read(maxValue_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<Int64TimeseriesPropertyDefinitionObject>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<Int64TimeseriesPropertyDefinitionObject&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const Int64TimeseriesPropertyDefinitionObject& >( other );
                if ( dataObject.minValue_ != minValue_ )
                {
                    return false;
                }
                if ( dataObject.maxValue_ != maxValue_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        Int64 MinValue( ) const
        {
            return minValue_;
        }
        void SetMinValue( Int64 minValue )
        {
            minValue_ = minValue;
        }
        Int64 MaxValue( ) const
        {
            return maxValue_;
        }
        void SetMaxValue( Int64 maxValue )
        {
            maxValue_ = maxValue;
        }
    };
    class ReferenceTimeseriesPropertyDefinitionObject : public TimeseriesPropertyDefinitionObject
    {
    public:
        using Base = TimeseriesPropertyDefinitionObject;
        static constexpr Kind KIND = Kind::ReferenceTimeseriesPropertyDefinition;
    private:
        Guid referencedElementType_;
    public:
        ReferenceTimeseriesPropertyDefinitionObject( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(referencedElementType_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(referencedElementType_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<ReferenceTimeseriesPropertyDefinitionObject>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<ReferenceTimeseriesPropertyDefinitionObject&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const ReferenceTimeseriesPropertyDefinitionObject& >( other );
                if ( dataObject.referencedElementType_ != referencedElementType_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        const Guid& ReferencedElementType( ) const
        {
            return referencedElementType_;
        }
        void SetReferencedElementType( const Guid& referencedElementType )
        {
            referencedElementType_ = referencedElementType;
        }
    };
    class SByteTimeseriesPropertyDefinitionObject : public TimeseriesPropertyDefinitionObject
    {
    public:
        using Base = TimeseriesPropertyDefinitionObject;
        static constexpr Kind KIND = Kind::SByteTimeseriesPropertyDefinition;
    private:
        SByte minValue_ = 0;
        SByte maxValue_ = 0;
    public:
        SByteTimeseriesPropertyDefinitionObject( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(minValue_);
            destination.Write(maxValue_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(minValue_);
            source.Read(maxValue_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<SByteTimeseriesPropertyDefinitionObject>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<SByteTimeseriesPropertyDefinitionObject&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const SByteTimeseriesPropertyDefinitionObject& >( other );
                if ( dataObject.minValue_ != minValue_ )
                {
                    return false;
                }
                if ( dataObject.maxValue_ != maxValue_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        SByte MinValue( ) const
        {
            return minValue_;
        }
        void SetMinValue( SByte minValue )
        {
            minValue_ = minValue;
        }
        SByte MaxValue( ) const
        {
            return maxValue_;
        }
        void SetMaxValue( SByte maxValue )
        {
            maxValue_ = maxValue;
        }
    };
    class SingleTimeseriesPropertyDefinitionObject : public TimeseriesPropertyDefinitionObject
    {
    public:
        using Base = TimeseriesPropertyDefinitionObject;
        static constexpr Kind KIND = Kind::SingleTimeseriesPropertyDefinition;
    private:
        float minValue_ = 0.0f;
        float maxValue_ = 0.0f;
    public:
        SingleTimeseriesPropertyDefinitionObject( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(minValue_);
            destination.Write(maxValue_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(minValue_);
            source.Read(maxValue_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<SingleTimeseriesPropertyDefinitionObject>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<SingleTimeseriesPropertyDefinitionObject&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const SingleTimeseriesPropertyDefinitionObject& >( other );
                if ( dataObject.minValue_ != minValue_ )
                {
                    return false;
                }
                if ( dataObject.maxValue_ != maxValue_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        float MinValue( ) const
        {
            return minValue_;
        }
        void SetMinValue( float minValue )
        {
            minValue_ = minValue;
        }
        float MaxValue( ) const
        {
            return maxValue_;
        }
        void SetMaxValue( float maxValue )
        {
            maxValue_ = maxValue;
        }
    };
    class StringTimeseriesPropertyDefinitionObject : public TimeseriesPropertyDefinitionObject
    {
    public:
        using Base = TimeseriesPropertyDefinitionObject;
        static constexpr Kind KIND = Kind::StringTimeseriesPropertyDefinition;
    private:
        FixedDBWideString<127> pattern_;
    public:
        StringTimeseriesPropertyDefinitionObject( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            pattern_.WriteTo( destination );
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            pattern_.ReadFrom( source );
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<StringTimeseriesPropertyDefinitionObject>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<StringTimeseriesPropertyDefinitionObject&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const StringTimeseriesPropertyDefinitionObject& >( other );
                if ( dataObject.pattern_ != pattern_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        const FixedDBWideString<127>& Pattern( ) const
        {
            return pattern_;
        }
        void SetPattern( const FixedDBWideString<127>& pattern )
        {
            pattern_ = pattern;
        }
    };
    class TimeSpanTimeseriesPropertyDefinitionObject : public TimeseriesPropertyDefinitionObject
    {
    public:
        using Base = TimeseriesPropertyDefinitionObject;
        static constexpr Kind KIND = Kind::TimeSpanTimeseriesPropertyDefinition;
    private:
        TimeSpan minValue_;
        TimeSpan maxValue_;
    public:
        TimeSpanTimeseriesPropertyDefinitionObject( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(minValue_);
            destination.Write(maxValue_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(minValue_);
            source.Read(maxValue_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<TimeSpanTimeseriesPropertyDefinitionObject>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<TimeSpanTimeseriesPropertyDefinitionObject&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const TimeSpanTimeseriesPropertyDefinitionObject& >( other );
                if ( dataObject.minValue_ != minValue_ )
                {
                    return false;
                }
                if ( dataObject.maxValue_ != maxValue_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        const TimeSpan& MinValue( ) const
        {
            return minValue_;
        }
        void SetMinValue( const TimeSpan& minValue )
        {
            minValue_ = minValue;
        }
        const TimeSpan& MaxValue( ) const
        {
            return maxValue_;
        }
        void SetMaxValue( const TimeSpan& maxValue )
        {
            maxValue_ = maxValue;
        }
    };
    class UInt16TimeseriesPropertyDefinitionObject : public TimeseriesPropertyDefinitionObject
    {
    public:
        using Base = TimeseriesPropertyDefinitionObject;
        static constexpr Kind KIND = Kind::UInt16TimeseriesPropertyDefinition;
    private:
        UInt16 minValue_ = 0;
        UInt16 maxValue_ = 0;
    public:
        UInt16TimeseriesPropertyDefinitionObject( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(minValue_);
            destination.Write(maxValue_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(minValue_);
            source.Read(maxValue_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<UInt16TimeseriesPropertyDefinitionObject>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<UInt16TimeseriesPropertyDefinitionObject&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const UInt16TimeseriesPropertyDefinitionObject& >( other );
                if ( dataObject.minValue_ != minValue_ )
                {
                    return false;
                }
                if ( dataObject.maxValue_ != maxValue_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        UInt16 MinValue( ) const
        {
            return minValue_;
        }
        void SetMinValue( UInt16 minValue )
        {
            minValue_ = minValue;
        }
        UInt16 MaxValue( ) const
        {
            return maxValue_;
        }
        void SetMaxValue( UInt16 maxValue )
        {
            maxValue_ = maxValue;
        }
    };
    class UInt32TimeseriesPropertyDefinitionObject : public TimeseriesPropertyDefinitionObject
    {
    public:
        using Base = TimeseriesPropertyDefinitionObject;
        static constexpr Kind KIND = Kind::UInt32TimeseriesPropertyDefinition;
    private:
        UInt32 minValue_ = 0;
        UInt32 maxValue_ = 0;
    public:
        UInt32TimeseriesPropertyDefinitionObject( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(minValue_);
            destination.Write(maxValue_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(minValue_);
            source.Read(maxValue_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<UInt32TimeseriesPropertyDefinitionObject>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<UInt32TimeseriesPropertyDefinitionObject&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const UInt32TimeseriesPropertyDefinitionObject& >( other );
                if ( dataObject.minValue_ != minValue_ )
                {
                    return false;
                }
                if ( dataObject.maxValue_ != maxValue_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        UInt32 MinValue( ) const
        {
            return minValue_;
        }
        void SetMinValue( UInt32 minValue )
        {
            minValue_ = minValue;
        }
        UInt32 MaxValue( ) const
        {
            return maxValue_;
        }
        void SetMaxValue( UInt32 maxValue )
        {
            maxValue_ = maxValue;
        }
    };
    class UInt64TimeseriesPropertyDefinitionObject : public TimeseriesPropertyDefinitionObject
    {
    public:
        using Base = TimeseriesPropertyDefinitionObject;
        static constexpr Kind KIND = Kind::UInt64TimeseriesPropertyDefinition;
    private:
        Int64 minValue_ = 0;
        Int64 maxValue_ = 0;
    public:
        UInt64TimeseriesPropertyDefinitionObject( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(minValue_);
            destination.Write(maxValue_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(minValue_);
            source.Read(maxValue_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<UInt64TimeseriesPropertyDefinitionObject>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<UInt64TimeseriesPropertyDefinitionObject&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const UInt64TimeseriesPropertyDefinitionObject& >( other );
                if ( dataObject.minValue_ != minValue_ )
                {
                    return false;
                }
                if ( dataObject.maxValue_ != maxValue_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        Int64 MinValue( ) const
        {
            return minValue_;
        }
        void SetMinValue( Int64 minValue )
        {
            minValue_ = minValue;
        }
        Int64 MaxValue( ) const
        {
            return maxValue_;
        }
        void SetMaxValue( Int64 maxValue )
        {
            maxValue_ = maxValue;
        }
    };
    class TimeSpanPropertyDefinitionObject : public PropertyDefinitionObject
    {
    public:
        using Base = PropertyDefinitionObject;
        static constexpr Kind KIND = Kind::TimeSpanPropertyDefinition;
    private:
        TimeSpan defaultValue_;
        TimeSpan minValue_;
        TimeSpan maxValue_;
    public:
        TimeSpanPropertyDefinitionObject( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(defaultValue_);
            destination.Write(minValue_);
            destination.Write(maxValue_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(defaultValue_);
            source.Read(minValue_);
            source.Read(maxValue_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<TimeSpanPropertyDefinitionObject>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<TimeSpanPropertyDefinitionObject&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const TimeSpanPropertyDefinitionObject& >( other );
                if ( dataObject.defaultValue_ != defaultValue_ )
                {
                    return false;
                }
                if ( dataObject.minValue_ != minValue_ )
                {
                    return false;
                }
                if ( dataObject.maxValue_ != maxValue_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        const TimeSpan& DefaultValue( ) const
        {
            return defaultValue_;
        }
        void SetDefaultValue( const TimeSpan& defaultValue )
        {
            defaultValue_ = defaultValue;
        }
        const TimeSpan& MinValue( ) const
        {
            return minValue_;
        }
        void SetMinValue( const TimeSpan& minValue )
        {
            minValue_ = minValue;
        }
        const TimeSpan& MaxValue( ) const
        {
            return maxValue_;
        }
        void SetMaxValue( const TimeSpan& maxValue )
        {
            maxValue_ = maxValue;
        }
    };
    class UInt16PropertyDefinitionObject : public PropertyDefinitionObject
    {
    public:
        using Base = PropertyDefinitionObject;
        static constexpr Kind KIND = Kind::UInt16PropertyDefinition;
    private:
        UInt16 defaultValue_ = 0;
        UInt16 minValue_ = 0;
        UInt16 maxValue_ = 0;
    public:
        UInt16PropertyDefinitionObject( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(defaultValue_);
            destination.Write(minValue_);
            destination.Write(maxValue_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(defaultValue_);
            source.Read(minValue_);
            source.Read(maxValue_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<UInt16PropertyDefinitionObject>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<UInt16PropertyDefinitionObject&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const UInt16PropertyDefinitionObject& >( other );
                if ( dataObject.defaultValue_ != defaultValue_ )
                {
                    return false;
                }
                if ( dataObject.minValue_ != minValue_ )
                {
                    return false;
                }
                if ( dataObject.maxValue_ != maxValue_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        UInt16 DefaultValue( ) const
        {
            return defaultValue_;
        }
        void SetDefaultValue( UInt16 defaultValue )
        {
            defaultValue_ = defaultValue;
        }
        UInt16 MinValue( ) const
        {
            return minValue_;
        }
        void SetMinValue( UInt16 minValue )
        {
            minValue_ = minValue;
        }
        UInt16 MaxValue( ) const
        {
            return maxValue_;
        }
        void SetMaxValue( UInt16 maxValue )
        {
            maxValue_ = maxValue;
        }
    };
    class UInt32PropertyDefinitionObject : public PropertyDefinitionObject
    {
    public:
        using Base = PropertyDefinitionObject;
        static constexpr Kind KIND = Kind::UInt32PropertyDefinition;
    private:
        UInt32 defaultValue_ = 0;
        UInt32 minValue_ = 0;
        UInt32 maxValue_ = 0;
    public:
        UInt32PropertyDefinitionObject( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(defaultValue_);
            destination.Write(minValue_);
            destination.Write(maxValue_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(defaultValue_);
            source.Read(minValue_);
            source.Read(maxValue_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<UInt32PropertyDefinitionObject>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<UInt32PropertyDefinitionObject&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const UInt32PropertyDefinitionObject& >( other );
                if ( dataObject.defaultValue_ != defaultValue_ )
                {
                    return false;
                }
                if ( dataObject.minValue_ != minValue_ )
                {
                    return false;
                }
                if ( dataObject.maxValue_ != maxValue_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        UInt32 DefaultValue( ) const
        {
            return defaultValue_;
        }
        void SetDefaultValue( UInt32 defaultValue )
        {
            defaultValue_ = defaultValue;
        }
        UInt32 MinValue( ) const
        {
            return minValue_;
        }
        void SetMinValue( UInt32 minValue )
        {
            minValue_ = minValue;
        }
        UInt32 MaxValue( ) const
        {
            return maxValue_;
        }
        void SetMaxValue( UInt32 maxValue )
        {
            maxValue_ = maxValue;
        }
    };
    class UInt64PropertyDefinitionObject : public PropertyDefinitionObject
    {
    public:
        using Base = PropertyDefinitionObject;
        static constexpr Kind KIND = Kind::UInt64PropertyDefinition;
    private:
        Int64 defaultValue_ = 0;
        Int64 minValue_ = 0;
        Int64 maxValue_ = 0;
    public:
        UInt64PropertyDefinitionObject( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(defaultValue_);
            destination.Write(minValue_);
            destination.Write(maxValue_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(defaultValue_);
            source.Read(minValue_);
            source.Read(maxValue_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<UInt64PropertyDefinitionObject>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<UInt64PropertyDefinitionObject&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const UInt64PropertyDefinitionObject& >( other );
                if ( dataObject.defaultValue_ != defaultValue_ )
                {
                    return false;
                }
                if ( dataObject.minValue_ != minValue_ )
                {
                    return false;
                }
                if ( dataObject.maxValue_ != maxValue_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        Int64 DefaultValue( ) const
        {
            return defaultValue_;
        }
        void SetDefaultValue( Int64 defaultValue )
        {
            defaultValue_ = defaultValue;
        }
        Int64 MinValue( ) const
        {
            return minValue_;
        }
        void SetMinValue( Int64 minValue )
        {
            minValue_ = minValue;
        }
        Int64 MaxValue( ) const
        {
            return maxValue_;
        }
        void SetMaxValue( Int64 maxValue )
        {
            maxValue_ = maxValue;
        }
    };
    class RadarAlarmStatusObject : public BaseData<Kind, Guid>
    {
    public:
        using Base = BaseData<Kind, Guid>;
        static constexpr Kind KIND = Kind::RadarAlarmStatus;
    private:
        Int64 rowVersion_ = 0;
        Guid radar_;
        DateTime timestamp_;
        Types::AlarmState type_ = Types::AlarmState::Unknown;
    public:
        RadarAlarmStatusObject( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(rowVersion_);
            destination.Write(radar_);
            destination.Write(timestamp_);
            destination.Write(type_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(rowVersion_);
            source.Read(radar_);
            source.Read(timestamp_);
            source.Read(type_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<RadarAlarmStatusObject>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<RadarAlarmStatusObject&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const RadarAlarmStatusObject& >( other );
                if ( dataObject.rowVersion_ != rowVersion_ )
                {
                    return false;
                }
                if ( dataObject.radar_ != radar_ )
                {
                    return false;
                }
                if ( dataObject.timestamp_ != timestamp_ )
                {
                    return false;
                }
                if ( dataObject.type_ != type_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        Int64 RowVersion( ) const
        {
            return rowVersion_;
        }
        void SetRowVersion( const Int64& rowVersion )
        {
            rowVersion_ = rowVersion;
        }
        const Guid& Radar( ) const
        {
            return radar_;
        }
        void SetRadar( const Guid& radar )
        {
            radar_ = radar;
        }
        const DateTime& Timestamp( ) const
        {
            return timestamp_;
        }
        void SetTimestamp( const DateTime& timestamp )
        {
            timestamp_ = timestamp;
        }
        Types::AlarmState Type( ) const
        {
            return type_;
        }
        void SetType( Types::AlarmState type )
        {
            type_ = type;
        }
    };
    class RadarCommandObject : public BaseData<Kind, Guid>
    {
    public:
        using Base = BaseData<Kind, Guid>;
        static constexpr Kind KIND = Kind::RadarCommand;
    private:
        Int64 rowVersion_ = 0;
        Guid radar_;
        DateTime timestamp_;
        Types::DeviceCommandSourceType deviceCommandSourceType_ = Types::DeviceCommandSourceType::Unknown;
        Guid deviceCommandSourceId_;
        Guid reply_;
    public:
        RadarCommandObject( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(rowVersion_);
            destination.Write(radar_);
            destination.Write(timestamp_);
            destination.Write(deviceCommandSourceType_);
            destination.Write(deviceCommandSourceId_);
            destination.Write(reply_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(rowVersion_);
            source.Read(radar_);
            source.Read(timestamp_);
            source.Read(deviceCommandSourceType_);
            source.Read(deviceCommandSourceId_);
            source.Read(reply_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<RadarCommandObject>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<RadarCommandObject&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const RadarCommandObject& >( other );
                if ( dataObject.rowVersion_ != rowVersion_ )
                {
                    return false;
                }
                if ( dataObject.radar_ != radar_ )
                {
                    return false;
                }
                if ( dataObject.timestamp_ != timestamp_ )
                {
                    return false;
                }
                if ( dataObject.deviceCommandSourceType_ != deviceCommandSourceType_ )
                {
                    return false;
                }
                if ( dataObject.deviceCommandSourceId_ != deviceCommandSourceId_ )
                {
                    return false;
                }
                if ( dataObject.reply_ != reply_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        Int64 RowVersion( ) const
        {
            return rowVersion_;
        }
        void SetRowVersion( const Int64& rowVersion )
        {
            rowVersion_ = rowVersion;
        }
        const Guid& Radar( ) const
        {
            return radar_;
        }
        void SetRadar( const Guid& radar )
        {
            radar_ = radar;
        }
        const DateTime& Timestamp( ) const
        {
            return timestamp_;
        }
        void SetTimestamp( const DateTime& timestamp )
        {
            timestamp_ = timestamp;
        }
        Types::DeviceCommandSourceType DeviceCommandSourceType( ) const
        {
            return deviceCommandSourceType_;
        }
        void SetDeviceCommandSourceType( Types::DeviceCommandSourceType deviceCommandSourceType )
        {
            deviceCommandSourceType_ = deviceCommandSourceType;
        }
        const Guid& DeviceCommandSourceId( ) const
        {
            return deviceCommandSourceId_;
        }
        void SetDeviceCommandSourceId( const Guid& deviceCommandSourceId )
        {
            deviceCommandSourceId_ = deviceCommandSourceId;
        }
        const Guid& Reply( ) const
        {
            return reply_;
        }
        void SetReply( const Guid& reply )
        {
            reply_ = reply;
        }
    };
    class RadarCommandGetStatusObject : public RadarCommandObject
    {
    public:
        using Base = RadarCommandObject;
        static constexpr Kind KIND = Kind::RadarCommandGetStatus;
    private:
    public:
        RadarCommandGetStatusObject( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<RadarCommandGetStatusObject>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<RadarCommandGetStatusObject&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const RadarCommandGetStatusObject& >( other );
                return true;
            }
            return false;
        }
    };
    class RadarCommandReplyObject : public BaseData<Kind, Guid>
    {
    public:
        using Base = BaseData<Kind, Guid>;
        static constexpr Kind KIND = Kind::RadarCommandReply;
    private:
        Int64 rowVersion_ = 0;
        Guid radar_;
        DateTime timestamp_;
        Guid command_;
        Types::DeviceCommandReplyStatus status_ = Types::DeviceCommandReplyStatus::Unknown;
        WideString message_;
        SQLLEN messageLength_ = SQL_NULL_DATA;
    public:
        RadarCommandReplyObject( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(rowVersion_);
            destination.Write(radar_);
            destination.Write(timestamp_);
            destination.Write(command_);
            destination.Write(status_);
            destination.Write(message_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(rowVersion_);
            source.Read(radar_);
            source.Read(timestamp_);
            source.Read(command_);
            source.Read(status_);
            source.Read(message_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<RadarCommandReplyObject>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<RadarCommandReplyObject&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const RadarCommandReplyObject& >( other );
                if ( dataObject.rowVersion_ != rowVersion_ )
                {
                    return false;
                }
                if ( dataObject.radar_ != radar_ )
                {
                    return false;
                }
                if ( dataObject.timestamp_ != timestamp_ )
                {
                    return false;
                }
                if ( dataObject.command_ != command_ )
                {
                    return false;
                }
                if ( dataObject.status_ != status_ )
                {
                    return false;
                }
                if ( dataObject.message_ != message_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        Int64 RowVersion( ) const
        {
            return rowVersion_;
        }
        void SetRowVersion( const Int64& rowVersion )
        {
            rowVersion_ = rowVersion;
        }
        const Guid& Radar( ) const
        {
            return radar_;
        }
        void SetRadar( const Guid& radar )
        {
            radar_ = radar;
        }
        const DateTime& Timestamp( ) const
        {
            return timestamp_;
        }
        void SetTimestamp( const DateTime& timestamp )
        {
            timestamp_ = timestamp;
        }
        const Guid& Command( ) const
        {
            return command_;
        }
        void SetCommand( const Guid& command )
        {
            command_ = command;
        }
        Types::DeviceCommandReplyStatus Status( ) const
        {
            return status_;
        }
        void SetStatus( Types::DeviceCommandReplyStatus status )
        {
            status_ = status;
        }
        const WideString& Message( ) const
        {
            return message_;
        }
        void SetMessage( const WideString& message )
        {
            message_ = message;
        }
    };
    class RadarCommandReplyGetStatusObject : public RadarCommandReplyObject
    {
    public:
        using Base = RadarCommandReplyObject;
        static constexpr Kind KIND = Kind::RadarCommandReplyGetStatus;
    private:
        Int32 azimuthCount_ = 0;
        Int32 triggerCount_ = 0;
        TimeSpan rotationCount_;
        Types::RadarPulse pulse_ = Types::RadarPulse::Short;
        bool tx_ = false;
    public:
        RadarCommandReplyGetStatusObject( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(azimuthCount_);
            destination.Write(triggerCount_);
            destination.Write(rotationCount_);
            destination.Write(pulse_);
            destination.Write(tx_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(azimuthCount_);
            source.Read(triggerCount_);
            source.Read(rotationCount_);
            source.Read(pulse_);
            source.Read(tx_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<RadarCommandReplyGetStatusObject>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<RadarCommandReplyGetStatusObject&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const RadarCommandReplyGetStatusObject& >( other );
                if ( dataObject.azimuthCount_ != azimuthCount_ )
                {
                    return false;
                }
                if ( dataObject.triggerCount_ != triggerCount_ )
                {
                    return false;
                }
                if ( dataObject.rotationCount_ != rotationCount_ )
                {
                    return false;
                }
                if ( dataObject.pulse_ != pulse_ )
                {
                    return false;
                }
                if ( dataObject.tx_ != tx_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        Int32 AzimuthCount( ) const
        {
            return azimuthCount_;
        }
        void SetAzimuthCount( Int32 azimuthCount )
        {
            azimuthCount_ = azimuthCount;
        }
        Int32 TriggerCount( ) const
        {
            return triggerCount_;
        }
        void SetTriggerCount( Int32 triggerCount )
        {
            triggerCount_ = triggerCount;
        }
        const TimeSpan& RotationCount( ) const
        {
            return rotationCount_;
        }
        void SetRotationCount( const TimeSpan& rotationCount )
        {
            rotationCount_ = rotationCount;
        }
        Types::RadarPulse Pulse( ) const
        {
            return pulse_;
        }
        void SetPulse( Types::RadarPulse pulse )
        {
            pulse_ = pulse;
        }
        bool Tx( ) const
        {
            return tx_;
        }
        void SetTx( bool tx )
        {
            tx_ = tx;
        }
    };
    class RadarConfigurationObject : public BaseData<Kind, Guid>
    {
    public:
        using Base = BaseData<Kind, Guid>;
        static constexpr Kind KIND = Kind::RadarConfiguration;
    private:
        Int64 rowVersion_ = 0;
        Guid radar_;
        DateTime timestamp_;
        Int32 radarProtocolVersion_ = 0;
        FixedDBWideString<127> radarIPAddress_;
        Int32 radarPort_ = 0;
        Int32 radarConfigurationPort_ = 0;
        TimeSpan skipMagicTimeout_;
        TimeSpan readTimeout_;
        TimeSpan synchronizationInterval_;
        Int32 targetsRefreshRate_ = 0;
        Int32 range_ = 0;
        Int32 sectorCount_ = 0;
        Int32 sectorOffset_ = 0;
        UInt32 imageColor_ = 0;
        DBUInt32 imageSubstitutionColor_;
        UInt32 transparentColor_ = 0;
        double imageScaleFactorX_ = 0.0;
        double imageOffsetX_ = 0.0;
        double imageScaleFactorY_ = 0.0;
        double imageOffsetY_ = 0.0;
        Types::RadarImageType radarImageType_ = Types::RadarImageType::MaskedProcessed;
        UInt32 trackColor_ = 0;
        UInt32 vectorColor_ = 0;
        bool enableNmea_ = false;
        FixedDBWideString<127> nmeaReceiverIPAddress_;
        Int32 nmeaReceiverPort_ = 0;
        FixedDBWideString<127> nmeaReceiverSourceId_;
    public:
        RadarConfigurationObject( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(rowVersion_);
            destination.Write(radar_);
            destination.Write(timestamp_);
            destination.Write(radarProtocolVersion_);
            radarIPAddress_.WriteTo( destination );
            destination.Write(radarPort_);
            destination.Write(radarConfigurationPort_);
            destination.Write(skipMagicTimeout_);
            destination.Write(readTimeout_);
            destination.Write(synchronizationInterval_);
            destination.Write(targetsRefreshRate_);
            destination.Write(range_);
            destination.Write(sectorCount_);
            destination.Write(sectorOffset_);
            destination.Write(imageColor_);
            imageSubstitutionColor_.WriteTo( destination );
            destination.Write(transparentColor_);
            destination.Write(imageScaleFactorX_);
            destination.Write(imageOffsetX_);
            destination.Write(imageScaleFactorY_);
            destination.Write(imageOffsetY_);
            destination.Write(radarImageType_);
            destination.Write(trackColor_);
            destination.Write(vectorColor_);
            destination.Write(enableNmea_);
            nmeaReceiverIPAddress_.WriteTo( destination );
            destination.Write(nmeaReceiverPort_);
            nmeaReceiverSourceId_.WriteTo( destination );
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(rowVersion_);
            source.Read(radar_);
            source.Read(timestamp_);
            source.Read(radarProtocolVersion_);
            radarIPAddress_.ReadFrom( source );
            source.Read(radarPort_);
            source.Read(radarConfigurationPort_);
            source.Read(skipMagicTimeout_);
            source.Read(readTimeout_);
            source.Read(synchronizationInterval_);
            source.Read(targetsRefreshRate_);
            source.Read(range_);
            source.Read(sectorCount_);
            source.Read(sectorOffset_);
            source.Read(imageColor_);
            imageSubstitutionColor_.ReadFrom( source );
            source.Read(transparentColor_);
            source.Read(imageScaleFactorX_);
            source.Read(imageOffsetX_);
            source.Read(imageScaleFactorY_);
            source.Read(imageOffsetY_);
            source.Read(radarImageType_);
            source.Read(trackColor_);
            source.Read(vectorColor_);
            source.Read(enableNmea_);
            nmeaReceiverIPAddress_.ReadFrom( source );
            source.Read(nmeaReceiverPort_);
            nmeaReceiverSourceId_.ReadFrom( source );
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<RadarConfigurationObject>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<RadarConfigurationObject&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const RadarConfigurationObject& >( other );
                if ( dataObject.rowVersion_ != rowVersion_ )
                {
                    return false;
                }
                if ( dataObject.radar_ != radar_ )
                {
                    return false;
                }
                if ( dataObject.timestamp_ != timestamp_ )
                {
                    return false;
                }
                if ( dataObject.radarProtocolVersion_ != radarProtocolVersion_ )
                {
                    return false;
                }
                if ( dataObject.radarIPAddress_ != radarIPAddress_ )
                {
                    return false;
                }
                if ( dataObject.radarPort_ != radarPort_ )
                {
                    return false;
                }
                if ( dataObject.radarConfigurationPort_ != radarConfigurationPort_ )
                {
                    return false;
                }
                if ( dataObject.skipMagicTimeout_ != skipMagicTimeout_ )
                {
                    return false;
                }
                if ( dataObject.readTimeout_ != readTimeout_ )
                {
                    return false;
                }
                if ( dataObject.synchronizationInterval_ != synchronizationInterval_ )
                {
                    return false;
                }
                if ( dataObject.targetsRefreshRate_ != targetsRefreshRate_ )
                {
                    return false;
                }
                if ( dataObject.range_ != range_ )
                {
                    return false;
                }
                if ( dataObject.sectorCount_ != sectorCount_ )
                {
                    return false;
                }
                if ( dataObject.sectorOffset_ != sectorOffset_ )
                {
                    return false;
                }
                if ( dataObject.imageColor_ != imageColor_ )
                {
                    return false;
                }
                if ( dataObject.imageSubstitutionColor_ != imageSubstitutionColor_ )
                {
                    return false;
                }
                if ( dataObject.transparentColor_ != transparentColor_ )
                {
                    return false;
                }
                if ( dataObject.imageScaleFactorX_ != imageScaleFactorX_ )
                {
                    return false;
                }
                if ( dataObject.imageOffsetX_ != imageOffsetX_ )
                {
                    return false;
                }
                if ( dataObject.imageScaleFactorY_ != imageScaleFactorY_ )
                {
                    return false;
                }
                if ( dataObject.imageOffsetY_ != imageOffsetY_ )
                {
                    return false;
                }
                if ( dataObject.radarImageType_ != radarImageType_ )
                {
                    return false;
                }
                if ( dataObject.trackColor_ != trackColor_ )
                {
                    return false;
                }
                if ( dataObject.vectorColor_ != vectorColor_ )
                {
                    return false;
                }
                if ( dataObject.enableNmea_ != enableNmea_ )
                {
                    return false;
                }
                if ( dataObject.nmeaReceiverIPAddress_ != nmeaReceiverIPAddress_ )
                {
                    return false;
                }
                if ( dataObject.nmeaReceiverPort_ != nmeaReceiverPort_ )
                {
                    return false;
                }
                if ( dataObject.nmeaReceiverSourceId_ != nmeaReceiverSourceId_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        Int64 RowVersion( ) const
        {
            return rowVersion_;
        }
        void SetRowVersion( const Int64& rowVersion )
        {
            rowVersion_ = rowVersion;
        }
        const Guid& Radar( ) const
        {
            return radar_;
        }
        void SetRadar( const Guid& radar )
        {
            radar_ = radar;
        }
        const DateTime& Timestamp( ) const
        {
            return timestamp_;
        }
        void SetTimestamp( const DateTime& timestamp )
        {
            timestamp_ = timestamp;
        }
        Int32 RadarProtocolVersion( ) const
        {
            return radarProtocolVersion_;
        }
        void SetRadarProtocolVersion( Int32 radarProtocolVersion )
        {
            radarProtocolVersion_ = radarProtocolVersion;
        }
        const FixedDBWideString<127>& RadarIPAddress( ) const
        {
            return radarIPAddress_;
        }
        void SetRadarIPAddress( const FixedDBWideString<127>& radarIPAddress )
        {
            radarIPAddress_ = radarIPAddress;
        }
        Int32 RadarPort( ) const
        {
            return radarPort_;
        }
        void SetRadarPort( Int32 radarPort )
        {
            radarPort_ = radarPort;
        }
        Int32 RadarConfigurationPort( ) const
        {
            return radarConfigurationPort_;
        }
        void SetRadarConfigurationPort( Int32 radarConfigurationPort )
        {
            radarConfigurationPort_ = radarConfigurationPort;
        }
        const TimeSpan& SkipMagicTimeout( ) const
        {
            return skipMagicTimeout_;
        }
        void SetSkipMagicTimeout( const TimeSpan& skipMagicTimeout )
        {
            skipMagicTimeout_ = skipMagicTimeout;
        }
        const TimeSpan& ReadTimeout( ) const
        {
            return readTimeout_;
        }
        void SetReadTimeout( const TimeSpan& readTimeout )
        {
            readTimeout_ = readTimeout;
        }
        const TimeSpan& SynchronizationInterval( ) const
        {
            return synchronizationInterval_;
        }
        void SetSynchronizationInterval( const TimeSpan& synchronizationInterval )
        {
            synchronizationInterval_ = synchronizationInterval;
        }
        Int32 TargetsRefreshRate( ) const
        {
            return targetsRefreshRate_;
        }
        void SetTargetsRefreshRate( Int32 targetsRefreshRate )
        {
            targetsRefreshRate_ = targetsRefreshRate;
        }
        Int32 Range( ) const
        {
            return range_;
        }
        void SetRange( Int32 range )
        {
            range_ = range;
        }
        Int32 SectorCount( ) const
        {
            return sectorCount_;
        }
        void SetSectorCount( Int32 sectorCount )
        {
            sectorCount_ = sectorCount;
        }
        Int32 SectorOffset( ) const
        {
            return sectorOffset_;
        }
        void SetSectorOffset( Int32 sectorOffset )
        {
            sectorOffset_ = sectorOffset;
        }
        UInt32 ImageColor( ) const
        {
            return imageColor_;
        }
        void SetImageColor( UInt32 imageColor )
        {
            imageColor_ = imageColor;
        }
        const DBUInt32& ImageSubstitutionColor( ) const
        {
            return imageSubstitutionColor_;
        }
        void SetImageSubstitutionColor( const DBUInt32& imageSubstitutionColor )
        {
            imageSubstitutionColor_ = imageSubstitutionColor;
        }
        UInt32 TransparentColor( ) const
        {
            return transparentColor_;
        }
        void SetTransparentColor( UInt32 transparentColor )
        {
            transparentColor_ = transparentColor;
        }
        double ImageScaleFactorX( ) const
        {
            return imageScaleFactorX_;
        }
        void SetImageScaleFactorX( double imageScaleFactorX )
        {
            imageScaleFactorX_ = imageScaleFactorX;
        }
        double ImageOffsetX( ) const
        {
            return imageOffsetX_;
        }
        void SetImageOffsetX( double imageOffsetX )
        {
            imageOffsetX_ = imageOffsetX;
        }
        double ImageScaleFactorY( ) const
        {
            return imageScaleFactorY_;
        }
        void SetImageScaleFactorY( double imageScaleFactorY )
        {
            imageScaleFactorY_ = imageScaleFactorY;
        }
        double ImageOffsetY( ) const
        {
            return imageOffsetY_;
        }
        void SetImageOffsetY( double imageOffsetY )
        {
            imageOffsetY_ = imageOffsetY;
        }
        Types::RadarImageType RadarImageType( ) const
        {
            return radarImageType_;
        }
        void SetRadarImageType( Types::RadarImageType radarImageType )
        {
            radarImageType_ = radarImageType;
        }
        UInt32 TrackColor( ) const
        {
            return trackColor_;
        }
        void SetTrackColor( UInt32 trackColor )
        {
            trackColor_ = trackColor;
        }
        UInt32 VectorColor( ) const
        {
            return vectorColor_;
        }
        void SetVectorColor( UInt32 vectorColor )
        {
            vectorColor_ = vectorColor;
        }
        bool EnableNmea( ) const
        {
            return enableNmea_;
        }
        void SetEnableNmea( bool enableNmea )
        {
            enableNmea_ = enableNmea;
        }
        const FixedDBWideString<127>& NmeaReceiverIPAddress( ) const
        {
            return nmeaReceiverIPAddress_;
        }
        void SetNmeaReceiverIPAddress( const FixedDBWideString<127>& nmeaReceiverIPAddress )
        {
            nmeaReceiverIPAddress_ = nmeaReceiverIPAddress;
        }
        Int32 NmeaReceiverPort( ) const
        {
            return nmeaReceiverPort_;
        }
        void SetNmeaReceiverPort( Int32 nmeaReceiverPort )
        {
            nmeaReceiverPort_ = nmeaReceiverPort;
        }
        const FixedDBWideString<127>& NmeaReceiverSourceId( ) const
        {
            return nmeaReceiverSourceId_;
        }
        void SetNmeaReceiverSourceId( const FixedDBWideString<127>& nmeaReceiverSourceId )
        {
            nmeaReceiverSourceId_ = nmeaReceiverSourceId;
        }
    };
    class RadarImageObject : public BaseData<Kind, Guid>
    {
    public:
        using Base = BaseData<Kind, Guid>;
        static constexpr Kind KIND = Kind::RadarImage;
    private:
        Int64 rowVersion_ = 0;
        Guid radar_;
        DateTime timestamp_;
        UInt32 depth_ = 0;
        Int32 resolution_ = 0;
        Int32 range_ = 0;
        Binary image_;
        SQLLEN imageLength_ = SQL_NULL_DATA;
    public:
        RadarImageObject( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(rowVersion_);
            destination.Write(radar_);
            destination.Write(timestamp_);
            destination.Write(depth_);
            destination.Write(resolution_);
            destination.Write(range_);
            destination.Write(image_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(rowVersion_);
            source.Read(radar_);
            source.Read(timestamp_);
            source.Read(depth_);
            source.Read(resolution_);
            source.Read(range_);
            source.Read(image_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<RadarImageObject>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<RadarImageObject&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const RadarImageObject& >( other );
                if ( dataObject.rowVersion_ != rowVersion_ )
                {
                    return false;
                }
                if ( dataObject.radar_ != radar_ )
                {
                    return false;
                }
                if ( dataObject.timestamp_ != timestamp_ )
                {
                    return false;
                }
                if ( dataObject.depth_ != depth_ )
                {
                    return false;
                }
                if ( dataObject.resolution_ != resolution_ )
                {
                    return false;
                }
                if ( dataObject.range_ != range_ )
                {
                    return false;
                }
                if ( dataObject.image_ != image_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        Int64 RowVersion( ) const
        {
            return rowVersion_;
        }
        void SetRowVersion( const Int64& rowVersion )
        {
            rowVersion_ = rowVersion;
        }
        const Guid& Radar( ) const
        {
            return radar_;
        }
        void SetRadar( const Guid& radar )
        {
            radar_ = radar;
        }
        const DateTime& Timestamp( ) const
        {
            return timestamp_;
        }
        void SetTimestamp( const DateTime& timestamp )
        {
            timestamp_ = timestamp;
        }
        UInt32 Depth( ) const
        {
            return depth_;
        }
        void SetDepth( UInt32 depth )
        {
            depth_ = depth;
        }
        Int32 Resolution( ) const
        {
            return resolution_;
        }
        void SetResolution( Int32 resolution )
        {
            resolution_ = resolution;
        }
        Int32 Range( ) const
        {
            return range_;
        }
        void SetRange( Int32 range )
        {
            range_ = range;
        }
        const Binary& Image( ) const
        {
            return image_;
        }
        void SetImage( const Binary& image )
        {
            image_ = image;
        }
    };
    class RadarRawTrackTableObject : public BaseData<Kind, Guid>
    {
    public:
        using Base = BaseData<Kind, Guid>;
        static constexpr Kind KIND = Kind::RadarRawTrackTable;
    private:
        Int64 rowVersion_ = 0;
        Guid radar_;
        DateTime timestamp_;
        Int32 count_ = 0;
        Binary table_;
        SQLLEN tableLength_ = SQL_NULL_DATA;
    public:
        RadarRawTrackTableObject( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(rowVersion_);
            destination.Write(radar_);
            destination.Write(timestamp_);
            destination.Write(count_);
            destination.Write(table_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(rowVersion_);
            source.Read(radar_);
            source.Read(timestamp_);
            source.Read(count_);
            source.Read(table_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<RadarRawTrackTableObject>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<RadarRawTrackTableObject&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const RadarRawTrackTableObject& >( other );
                if ( dataObject.rowVersion_ != rowVersion_ )
                {
                    return false;
                }
                if ( dataObject.radar_ != radar_ )
                {
                    return false;
                }
                if ( dataObject.timestamp_ != timestamp_ )
                {
                    return false;
                }
                if ( dataObject.count_ != count_ )
                {
                    return false;
                }
                if ( dataObject.table_ != table_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        Int64 RowVersion( ) const
        {
            return rowVersion_;
        }
        void SetRowVersion( const Int64& rowVersion )
        {
            rowVersion_ = rowVersion;
        }
        const Guid& Radar( ) const
        {
            return radar_;
        }
        void SetRadar( const Guid& radar )
        {
            radar_ = radar;
        }
        const DateTime& Timestamp( ) const
        {
            return timestamp_;
        }
        void SetTimestamp( const DateTime& timestamp )
        {
            timestamp_ = timestamp;
        }
        Int32 Count( ) const
        {
            return count_;
        }
        void SetCount( Int32 count )
        {
            count_ = count;
        }
        const Binary& Table( ) const
        {
            return table_;
        }
        void SetTable( const Binary& table )
        {
            table_ = table;
        }
    };
    class RadarStatusObject : public BaseData<Kind, Guid>
    {
    public:
        using Base = BaseData<Kind, Guid>;
        static constexpr Kind KIND = Kind::RadarStatus;
    private:
        Int64 rowVersion_ = 0;
        Guid radar_;
        DateTime timestamp_;
        Int32 azimuthCount_ = 0;
        Int32 triggerCount_ = 0;
        TimeSpan rotationTime_;
        Types::RadarPulse pulse_ = Types::RadarPulse::Short;
        bool tx_ = false;
        bool tracking_ = false;
    public:
        RadarStatusObject( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(rowVersion_);
            destination.Write(radar_);
            destination.Write(timestamp_);
            destination.Write(azimuthCount_);
            destination.Write(triggerCount_);
            destination.Write(rotationTime_);
            destination.Write(pulse_);
            destination.Write(tx_);
            destination.Write(tracking_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(rowVersion_);
            source.Read(radar_);
            source.Read(timestamp_);
            source.Read(azimuthCount_);
            source.Read(triggerCount_);
            source.Read(rotationTime_);
            source.Read(pulse_);
            source.Read(tx_);
            source.Read(tracking_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<RadarStatusObject>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<RadarStatusObject&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const RadarStatusObject& >( other );
                if ( dataObject.rowVersion_ != rowVersion_ )
                {
                    return false;
                }
                if ( dataObject.radar_ != radar_ )
                {
                    return false;
                }
                if ( dataObject.timestamp_ != timestamp_ )
                {
                    return false;
                }
                if ( dataObject.azimuthCount_ != azimuthCount_ )
                {
                    return false;
                }
                if ( dataObject.triggerCount_ != triggerCount_ )
                {
                    return false;
                }
                if ( dataObject.rotationTime_ != rotationTime_ )
                {
                    return false;
                }
                if ( dataObject.pulse_ != pulse_ )
                {
                    return false;
                }
                if ( dataObject.tx_ != tx_ )
                {
                    return false;
                }
                if ( dataObject.tracking_ != tracking_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        Int64 RowVersion( ) const
        {
            return rowVersion_;
        }
        void SetRowVersion( const Int64& rowVersion )
        {
            rowVersion_ = rowVersion;
        }
        const Guid& Radar( ) const
        {
            return radar_;
        }
        void SetRadar( const Guid& radar )
        {
            radar_ = radar;
        }
        const DateTime& Timestamp( ) const
        {
            return timestamp_;
        }
        void SetTimestamp( const DateTime& timestamp )
        {
            timestamp_ = timestamp;
        }
        Int32 AzimuthCount( ) const
        {
            return azimuthCount_;
        }
        void SetAzimuthCount( Int32 azimuthCount )
        {
            azimuthCount_ = azimuthCount;
        }
        Int32 TriggerCount( ) const
        {
            return triggerCount_;
        }
        void SetTriggerCount( Int32 triggerCount )
        {
            triggerCount_ = triggerCount;
        }
        const TimeSpan& RotationTime( ) const
        {
            return rotationTime_;
        }
        void SetRotationTime( const TimeSpan& rotationTime )
        {
            rotationTime_ = rotationTime;
        }
        Types::RadarPulse Pulse( ) const
        {
            return pulse_;
        }
        void SetPulse( Types::RadarPulse pulse )
        {
            pulse_ = pulse;
        }
        bool Tx( ) const
        {
            return tx_;
        }
        void SetTx( bool tx )
        {
            tx_ = tx;
        }
        bool Tracking( ) const
        {
            return tracking_;
        }
        void SetTracking( bool tracking )
        {
            tracking_ = tracking;
        }
    };
    class RadioCommandObject : public BaseData<Kind, Guid>
    {
    public:
        using Base = BaseData<Kind, Guid>;
        static constexpr Kind KIND = Kind::RadioCommand;
    private:
        Int64 rowVersion_ = 0;
        Guid radio_;
        DateTime timestamp_;
        Types::DeviceCommandSourceType deviceCommandSourceType_ = Types::DeviceCommandSourceType::Unknown;
        Guid deviceCommandSourceId_;
        Guid reply_;
    public:
        RadioCommandObject( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(rowVersion_);
            destination.Write(radio_);
            destination.Write(timestamp_);
            destination.Write(deviceCommandSourceType_);
            destination.Write(deviceCommandSourceId_);
            destination.Write(reply_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(rowVersion_);
            source.Read(radio_);
            source.Read(timestamp_);
            source.Read(deviceCommandSourceType_);
            source.Read(deviceCommandSourceId_);
            source.Read(reply_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<RadioCommandObject>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<RadioCommandObject&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const RadioCommandObject& >( other );
                if ( dataObject.rowVersion_ != rowVersion_ )
                {
                    return false;
                }
                if ( dataObject.radio_ != radio_ )
                {
                    return false;
                }
                if ( dataObject.timestamp_ != timestamp_ )
                {
                    return false;
                }
                if ( dataObject.deviceCommandSourceType_ != deviceCommandSourceType_ )
                {
                    return false;
                }
                if ( dataObject.deviceCommandSourceId_ != deviceCommandSourceId_ )
                {
                    return false;
                }
                if ( dataObject.reply_ != reply_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        Int64 RowVersion( ) const
        {
            return rowVersion_;
        }
        void SetRowVersion( const Int64& rowVersion )
        {
            rowVersion_ = rowVersion;
        }
        const Guid& Radio( ) const
        {
            return radio_;
        }
        void SetRadio( const Guid& radio )
        {
            radio_ = radio;
        }
        const DateTime& Timestamp( ) const
        {
            return timestamp_;
        }
        void SetTimestamp( const DateTime& timestamp )
        {
            timestamp_ = timestamp;
        }
        Types::DeviceCommandSourceType DeviceCommandSourceType( ) const
        {
            return deviceCommandSourceType_;
        }
        void SetDeviceCommandSourceType( Types::DeviceCommandSourceType deviceCommandSourceType )
        {
            deviceCommandSourceType_ = deviceCommandSourceType;
        }
        const Guid& DeviceCommandSourceId( ) const
        {
            return deviceCommandSourceId_;
        }
        void SetDeviceCommandSourceId( const Guid& deviceCommandSourceId )
        {
            deviceCommandSourceId_ = deviceCommandSourceId;
        }
        const Guid& Reply( ) const
        {
            return reply_;
        }
        void SetReply( const Guid& reply )
        {
            reply_ = reply;
        }
    };
    class RadioCommandReplyObject : public BaseData<Kind, Guid>
    {
    public:
        using Base = BaseData<Kind, Guid>;
        static constexpr Kind KIND = Kind::RadioCommandReply;
    private:
        Int64 rowVersion_ = 0;
        Guid radio_;
        DateTime timestamp_;
        Guid command_;
        Types::DeviceCommandReplyStatus status_ = Types::DeviceCommandReplyStatus::Unknown;
        WideString message_;
        SQLLEN messageLength_ = SQL_NULL_DATA;
    public:
        RadioCommandReplyObject( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(rowVersion_);
            destination.Write(radio_);
            destination.Write(timestamp_);
            destination.Write(command_);
            destination.Write(status_);
            destination.Write(message_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(rowVersion_);
            source.Read(radio_);
            source.Read(timestamp_);
            source.Read(command_);
            source.Read(status_);
            source.Read(message_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<RadioCommandReplyObject>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<RadioCommandReplyObject&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const RadioCommandReplyObject& >( other );
                if ( dataObject.rowVersion_ != rowVersion_ )
                {
                    return false;
                }
                if ( dataObject.radio_ != radio_ )
                {
                    return false;
                }
                if ( dataObject.timestamp_ != timestamp_ )
                {
                    return false;
                }
                if ( dataObject.command_ != command_ )
                {
                    return false;
                }
                if ( dataObject.status_ != status_ )
                {
                    return false;
                }
                if ( dataObject.message_ != message_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        Int64 RowVersion( ) const
        {
            return rowVersion_;
        }
        void SetRowVersion( const Int64& rowVersion )
        {
            rowVersion_ = rowVersion;
        }
        const Guid& Radio( ) const
        {
            return radio_;
        }
        void SetRadio( const Guid& radio )
        {
            radio_ = radio;
        }
        const DateTime& Timestamp( ) const
        {
            return timestamp_;
        }
        void SetTimestamp( const DateTime& timestamp )
        {
            timestamp_ = timestamp;
        }
        const Guid& Command( ) const
        {
            return command_;
        }
        void SetCommand( const Guid& command )
        {
            command_ = command;
        }
        Types::DeviceCommandReplyStatus Status( ) const
        {
            return status_;
        }
        void SetStatus( Types::DeviceCommandReplyStatus status )
        {
            status_ = status;
        }
        const WideString& Message( ) const
        {
            return message_;
        }
        void SetMessage( const WideString& message )
        {
            message_ = message;
        }
    };
    class RadioConfigurationObject : public BaseData<Kind, Guid>
    {
    public:
        using Base = BaseData<Kind, Guid>;
        static constexpr Kind KIND = Kind::RadioConfiguration;
    private:
        Int64 rowVersion_ = 0;
        Guid radio_;
        DateTime timestamp_;
        double longitude_ = 0.0;
        double latitude_ = 0.0;
        FixedDBWideString<127> playbackUrl_;
        FixedDBWideString<127> radioIPAddress_;
        Int32 radioPort_ = 0;
        FixedDBWideString<127> ed137IPAddress_;
        Int32 ed137Port_ = 0;
    public:
        RadioConfigurationObject( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(rowVersion_);
            destination.Write(radio_);
            destination.Write(timestamp_);
            destination.Write(longitude_);
            destination.Write(latitude_);
            playbackUrl_.WriteTo( destination );
            radioIPAddress_.WriteTo( destination );
            destination.Write(radioPort_);
            ed137IPAddress_.WriteTo( destination );
            destination.Write(ed137Port_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(rowVersion_);
            source.Read(radio_);
            source.Read(timestamp_);
            source.Read(longitude_);
            source.Read(latitude_);
            playbackUrl_.ReadFrom( source );
            radioIPAddress_.ReadFrom( source );
            source.Read(radioPort_);
            ed137IPAddress_.ReadFrom( source );
            source.Read(ed137Port_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<RadioConfigurationObject>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<RadioConfigurationObject&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const RadioConfigurationObject& >( other );
                if ( dataObject.rowVersion_ != rowVersion_ )
                {
                    return false;
                }
                if ( dataObject.radio_ != radio_ )
                {
                    return false;
                }
                if ( dataObject.timestamp_ != timestamp_ )
                {
                    return false;
                }
                if ( dataObject.longitude_ != longitude_ )
                {
                    return false;
                }
                if ( dataObject.latitude_ != latitude_ )
                {
                    return false;
                }
                if ( dataObject.playbackUrl_ != playbackUrl_ )
                {
                    return false;
                }
                if ( dataObject.radioIPAddress_ != radioIPAddress_ )
                {
                    return false;
                }
                if ( dataObject.radioPort_ != radioPort_ )
                {
                    return false;
                }
                if ( dataObject.ed137IPAddress_ != ed137IPAddress_ )
                {
                    return false;
                }
                if ( dataObject.ed137Port_ != ed137Port_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        Int64 RowVersion( ) const
        {
            return rowVersion_;
        }
        void SetRowVersion( const Int64& rowVersion )
        {
            rowVersion_ = rowVersion;
        }
        const Guid& Radio( ) const
        {
            return radio_;
        }
        void SetRadio( const Guid& radio )
        {
            radio_ = radio;
        }
        const DateTime& Timestamp( ) const
        {
            return timestamp_;
        }
        void SetTimestamp( const DateTime& timestamp )
        {
            timestamp_ = timestamp;
        }
        double Longitude( ) const
        {
            return longitude_;
        }
        void SetLongitude( double longitude )
        {
            longitude_ = longitude;
        }
        double Latitude( ) const
        {
            return latitude_;
        }
        void SetLatitude( double latitude )
        {
            latitude_ = latitude;
        }
        const FixedDBWideString<127>& PlaybackUrl( ) const
        {
            return playbackUrl_;
        }
        void SetPlaybackUrl( const FixedDBWideString<127>& playbackUrl )
        {
            playbackUrl_ = playbackUrl;
        }
        const FixedDBWideString<127>& RadioIPAddress( ) const
        {
            return radioIPAddress_;
        }
        void SetRadioIPAddress( const FixedDBWideString<127>& radioIPAddress )
        {
            radioIPAddress_ = radioIPAddress;
        }
        Int32 RadioPort( ) const
        {
            return radioPort_;
        }
        void SetRadioPort( Int32 radioPort )
        {
            radioPort_ = radioPort;
        }
        const FixedDBWideString<127>& Ed137IPAddress( ) const
        {
            return ed137IPAddress_;
        }
        void SetEd137IPAddress( const FixedDBWideString<127>& ed137IPAddress )
        {
            ed137IPAddress_ = ed137IPAddress;
        }
        Int32 Ed137Port( ) const
        {
            return ed137Port_;
        }
        void SetEd137Port( Int32 ed137Port )
        {
            ed137Port_ = ed137Port;
        }
    };
    class RadomeCommandObject : public BaseData<Kind, Guid>
    {
    public:
        using Base = BaseData<Kind, Guid>;
        static constexpr Kind KIND = Kind::RadomeCommand;
    private:
        Int64 rowVersion_ = 0;
        Guid radome_;
        DateTime timestamp_;
        Types::DeviceCommandSourceType deviceCommandSourceType_ = Types::DeviceCommandSourceType::Unknown;
        Guid deviceCommandSourceId_;
        Guid reply_;
    public:
        RadomeCommandObject( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(rowVersion_);
            destination.Write(radome_);
            destination.Write(timestamp_);
            destination.Write(deviceCommandSourceType_);
            destination.Write(deviceCommandSourceId_);
            destination.Write(reply_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(rowVersion_);
            source.Read(radome_);
            source.Read(timestamp_);
            source.Read(deviceCommandSourceType_);
            source.Read(deviceCommandSourceId_);
            source.Read(reply_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<RadomeCommandObject>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<RadomeCommandObject&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const RadomeCommandObject& >( other );
                if ( dataObject.rowVersion_ != rowVersion_ )
                {
                    return false;
                }
                if ( dataObject.radome_ != radome_ )
                {
                    return false;
                }
                if ( dataObject.timestamp_ != timestamp_ )
                {
                    return false;
                }
                if ( dataObject.deviceCommandSourceType_ != deviceCommandSourceType_ )
                {
                    return false;
                }
                if ( dataObject.deviceCommandSourceId_ != deviceCommandSourceId_ )
                {
                    return false;
                }
                if ( dataObject.reply_ != reply_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        Int64 RowVersion( ) const
        {
            return rowVersion_;
        }
        void SetRowVersion( const Int64& rowVersion )
        {
            rowVersion_ = rowVersion;
        }
        const Guid& Radome( ) const
        {
            return radome_;
        }
        void SetRadome( const Guid& radome )
        {
            radome_ = radome;
        }
        const DateTime& Timestamp( ) const
        {
            return timestamp_;
        }
        void SetTimestamp( const DateTime& timestamp )
        {
            timestamp_ = timestamp;
        }
        Types::DeviceCommandSourceType DeviceCommandSourceType( ) const
        {
            return deviceCommandSourceType_;
        }
        void SetDeviceCommandSourceType( Types::DeviceCommandSourceType deviceCommandSourceType )
        {
            deviceCommandSourceType_ = deviceCommandSourceType;
        }
        const Guid& DeviceCommandSourceId( ) const
        {
            return deviceCommandSourceId_;
        }
        void SetDeviceCommandSourceId( const Guid& deviceCommandSourceId )
        {
            deviceCommandSourceId_ = deviceCommandSourceId;
        }
        const Guid& Reply( ) const
        {
            return reply_;
        }
        void SetReply( const Guid& reply )
        {
            reply_ = reply;
        }
    };
    class RadomeCommandReplyObject : public BaseData<Kind, Guid>
    {
    public:
        using Base = BaseData<Kind, Guid>;
        static constexpr Kind KIND = Kind::RadomeCommandReply;
    private:
        Int64 rowVersion_ = 0;
        Guid radome_;
        DateTime timestamp_;
        Guid command_;
        Types::DeviceCommandReplyStatus status_ = Types::DeviceCommandReplyStatus::Unknown;
        WideString message_;
        SQLLEN messageLength_ = SQL_NULL_DATA;
    public:
        RadomeCommandReplyObject( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(rowVersion_);
            destination.Write(radome_);
            destination.Write(timestamp_);
            destination.Write(command_);
            destination.Write(status_);
            destination.Write(message_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(rowVersion_);
            source.Read(radome_);
            source.Read(timestamp_);
            source.Read(command_);
            source.Read(status_);
            source.Read(message_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<RadomeCommandReplyObject>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<RadomeCommandReplyObject&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const RadomeCommandReplyObject& >( other );
                if ( dataObject.rowVersion_ != rowVersion_ )
                {
                    return false;
                }
                if ( dataObject.radome_ != radome_ )
                {
                    return false;
                }
                if ( dataObject.timestamp_ != timestamp_ )
                {
                    return false;
                }
                if ( dataObject.command_ != command_ )
                {
                    return false;
                }
                if ( dataObject.status_ != status_ )
                {
                    return false;
                }
                if ( dataObject.message_ != message_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        Int64 RowVersion( ) const
        {
            return rowVersion_;
        }
        void SetRowVersion( const Int64& rowVersion )
        {
            rowVersion_ = rowVersion;
        }
        const Guid& Radome( ) const
        {
            return radome_;
        }
        void SetRadome( const Guid& radome )
        {
            radome_ = radome;
        }
        const DateTime& Timestamp( ) const
        {
            return timestamp_;
        }
        void SetTimestamp( const DateTime& timestamp )
        {
            timestamp_ = timestamp;
        }
        const Guid& Command( ) const
        {
            return command_;
        }
        void SetCommand( const Guid& command )
        {
            command_ = command;
        }
        Types::DeviceCommandReplyStatus Status( ) const
        {
            return status_;
        }
        void SetStatus( Types::DeviceCommandReplyStatus status )
        {
            status_ = status;
        }
        const WideString& Message( ) const
        {
            return message_;
        }
        void SetMessage( const WideString& message )
        {
            message_ = message;
        }
    };
    class RadomeConfigurationObject : public BaseData<Kind, Guid>
    {
    public:
        using Base = BaseData<Kind, Guid>;
        static constexpr Kind KIND = Kind::RadomeConfiguration;
    private:
        Int64 rowVersion_ = 0;
        Guid radome_;
        DateTime timestamp_;
        TimeSpan interval_;
        double lowPressureLimit_ = 0.0;
        double highPressureLimit_ = 0.0;
        double lowTemperatureLimit_ = 0.0;
        double highTemperatureLimit_ = 0.0;
    public:
        RadomeConfigurationObject( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(rowVersion_);
            destination.Write(radome_);
            destination.Write(timestamp_);
            destination.Write(interval_);
            destination.Write(lowPressureLimit_);
            destination.Write(highPressureLimit_);
            destination.Write(lowTemperatureLimit_);
            destination.Write(highTemperatureLimit_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(rowVersion_);
            source.Read(radome_);
            source.Read(timestamp_);
            source.Read(interval_);
            source.Read(lowPressureLimit_);
            source.Read(highPressureLimit_);
            source.Read(lowTemperatureLimit_);
            source.Read(highTemperatureLimit_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<RadomeConfigurationObject>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<RadomeConfigurationObject&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const RadomeConfigurationObject& >( other );
                if ( dataObject.rowVersion_ != rowVersion_ )
                {
                    return false;
                }
                if ( dataObject.radome_ != radome_ )
                {
                    return false;
                }
                if ( dataObject.timestamp_ != timestamp_ )
                {
                    return false;
                }
                if ( dataObject.interval_ != interval_ )
                {
                    return false;
                }
                if ( dataObject.lowPressureLimit_ != lowPressureLimit_ )
                {
                    return false;
                }
                if ( dataObject.highPressureLimit_ != highPressureLimit_ )
                {
                    return false;
                }
                if ( dataObject.lowTemperatureLimit_ != lowTemperatureLimit_ )
                {
                    return false;
                }
                if ( dataObject.highTemperatureLimit_ != highTemperatureLimit_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        Int64 RowVersion( ) const
        {
            return rowVersion_;
        }
        void SetRowVersion( const Int64& rowVersion )
        {
            rowVersion_ = rowVersion;
        }
        const Guid& Radome( ) const
        {
            return radome_;
        }
        void SetRadome( const Guid& radome )
        {
            radome_ = radome;
        }
        const DateTime& Timestamp( ) const
        {
            return timestamp_;
        }
        void SetTimestamp( const DateTime& timestamp )
        {
            timestamp_ = timestamp;
        }
        const TimeSpan& Interval( ) const
        {
            return interval_;
        }
        void SetInterval( const TimeSpan& interval )
        {
            interval_ = interval;
        }
        double LowPressureLimit( ) const
        {
            return lowPressureLimit_;
        }
        void SetLowPressureLimit( double lowPressureLimit )
        {
            lowPressureLimit_ = lowPressureLimit;
        }
        double HighPressureLimit( ) const
        {
            return highPressureLimit_;
        }
        void SetHighPressureLimit( double highPressureLimit )
        {
            highPressureLimit_ = highPressureLimit;
        }
        double LowTemperatureLimit( ) const
        {
            return lowTemperatureLimit_;
        }
        void SetLowTemperatureLimit( double lowTemperatureLimit )
        {
            lowTemperatureLimit_ = lowTemperatureLimit;
        }
        double HighTemperatureLimit( ) const
        {
            return highTemperatureLimit_;
        }
        void SetHighTemperatureLimit( double highTemperatureLimit )
        {
            highTemperatureLimit_ = highTemperatureLimit;
        }
    };
    class ReferenceTimeseriesValueObject : public BaseData<Kind, Guid>
    {
    public:
        using Base = BaseData<Kind, Guid>;
        static constexpr Kind KIND = Kind::ReferenceTimeseriesValue;
    private:
        Int64 rowVersion_ = 0;
        Guid timeseries_;
        DateTime timestamp_;
        Guid value_;
    public:
        ReferenceTimeseriesValueObject( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(rowVersion_);
            destination.Write(timeseries_);
            destination.Write(timestamp_);
            destination.Write(value_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(rowVersion_);
            source.Read(timeseries_);
            source.Read(timestamp_);
            source.Read(value_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<ReferenceTimeseriesValueObject>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<ReferenceTimeseriesValueObject&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const ReferenceTimeseriesValueObject& >( other );
                if ( dataObject.rowVersion_ != rowVersion_ )
                {
                    return false;
                }
                if ( dataObject.timeseries_ != timeseries_ )
                {
                    return false;
                }
                if ( dataObject.timestamp_ != timestamp_ )
                {
                    return false;
                }
                if ( dataObject.value_ != value_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        Int64 RowVersion( ) const
        {
            return rowVersion_;
        }
        void SetRowVersion( const Int64& rowVersion )
        {
            rowVersion_ = rowVersion;
        }
        const Guid& Timeseries( ) const
        {
            return timeseries_;
        }
        void SetTimeseries( const Guid& timeseries )
        {
            timeseries_ = timeseries;
        }
        const DateTime& Timestamp( ) const
        {
            return timestamp_;
        }
        void SetTimestamp( const DateTime& timestamp )
        {
            timestamp_ = timestamp;
        }
        const Guid& Value( ) const
        {
            return value_;
        }
        void SetValue( const Guid& value )
        {
            value_ = value;
        }
    };
    class SByteTimeseriesValueObject : public BaseData<Kind, Guid>
    {
    public:
        using Base = BaseData<Kind, Guid>;
        static constexpr Kind KIND = Kind::SByteTimeseriesValue;
    private:
        Int64 rowVersion_ = 0;
        Guid timeseries_;
        DateTime timestamp_;
        DBSByte value_;
    public:
        SByteTimeseriesValueObject( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(rowVersion_);
            destination.Write(timeseries_);
            destination.Write(timestamp_);
            value_.WriteTo( destination );
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(rowVersion_);
            source.Read(timeseries_);
            source.Read(timestamp_);
            value_.ReadFrom( source );
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<SByteTimeseriesValueObject>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<SByteTimeseriesValueObject&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const SByteTimeseriesValueObject& >( other );
                if ( dataObject.rowVersion_ != rowVersion_ )
                {
                    return false;
                }
                if ( dataObject.timeseries_ != timeseries_ )
                {
                    return false;
                }
                if ( dataObject.timestamp_ != timestamp_ )
                {
                    return false;
                }
                if ( dataObject.value_ != value_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        Int64 RowVersion( ) const
        {
            return rowVersion_;
        }
        void SetRowVersion( const Int64& rowVersion )
        {
            rowVersion_ = rowVersion;
        }
        const Guid& Timeseries( ) const
        {
            return timeseries_;
        }
        void SetTimeseries( const Guid& timeseries )
        {
            timeseries_ = timeseries;
        }
        const DateTime& Timestamp( ) const
        {
            return timestamp_;
        }
        void SetTimestamp( const DateTime& timestamp )
        {
            timestamp_ = timestamp;
        }
        const DBSByte& Value( ) const
        {
            return value_;
        }
        void SetValue( const DBSByte& value )
        {
            value_ = value;
        }
    };
    class SecurityDomainObject : public BaseData<Kind, Guid>
    {
    public:
        using Base = BaseData<Kind, Guid>;
        static constexpr Kind KIND = Kind::SecurityDomain;
    private:
        Int64 rowVersion_ = 0;
        FixedDBWideString<127> name_;
        WideString description_;
        SQLLEN descriptionLength_ = SQL_NULL_DATA;
    public:
        SecurityDomainObject( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(rowVersion_);
            name_.WriteTo( destination );
            destination.Write(description_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(rowVersion_);
            name_.ReadFrom( source );
            source.Read(description_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<SecurityDomainObject>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<SecurityDomainObject&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const SecurityDomainObject& >( other );
                if ( dataObject.rowVersion_ != rowVersion_ )
                {
                    return false;
                }
                if ( dataObject.name_ != name_ )
                {
                    return false;
                }
                if ( dataObject.description_ != description_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        Int64 RowVersion( ) const
        {
            return rowVersion_;
        }
        void SetRowVersion( const Int64& rowVersion )
        {
            rowVersion_ = rowVersion;
        }
        const FixedDBWideString<127>& Name( ) const
        {
            return name_;
        }
        void SetName( const FixedDBWideString<127>& name )
        {
            name_ = name;
        }
        const WideString& Description( ) const
        {
            return description_;
        }
        void SetDescription( const WideString& description )
        {
            description_ = description;
        }
    };
    class SecurityIdentifierObject : public BaseData<Kind, Guid>
    {
    public:
        using Base = BaseData<Kind, Guid>;
        static constexpr Kind KIND = Kind::SecurityIdentifier;
    private:
        Int64 rowVersion_ = 0;
        Guid domain_;
        FixedDBWideString<255> identity_;
        WideString description_;
        SQLLEN descriptionLength_ = SQL_NULL_DATA;
    public:
        SecurityIdentifierObject( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(rowVersion_);
            destination.Write(domain_);
            identity_.WriteTo( destination );
            destination.Write(description_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(rowVersion_);
            source.Read(domain_);
            identity_.ReadFrom( source );
            source.Read(description_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<SecurityIdentifierObject>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<SecurityIdentifierObject&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const SecurityIdentifierObject& >( other );
                if ( dataObject.rowVersion_ != rowVersion_ )
                {
                    return false;
                }
                if ( dataObject.domain_ != domain_ )
                {
                    return false;
                }
                if ( dataObject.identity_ != identity_ )
                {
                    return false;
                }
                if ( dataObject.description_ != description_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        Int64 RowVersion( ) const
        {
            return rowVersion_;
        }
        void SetRowVersion( const Int64& rowVersion )
        {
            rowVersion_ = rowVersion;
        }
        const Guid& Domain( ) const
        {
            return domain_;
        }
        void SetDomain( const Guid& domain )
        {
            domain_ = domain;
        }
        const FixedDBWideString<255>& Identity( ) const
        {
            return identity_;
        }
        void SetIdentity( const FixedDBWideString<255>& identity )
        {
            identity_ = identity;
        }
        const WideString& Description( ) const
        {
            return description_;
        }
        void SetDescription( const WideString& description )
        {
            description_ = description;
        }
    };
    class SecurityLoginObject : public SecurityIdentifierObject
    {
    public:
        using Base = SecurityIdentifierObject;
        static constexpr Kind KIND = Kind::SecurityLogin;
    private:
    public:
        SecurityLoginObject( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<SecurityLoginObject>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<SecurityLoginObject&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const SecurityLoginObject& >( other );
                return true;
            }
            return false;
        }
    };
    class SecurityRoleObject : public SecurityIdentifierObject
    {
    public:
        using Base = SecurityIdentifierObject;
        static constexpr Kind KIND = Kind::SecurityRole;
    private:
        FixedDBWideString<127> name_;
    public:
        SecurityRoleObject( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            name_.WriteTo( destination );
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            name_.ReadFrom( source );
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<SecurityRoleObject>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<SecurityRoleObject&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const SecurityRoleObject& >( other );
                if ( dataObject.name_ != name_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        const FixedDBWideString<127>& Name( ) const
        {
            return name_;
        }
        void SetName( const FixedDBWideString<127>& name )
        {
            name_ = name;
        }
    };
    class SecurityIdentifierRoleLinkObject : public BaseData<Kind, Guid>
    {
    public:
        using Base = BaseData<Kind, Guid>;
        static constexpr Kind KIND = Kind::SecurityIdentifierRoleLink;
    private:
        Int64 rowVersion_ = 0;
        Guid member_;
        Guid role_;
        DateTime start_;
        DBDateTime end_;
    public:
        SecurityIdentifierRoleLinkObject( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(rowVersion_);
            destination.Write(member_);
            destination.Write(role_);
            destination.Write(start_);
            end_.WriteTo( destination );
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(rowVersion_);
            source.Read(member_);
            source.Read(role_);
            source.Read(start_);
            end_.ReadFrom( source );
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<SecurityIdentifierRoleLinkObject>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<SecurityIdentifierRoleLinkObject&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const SecurityIdentifierRoleLinkObject& >( other );
                if ( dataObject.rowVersion_ != rowVersion_ )
                {
                    return false;
                }
                if ( dataObject.member_ != member_ )
                {
                    return false;
                }
                if ( dataObject.role_ != role_ )
                {
                    return false;
                }
                if ( dataObject.start_ != start_ )
                {
                    return false;
                }
                if ( dataObject.end_ != end_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        Int64 RowVersion( ) const
        {
            return rowVersion_;
        }
        void SetRowVersion( const Int64& rowVersion )
        {
            rowVersion_ = rowVersion;
        }
        const Guid& Member( ) const
        {
            return member_;
        }
        void SetMember( const Guid& member )
        {
            member_ = member;
        }
        const Guid& Role( ) const
        {
            return role_;
        }
        void SetRole( const Guid& role )
        {
            role_ = role;
        }
        const DateTime& Start( ) const
        {
            return start_;
        }
        void SetStart( const DateTime& start )
        {
            start_ = start;
        }
        const DBDateTime& End( ) const
        {
            return end_;
        }
        void SetEnd( const DBDateTime& end )
        {
            end_ = end;
        }
    };
    class SecurityLoginSessionObject : public BaseData<Kind, Guid>
    {
    public:
        using Base = BaseData<Kind, Guid>;
        static constexpr Kind KIND = Kind::SecurityLoginSession;
    private:
        Int64 rowVersion_ = 0;
        Guid login_;
        DateTime fromTime_;
        DBDateTime throughTime_;
        Guid clientSession_;
        FixedDBWideString<260> notificationQueueName_;
        FixedDBWideString<260> messageQueueName_;
    public:
        SecurityLoginSessionObject( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(rowVersion_);
            destination.Write(login_);
            destination.Write(fromTime_);
            throughTime_.WriteTo( destination );
            destination.Write(clientSession_);
            notificationQueueName_.WriteTo( destination );
            messageQueueName_.WriteTo( destination );
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(rowVersion_);
            source.Read(login_);
            source.Read(fromTime_);
            throughTime_.ReadFrom( source );
            source.Read(clientSession_);
            notificationQueueName_.ReadFrom( source );
            messageQueueName_.ReadFrom( source );
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<SecurityLoginSessionObject>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<SecurityLoginSessionObject&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const SecurityLoginSessionObject& >( other );
                if ( dataObject.rowVersion_ != rowVersion_ )
                {
                    return false;
                }
                if ( dataObject.login_ != login_ )
                {
                    return false;
                }
                if ( dataObject.fromTime_ != fromTime_ )
                {
                    return false;
                }
                if ( dataObject.throughTime_ != throughTime_ )
                {
                    return false;
                }
                if ( dataObject.clientSession_ != clientSession_ )
                {
                    return false;
                }
                if ( dataObject.notificationQueueName_ != notificationQueueName_ )
                {
                    return false;
                }
                if ( dataObject.messageQueueName_ != messageQueueName_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        Int64 RowVersion( ) const
        {
            return rowVersion_;
        }
        void SetRowVersion( const Int64& rowVersion )
        {
            rowVersion_ = rowVersion;
        }
        const Guid& Login( ) const
        {
            return login_;
        }
        void SetLogin( const Guid& login )
        {
            login_ = login;
        }
        const DateTime& FromTime( ) const
        {
            return fromTime_;
        }
        void SetFromTime( const DateTime& fromTime )
        {
            fromTime_ = fromTime;
        }
        const DBDateTime& ThroughTime( ) const
        {
            return throughTime_;
        }
        void SetThroughTime( const DBDateTime& throughTime )
        {
            throughTime_ = throughTime;
        }
        const Guid& ClientSession( ) const
        {
            return clientSession_;
        }
        void SetClientSession( const Guid& clientSession )
        {
            clientSession_ = clientSession;
        }
        const FixedDBWideString<260>& NotificationQueueName( ) const
        {
            return notificationQueueName_;
        }
        void SetNotificationQueueName( const FixedDBWideString<260>& notificationQueueName )
        {
            notificationQueueName_ = notificationQueueName;
        }
        const FixedDBWideString<260>& MessageQueueName( ) const
        {
            return messageQueueName_;
        }
        void SetMessageQueueName( const FixedDBWideString<260>& messageQueueName )
        {
            messageQueueName_ = messageQueueName;
        }
    };
    class SecurityPermissionObject : public BaseData<Kind, Guid>
    {
    public:
        using Base = BaseData<Kind, Guid>;
        static constexpr Kind KIND = Kind::SecurityPermission;
    private:
        Int64 rowVersion_ = 0;
        Guid identifier_;
        DateTime timestamp_;
        Int32 typeCode_ = 0;
        bool canCreate_ = false;
        bool canRead_ = false;
        bool canUpdate_ = false;
        bool canDelete_ = false;
    public:
        SecurityPermissionObject( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(rowVersion_);
            destination.Write(identifier_);
            destination.Write(timestamp_);
            destination.Write(typeCode_);
            destination.Write(canCreate_);
            destination.Write(canRead_);
            destination.Write(canUpdate_);
            destination.Write(canDelete_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(rowVersion_);
            source.Read(identifier_);
            source.Read(timestamp_);
            source.Read(typeCode_);
            source.Read(canCreate_);
            source.Read(canRead_);
            source.Read(canUpdate_);
            source.Read(canDelete_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<SecurityPermissionObject>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<SecurityPermissionObject&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const SecurityPermissionObject& >( other );
                if ( dataObject.rowVersion_ != rowVersion_ )
                {
                    return false;
                }
                if ( dataObject.identifier_ != identifier_ )
                {
                    return false;
                }
                if ( dataObject.timestamp_ != timestamp_ )
                {
                    return false;
                }
                if ( dataObject.typeCode_ != typeCode_ )
                {
                    return false;
                }
                if ( dataObject.canCreate_ != canCreate_ )
                {
                    return false;
                }
                if ( dataObject.canRead_ != canRead_ )
                {
                    return false;
                }
                if ( dataObject.canUpdate_ != canUpdate_ )
                {
                    return false;
                }
                if ( dataObject.canDelete_ != canDelete_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        Int64 RowVersion( ) const
        {
            return rowVersion_;
        }
        void SetRowVersion( const Int64& rowVersion )
        {
            rowVersion_ = rowVersion;
        }
        const Guid& Identifier( ) const
        {
            return identifier_;
        }
        void SetIdentifier( const Guid& identifier )
        {
            identifier_ = identifier;
        }
        const DateTime& Timestamp( ) const
        {
            return timestamp_;
        }
        void SetTimestamp( const DateTime& timestamp )
        {
            timestamp_ = timestamp;
        }
        Int32 TypeCode( ) const
        {
            return typeCode_;
        }
        void SetTypeCode( Int32 typeCode )
        {
            typeCode_ = typeCode;
        }
        bool CanCreate( ) const
        {
            return canCreate_;
        }
        void SetCanCreate( bool canCreate )
        {
            canCreate_ = canCreate;
        }
        bool CanRead( ) const
        {
            return canRead_;
        }
        void SetCanRead( bool canRead )
        {
            canRead_ = canRead;
        }
        bool CanUpdate( ) const
        {
            return canUpdate_;
        }
        void SetCanUpdate( bool canUpdate )
        {
            canUpdate_ = canUpdate;
        }
        bool CanDelete( ) const
        {
            return canDelete_;
        }
        void SetCanDelete( bool canDelete )
        {
            canDelete_ = canDelete;
        }
    };
    class SingleTimeseriesValueObject : public BaseData<Kind, Guid>
    {
    public:
        using Base = BaseData<Kind, Guid>;
        static constexpr Kind KIND = Kind::SingleTimeseriesValue;
    private:
        Int64 rowVersion_ = 0;
        Guid timeseries_;
        DateTime timestamp_;
        DBSingle value_;
    public:
        SingleTimeseriesValueObject( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(rowVersion_);
            destination.Write(timeseries_);
            destination.Write(timestamp_);
            value_.WriteTo( destination );
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(rowVersion_);
            source.Read(timeseries_);
            source.Read(timestamp_);
            value_.ReadFrom( source );
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<SingleTimeseriesValueObject>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<SingleTimeseriesValueObject&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const SingleTimeseriesValueObject& >( other );
                if ( dataObject.rowVersion_ != rowVersion_ )
                {
                    return false;
                }
                if ( dataObject.timeseries_ != timeseries_ )
                {
                    return false;
                }
                if ( dataObject.timestamp_ != timestamp_ )
                {
                    return false;
                }
                if ( dataObject.value_ != value_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        Int64 RowVersion( ) const
        {
            return rowVersion_;
        }
        void SetRowVersion( const Int64& rowVersion )
        {
            rowVersion_ = rowVersion;
        }
        const Guid& Timeseries( ) const
        {
            return timeseries_;
        }
        void SetTimeseries( const Guid& timeseries )
        {
            timeseries_ = timeseries;
        }
        const DateTime& Timestamp( ) const
        {
            return timestamp_;
        }
        void SetTimestamp( const DateTime& timestamp )
        {
            timestamp_ = timestamp;
        }
        const DBSingle& Value( ) const
        {
            return value_;
        }
        void SetValue( const DBSingle& value )
        {
            value_ = value;
        }
    };
    class StringTimeseriesValueObject : public BaseData<Kind, Guid>
    {
    public:
        using Base = BaseData<Kind, Guid>;
        static constexpr Kind KIND = Kind::StringTimeseriesValue;
    private:
        Int64 rowVersion_ = 0;
        Guid timeseries_;
        DateTime timestamp_;
        WideString value_;
        SQLLEN valueLength_ = SQL_NULL_DATA;
    public:
        StringTimeseriesValueObject( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(rowVersion_);
            destination.Write(timeseries_);
            destination.Write(timestamp_);
            destination.Write(value_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(rowVersion_);
            source.Read(timeseries_);
            source.Read(timestamp_);
            source.Read(value_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<StringTimeseriesValueObject>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<StringTimeseriesValueObject&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const StringTimeseriesValueObject& >( other );
                if ( dataObject.rowVersion_ != rowVersion_ )
                {
                    return false;
                }
                if ( dataObject.timeseries_ != timeseries_ )
                {
                    return false;
                }
                if ( dataObject.timestamp_ != timestamp_ )
                {
                    return false;
                }
                if ( dataObject.value_ != value_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        Int64 RowVersion( ) const
        {
            return rowVersion_;
        }
        void SetRowVersion( const Int64& rowVersion )
        {
            rowVersion_ = rowVersion;
        }
        const Guid& Timeseries( ) const
        {
            return timeseries_;
        }
        void SetTimeseries( const Guid& timeseries )
        {
            timeseries_ = timeseries;
        }
        const DateTime& Timestamp( ) const
        {
            return timestamp_;
        }
        void SetTimestamp( const DateTime& timestamp )
        {
            timestamp_ = timestamp;
        }
        const WideString& Value( ) const
        {
            return value_;
        }
        void SetValue( const WideString& value )
        {
            value_ = value;
        }
    };
    class TimeseriesCatalogElementObject : public BaseData<Kind, Guid>
    {
    public:
        using Base = BaseData<Kind, Guid>;
        static constexpr Kind KIND = Kind::TimeseriesCatalogElement;
    private:
        Int64 rowVersion_ = 0;
        DBGuid catalog_;
        FixedDBWideString<127> name_;
    public:
        TimeseriesCatalogElementObject( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(rowVersion_);
            catalog_.WriteTo( destination );
            name_.WriteTo( destination );
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(rowVersion_);
            catalog_.ReadFrom( source );
            name_.ReadFrom( source );
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<TimeseriesCatalogElementObject>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<TimeseriesCatalogElementObject&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const TimeseriesCatalogElementObject& >( other );
                if ( dataObject.rowVersion_ != rowVersion_ )
                {
                    return false;
                }
                if ( dataObject.catalog_ != catalog_ )
                {
                    return false;
                }
                if ( dataObject.name_ != name_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        Int64 RowVersion( ) const
        {
            return rowVersion_;
        }
        void SetRowVersion( const Int64& rowVersion )
        {
            rowVersion_ = rowVersion;
        }
        const DBGuid& Catalog( ) const
        {
            return catalog_;
        }
        void SetCatalog( const DBGuid& catalog )
        {
            catalog_ = catalog;
        }
        const FixedDBWideString<127>& Name( ) const
        {
            return name_;
        }
        void SetName( const FixedDBWideString<127>& name )
        {
            name_ = name;
        }
    };
    class TimeseriesObject : public TimeseriesCatalogElementObject
    {
    public:
        using Base = TimeseriesCatalogElementObject;
        static constexpr Kind KIND = Kind::Timeseries;
    private:
        TimeSpan maxRetention_;
    public:
        TimeseriesObject( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(maxRetention_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(maxRetention_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<TimeseriesObject>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<TimeseriesObject&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const TimeseriesObject& >( other );
                if ( dataObject.maxRetention_ != maxRetention_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        const TimeSpan& MaxRetention( ) const
        {
            return maxRetention_;
        }
        void SetMaxRetention( const TimeSpan& maxRetention )
        {
            maxRetention_ = maxRetention;
        }
    };
    class BinaryTimeseriesObject : public TimeseriesObject
    {
    public:
        using Base = TimeseriesObject;
        static constexpr Kind KIND = Kind::BinaryTimeseries;
    private:
    public:
        BinaryTimeseriesObject( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<BinaryTimeseriesObject>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<BinaryTimeseriesObject&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const BinaryTimeseriesObject& >( other );
                return true;
            }
            return false;
        }
    };
    class BooleanTimeseriesObject : public TimeseriesObject
    {
    public:
        using Base = TimeseriesObject;
        static constexpr Kind KIND = Kind::BooleanTimeseries;
    private:
    public:
        BooleanTimeseriesObject( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<BooleanTimeseriesObject>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<BooleanTimeseriesObject&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const BooleanTimeseriesObject& >( other );
                return true;
            }
            return false;
        }
    };
    class AisAidToNavigationOffPositionTimeseriesObject : public BooleanTimeseriesObject
    {
    public:
        using Base = BooleanTimeseriesObject;
        static constexpr Kind KIND = Kind::AisAidToNavigationOffPositionTimeseries;
    private:
        Guid aidToNavigation_;
    public:
        AisAidToNavigationOffPositionTimeseriesObject( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(aidToNavigation_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(aidToNavigation_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<AisAidToNavigationOffPositionTimeseriesObject>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<AisAidToNavigationOffPositionTimeseriesObject&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const AisAidToNavigationOffPositionTimeseriesObject& >( other );
                if ( dataObject.aidToNavigation_ != aidToNavigation_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        const Guid& AidToNavigation( ) const
        {
            return aidToNavigation_;
        }
        void SetAidToNavigation( const Guid& aidToNavigation )
        {
            aidToNavigation_ = aidToNavigation;
        }
    };
    class DeviceEnabledTimeseriesObject : public BooleanTimeseriesObject
    {
    public:
        using Base = BooleanTimeseriesObject;
        static constexpr Kind KIND = Kind::DeviceEnabledTimeseries;
    private:
        DBGuid device_;
    public:
        DeviceEnabledTimeseriesObject( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            device_.WriteTo( destination );
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            device_.ReadFrom( source );
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<DeviceEnabledTimeseriesObject>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<DeviceEnabledTimeseriesObject&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const DeviceEnabledTimeseriesObject& >( other );
                if ( dataObject.device_ != device_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        const DBGuid& Device( ) const
        {
            return device_;
        }
        void SetDevice( const DBGuid& device )
        {
            device_ = device;
        }
    };
    class RadarAutomaticSensitivityTimeControlTimeseriesObject : public BooleanTimeseriesObject
    {
    public:
        using Base = BooleanTimeseriesObject;
        static constexpr Kind KIND = Kind::RadarAutomaticSensitivityTimeControlTimeseries;
    private:
        Guid radar_;
    public:
        RadarAutomaticSensitivityTimeControlTimeseriesObject( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(radar_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(radar_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<RadarAutomaticSensitivityTimeControlTimeseriesObject>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<RadarAutomaticSensitivityTimeControlTimeseriesObject&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const RadarAutomaticSensitivityTimeControlTimeseriesObject& >( other );
                if ( dataObject.radar_ != radar_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        const Guid& Radar( ) const
        {
            return radar_;
        }
        void SetRadar( const Guid& radar )
        {
            radar_ = radar;
        }
    };
    class RadarBlankSector1TimeseriesObject : public BooleanTimeseriesObject
    {
    public:
        using Base = BooleanTimeseriesObject;
        static constexpr Kind KIND = Kind::RadarBlankSector1Timeseries;
    private:
        Guid radar_;
    public:
        RadarBlankSector1TimeseriesObject( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(radar_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(radar_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<RadarBlankSector1TimeseriesObject>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<RadarBlankSector1TimeseriesObject&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const RadarBlankSector1TimeseriesObject& >( other );
                if ( dataObject.radar_ != radar_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        const Guid& Radar( ) const
        {
            return radar_;
        }
        void SetRadar( const Guid& radar )
        {
            radar_ = radar;
        }
    };
    class RadarBlankSector2TimeseriesObject : public BooleanTimeseriesObject
    {
    public:
        using Base = BooleanTimeseriesObject;
        static constexpr Kind KIND = Kind::RadarBlankSector2Timeseries;
    private:
        Guid radar_;
    public:
        RadarBlankSector2TimeseriesObject( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(radar_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(radar_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<RadarBlankSector2TimeseriesObject>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<RadarBlankSector2TimeseriesObject&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const RadarBlankSector2TimeseriesObject& >( other );
                if ( dataObject.radar_ != radar_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        const Guid& Radar( ) const
        {
            return radar_;
        }
        void SetRadar( const Guid& radar )
        {
            radar_ = radar;
        }
    };
    class RadarEnableAutomaticFrequencyControlTimeseriesObject : public BooleanTimeseriesObject
    {
    public:
        using Base = BooleanTimeseriesObject;
        static constexpr Kind KIND = Kind::RadarEnableAutomaticFrequencyControlTimeseries;
    private:
        Guid radar_;
    public:
        RadarEnableAutomaticFrequencyControlTimeseriesObject( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(radar_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(radar_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<RadarEnableAutomaticFrequencyControlTimeseriesObject>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<RadarEnableAutomaticFrequencyControlTimeseriesObject&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const RadarEnableAutomaticFrequencyControlTimeseriesObject& >( other );
                if ( dataObject.radar_ != radar_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        const Guid& Radar( ) const
        {
            return radar_;
        }
        void SetRadar( const Guid& radar )
        {
            radar_ = radar;
        }
    };
    class RadarEnableFastTimeConstantTimeseriesObject : public BooleanTimeseriesObject
    {
    public:
        using Base = BooleanTimeseriesObject;
        static constexpr Kind KIND = Kind::RadarEnableFastTimeConstantTimeseries;
    private:
        Guid radar_;
    public:
        RadarEnableFastTimeConstantTimeseriesObject( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(radar_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(radar_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<RadarEnableFastTimeConstantTimeseriesObject>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<RadarEnableFastTimeConstantTimeseriesObject&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const RadarEnableFastTimeConstantTimeseriesObject& >( other );
                if ( dataObject.radar_ != radar_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        const Guid& Radar( ) const
        {
            return radar_;
        }
        void SetRadar( const Guid& radar )
        {
            radar_ = radar;
        }
    };
    class RadarEnableSensitivityTimeControlTimeseriesObject : public BooleanTimeseriesObject
    {
    public:
        using Base = BooleanTimeseriesObject;
        static constexpr Kind KIND = Kind::RadarEnableSensitivityTimeControlTimeseries;
    private:
        Guid radar_;
    public:
        RadarEnableSensitivityTimeControlTimeseriesObject( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(radar_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(radar_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<RadarEnableSensitivityTimeControlTimeseriesObject>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<RadarEnableSensitivityTimeControlTimeseriesObject&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const RadarEnableSensitivityTimeControlTimeseriesObject& >( other );
                if ( dataObject.radar_ != radar_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        const Guid& Radar( ) const
        {
            return radar_;
        }
        void SetRadar( const Guid& radar )
        {
            radar_ = radar;
        }
    };
    class RadarPowerOnTimeseriesObject : public BooleanTimeseriesObject
    {
    public:
        using Base = BooleanTimeseriesObject;
        static constexpr Kind KIND = Kind::RadarPowerOnTimeseries;
    private:
        Guid radar_;
    public:
        RadarPowerOnTimeseriesObject( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(radar_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(radar_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<RadarPowerOnTimeseriesObject>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<RadarPowerOnTimeseriesObject&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const RadarPowerOnTimeseriesObject& >( other );
                if ( dataObject.radar_ != radar_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        const Guid& Radar( ) const
        {
            return radar_;
        }
        void SetRadar( const Guid& radar )
        {
            radar_ = radar;
        }
    };
    class RadarSaveSettingsTimeseriesObject : public BooleanTimeseriesObject
    {
    public:
        using Base = BooleanTimeseriesObject;
        static constexpr Kind KIND = Kind::RadarSaveSettingsTimeseries;
    private:
        Guid radar_;
    public:
        RadarSaveSettingsTimeseriesObject( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(radar_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(radar_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<RadarSaveSettingsTimeseriesObject>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<RadarSaveSettingsTimeseriesObject&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const RadarSaveSettingsTimeseriesObject& >( other );
                if ( dataObject.radar_ != radar_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        const Guid& Radar( ) const
        {
            return radar_;
        }
        void SetRadar( const Guid& radar )
        {
            radar_ = radar;
        }
    };
    class RadarTrackingTimeseriesObject : public BooleanTimeseriesObject
    {
    public:
        using Base = BooleanTimeseriesObject;
        static constexpr Kind KIND = Kind::RadarTrackingTimeseries;
    private:
        Guid radar_;
    public:
        RadarTrackingTimeseriesObject( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(radar_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(radar_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<RadarTrackingTimeseriesObject>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<RadarTrackingTimeseriesObject&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const RadarTrackingTimeseriesObject& >( other );
                if ( dataObject.radar_ != radar_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        const Guid& Radar( ) const
        {
            return radar_;
        }
        void SetRadar( const Guid& radar )
        {
            radar_ = radar;
        }
    };
    class MediaProxySessionEnabledTimeseriesObject : public BooleanTimeseriesObject
    {
    public:
        using Base = BooleanTimeseriesObject;
        static constexpr Kind KIND = Kind::MediaProxySessionEnabledTimeseries;
    private:
        Guid proxySession_;
    public:
        MediaProxySessionEnabledTimeseriesObject( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(proxySession_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(proxySession_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<MediaProxySessionEnabledTimeseriesObject>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<MediaProxySessionEnabledTimeseriesObject&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const MediaProxySessionEnabledTimeseriesObject& >( other );
                if ( dataObject.proxySession_ != proxySession_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        const Guid& ProxySession( ) const
        {
            return proxySession_;
        }
        void SetProxySession( const Guid& proxySession )
        {
            proxySession_ = proxySession;
        }
    };
    class MediaServiceEnabledTimeseriesObject : public BooleanTimeseriesObject
    {
    public:
        using Base = BooleanTimeseriesObject;
        static constexpr Kind KIND = Kind::MediaServiceEnabledTimeseries;
    private:
        Guid service_;
    public:
        MediaServiceEnabledTimeseriesObject( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(service_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(service_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<MediaServiceEnabledTimeseriesObject>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<MediaServiceEnabledTimeseriesObject&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const MediaServiceEnabledTimeseriesObject& >( other );
                if ( dataObject.service_ != service_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        const Guid& Service( ) const
        {
            return service_;
        }
        void SetService( const Guid& service )
        {
            service_ = service;
        }
    };
    class ByteTimeseriesObject : public TimeseriesObject
    {
    public:
        using Base = TimeseriesObject;
        static constexpr Kind KIND = Kind::ByteTimeseries;
    private:
    public:
        ByteTimeseriesObject( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<ByteTimeseriesObject>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<ByteTimeseriesObject&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const ByteTimeseriesObject& >( other );
                return true;
            }
            return false;
        }
    };
    class DateTimeTimeseriesObject : public TimeseriesObject
    {
    public:
        using Base = TimeseriesObject;
        static constexpr Kind KIND = Kind::DateTimeTimeseries;
    private:
    public:
        DateTimeTimeseriesObject( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<DateTimeTimeseriesObject>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<DateTimeTimeseriesObject&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const DateTimeTimeseriesObject& >( other );
                return true;
            }
            return false;
        }
    };
    class DoubleTimeseriesObject : public TimeseriesObject
    {
    public:
        using Base = TimeseriesObject;
        static constexpr Kind KIND = Kind::DoubleTimeseries;
    private:
    public:
        DoubleTimeseriesObject( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<DoubleTimeseriesObject>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<DoubleTimeseriesObject&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const DoubleTimeseriesObject& >( other );
                return true;
            }
            return false;
        }
    };
    class GNSSAltitudeTimeseriesObject : public DoubleTimeseriesObject
    {
    public:
        using Base = DoubleTimeseriesObject;
        static constexpr Kind KIND = Kind::GNSSAltitudeTimeseries;
    private:
        Guid gNSSDevice_;
    public:
        GNSSAltitudeTimeseriesObject( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(gNSSDevice_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(gNSSDevice_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<GNSSAltitudeTimeseriesObject>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<GNSSAltitudeTimeseriesObject&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const GNSSAltitudeTimeseriesObject& >( other );
                if ( dataObject.gNSSDevice_ != gNSSDevice_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        const Guid& GNSSDevice( ) const
        {
            return gNSSDevice_;
        }
        void SetGNSSDevice( const Guid& gNSSDevice )
        {
            gNSSDevice_ = gNSSDevice;
        }
    };
    class GNSSLatitudeTimeseriesObject : public DoubleTimeseriesObject
    {
    public:
        using Base = DoubleTimeseriesObject;
        static constexpr Kind KIND = Kind::GNSSLatitudeTimeseries;
    private:
        Guid gNSSDevice_;
    public:
        GNSSLatitudeTimeseriesObject( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(gNSSDevice_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(gNSSDevice_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<GNSSLatitudeTimeseriesObject>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<GNSSLatitudeTimeseriesObject&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const GNSSLatitudeTimeseriesObject& >( other );
                if ( dataObject.gNSSDevice_ != gNSSDevice_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        const Guid& GNSSDevice( ) const
        {
            return gNSSDevice_;
        }
        void SetGNSSDevice( const Guid& gNSSDevice )
        {
            gNSSDevice_ = gNSSDevice;
        }
    };
    class GNSSLongitudeTimeseriesObject : public DoubleTimeseriesObject
    {
    public:
        using Base = DoubleTimeseriesObject;
        static constexpr Kind KIND = Kind::GNSSLongitudeTimeseries;
    private:
        Guid gNSSDevice_;
    public:
        GNSSLongitudeTimeseriesObject( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(gNSSDevice_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(gNSSDevice_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<GNSSLongitudeTimeseriesObject>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<GNSSLongitudeTimeseriesObject&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const GNSSLongitudeTimeseriesObject& >( other );
                if ( dataObject.gNSSDevice_ != gNSSDevice_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        const Guid& GNSSDevice( ) const
        {
            return gNSSDevice_;
        }
        void SetGNSSDevice( const Guid& gNSSDevice )
        {
            gNSSDevice_ = gNSSDevice;
        }
    };
    class GyroCourseTimeseriesObject : public DoubleTimeseriesObject
    {
    public:
        using Base = DoubleTimeseriesObject;
        static constexpr Kind KIND = Kind::GyroCourseTimeseries;
    private:
        Guid gyroDevice_;
    public:
        GyroCourseTimeseriesObject( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(gyroDevice_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(gyroDevice_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<GyroCourseTimeseriesObject>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<GyroCourseTimeseriesObject&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const GyroCourseTimeseriesObject& >( other );
                if ( dataObject.gyroDevice_ != gyroDevice_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        const Guid& GyroDevice( ) const
        {
            return gyroDevice_;
        }
        void SetGyroDevice( const Guid& gyroDevice )
        {
            gyroDevice_ = gyroDevice;
        }
    };
    class GyroHeadingMagneticNorthTimeseriesObject : public DoubleTimeseriesObject
    {
    public:
        using Base = DoubleTimeseriesObject;
        static constexpr Kind KIND = Kind::GyroHeadingMagneticNorthTimeseries;
    private:
        Guid gyroDevice_;
    public:
        GyroHeadingMagneticNorthTimeseriesObject( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(gyroDevice_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(gyroDevice_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<GyroHeadingMagneticNorthTimeseriesObject>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<GyroHeadingMagneticNorthTimeseriesObject&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const GyroHeadingMagneticNorthTimeseriesObject& >( other );
                if ( dataObject.gyroDevice_ != gyroDevice_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        const Guid& GyroDevice( ) const
        {
            return gyroDevice_;
        }
        void SetGyroDevice( const Guid& gyroDevice )
        {
            gyroDevice_ = gyroDevice;
        }
    };
    class GyroHeadingTrueNorthTimeseriesObject : public DoubleTimeseriesObject
    {
    public:
        using Base = DoubleTimeseriesObject;
        static constexpr Kind KIND = Kind::GyroHeadingTrueNorthTimeseries;
    private:
        Guid gyroDevice_;
    public:
        GyroHeadingTrueNorthTimeseriesObject( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(gyroDevice_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(gyroDevice_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<GyroHeadingTrueNorthTimeseriesObject>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<GyroHeadingTrueNorthTimeseriesObject&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const GyroHeadingTrueNorthTimeseriesObject& >( other );
                if ( dataObject.gyroDevice_ != gyroDevice_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        const Guid& GyroDevice( ) const
        {
            return gyroDevice_;
        }
        void SetGyroDevice( const Guid& gyroDevice )
        {
            gyroDevice_ = gyroDevice;
        }
    };
    class GyroPitchTimeseriesObject : public DoubleTimeseriesObject
    {
    public:
        using Base = DoubleTimeseriesObject;
        static constexpr Kind KIND = Kind::GyroPitchTimeseries;
    private:
        Guid gyroDevice_;
    public:
        GyroPitchTimeseriesObject( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(gyroDevice_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(gyroDevice_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<GyroPitchTimeseriesObject>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<GyroPitchTimeseriesObject&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const GyroPitchTimeseriesObject& >( other );
                if ( dataObject.gyroDevice_ != gyroDevice_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        const Guid& GyroDevice( ) const
        {
            return gyroDevice_;
        }
        void SetGyroDevice( const Guid& gyroDevice )
        {
            gyroDevice_ = gyroDevice;
        }
    };
    class GyroRateOfTurnTimeseriesObject : public DoubleTimeseriesObject
    {
    public:
        using Base = DoubleTimeseriesObject;
        static constexpr Kind KIND = Kind::GyroRateOfTurnTimeseries;
    private:
        Guid gyroDevice_;
    public:
        GyroRateOfTurnTimeseriesObject( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(gyroDevice_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(gyroDevice_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<GyroRateOfTurnTimeseriesObject>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<GyroRateOfTurnTimeseriesObject&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const GyroRateOfTurnTimeseriesObject& >( other );
                if ( dataObject.gyroDevice_ != gyroDevice_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        const Guid& GyroDevice( ) const
        {
            return gyroDevice_;
        }
        void SetGyroDevice( const Guid& gyroDevice )
        {
            gyroDevice_ = gyroDevice;
        }
    };
    class GyroRollTimeseriesObject : public DoubleTimeseriesObject
    {
    public:
        using Base = DoubleTimeseriesObject;
        static constexpr Kind KIND = Kind::GyroRollTimeseries;
    private:
        Guid gyroDevice_;
    public:
        GyroRollTimeseriesObject( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(gyroDevice_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(gyroDevice_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<GyroRollTimeseriesObject>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<GyroRollTimeseriesObject&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const GyroRollTimeseriesObject& >( other );
                if ( dataObject.gyroDevice_ != gyroDevice_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        const Guid& GyroDevice( ) const
        {
            return gyroDevice_;
        }
        void SetGyroDevice( const Guid& gyroDevice )
        {
            gyroDevice_ = gyroDevice;
        }
    };
    class GyroSpeedTimeseriesObject : public DoubleTimeseriesObject
    {
    public:
        using Base = DoubleTimeseriesObject;
        static constexpr Kind KIND = Kind::GyroSpeedTimeseries;
    private:
        Guid gyroDevice_;
    public:
        GyroSpeedTimeseriesObject( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(gyroDevice_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(gyroDevice_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<GyroSpeedTimeseriesObject>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<GyroSpeedTimeseriesObject&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const GyroSpeedTimeseriesObject& >( other );
                if ( dataObject.gyroDevice_ != gyroDevice_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        const Guid& GyroDevice( ) const
        {
            return gyroDevice_;
        }
        void SetGyroDevice( const Guid& gyroDevice )
        {
            gyroDevice_ = gyroDevice;
        }
    };
    class RadarLatitudeTimeseriesObject : public DoubleTimeseriesObject
    {
    public:
        using Base = DoubleTimeseriesObject;
        static constexpr Kind KIND = Kind::RadarLatitudeTimeseries;
    private:
        Guid radar_;
    public:
        RadarLatitudeTimeseriesObject( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(radar_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(radar_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<RadarLatitudeTimeseriesObject>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<RadarLatitudeTimeseriesObject&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const RadarLatitudeTimeseriesObject& >( other );
                if ( dataObject.radar_ != radar_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        const Guid& Radar( ) const
        {
            return radar_;
        }
        void SetRadar( const Guid& radar )
        {
            radar_ = radar;
        }
    };
    class RadarLongitudeTimeseriesObject : public DoubleTimeseriesObject
    {
    public:
        using Base = DoubleTimeseriesObject;
        static constexpr Kind KIND = Kind::RadarLongitudeTimeseries;
    private:
        Guid radar_;
    public:
        RadarLongitudeTimeseriesObject( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(radar_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(radar_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<RadarLongitudeTimeseriesObject>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<RadarLongitudeTimeseriesObject&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const RadarLongitudeTimeseriesObject& >( other );
                if ( dataObject.radar_ != radar_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        const Guid& Radar( ) const
        {
            return radar_;
        }
        void SetRadar( const Guid& radar )
        {
            radar_ = radar;
        }
    };
    class RadomeDewPointTimeseriesObject : public DoubleTimeseriesObject
    {
    public:
        using Base = DoubleTimeseriesObject;
        static constexpr Kind KIND = Kind::RadomeDewPointTimeseries;
    private:
        Guid radome_;
    public:
        RadomeDewPointTimeseriesObject( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(radome_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(radome_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<RadomeDewPointTimeseriesObject>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<RadomeDewPointTimeseriesObject&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const RadomeDewPointTimeseriesObject& >( other );
                if ( dataObject.radome_ != radome_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        const Guid& Radome( ) const
        {
            return radome_;
        }
        void SetRadome( const Guid& radome )
        {
            radome_ = radome;
        }
    };
    class RadomePressureTimeseriesObject : public DoubleTimeseriesObject
    {
    public:
        using Base = DoubleTimeseriesObject;
        static constexpr Kind KIND = Kind::RadomePressureTimeseries;
    private:
        Guid radome_;
    public:
        RadomePressureTimeseriesObject( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(radome_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(radome_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<RadomePressureTimeseriesObject>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<RadomePressureTimeseriesObject&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const RadomePressureTimeseriesObject& >( other );
                if ( dataObject.radome_ != radome_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        const Guid& Radome( ) const
        {
            return radome_;
        }
        void SetRadome( const Guid& radome )
        {
            radome_ = radome;
        }
    };
    class RadomeTemperatureTimeseriesObject : public DoubleTimeseriesObject
    {
    public:
        using Base = DoubleTimeseriesObject;
        static constexpr Kind KIND = Kind::RadomeTemperatureTimeseries;
    private:
        Guid radome_;
    public:
        RadomeTemperatureTimeseriesObject( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(radome_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(radome_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<RadomeTemperatureTimeseriesObject>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<RadomeTemperatureTimeseriesObject&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const RadomeTemperatureTimeseriesObject& >( other );
                if ( dataObject.radome_ != radome_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        const Guid& Radome( ) const
        {
            return radome_;
        }
        void SetRadome( const Guid& radome )
        {
            radome_ = radome;
        }
    };
    class VesselDraughtTimeseriesObject : public DoubleTimeseriesObject
    {
    public:
        using Base = DoubleTimeseriesObject;
        static constexpr Kind KIND = Kind::VesselDraughtTimeseries;
    private:
        Guid vessel_;
    public:
        VesselDraughtTimeseriesObject( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(vessel_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(vessel_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<VesselDraughtTimeseriesObject>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<VesselDraughtTimeseriesObject&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const VesselDraughtTimeseriesObject& >( other );
                if ( dataObject.vessel_ != vessel_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        const Guid& Vessel( ) const
        {
            return vessel_;
        }
        void SetVessel( const Guid& vessel )
        {
            vessel_ = vessel;
        }
    };
    class ViewLatitudeTimeseriesObject : public DoubleTimeseriesObject
    {
    public:
        using Base = DoubleTimeseriesObject;
        static constexpr Kind KIND = Kind::ViewLatitudeTimeseries;
    private:
        Guid view_;
    public:
        ViewLatitudeTimeseriesObject( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(view_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(view_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<ViewLatitudeTimeseriesObject>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<ViewLatitudeTimeseriesObject&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const ViewLatitudeTimeseriesObject& >( other );
                if ( dataObject.view_ != view_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        const Guid& View( ) const
        {
            return view_;
        }
        void SetView( const Guid& view )
        {
            view_ = view;
        }
    };
    class ViewLongitudeTimeseriesObject : public DoubleTimeseriesObject
    {
    public:
        using Base = DoubleTimeseriesObject;
        static constexpr Kind KIND = Kind::ViewLongitudeTimeseries;
    private:
        Guid view_;
    public:
        ViewLongitudeTimeseriesObject( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(view_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(view_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<ViewLongitudeTimeseriesObject>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<ViewLongitudeTimeseriesObject&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const ViewLongitudeTimeseriesObject& >( other );
                if ( dataObject.view_ != view_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        const Guid& View( ) const
        {
            return view_;
        }
        void SetView( const Guid& view )
        {
            view_ = view;
        }
    };
    class ViewZoomLevelTimeseriesObject : public DoubleTimeseriesObject
    {
    public:
        using Base = DoubleTimeseriesObject;
        static constexpr Kind KIND = Kind::ViewZoomLevelTimeseries;
    private:
        Guid view_;
    public:
        ViewZoomLevelTimeseriesObject( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(view_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(view_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<ViewZoomLevelTimeseriesObject>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<ViewZoomLevelTimeseriesObject&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const ViewZoomLevelTimeseriesObject& >( other );
                if ( dataObject.view_ != view_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        const Guid& View( ) const
        {
            return view_;
        }
        void SetView( const Guid& view )
        {
            view_ = view;
        }
    };
    class WeatherStationAbsoluteHumidityTimeseriesObject : public DoubleTimeseriesObject
    {
    public:
        using Base = DoubleTimeseriesObject;
        static constexpr Kind KIND = Kind::WeatherStationAbsoluteHumidityTimeseries;
    private:
        Guid weatherStation_;
    public:
        WeatherStationAbsoluteHumidityTimeseriesObject( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(weatherStation_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(weatherStation_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<WeatherStationAbsoluteHumidityTimeseriesObject>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<WeatherStationAbsoluteHumidityTimeseriesObject&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const WeatherStationAbsoluteHumidityTimeseriesObject& >( other );
                if ( dataObject.weatherStation_ != weatherStation_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        const Guid& WeatherStation( ) const
        {
            return weatherStation_;
        }
        void SetWeatherStation( const Guid& weatherStation )
        {
            weatherStation_ = weatherStation;
        }
    };
    class WeatherStationAirTemperatureTimeseriesObject : public DoubleTimeseriesObject
    {
    public:
        using Base = DoubleTimeseriesObject;
        static constexpr Kind KIND = Kind::WeatherStationAirTemperatureTimeseries;
    private:
        Guid weatherStation_;
    public:
        WeatherStationAirTemperatureTimeseriesObject( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(weatherStation_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(weatherStation_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<WeatherStationAirTemperatureTimeseriesObject>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<WeatherStationAirTemperatureTimeseriesObject&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const WeatherStationAirTemperatureTimeseriesObject& >( other );
                if ( dataObject.weatherStation_ != weatherStation_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        const Guid& WeatherStation( ) const
        {
            return weatherStation_;
        }
        void SetWeatherStation( const Guid& weatherStation )
        {
            weatherStation_ = weatherStation;
        }
    };
    class WeatherStationBarometricPressureTimeseriesObject : public DoubleTimeseriesObject
    {
    public:
        using Base = DoubleTimeseriesObject;
        static constexpr Kind KIND = Kind::WeatherStationBarometricPressureTimeseries;
    private:
        Guid weatherStation_;
    public:
        WeatherStationBarometricPressureTimeseriesObject( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(weatherStation_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(weatherStation_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<WeatherStationBarometricPressureTimeseriesObject>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<WeatherStationBarometricPressureTimeseriesObject&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const WeatherStationBarometricPressureTimeseriesObject& >( other );
                if ( dataObject.weatherStation_ != weatherStation_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        const Guid& WeatherStation( ) const
        {
            return weatherStation_;
        }
        void SetWeatherStation( const Guid& weatherStation )
        {
            weatherStation_ = weatherStation;
        }
    };
    class WeatherStationDewPointTimeseriesObject : public DoubleTimeseriesObject
    {
    public:
        using Base = DoubleTimeseriesObject;
        static constexpr Kind KIND = Kind::WeatherStationDewPointTimeseries;
    private:
        Guid weatherStation_;
    public:
        WeatherStationDewPointTimeseriesObject( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(weatherStation_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(weatherStation_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<WeatherStationDewPointTimeseriesObject>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<WeatherStationDewPointTimeseriesObject&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const WeatherStationDewPointTimeseriesObject& >( other );
                if ( dataObject.weatherStation_ != weatherStation_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        const Guid& WeatherStation( ) const
        {
            return weatherStation_;
        }
        void SetWeatherStation( const Guid& weatherStation )
        {
            weatherStation_ = weatherStation;
        }
    };
    class WeatherStationRelativeHumidityTimeseriesObject : public DoubleTimeseriesObject
    {
    public:
        using Base = DoubleTimeseriesObject;
        static constexpr Kind KIND = Kind::WeatherStationRelativeHumidityTimeseries;
    private:
        Guid weatherStation_;
    public:
        WeatherStationRelativeHumidityTimeseriesObject( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(weatherStation_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(weatherStation_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<WeatherStationRelativeHumidityTimeseriesObject>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<WeatherStationRelativeHumidityTimeseriesObject&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const WeatherStationRelativeHumidityTimeseriesObject& >( other );
                if ( dataObject.weatherStation_ != weatherStation_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        const Guid& WeatherStation( ) const
        {
            return weatherStation_;
        }
        void SetWeatherStation( const Guid& weatherStation )
        {
            weatherStation_ = weatherStation;
        }
    };
    class WeatherStationWaterTemperatureTimeseriesObject : public DoubleTimeseriesObject
    {
    public:
        using Base = DoubleTimeseriesObject;
        static constexpr Kind KIND = Kind::WeatherStationWaterTemperatureTimeseries;
    private:
        Guid weatherStation_;
    public:
        WeatherStationWaterTemperatureTimeseriesObject( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(weatherStation_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(weatherStation_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<WeatherStationWaterTemperatureTimeseriesObject>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<WeatherStationWaterTemperatureTimeseriesObject&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const WeatherStationWaterTemperatureTimeseriesObject& >( other );
                if ( dataObject.weatherStation_ != weatherStation_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        const Guid& WeatherStation( ) const
        {
            return weatherStation_;
        }
        void SetWeatherStation( const Guid& weatherStation )
        {
            weatherStation_ = weatherStation;
        }
    };
    class WeatherStationWindDirectionTimeseriesObject : public DoubleTimeseriesObject
    {
    public:
        using Base = DoubleTimeseriesObject;
        static constexpr Kind KIND = Kind::WeatherStationWindDirectionTimeseries;
    private:
        Guid weatherStation_;
    public:
        WeatherStationWindDirectionTimeseriesObject( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(weatherStation_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(weatherStation_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<WeatherStationWindDirectionTimeseriesObject>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<WeatherStationWindDirectionTimeseriesObject&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const WeatherStationWindDirectionTimeseriesObject& >( other );
                if ( dataObject.weatherStation_ != weatherStation_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        const Guid& WeatherStation( ) const
        {
            return weatherStation_;
        }
        void SetWeatherStation( const Guid& weatherStation )
        {
            weatherStation_ = weatherStation;
        }
    };
    class WeatherStationWindSpeedTimeseriesObject : public DoubleTimeseriesObject
    {
    public:
        using Base = DoubleTimeseriesObject;
        static constexpr Kind KIND = Kind::WeatherStationWindSpeedTimeseries;
    private:
        Guid weatherStation_;
    public:
        WeatherStationWindSpeedTimeseriesObject( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(weatherStation_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(weatherStation_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<WeatherStationWindSpeedTimeseriesObject>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<WeatherStationWindSpeedTimeseriesObject&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const WeatherStationWindSpeedTimeseriesObject& >( other );
                if ( dataObject.weatherStation_ != weatherStation_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        const Guid& WeatherStation( ) const
        {
            return weatherStation_;
        }
        void SetWeatherStation( const Guid& weatherStation )
        {
            weatherStation_ = weatherStation;
        }
    };
    class GeoPosition2DTimeseriesObject : public TimeseriesObject
    {
    public:
        using Base = TimeseriesObject;
        static constexpr Kind KIND = Kind::GeoPosition2DTimeseries;
    private:
    public:
        GeoPosition2DTimeseriesObject( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<GeoPosition2DTimeseriesObject>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<GeoPosition2DTimeseriesObject&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const GeoPosition2DTimeseriesObject& >( other );
                return true;
            }
            return false;
        }
    };
    class AisAidToNavigationPositionTimeseriesObject : public GeoPosition2DTimeseriesObject
    {
    public:
        using Base = GeoPosition2DTimeseriesObject;
        static constexpr Kind KIND = Kind::AisAidToNavigationPositionTimeseries;
    private:
        Guid aidToNavigation_;
    public:
        AisAidToNavigationPositionTimeseriesObject( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(aidToNavigation_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(aidToNavigation_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<AisAidToNavigationPositionTimeseriesObject>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<AisAidToNavigationPositionTimeseriesObject&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const AisAidToNavigationPositionTimeseriesObject& >( other );
                if ( dataObject.aidToNavigation_ != aidToNavigation_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        const Guid& AidToNavigation( ) const
        {
            return aidToNavigation_;
        }
        void SetAidToNavigation( const Guid& aidToNavigation )
        {
            aidToNavigation_ = aidToNavigation;
        }
    };
    class GeoPosition3DTimeseriesObject : public TimeseriesObject
    {
    public:
        using Base = TimeseriesObject;
        static constexpr Kind KIND = Kind::GeoPosition3DTimeseries;
    private:
    public:
        GeoPosition3DTimeseriesObject( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<GeoPosition3DTimeseriesObject>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<GeoPosition3DTimeseriesObject&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const GeoPosition3DTimeseriesObject& >( other );
                return true;
            }
            return false;
        }
    };
    class GuidTimeseriesObject : public TimeseriesObject
    {
    public:
        using Base = TimeseriesObject;
        static constexpr Kind KIND = Kind::GuidTimeseries;
    private:
    public:
        GuidTimeseriesObject( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<GuidTimeseriesObject>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<GuidTimeseriesObject&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const GuidTimeseriesObject& >( other );
                return true;
            }
            return false;
        }
    };
    class Int16TimeseriesObject : public TimeseriesObject
    {
    public:
        using Base = TimeseriesObject;
        static constexpr Kind KIND = Kind::Int16Timeseries;
    private:
    public:
        Int16TimeseriesObject( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<Int16TimeseriesObject>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<Int16TimeseriesObject&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const Int16TimeseriesObject& >( other );
                return true;
            }
            return false;
        }
    };
    class Int32TimeseriesObject : public TimeseriesObject
    {
    public:
        using Base = TimeseriesObject;
        static constexpr Kind KIND = Kind::Int32Timeseries;
    private:
    public:
        Int32TimeseriesObject( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<Int32TimeseriesObject>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<Int32TimeseriesObject&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const Int32TimeseriesObject& >( other );
                return true;
            }
            return false;
        }
    };
    class RadarAzimuthOffsetTimeseriesObject : public Int32TimeseriesObject
    {
    public:
        using Base = Int32TimeseriesObject;
        static constexpr Kind KIND = Kind::RadarAzimuthOffsetTimeseries;
    private:
        Guid radar_;
    public:
        RadarAzimuthOffsetTimeseriesObject( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(radar_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(radar_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<RadarAzimuthOffsetTimeseriesObject>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<RadarAzimuthOffsetTimeseriesObject&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const RadarAzimuthOffsetTimeseriesObject& >( other );
                if ( dataObject.radar_ != radar_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        const Guid& Radar( ) const
        {
            return radar_;
        }
        void SetRadar( const Guid& radar )
        {
            radar_ = radar;
        }
    };
    class RadarFastTimeConstantLevelTimeseriesObject : public Int32TimeseriesObject
    {
    public:
        using Base = Int32TimeseriesObject;
        static constexpr Kind KIND = Kind::RadarFastTimeConstantLevelTimeseries;
    private:
        Guid radar_;
    public:
        RadarFastTimeConstantLevelTimeseriesObject( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(radar_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(radar_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<RadarFastTimeConstantLevelTimeseriesObject>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<RadarFastTimeConstantLevelTimeseriesObject&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const RadarFastTimeConstantLevelTimeseriesObject& >( other );
                if ( dataObject.radar_ != radar_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        const Guid& Radar( ) const
        {
            return radar_;
        }
        void SetRadar( const Guid& radar )
        {
            radar_ = radar;
        }
    };
    class RadarFastTimeConstantModeTimeseriesObject : public Int32TimeseriesObject
    {
    public:
        using Base = Int32TimeseriesObject;
        static constexpr Kind KIND = Kind::RadarFastTimeConstantModeTimeseries;
    private:
        Guid radar_;
    public:
        RadarFastTimeConstantModeTimeseriesObject( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(radar_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(radar_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<RadarFastTimeConstantModeTimeseriesObject>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<RadarFastTimeConstantModeTimeseriesObject&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const RadarFastTimeConstantModeTimeseriesObject& >( other );
                if ( dataObject.radar_ != radar_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        const Guid& Radar( ) const
        {
            return radar_;
        }
        void SetRadar( const Guid& radar )
        {
            radar_ = radar;
        }
    };
    class RadarPulseTimeseriesObject : public Int32TimeseriesObject
    {
    public:
        using Base = Int32TimeseriesObject;
        static constexpr Kind KIND = Kind::RadarPulseTimeseries;
    private:
        Guid radar_;
    public:
        RadarPulseTimeseriesObject( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(radar_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(radar_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<RadarPulseTimeseriesObject>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<RadarPulseTimeseriesObject&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const RadarPulseTimeseriesObject& >( other );
                if ( dataObject.radar_ != radar_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        const Guid& Radar( ) const
        {
            return radar_;
        }
        void SetRadar( const Guid& radar )
        {
            radar_ = radar;
        }
    };
    class RadarSector1EndTimeseriesObject : public Int32TimeseriesObject
    {
    public:
        using Base = Int32TimeseriesObject;
        static constexpr Kind KIND = Kind::RadarSector1EndTimeseries;
    private:
        Guid radar_;
    public:
        RadarSector1EndTimeseriesObject( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(radar_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(radar_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<RadarSector1EndTimeseriesObject>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<RadarSector1EndTimeseriesObject&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const RadarSector1EndTimeseriesObject& >( other );
                if ( dataObject.radar_ != radar_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        const Guid& Radar( ) const
        {
            return radar_;
        }
        void SetRadar( const Guid& radar )
        {
            radar_ = radar;
        }
    };
    class RadarSector1StartTimeseriesObject : public Int32TimeseriesObject
    {
    public:
        using Base = Int32TimeseriesObject;
        static constexpr Kind KIND = Kind::RadarSector1StartTimeseries;
    private:
        Guid radar_;
    public:
        RadarSector1StartTimeseriesObject( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(radar_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(radar_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<RadarSector1StartTimeseriesObject>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<RadarSector1StartTimeseriesObject&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const RadarSector1StartTimeseriesObject& >( other );
                if ( dataObject.radar_ != radar_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        const Guid& Radar( ) const
        {
            return radar_;
        }
        void SetRadar( const Guid& radar )
        {
            radar_ = radar;
        }
    };
    class RadarSector2EndTimeseriesObject : public Int32TimeseriesObject
    {
    public:
        using Base = Int32TimeseriesObject;
        static constexpr Kind KIND = Kind::RadarSector2EndTimeseries;
    private:
        Guid radar_;
    public:
        RadarSector2EndTimeseriesObject( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(radar_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(radar_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<RadarSector2EndTimeseriesObject>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<RadarSector2EndTimeseriesObject&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const RadarSector2EndTimeseriesObject& >( other );
                if ( dataObject.radar_ != radar_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        const Guid& Radar( ) const
        {
            return radar_;
        }
        void SetRadar( const Guid& radar )
        {
            radar_ = radar;
        }
    };
    class RadarSector2StartTimeseriesObject : public Int32TimeseriesObject
    {
    public:
        using Base = Int32TimeseriesObject;
        static constexpr Kind KIND = Kind::RadarSector2StartTimeseries;
    private:
        Guid radar_;
    public:
        RadarSector2StartTimeseriesObject( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(radar_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(radar_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<RadarSector2StartTimeseriesObject>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<RadarSector2StartTimeseriesObject&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const RadarSector2StartTimeseriesObject& >( other );
                if ( dataObject.radar_ != radar_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        const Guid& Radar( ) const
        {
            return radar_;
        }
        void SetRadar( const Guid& radar )
        {
            radar_ = radar;
        }
    };
    class RadarSensitivityTimeControlLevelTimeseriesObject : public Int32TimeseriesObject
    {
    public:
        using Base = Int32TimeseriesObject;
        static constexpr Kind KIND = Kind::RadarSensitivityTimeControlLevelTimeseries;
    private:
        Guid radar_;
    public:
        RadarSensitivityTimeControlLevelTimeseriesObject( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(radar_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(radar_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<RadarSensitivityTimeControlLevelTimeseriesObject>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<RadarSensitivityTimeControlLevelTimeseriesObject&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const RadarSensitivityTimeControlLevelTimeseriesObject& >( other );
                if ( dataObject.radar_ != radar_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        const Guid& Radar( ) const
        {
            return radar_;
        }
        void SetRadar( const Guid& radar )
        {
            radar_ = radar;
        }
    };
    class RadarTuningTimeseriesObject : public Int32TimeseriesObject
    {
    public:
        using Base = Int32TimeseriesObject;
        static constexpr Kind KIND = Kind::RadarTuningTimeseries;
    private:
        Guid radar_;
    public:
        RadarTuningTimeseriesObject( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(radar_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(radar_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<RadarTuningTimeseriesObject>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<RadarTuningTimeseriesObject&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const RadarTuningTimeseriesObject& >( other );
                if ( dataObject.radar_ != radar_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        const Guid& Radar( ) const
        {
            return radar_;
        }
        void SetRadar( const Guid& radar )
        {
            radar_ = radar;
        }
    };
    class VesselPersonsOnBoardTimeseriesObject : public Int32TimeseriesObject
    {
    public:
        using Base = Int32TimeseriesObject;
        static constexpr Kind KIND = Kind::VesselPersonsOnBoardTimeseries;
    private:
        Guid vessel_;
    public:
        VesselPersonsOnBoardTimeseriesObject( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(vessel_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(vessel_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<VesselPersonsOnBoardTimeseriesObject>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<VesselPersonsOnBoardTimeseriesObject&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const VesselPersonsOnBoardTimeseriesObject& >( other );
                if ( dataObject.vessel_ != vessel_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        const Guid& Vessel( ) const
        {
            return vessel_;
        }
        void SetVessel( const Guid& vessel )
        {
            vessel_ = vessel;
        }
    };
    class Int64TimeseriesObject : public TimeseriesObject
    {
    public:
        using Base = TimeseriesObject;
        static constexpr Kind KIND = Kind::Int64Timeseries;
    private:
    public:
        Int64TimeseriesObject( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<Int64TimeseriesObject>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<Int64TimeseriesObject&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const Int64TimeseriesObject& >( other );
                return true;
            }
            return false;
        }
    };
    class Position2DTimeseriesObject : public TimeseriesObject
    {
    public:
        using Base = TimeseriesObject;
        static constexpr Kind KIND = Kind::Position2DTimeseries;
    private:
    public:
        Position2DTimeseriesObject( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<Position2DTimeseriesObject>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<Position2DTimeseriesObject&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const Position2DTimeseriesObject& >( other );
                return true;
            }
            return false;
        }
    };
    class Position3DTimeseriesObject : public TimeseriesObject
    {
    public:
        using Base = TimeseriesObject;
        static constexpr Kind KIND = Kind::Position3DTimeseries;
    private:
    public:
        Position3DTimeseriesObject( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<Position3DTimeseriesObject>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<Position3DTimeseriesObject&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const Position3DTimeseriesObject& >( other );
                return true;
            }
            return false;
        }
    };
    class ReferenceTimeseriesObject : public TimeseriesObject
    {
    public:
        using Base = TimeseriesObject;
        static constexpr Kind KIND = Kind::ReferenceTimeseries;
    private:
    public:
        ReferenceTimeseriesObject( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<ReferenceTimeseriesObject>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<ReferenceTimeseriesObject&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const ReferenceTimeseriesObject& >( other );
                return true;
            }
            return false;
        }
    };
    class SByteTimeseriesObject : public TimeseriesObject
    {
    public:
        using Base = TimeseriesObject;
        static constexpr Kind KIND = Kind::SByteTimeseries;
    private:
    public:
        SByteTimeseriesObject( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<SByteTimeseriesObject>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<SByteTimeseriesObject&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const SByteTimeseriesObject& >( other );
                return true;
            }
            return false;
        }
    };
    class SingleTimeseriesObject : public TimeseriesObject
    {
    public:
        using Base = TimeseriesObject;
        static constexpr Kind KIND = Kind::SingleTimeseries;
    private:
    public:
        SingleTimeseriesObject( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<SingleTimeseriesObject>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<SingleTimeseriesObject&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const SingleTimeseriesObject& >( other );
                return true;
            }
            return false;
        }
    };
    class StringTimeseriesObject : public TimeseriesObject
    {
    public:
        using Base = TimeseriesObject;
        static constexpr Kind KIND = Kind::StringTimeseries;
    private:
    public:
        StringTimeseriesObject( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<StringTimeseriesObject>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<StringTimeseriesObject&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const StringTimeseriesObject& >( other );
                return true;
            }
            return false;
        }
    };
    class TimeSpanTimeseriesObject : public TimeseriesObject
    {
    public:
        using Base = TimeseriesObject;
        static constexpr Kind KIND = Kind::TimeSpanTimeseries;
    private:
    public:
        TimeSpanTimeseriesObject( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<TimeSpanTimeseriesObject>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<TimeSpanTimeseriesObject&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const TimeSpanTimeseriesObject& >( other );
                return true;
            }
            return false;
        }
    };
    class UInt16TimeseriesObject : public TimeseriesObject
    {
    public:
        using Base = TimeseriesObject;
        static constexpr Kind KIND = Kind::UInt16Timeseries;
    private:
    public:
        UInt16TimeseriesObject( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<UInt16TimeseriesObject>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<UInt16TimeseriesObject&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const UInt16TimeseriesObject& >( other );
                return true;
            }
            return false;
        }
    };
    class UInt32TimeseriesObject : public TimeseriesObject
    {
    public:
        using Base = TimeseriesObject;
        static constexpr Kind KIND = Kind::UInt32Timeseries;
    private:
    public:
        UInt32TimeseriesObject( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<UInt32TimeseriesObject>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<UInt32TimeseriesObject&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const UInt32TimeseriesObject& >( other );
                return true;
            }
            return false;
        }
    };
    class RadomeStatusTimeseriesObject : public UInt32TimeseriesObject
    {
    public:
        using Base = UInt32TimeseriesObject;
        static constexpr Kind KIND = Kind::RadomeStatusTimeseries;
    private:
        Guid radome_;
    public:
        RadomeStatusTimeseriesObject( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(radome_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(radome_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<RadomeStatusTimeseriesObject>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<RadomeStatusTimeseriesObject&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const RadomeStatusTimeseriesObject& >( other );
                if ( dataObject.radome_ != radome_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        const Guid& Radome( ) const
        {
            return radome_;
        }
        void SetRadome( const Guid& radome )
        {
            radome_ = radome;
        }
    };
    class UInt64TimeseriesObject : public TimeseriesObject
    {
    public:
        using Base = TimeseriesObject;
        static constexpr Kind KIND = Kind::UInt64Timeseries;
    private:
    public:
        UInt64TimeseriesObject( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<UInt64TimeseriesObject>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<UInt64TimeseriesObject&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const UInt64TimeseriesObject& >( other );
                return true;
            }
            return false;
        }
    };
    class TimeseriesCatalogObject : public TimeseriesCatalogElementObject
    {
    public:
        using Base = TimeseriesCatalogElementObject;
        static constexpr Kind KIND = Kind::TimeseriesCatalog;
    private:
    public:
        TimeseriesCatalogObject( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<TimeseriesCatalogObject>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<TimeseriesCatalogObject&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const TimeseriesCatalogObject& >( other );
                return true;
            }
            return false;
        }
    };
    class TimeseriesInfoObject : public BaseData<Kind, Guid>
    {
    public:
        using Base = BaseData<Kind, Guid>;
        static constexpr Kind KIND = Kind::TimeseriesInfo;
    private:
        Int64 rowVersion_ = 0;
        DBDateTime firstTimestamp_;
        DBDateTime lastTimestamp_;
        Int64 count_ = 0;
    public:
        TimeseriesInfoObject( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(rowVersion_);
            firstTimestamp_.WriteTo( destination );
            lastTimestamp_.WriteTo( destination );
            destination.Write(count_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(rowVersion_);
            firstTimestamp_.ReadFrom( source );
            lastTimestamp_.ReadFrom( source );
            source.Read(count_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<TimeseriesInfoObject>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<TimeseriesInfoObject&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const TimeseriesInfoObject& >( other );
                if ( dataObject.rowVersion_ != rowVersion_ )
                {
                    return false;
                }
                if ( dataObject.firstTimestamp_ != firstTimestamp_ )
                {
                    return false;
                }
                if ( dataObject.lastTimestamp_ != lastTimestamp_ )
                {
                    return false;
                }
                if ( dataObject.count_ != count_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        Int64 RowVersion( ) const
        {
            return rowVersion_;
        }
        void SetRowVersion( const Int64& rowVersion )
        {
            rowVersion_ = rowVersion;
        }
        const DBDateTime& FirstTimestamp( ) const
        {
            return firstTimestamp_;
        }
        void SetFirstTimestamp( const DBDateTime& firstTimestamp )
        {
            firstTimestamp_ = firstTimestamp;
        }
        const DBDateTime& LastTimestamp( ) const
        {
            return lastTimestamp_;
        }
        void SetLastTimestamp( const DBDateTime& lastTimestamp )
        {
            lastTimestamp_ = lastTimestamp;
        }
        Int64 Count( ) const
        {
            return count_;
        }
        void SetCount( Int64 count )
        {
            count_ = count;
        }
    };
    class TimeSpanTimeseriesValueObject : public BaseData<Kind, Guid>
    {
    public:
        using Base = BaseData<Kind, Guid>;
        static constexpr Kind KIND = Kind::TimeSpanTimeseriesValue;
    private:
        Int64 rowVersion_ = 0;
        Guid timeseries_;
        DateTime timestamp_;
        DBTimeSpan value_;
    public:
        TimeSpanTimeseriesValueObject( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(rowVersion_);
            destination.Write(timeseries_);
            destination.Write(timestamp_);
            value_.WriteTo( destination );
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(rowVersion_);
            source.Read(timeseries_);
            source.Read(timestamp_);
            value_.ReadFrom( source );
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<TimeSpanTimeseriesValueObject>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<TimeSpanTimeseriesValueObject&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const TimeSpanTimeseriesValueObject& >( other );
                if ( dataObject.rowVersion_ != rowVersion_ )
                {
                    return false;
                }
                if ( dataObject.timeseries_ != timeseries_ )
                {
                    return false;
                }
                if ( dataObject.timestamp_ != timestamp_ )
                {
                    return false;
                }
                if ( dataObject.value_ != value_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        Int64 RowVersion( ) const
        {
            return rowVersion_;
        }
        void SetRowVersion( const Int64& rowVersion )
        {
            rowVersion_ = rowVersion;
        }
        const Guid& Timeseries( ) const
        {
            return timeseries_;
        }
        void SetTimeseries( const Guid& timeseries )
        {
            timeseries_ = timeseries;
        }
        const DateTime& Timestamp( ) const
        {
            return timestamp_;
        }
        void SetTimestamp( const DateTime& timestamp )
        {
            timestamp_ = timestamp;
        }
        const DBTimeSpan& Value( ) const
        {
            return value_;
        }
        void SetValue( const DBTimeSpan& value )
        {
            value_ = value;
        }
    };
    class TrackableItemTrackLinkObject : public BaseData<Kind, Guid>
    {
    public:
        using Base = BaseData<Kind, Guid>;
        static constexpr Kind KIND = Kind::TrackableItemTrackLink;
    private:
        Int64 rowVersion_ = 0;
        Guid item_;
        Guid track_;
        DateTime start_;
        DBDateTime end_;
    public:
        TrackableItemTrackLinkObject( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(rowVersion_);
            destination.Write(item_);
            destination.Write(track_);
            destination.Write(start_);
            end_.WriteTo( destination );
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(rowVersion_);
            source.Read(item_);
            source.Read(track_);
            source.Read(start_);
            end_.ReadFrom( source );
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<TrackableItemTrackLinkObject>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<TrackableItemTrackLinkObject&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const TrackableItemTrackLinkObject& >( other );
                if ( dataObject.rowVersion_ != rowVersion_ )
                {
                    return false;
                }
                if ( dataObject.item_ != item_ )
                {
                    return false;
                }
                if ( dataObject.track_ != track_ )
                {
                    return false;
                }
                if ( dataObject.start_ != start_ )
                {
                    return false;
                }
                if ( dataObject.end_ != end_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        Int64 RowVersion( ) const
        {
            return rowVersion_;
        }
        void SetRowVersion( const Int64& rowVersion )
        {
            rowVersion_ = rowVersion;
        }
        const Guid& Item( ) const
        {
            return item_;
        }
        void SetItem( const Guid& item )
        {
            item_ = item;
        }
        const Guid& Track( ) const
        {
            return track_;
        }
        void SetTrack( const Guid& track )
        {
            track_ = track;
        }
        const DateTime& Start( ) const
        {
            return start_;
        }
        void SetStart( const DateTime& start )
        {
            start_ = start;
        }
        const DBDateTime& End( ) const
        {
            return end_;
        }
        void SetEnd( const DBDateTime& end )
        {
            end_ = end;
        }
    };
    class TrackBaseObject : public BaseData<Kind, Guid>
    {
    public:
        using Base = BaseData<Kind, Guid>;
        static constexpr Kind KIND = Kind::TrackBase;
    private:
        Int64 rowVersion_ = 0;
        Guid tracker_;
        Int64 trackNumber_ = 0;
        DateTime timestamp_;
    public:
        TrackBaseObject( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(rowVersion_);
            destination.Write(tracker_);
            destination.Write(trackNumber_);
            destination.Write(timestamp_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(rowVersion_);
            source.Read(tracker_);
            source.Read(trackNumber_);
            source.Read(timestamp_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<TrackBaseObject>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<TrackBaseObject&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const TrackBaseObject& >( other );
                if ( dataObject.rowVersion_ != rowVersion_ )
                {
                    return false;
                }
                if ( dataObject.tracker_ != tracker_ )
                {
                    return false;
                }
                if ( dataObject.trackNumber_ != trackNumber_ )
                {
                    return false;
                }
                if ( dataObject.timestamp_ != timestamp_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        Int64 RowVersion( ) const
        {
            return rowVersion_;
        }
        void SetRowVersion( const Int64& rowVersion )
        {
            rowVersion_ = rowVersion;
        }
        const Guid& Tracker( ) const
        {
            return tracker_;
        }
        void SetTracker( const Guid& tracker )
        {
            tracker_ = tracker;
        }
        Int64 TrackNumber( ) const
        {
            return trackNumber_;
        }
        void SetTrackNumber( Int64 trackNumber )
        {
            trackNumber_ = trackNumber;
        }
        const DateTime& Timestamp( ) const
        {
            return timestamp_;
        }
        void SetTimestamp( const DateTime& timestamp )
        {
            timestamp_ = timestamp;
        }
    };
    class TrackObject : public TrackBaseObject
    {
    public:
        using Base = TrackBaseObject;
        static constexpr Kind KIND = Kind::Track;
    private:
    public:
        TrackObject( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<TrackObject>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<TrackObject&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const TrackObject& >( other );
                return true;
            }
            return false;
        }
    };
    class Track3DObject : public TrackBaseObject
    {
    public:
        using Base = TrackBaseObject;
        static constexpr Kind KIND = Kind::Track3D;
    private:
    public:
        Track3DObject( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<Track3DObject>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<Track3DObject&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const Track3DObject& >( other );
                return true;
            }
            return false;
        }
    };
    class TrackerFilterParametersObject : public BaseData<Kind, Guid>
    {
    public:
        using Base = BaseData<Kind, Guid>;
        static constexpr Kind KIND = Kind::TrackerFilterParameters;
    private:
        Int64 rowVersion_ = 0;
        Guid tracker_;
        FixedDBWideString<127> name_;
    public:
        TrackerFilterParametersObject( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(rowVersion_);
            destination.Write(tracker_);
            name_.WriteTo( destination );
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(rowVersion_);
            source.Read(tracker_);
            name_.ReadFrom( source );
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<TrackerFilterParametersObject>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<TrackerFilterParametersObject&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const TrackerFilterParametersObject& >( other );
                if ( dataObject.rowVersion_ != rowVersion_ )
                {
                    return false;
                }
                if ( dataObject.tracker_ != tracker_ )
                {
                    return false;
                }
                if ( dataObject.name_ != name_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        Int64 RowVersion( ) const
        {
            return rowVersion_;
        }
        void SetRowVersion( const Int64& rowVersion )
        {
            rowVersion_ = rowVersion;
        }
        const Guid& Tracker( ) const
        {
            return tracker_;
        }
        void SetTracker( const Guid& tracker )
        {
            tracker_ = tracker;
        }
        const FixedDBWideString<127>& Name( ) const
        {
            return name_;
        }
        void SetName( const FixedDBWideString<127>& name )
        {
            name_ = name;
        }
    };
    class TrackerFilterParametersConfigurationObject : public BaseData<Kind, Guid>
    {
    public:
        using Base = BaseData<Kind, Guid>;
        static constexpr Kind KIND = Kind::TrackerFilterParametersConfiguration;
    private:
        Int64 rowVersion_ = 0;
        Guid parameters_;
        DateTime timestamp_;
        bool useNaivePredictor_ = false;
        Int32 numberOfPoints_ = 0;
        Int32 windowSize_ = 0;
        Int32 stabilizeCount_ = 0;
        Int32 maxBadPoints_ = 0;
        Types::TrackerFilterModelType modelType_ = Types::TrackerFilterModelType::Unknown;
        double sigmaR_ = 0.0;
        double sigmaAcc_ = 0.0;
        double tauVel_ = 0.0;
        double tauAcc_ = 0.0;
        double deltaRMin_ = 0.0;
        double deltaVMax_ = 0.0;
        double deltaAMax_ = 0.0;
    public:
        TrackerFilterParametersConfigurationObject( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(rowVersion_);
            destination.Write(parameters_);
            destination.Write(timestamp_);
            destination.Write(useNaivePredictor_);
            destination.Write(numberOfPoints_);
            destination.Write(windowSize_);
            destination.Write(stabilizeCount_);
            destination.Write(maxBadPoints_);
            destination.Write(modelType_);
            destination.Write(sigmaR_);
            destination.Write(sigmaAcc_);
            destination.Write(tauVel_);
            destination.Write(tauAcc_);
            destination.Write(deltaRMin_);
            destination.Write(deltaVMax_);
            destination.Write(deltaAMax_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(rowVersion_);
            source.Read(parameters_);
            source.Read(timestamp_);
            source.Read(useNaivePredictor_);
            source.Read(numberOfPoints_);
            source.Read(windowSize_);
            source.Read(stabilizeCount_);
            source.Read(maxBadPoints_);
            source.Read(modelType_);
            source.Read(sigmaR_);
            source.Read(sigmaAcc_);
            source.Read(tauVel_);
            source.Read(tauAcc_);
            source.Read(deltaRMin_);
            source.Read(deltaVMax_);
            source.Read(deltaAMax_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<TrackerFilterParametersConfigurationObject>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<TrackerFilterParametersConfigurationObject&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const TrackerFilterParametersConfigurationObject& >( other );
                if ( dataObject.rowVersion_ != rowVersion_ )
                {
                    return false;
                }
                if ( dataObject.parameters_ != parameters_ )
                {
                    return false;
                }
                if ( dataObject.timestamp_ != timestamp_ )
                {
                    return false;
                }
                if ( dataObject.useNaivePredictor_ != useNaivePredictor_ )
                {
                    return false;
                }
                if ( dataObject.numberOfPoints_ != numberOfPoints_ )
                {
                    return false;
                }
                if ( dataObject.windowSize_ != windowSize_ )
                {
                    return false;
                }
                if ( dataObject.stabilizeCount_ != stabilizeCount_ )
                {
                    return false;
                }
                if ( dataObject.maxBadPoints_ != maxBadPoints_ )
                {
                    return false;
                }
                if ( dataObject.modelType_ != modelType_ )
                {
                    return false;
                }
                if ( dataObject.sigmaR_ != sigmaR_ )
                {
                    return false;
                }
                if ( dataObject.sigmaAcc_ != sigmaAcc_ )
                {
                    return false;
                }
                if ( dataObject.tauVel_ != tauVel_ )
                {
                    return false;
                }
                if ( dataObject.tauAcc_ != tauAcc_ )
                {
                    return false;
                }
                if ( dataObject.deltaRMin_ != deltaRMin_ )
                {
                    return false;
                }
                if ( dataObject.deltaVMax_ != deltaVMax_ )
                {
                    return false;
                }
                if ( dataObject.deltaAMax_ != deltaAMax_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        Int64 RowVersion( ) const
        {
            return rowVersion_;
        }
        void SetRowVersion( const Int64& rowVersion )
        {
            rowVersion_ = rowVersion;
        }
        const Guid& Parameters( ) const
        {
            return parameters_;
        }
        void SetParameters( const Guid& parameters )
        {
            parameters_ = parameters;
        }
        const DateTime& Timestamp( ) const
        {
            return timestamp_;
        }
        void SetTimestamp( const DateTime& timestamp )
        {
            timestamp_ = timestamp;
        }
        bool UseNaivePredictor( ) const
        {
            return useNaivePredictor_;
        }
        void SetUseNaivePredictor( bool useNaivePredictor )
        {
            useNaivePredictor_ = useNaivePredictor;
        }
        Int32 NumberOfPoints( ) const
        {
            return numberOfPoints_;
        }
        void SetNumberOfPoints( Int32 numberOfPoints )
        {
            numberOfPoints_ = numberOfPoints;
        }
        Int32 WindowSize( ) const
        {
            return windowSize_;
        }
        void SetWindowSize( Int32 windowSize )
        {
            windowSize_ = windowSize;
        }
        Int32 StabilizeCount( ) const
        {
            return stabilizeCount_;
        }
        void SetStabilizeCount( Int32 stabilizeCount )
        {
            stabilizeCount_ = stabilizeCount;
        }
        Int32 MaxBadPoints( ) const
        {
            return maxBadPoints_;
        }
        void SetMaxBadPoints( Int32 maxBadPoints )
        {
            maxBadPoints_ = maxBadPoints;
        }
        Types::TrackerFilterModelType ModelType( ) const
        {
            return modelType_;
        }
        void SetModelType( Types::TrackerFilterModelType modelType )
        {
            modelType_ = modelType;
        }
        double SigmaR( ) const
        {
            return sigmaR_;
        }
        void SetSigmaR( double sigmaR )
        {
            sigmaR_ = sigmaR;
        }
        double SigmaAcc( ) const
        {
            return sigmaAcc_;
        }
        void SetSigmaAcc( double sigmaAcc )
        {
            sigmaAcc_ = sigmaAcc;
        }
        double TauVel( ) const
        {
            return tauVel_;
        }
        void SetTauVel( double tauVel )
        {
            tauVel_ = tauVel;
        }
        double TauAcc( ) const
        {
            return tauAcc_;
        }
        void SetTauAcc( double tauAcc )
        {
            tauAcc_ = tauAcc;
        }
        double DeltaRMin( ) const
        {
            return deltaRMin_;
        }
        void SetDeltaRMin( double deltaRMin )
        {
            deltaRMin_ = deltaRMin;
        }
        double DeltaVMax( ) const
        {
            return deltaVMax_;
        }
        void SetDeltaVMax( double deltaVMax )
        {
            deltaVMax_ = deltaVMax;
        }
        double DeltaAMax( ) const
        {
            return deltaAMax_;
        }
        void SetDeltaAMax( double deltaAMax )
        {
            deltaAMax_ = deltaAMax;
        }
    };
    class TrackInfoObject : public BaseData<Kind, Guid>
    {
    public:
        using Base = BaseData<Kind, Guid>;
        static constexpr Kind KIND = Kind::TrackInfo;
    private:
        Int64 rowVersion_ = 0;
        DBDateTime firstTimestamp_;
        DBDateTime lastTimestamp_;
        Int64 count_ = 0;
        DBDouble northWestLatitude_;
        DBDouble northWestLongitude_;
        DBDouble southEastLatitude_;
        DBDouble southEastLongitude_;
    public:
        TrackInfoObject( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(rowVersion_);
            firstTimestamp_.WriteTo( destination );
            lastTimestamp_.WriteTo( destination );
            destination.Write(count_);
            northWestLatitude_.WriteTo( destination );
            northWestLongitude_.WriteTo( destination );
            southEastLatitude_.WriteTo( destination );
            southEastLongitude_.WriteTo( destination );
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(rowVersion_);
            firstTimestamp_.ReadFrom( source );
            lastTimestamp_.ReadFrom( source );
            source.Read(count_);
            northWestLatitude_.ReadFrom( source );
            northWestLongitude_.ReadFrom( source );
            southEastLatitude_.ReadFrom( source );
            southEastLongitude_.ReadFrom( source );
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<TrackInfoObject>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<TrackInfoObject&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const TrackInfoObject& >( other );
                if ( dataObject.rowVersion_ != rowVersion_ )
                {
                    return false;
                }
                if ( dataObject.firstTimestamp_ != firstTimestamp_ )
                {
                    return false;
                }
                if ( dataObject.lastTimestamp_ != lastTimestamp_ )
                {
                    return false;
                }
                if ( dataObject.count_ != count_ )
                {
                    return false;
                }
                if ( dataObject.northWestLatitude_ != northWestLatitude_ )
                {
                    return false;
                }
                if ( dataObject.northWestLongitude_ != northWestLongitude_ )
                {
                    return false;
                }
                if ( dataObject.southEastLatitude_ != southEastLatitude_ )
                {
                    return false;
                }
                if ( dataObject.southEastLongitude_ != southEastLongitude_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        Int64 RowVersion( ) const
        {
            return rowVersion_;
        }
        void SetRowVersion( const Int64& rowVersion )
        {
            rowVersion_ = rowVersion;
        }
        const DBDateTime& FirstTimestamp( ) const
        {
            return firstTimestamp_;
        }
        void SetFirstTimestamp( const DBDateTime& firstTimestamp )
        {
            firstTimestamp_ = firstTimestamp;
        }
        const DBDateTime& LastTimestamp( ) const
        {
            return lastTimestamp_;
        }
        void SetLastTimestamp( const DBDateTime& lastTimestamp )
        {
            lastTimestamp_ = lastTimestamp;
        }
        Int64 Count( ) const
        {
            return count_;
        }
        void SetCount( Int64 count )
        {
            count_ = count;
        }
        const DBDouble& NorthWestLatitude( ) const
        {
            return northWestLatitude_;
        }
        void SetNorthWestLatitude( const DBDouble& northWestLatitude )
        {
            northWestLatitude_ = northWestLatitude;
        }
        const DBDouble& NorthWestLongitude( ) const
        {
            return northWestLongitude_;
        }
        void SetNorthWestLongitude( const DBDouble& northWestLongitude )
        {
            northWestLongitude_ = northWestLongitude;
        }
        const DBDouble& SouthEastLatitude( ) const
        {
            return southEastLatitude_;
        }
        void SetSouthEastLatitude( const DBDouble& southEastLatitude )
        {
            southEastLatitude_ = southEastLatitude;
        }
        const DBDouble& SouthEastLongitude( ) const
        {
            return southEastLongitude_;
        }
        void SetSouthEastLongitude( const DBDouble& southEastLongitude )
        {
            southEastLongitude_ = southEastLongitude;
        }
    };
    class TrackingServiceOptionsObject : public BaseData<Kind, Guid>
    {
    public:
        using Base = BaseData<Kind, Guid>;
        static constexpr Kind KIND = Kind::TrackingServiceOptions;
    private:
        Int64 rowVersion_ = 0;
        DateTime timestamp_;
        TimeSpan timerInterval_;
        TimeSpan maxAgeOfCurrentTrackValue_;
        double falseThreshold_ = 0.0;
        double distanceThreshold_ = 0.0;
        double distanceUnmergeThreshold_ = 0.0;
        Int64 unmergeLatency_ = 0;
        bool kalmanFiltering_ = false;
        double maxCourseDeviation_ = 0.0;
        double maxSpeedDeviation_ = 0.0;
        double minimumSpeedThreshold_ = 0.0;
    public:
        TrackingServiceOptionsObject( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(rowVersion_);
            destination.Write(timestamp_);
            destination.Write(timerInterval_);
            destination.Write(maxAgeOfCurrentTrackValue_);
            destination.Write(falseThreshold_);
            destination.Write(distanceThreshold_);
            destination.Write(distanceUnmergeThreshold_);
            destination.Write(unmergeLatency_);
            destination.Write(kalmanFiltering_);
            destination.Write(maxCourseDeviation_);
            destination.Write(maxSpeedDeviation_);
            destination.Write(minimumSpeedThreshold_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(rowVersion_);
            source.Read(timestamp_);
            source.Read(timerInterval_);
            source.Read(maxAgeOfCurrentTrackValue_);
            source.Read(falseThreshold_);
            source.Read(distanceThreshold_);
            source.Read(distanceUnmergeThreshold_);
            source.Read(unmergeLatency_);
            source.Read(kalmanFiltering_);
            source.Read(maxCourseDeviation_);
            source.Read(maxSpeedDeviation_);
            source.Read(minimumSpeedThreshold_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<TrackingServiceOptionsObject>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<TrackingServiceOptionsObject&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const TrackingServiceOptionsObject& >( other );
                if ( dataObject.rowVersion_ != rowVersion_ )
                {
                    return false;
                }
                if ( dataObject.timestamp_ != timestamp_ )
                {
                    return false;
                }
                if ( dataObject.timerInterval_ != timerInterval_ )
                {
                    return false;
                }
                if ( dataObject.maxAgeOfCurrentTrackValue_ != maxAgeOfCurrentTrackValue_ )
                {
                    return false;
                }
                if ( dataObject.falseThreshold_ != falseThreshold_ )
                {
                    return false;
                }
                if ( dataObject.distanceThreshold_ != distanceThreshold_ )
                {
                    return false;
                }
                if ( dataObject.distanceUnmergeThreshold_ != distanceUnmergeThreshold_ )
                {
                    return false;
                }
                if ( dataObject.unmergeLatency_ != unmergeLatency_ )
                {
                    return false;
                }
                if ( dataObject.kalmanFiltering_ != kalmanFiltering_ )
                {
                    return false;
                }
                if ( dataObject.maxCourseDeviation_ != maxCourseDeviation_ )
                {
                    return false;
                }
                if ( dataObject.maxSpeedDeviation_ != maxSpeedDeviation_ )
                {
                    return false;
                }
                if ( dataObject.minimumSpeedThreshold_ != minimumSpeedThreshold_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        Int64 RowVersion( ) const
        {
            return rowVersion_;
        }
        void SetRowVersion( const Int64& rowVersion )
        {
            rowVersion_ = rowVersion;
        }
        const DateTime& Timestamp( ) const
        {
            return timestamp_;
        }
        void SetTimestamp( const DateTime& timestamp )
        {
            timestamp_ = timestamp;
        }
        const TimeSpan& TimerInterval( ) const
        {
            return timerInterval_;
        }
        void SetTimerInterval( const TimeSpan& timerInterval )
        {
            timerInterval_ = timerInterval;
        }
        const TimeSpan& MaxAgeOfCurrentTrackValue( ) const
        {
            return maxAgeOfCurrentTrackValue_;
        }
        void SetMaxAgeOfCurrentTrackValue( const TimeSpan& maxAgeOfCurrentTrackValue )
        {
            maxAgeOfCurrentTrackValue_ = maxAgeOfCurrentTrackValue;
        }
        double FalseThreshold( ) const
        {
            return falseThreshold_;
        }
        void SetFalseThreshold( double falseThreshold )
        {
            falseThreshold_ = falseThreshold;
        }
        double DistanceThreshold( ) const
        {
            return distanceThreshold_;
        }
        void SetDistanceThreshold( double distanceThreshold )
        {
            distanceThreshold_ = distanceThreshold;
        }
        double DistanceUnmergeThreshold( ) const
        {
            return distanceUnmergeThreshold_;
        }
        void SetDistanceUnmergeThreshold( double distanceUnmergeThreshold )
        {
            distanceUnmergeThreshold_ = distanceUnmergeThreshold;
        }
        Int64 UnmergeLatency( ) const
        {
            return unmergeLatency_;
        }
        void SetUnmergeLatency( Int64 unmergeLatency )
        {
            unmergeLatency_ = unmergeLatency;
        }
        bool KalmanFiltering( ) const
        {
            return kalmanFiltering_;
        }
        void SetKalmanFiltering( bool kalmanFiltering )
        {
            kalmanFiltering_ = kalmanFiltering;
        }
        double MaxCourseDeviation( ) const
        {
            return maxCourseDeviation_;
        }
        void SetMaxCourseDeviation( double maxCourseDeviation )
        {
            maxCourseDeviation_ = maxCourseDeviation;
        }
        double MaxSpeedDeviation( ) const
        {
            return maxSpeedDeviation_;
        }
        void SetMaxSpeedDeviation( double maxSpeedDeviation )
        {
            maxSpeedDeviation_ = maxSpeedDeviation;
        }
        double MinimumSpeedThreshold( ) const
        {
            return minimumSpeedThreshold_;
        }
        void SetMinimumSpeedThreshold( double minimumSpeedThreshold )
        {
            minimumSpeedThreshold_ = minimumSpeedThreshold;
        }
    };
    class TrackLinkObject : public BaseData<Kind, Guid>
    {
    public:
        using Base = BaseData<Kind, Guid>;
        static constexpr Kind KIND = Kind::TrackLink;
    private:
        Int64 rowVersion_ = 0;
        Guid primary_;
        Guid secondary_;
        DateTime start_;
        DBDateTime end_;
    public:
        TrackLinkObject( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(rowVersion_);
            destination.Write(primary_);
            destination.Write(secondary_);
            destination.Write(start_);
            end_.WriteTo( destination );
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(rowVersion_);
            source.Read(primary_);
            source.Read(secondary_);
            source.Read(start_);
            end_.ReadFrom( source );
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<TrackLinkObject>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<TrackLinkObject&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const TrackLinkObject& >( other );
                if ( dataObject.rowVersion_ != rowVersion_ )
                {
                    return false;
                }
                if ( dataObject.primary_ != primary_ )
                {
                    return false;
                }
                if ( dataObject.secondary_ != secondary_ )
                {
                    return false;
                }
                if ( dataObject.start_ != start_ )
                {
                    return false;
                }
                if ( dataObject.end_ != end_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        Int64 RowVersion( ) const
        {
            return rowVersion_;
        }
        void SetRowVersion( const Int64& rowVersion )
        {
            rowVersion_ = rowVersion;
        }
        const Guid& Primary( ) const
        {
            return primary_;
        }
        void SetPrimary( const Guid& primary )
        {
            primary_ = primary;
        }
        const Guid& Secondary( ) const
        {
            return secondary_;
        }
        void SetSecondary( const Guid& secondary )
        {
            secondary_ = secondary;
        }
        const DateTime& Start( ) const
        {
            return start_;
        }
        void SetStart( const DateTime& start )
        {
            start_ = start;
        }
        const DBDateTime& End( ) const
        {
            return end_;
        }
        void SetEnd( const DBDateTime& end )
        {
            end_ = end;
        }
    };
    class TrackValueObject : public BaseData<Kind, Guid>
    {
    public:
        using Base = BaseData<Kind, Guid>;
        static constexpr Kind KIND = Kind::TrackValue;
    private:
        Int64 rowVersion_ = 0;
        Guid track_;
        DateTime timestamp_;
        Types::TrackFlags flags_ = Types::TrackFlags::None;
        Types::TrackStatus status_ = Types::TrackStatus::Unknown;
        double latitude_ = 0.0;
        double longitude_ = 0.0;
        double speed_ = 0.0;
        double course_ = 0.0;
        double heading_ = 0.0;
    public:
        TrackValueObject( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(rowVersion_);
            destination.Write(track_);
            destination.Write(timestamp_);
            destination.Write(flags_);
            destination.Write(status_);
            destination.Write(latitude_);
            destination.Write(longitude_);
            destination.Write(speed_);
            destination.Write(course_);
            destination.Write(heading_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(rowVersion_);
            source.Read(track_);
            source.Read(timestamp_);
            source.Read(flags_);
            source.Read(status_);
            source.Read(latitude_);
            source.Read(longitude_);
            source.Read(speed_);
            source.Read(course_);
            source.Read(heading_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<TrackValueObject>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<TrackValueObject&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const TrackValueObject& >( other );
                if ( dataObject.rowVersion_ != rowVersion_ )
                {
                    return false;
                }
                if ( dataObject.track_ != track_ )
                {
                    return false;
                }
                if ( dataObject.timestamp_ != timestamp_ )
                {
                    return false;
                }
                if ( dataObject.flags_ != flags_ )
                {
                    return false;
                }
                if ( dataObject.status_ != status_ )
                {
                    return false;
                }
                if ( dataObject.latitude_ != latitude_ )
                {
                    return false;
                }
                if ( dataObject.longitude_ != longitude_ )
                {
                    return false;
                }
                if ( dataObject.speed_ != speed_ )
                {
                    return false;
                }
                if ( dataObject.course_ != course_ )
                {
                    return false;
                }
                if ( dataObject.heading_ != heading_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        Int64 RowVersion( ) const
        {
            return rowVersion_;
        }
        void SetRowVersion( const Int64& rowVersion )
        {
            rowVersion_ = rowVersion;
        }
        const Guid& Track( ) const
        {
            return track_;
        }
        void SetTrack( const Guid& track )
        {
            track_ = track;
        }
        const DateTime& Timestamp( ) const
        {
            return timestamp_;
        }
        void SetTimestamp( const DateTime& timestamp )
        {
            timestamp_ = timestamp;
        }
        Types::TrackFlags Flags( ) const
        {
            return flags_;
        }
        void SetFlags( Types::TrackFlags flags )
        {
            flags_ = flags;
        }
        Types::TrackStatus Status( ) const
        {
            return status_;
        }
        void SetStatus( Types::TrackStatus status )
        {
            status_ = status;
        }
        double Latitude( ) const
        {
            return latitude_;
        }
        void SetLatitude( double latitude )
        {
            latitude_ = latitude;
        }
        double Longitude( ) const
        {
            return longitude_;
        }
        void SetLongitude( double longitude )
        {
            longitude_ = longitude;
        }
        double Speed( ) const
        {
            return speed_;
        }
        void SetSpeed( double speed )
        {
            speed_ = speed;
        }
        double Course( ) const
        {
            return course_;
        }
        void SetCourse( double course )
        {
            course_ = course;
        }
        double Heading( ) const
        {
            return heading_;
        }
        void SetHeading( double heading )
        {
            heading_ = heading;
        }
    };
    class TrackValue3DObject : public BaseData<Kind, Guid>
    {
    public:
        using Base = BaseData<Kind, Guid>;
        static constexpr Kind KIND = Kind::TrackValue3D;
    private:
        Int64 rowVersion_ = 0;
        Guid track_;
        DateTime timestamp_;
        Types::TrackFlags3D flags_ = Types::TrackFlags3D::None;
        UInt32 status_ = 0;
        double latitude_ = 0.0;
        double longitude_ = 0.0;
        double altitude_ = 0.0;
        double speed_ = 0.0;
        double course_ = 0.0;
        double rateOfClimb_ = 0.0;
    public:
        TrackValue3DObject( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(rowVersion_);
            destination.Write(track_);
            destination.Write(timestamp_);
            destination.Write(flags_);
            destination.Write(status_);
            destination.Write(latitude_);
            destination.Write(longitude_);
            destination.Write(altitude_);
            destination.Write(speed_);
            destination.Write(course_);
            destination.Write(rateOfClimb_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(rowVersion_);
            source.Read(track_);
            source.Read(timestamp_);
            source.Read(flags_);
            source.Read(status_);
            source.Read(latitude_);
            source.Read(longitude_);
            source.Read(altitude_);
            source.Read(speed_);
            source.Read(course_);
            source.Read(rateOfClimb_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<TrackValue3DObject>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<TrackValue3DObject&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const TrackValue3DObject& >( other );
                if ( dataObject.rowVersion_ != rowVersion_ )
                {
                    return false;
                }
                if ( dataObject.track_ != track_ )
                {
                    return false;
                }
                if ( dataObject.timestamp_ != timestamp_ )
                {
                    return false;
                }
                if ( dataObject.flags_ != flags_ )
                {
                    return false;
                }
                if ( dataObject.status_ != status_ )
                {
                    return false;
                }
                if ( dataObject.latitude_ != latitude_ )
                {
                    return false;
                }
                if ( dataObject.longitude_ != longitude_ )
                {
                    return false;
                }
                if ( dataObject.altitude_ != altitude_ )
                {
                    return false;
                }
                if ( dataObject.speed_ != speed_ )
                {
                    return false;
                }
                if ( dataObject.course_ != course_ )
                {
                    return false;
                }
                if ( dataObject.rateOfClimb_ != rateOfClimb_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        Int64 RowVersion( ) const
        {
            return rowVersion_;
        }
        void SetRowVersion( const Int64& rowVersion )
        {
            rowVersion_ = rowVersion;
        }
        const Guid& Track( ) const
        {
            return track_;
        }
        void SetTrack( const Guid& track )
        {
            track_ = track;
        }
        const DateTime& Timestamp( ) const
        {
            return timestamp_;
        }
        void SetTimestamp( const DateTime& timestamp )
        {
            timestamp_ = timestamp;
        }
        Types::TrackFlags3D Flags( ) const
        {
            return flags_;
        }
        void SetFlags( Types::TrackFlags3D flags )
        {
            flags_ = flags;
        }
        UInt32 Status( ) const
        {
            return status_;
        }
        void SetStatus( UInt32 status )
        {
            status_ = status;
        }
        double Latitude( ) const
        {
            return latitude_;
        }
        void SetLatitude( double latitude )
        {
            latitude_ = latitude;
        }
        double Longitude( ) const
        {
            return longitude_;
        }
        void SetLongitude( double longitude )
        {
            longitude_ = longitude;
        }
        double Altitude( ) const
        {
            return altitude_;
        }
        void SetAltitude( double altitude )
        {
            altitude_ = altitude;
        }
        double Speed( ) const
        {
            return speed_;
        }
        void SetSpeed( double speed )
        {
            speed_ = speed;
        }
        double Course( ) const
        {
            return course_;
        }
        void SetCourse( double course )
        {
            course_ = course;
        }
        double RateOfClimb( ) const
        {
            return rateOfClimb_;
        }
        void SetRateOfClimb( double rateOfClimb )
        {
            rateOfClimb_ = rateOfClimb;
        }
    };
    class UInt16TimeseriesValueObject : public BaseData<Kind, Guid>
    {
    public:
        using Base = BaseData<Kind, Guid>;
        static constexpr Kind KIND = Kind::UInt16TimeseriesValue;
    private:
        Int64 rowVersion_ = 0;
        Guid timeseries_;
        DateTime timestamp_;
        DBUInt16 value_;
    public:
        UInt16TimeseriesValueObject( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(rowVersion_);
            destination.Write(timeseries_);
            destination.Write(timestamp_);
            value_.WriteTo( destination );
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(rowVersion_);
            source.Read(timeseries_);
            source.Read(timestamp_);
            value_.ReadFrom( source );
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<UInt16TimeseriesValueObject>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<UInt16TimeseriesValueObject&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const UInt16TimeseriesValueObject& >( other );
                if ( dataObject.rowVersion_ != rowVersion_ )
                {
                    return false;
                }
                if ( dataObject.timeseries_ != timeseries_ )
                {
                    return false;
                }
                if ( dataObject.timestamp_ != timestamp_ )
                {
                    return false;
                }
                if ( dataObject.value_ != value_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        Int64 RowVersion( ) const
        {
            return rowVersion_;
        }
        void SetRowVersion( const Int64& rowVersion )
        {
            rowVersion_ = rowVersion;
        }
        const Guid& Timeseries( ) const
        {
            return timeseries_;
        }
        void SetTimeseries( const Guid& timeseries )
        {
            timeseries_ = timeseries;
        }
        const DateTime& Timestamp( ) const
        {
            return timestamp_;
        }
        void SetTimestamp( const DateTime& timestamp )
        {
            timestamp_ = timestamp;
        }
        const DBUInt16& Value( ) const
        {
            return value_;
        }
        void SetValue( const DBUInt16& value )
        {
            value_ = value;
        }
    };
    class UInt32TimeseriesValueObject : public BaseData<Kind, Guid>
    {
    public:
        using Base = BaseData<Kind, Guid>;
        static constexpr Kind KIND = Kind::UInt32TimeseriesValue;
    private:
        Int64 rowVersion_ = 0;
        Guid timeseries_;
        DateTime timestamp_;
        DBUInt32 value_;
    public:
        UInt32TimeseriesValueObject( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(rowVersion_);
            destination.Write(timeseries_);
            destination.Write(timestamp_);
            value_.WriteTo( destination );
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(rowVersion_);
            source.Read(timeseries_);
            source.Read(timestamp_);
            value_.ReadFrom( source );
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<UInt32TimeseriesValueObject>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<UInt32TimeseriesValueObject&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const UInt32TimeseriesValueObject& >( other );
                if ( dataObject.rowVersion_ != rowVersion_ )
                {
                    return false;
                }
                if ( dataObject.timeseries_ != timeseries_ )
                {
                    return false;
                }
                if ( dataObject.timestamp_ != timestamp_ )
                {
                    return false;
                }
                if ( dataObject.value_ != value_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        Int64 RowVersion( ) const
        {
            return rowVersion_;
        }
        void SetRowVersion( const Int64& rowVersion )
        {
            rowVersion_ = rowVersion;
        }
        const Guid& Timeseries( ) const
        {
            return timeseries_;
        }
        void SetTimeseries( const Guid& timeseries )
        {
            timeseries_ = timeseries;
        }
        const DateTime& Timestamp( ) const
        {
            return timestamp_;
        }
        void SetTimestamp( const DateTime& timestamp )
        {
            timestamp_ = timestamp;
        }
        const DBUInt32& Value( ) const
        {
            return value_;
        }
        void SetValue( const DBUInt32& value )
        {
            value_ = value;
        }
    };
    class UInt64TimeseriesValueObject : public BaseData<Kind, Guid>
    {
    public:
        using Base = BaseData<Kind, Guid>;
        static constexpr Kind KIND = Kind::UInt64TimeseriesValue;
    private:
        Int64 rowVersion_ = 0;
        Guid timeseries_;
        DateTime timestamp_;
        DBInt64 value_;
    public:
        UInt64TimeseriesValueObject( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(rowVersion_);
            destination.Write(timeseries_);
            destination.Write(timestamp_);
            value_.WriteTo( destination );
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(rowVersion_);
            source.Read(timeseries_);
            source.Read(timestamp_);
            value_.ReadFrom( source );
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<UInt64TimeseriesValueObject>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<UInt64TimeseriesValueObject&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const UInt64TimeseriesValueObject& >( other );
                if ( dataObject.rowVersion_ != rowVersion_ )
                {
                    return false;
                }
                if ( dataObject.timeseries_ != timeseries_ )
                {
                    return false;
                }
                if ( dataObject.timestamp_ != timestamp_ )
                {
                    return false;
                }
                if ( dataObject.value_ != value_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        Int64 RowVersion( ) const
        {
            return rowVersion_;
        }
        void SetRowVersion( const Int64& rowVersion )
        {
            rowVersion_ = rowVersion;
        }
        const Guid& Timeseries( ) const
        {
            return timeseries_;
        }
        void SetTimeseries( const Guid& timeseries )
        {
            timeseries_ = timeseries;
        }
        const DateTime& Timestamp( ) const
        {
            return timestamp_;
        }
        void SetTimestamp( const DateTime& timestamp )
        {
            timestamp_ = timestamp;
        }
        const DBInt64& Value( ) const
        {
            return value_;
        }
        void SetValue( const DBInt64& value )
        {
            value_ = value;
        }
    };
    class VehicleTypeObject : public BaseData<Kind, Guid>
    {
    public:
        using Base = BaseData<Kind, Guid>;
        static constexpr Kind KIND = Kind::VehicleType;
    private:
        Int64 rowVersion_ = 0;
        FixedDBWideString<127> name_;
    public:
        VehicleTypeObject( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(rowVersion_);
            name_.WriteTo( destination );
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(rowVersion_);
            name_.ReadFrom( source );
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<VehicleTypeObject>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<VehicleTypeObject&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const VehicleTypeObject& >( other );
                if ( dataObject.rowVersion_ != rowVersion_ )
                {
                    return false;
                }
                if ( dataObject.name_ != name_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        Int64 RowVersion( ) const
        {
            return rowVersion_;
        }
        void SetRowVersion( const Int64& rowVersion )
        {
            rowVersion_ = rowVersion;
        }
        const FixedDBWideString<127>& Name( ) const
        {
            return name_;
        }
        void SetName( const FixedDBWideString<127>& name )
        {
            name_ = name;
        }
    };
    class VesselTypeObject : public BaseData<Kind, Guid>
    {
    public:
        using Base = BaseData<Kind, Guid>;
        static constexpr Kind KIND = Kind::VesselType;
    private:
        Int64 rowVersion_ = 0;
        FixedDBWideString<127> name_;
        Int32 code_ = 0;
    public:
        VesselTypeObject( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(rowVersion_);
            name_.WriteTo( destination );
            destination.Write(code_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(rowVersion_);
            name_.ReadFrom( source );
            source.Read(code_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<VesselTypeObject>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<VesselTypeObject&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const VesselTypeObject& >( other );
                if ( dataObject.rowVersion_ != rowVersion_ )
                {
                    return false;
                }
                if ( dataObject.name_ != name_ )
                {
                    return false;
                }
                if ( dataObject.code_ != code_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        Int64 RowVersion( ) const
        {
            return rowVersion_;
        }
        void SetRowVersion( const Int64& rowVersion )
        {
            rowVersion_ = rowVersion;
        }
        const FixedDBWideString<127>& Name( ) const
        {
            return name_;
        }
        void SetName( const FixedDBWideString<127>& name )
        {
            name_ = name;
        }
        Int32 Code( ) const
        {
            return code_;
        }
        void SetCode( Int32 code )
        {
            code_ = code;
        }
    };
    class ViewObject : public BaseData<Kind, Guid>
    {
    public:
        using Base = BaseData<Kind, Guid>;
        static constexpr Kind KIND = Kind::View;
    private:
        Int64 rowVersion_ = 0;
        FixedDBWideString<127> name_;
        Guid latitudeTimeseries_;
        Guid longitudeTimeseries_;
        Guid zoomLevelTimeseries_;
    public:
        ViewObject( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(rowVersion_);
            name_.WriteTo( destination );
            destination.Write(latitudeTimeseries_);
            destination.Write(longitudeTimeseries_);
            destination.Write(zoomLevelTimeseries_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(rowVersion_);
            name_.ReadFrom( source );
            source.Read(latitudeTimeseries_);
            source.Read(longitudeTimeseries_);
            source.Read(zoomLevelTimeseries_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<ViewObject>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<ViewObject&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const ViewObject& >( other );
                if ( dataObject.rowVersion_ != rowVersion_ )
                {
                    return false;
                }
                if ( dataObject.name_ != name_ )
                {
                    return false;
                }
                if ( dataObject.latitudeTimeseries_ != latitudeTimeseries_ )
                {
                    return false;
                }
                if ( dataObject.longitudeTimeseries_ != longitudeTimeseries_ )
                {
                    return false;
                }
                if ( dataObject.zoomLevelTimeseries_ != zoomLevelTimeseries_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        Int64 RowVersion( ) const
        {
            return rowVersion_;
        }
        void SetRowVersion( const Int64& rowVersion )
        {
            rowVersion_ = rowVersion;
        }
        const FixedDBWideString<127>& Name( ) const
        {
            return name_;
        }
        void SetName( const FixedDBWideString<127>& name )
        {
            name_ = name;
        }
        const Guid& LatitudeTimeseries( ) const
        {
            return latitudeTimeseries_;
        }
        void SetLatitudeTimeseries( const Guid& latitudeTimeseries )
        {
            latitudeTimeseries_ = latitudeTimeseries;
        }
        const Guid& LongitudeTimeseries( ) const
        {
            return longitudeTimeseries_;
        }
        void SetLongitudeTimeseries( const Guid& longitudeTimeseries )
        {
            longitudeTimeseries_ = longitudeTimeseries;
        }
        const Guid& ZoomLevelTimeseries( ) const
        {
            return zoomLevelTimeseries_;
        }
        void SetZoomLevelTimeseries( const Guid& zoomLevelTimeseries )
        {
            zoomLevelTimeseries_ = zoomLevelTimeseries;
        }
    };
    class ViewCameraLinkObject : public BaseData<Kind, Guid>
    {
    public:
        using Base = BaseData<Kind, Guid>;
        static constexpr Kind KIND = Kind::ViewCameraLink;
    private:
        Int64 rowVersion_ = 0;
        Guid view_;
        Guid camera_;
        DateTime start_;
        DBDateTime end_;
    public:
        ViewCameraLinkObject( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(rowVersion_);
            destination.Write(view_);
            destination.Write(camera_);
            destination.Write(start_);
            end_.WriteTo( destination );
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(rowVersion_);
            source.Read(view_);
            source.Read(camera_);
            source.Read(start_);
            end_.ReadFrom( source );
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<ViewCameraLinkObject>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<ViewCameraLinkObject&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const ViewCameraLinkObject& >( other );
                if ( dataObject.rowVersion_ != rowVersion_ )
                {
                    return false;
                }
                if ( dataObject.view_ != view_ )
                {
                    return false;
                }
                if ( dataObject.camera_ != camera_ )
                {
                    return false;
                }
                if ( dataObject.start_ != start_ )
                {
                    return false;
                }
                if ( dataObject.end_ != end_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        Int64 RowVersion( ) const
        {
            return rowVersion_;
        }
        void SetRowVersion( const Int64& rowVersion )
        {
            rowVersion_ = rowVersion;
        }
        const Guid& View( ) const
        {
            return view_;
        }
        void SetView( const Guid& view )
        {
            view_ = view;
        }
        const Guid& Camera( ) const
        {
            return camera_;
        }
        void SetCamera( const Guid& camera )
        {
            camera_ = camera;
        }
        const DateTime& Start( ) const
        {
            return start_;
        }
        void SetStart( const DateTime& start )
        {
            start_ = start;
        }
        const DBDateTime& End( ) const
        {
            return end_;
        }
        void SetEnd( const DBDateTime& end )
        {
            end_ = end;
        }
    };
    class ViewTrackerLinkObject : public BaseData<Kind, Guid>
    {
    public:
        using Base = BaseData<Kind, Guid>;
        static constexpr Kind KIND = Kind::ViewTrackerLink;
    private:
        Int64 rowVersion_ = 0;
        Guid view_;
        Guid tracker_;
        DateTime start_;
        DBDateTime end_;
    public:
        ViewTrackerLinkObject( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(rowVersion_);
            destination.Write(view_);
            destination.Write(tracker_);
            destination.Write(start_);
            end_.WriteTo( destination );
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(rowVersion_);
            source.Read(view_);
            source.Read(tracker_);
            source.Read(start_);
            end_.ReadFrom( source );
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<ViewTrackerLinkObject>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<ViewTrackerLinkObject&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const ViewTrackerLinkObject& >( other );
                if ( dataObject.rowVersion_ != rowVersion_ )
                {
                    return false;
                }
                if ( dataObject.view_ != view_ )
                {
                    return false;
                }
                if ( dataObject.tracker_ != tracker_ )
                {
                    return false;
                }
                if ( dataObject.start_ != start_ )
                {
                    return false;
                }
                if ( dataObject.end_ != end_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        Int64 RowVersion( ) const
        {
            return rowVersion_;
        }
        void SetRowVersion( const Int64& rowVersion )
        {
            rowVersion_ = rowVersion;
        }
        const Guid& View( ) const
        {
            return view_;
        }
        void SetView( const Guid& view )
        {
            view_ = view;
        }
        const Guid& Tracker( ) const
        {
            return tracker_;
        }
        void SetTracker( const Guid& tracker )
        {
            tracker_ = tracker;
        }
        const DateTime& Start( ) const
        {
            return start_;
        }
        void SetStart( const DateTime& start )
        {
            start_ = start;
        }
        const DBDateTime& End( ) const
        {
            return end_;
        }
        void SetEnd( const DBDateTime& end )
        {
            end_ = end;
        }
    };
    class WeatherStationCommandObject : public BaseData<Kind, Guid>
    {
    public:
        using Base = BaseData<Kind, Guid>;
        static constexpr Kind KIND = Kind::WeatherStationCommand;
    private:
        Int64 rowVersion_ = 0;
        Guid weatherStation_;
        DateTime timestamp_;
        Types::DeviceCommandSourceType deviceCommandSourceType_ = Types::DeviceCommandSourceType::Unknown;
        Guid deviceCommandSourceId_;
        Guid reply_;
    public:
        WeatherStationCommandObject( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(rowVersion_);
            destination.Write(weatherStation_);
            destination.Write(timestamp_);
            destination.Write(deviceCommandSourceType_);
            destination.Write(deviceCommandSourceId_);
            destination.Write(reply_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(rowVersion_);
            source.Read(weatherStation_);
            source.Read(timestamp_);
            source.Read(deviceCommandSourceType_);
            source.Read(deviceCommandSourceId_);
            source.Read(reply_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<WeatherStationCommandObject>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<WeatherStationCommandObject&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const WeatherStationCommandObject& >( other );
                if ( dataObject.rowVersion_ != rowVersion_ )
                {
                    return false;
                }
                if ( dataObject.weatherStation_ != weatherStation_ )
                {
                    return false;
                }
                if ( dataObject.timestamp_ != timestamp_ )
                {
                    return false;
                }
                if ( dataObject.deviceCommandSourceType_ != deviceCommandSourceType_ )
                {
                    return false;
                }
                if ( dataObject.deviceCommandSourceId_ != deviceCommandSourceId_ )
                {
                    return false;
                }
                if ( dataObject.reply_ != reply_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        Int64 RowVersion( ) const
        {
            return rowVersion_;
        }
        void SetRowVersion( const Int64& rowVersion )
        {
            rowVersion_ = rowVersion;
        }
        const Guid& WeatherStation( ) const
        {
            return weatherStation_;
        }
        void SetWeatherStation( const Guid& weatherStation )
        {
            weatherStation_ = weatherStation;
        }
        const DateTime& Timestamp( ) const
        {
            return timestamp_;
        }
        void SetTimestamp( const DateTime& timestamp )
        {
            timestamp_ = timestamp;
        }
        Types::DeviceCommandSourceType DeviceCommandSourceType( ) const
        {
            return deviceCommandSourceType_;
        }
        void SetDeviceCommandSourceType( Types::DeviceCommandSourceType deviceCommandSourceType )
        {
            deviceCommandSourceType_ = deviceCommandSourceType;
        }
        const Guid& DeviceCommandSourceId( ) const
        {
            return deviceCommandSourceId_;
        }
        void SetDeviceCommandSourceId( const Guid& deviceCommandSourceId )
        {
            deviceCommandSourceId_ = deviceCommandSourceId;
        }
        const Guid& Reply( ) const
        {
            return reply_;
        }
        void SetReply( const Guid& reply )
        {
            reply_ = reply;
        }
    };
    class WeatherStationCommandReplyObject : public BaseData<Kind, Guid>
    {
    public:
        using Base = BaseData<Kind, Guid>;
        static constexpr Kind KIND = Kind::WeatherStationCommandReply;
    private:
        Int64 rowVersion_ = 0;
        Guid weatherStation_;
        DateTime timestamp_;
        Guid command_;
        Types::DeviceCommandReplyStatus status_ = Types::DeviceCommandReplyStatus::Unknown;
        WideString message_;
        SQLLEN messageLength_ = SQL_NULL_DATA;
    public:
        WeatherStationCommandReplyObject( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(rowVersion_);
            destination.Write(weatherStation_);
            destination.Write(timestamp_);
            destination.Write(command_);
            destination.Write(status_);
            destination.Write(message_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(rowVersion_);
            source.Read(weatherStation_);
            source.Read(timestamp_);
            source.Read(command_);
            source.Read(status_);
            source.Read(message_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<WeatherStationCommandReplyObject>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<WeatherStationCommandReplyObject&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const WeatherStationCommandReplyObject& >( other );
                if ( dataObject.rowVersion_ != rowVersion_ )
                {
                    return false;
                }
                if ( dataObject.weatherStation_ != weatherStation_ )
                {
                    return false;
                }
                if ( dataObject.timestamp_ != timestamp_ )
                {
                    return false;
                }
                if ( dataObject.command_ != command_ )
                {
                    return false;
                }
                if ( dataObject.status_ != status_ )
                {
                    return false;
                }
                if ( dataObject.message_ != message_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        Int64 RowVersion( ) const
        {
            return rowVersion_;
        }
        void SetRowVersion( const Int64& rowVersion )
        {
            rowVersion_ = rowVersion;
        }
        const Guid& WeatherStation( ) const
        {
            return weatherStation_;
        }
        void SetWeatherStation( const Guid& weatherStation )
        {
            weatherStation_ = weatherStation;
        }
        const DateTime& Timestamp( ) const
        {
            return timestamp_;
        }
        void SetTimestamp( const DateTime& timestamp )
        {
            timestamp_ = timestamp;
        }
        const Guid& Command( ) const
        {
            return command_;
        }
        void SetCommand( const Guid& command )
        {
            command_ = command;
        }
        Types::DeviceCommandReplyStatus Status( ) const
        {
            return status_;
        }
        void SetStatus( Types::DeviceCommandReplyStatus status )
        {
            status_ = status;
        }
        const WideString& Message( ) const
        {
            return message_;
        }
        void SetMessage( const WideString& message )
        {
            message_ = message;
        }
    };
    class WeatherStationConfigurationObject : public BaseData<Kind, Guid>
    {
    public:
        using Base = BaseData<Kind, Guid>;
        static constexpr Kind KIND = Kind::WeatherStationConfiguration;
    private:
        Int64 rowVersion_ = 0;
        Guid weatherStation_;
        DateTime timestamp_;
        TimeSpan noDataTimeOut_;
        TimeSpan sendInterval_;
        double latitude_ = 0.0;
        double longitude_ = 0.0;
        double gyroOffset_ = 0.0;
        bool enableAveraging_ = false;
        TimeSpan averagingInterval_;
    public:
        WeatherStationConfigurationObject( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(rowVersion_);
            destination.Write(weatherStation_);
            destination.Write(timestamp_);
            destination.Write(noDataTimeOut_);
            destination.Write(sendInterval_);
            destination.Write(latitude_);
            destination.Write(longitude_);
            destination.Write(gyroOffset_);
            destination.Write(enableAveraging_);
            destination.Write(averagingInterval_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(rowVersion_);
            source.Read(weatherStation_);
            source.Read(timestamp_);
            source.Read(noDataTimeOut_);
            source.Read(sendInterval_);
            source.Read(latitude_);
            source.Read(longitude_);
            source.Read(gyroOffset_);
            source.Read(enableAveraging_);
            source.Read(averagingInterval_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<WeatherStationConfigurationObject>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<WeatherStationConfigurationObject&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const WeatherStationConfigurationObject& >( other );
                if ( dataObject.rowVersion_ != rowVersion_ )
                {
                    return false;
                }
                if ( dataObject.weatherStation_ != weatherStation_ )
                {
                    return false;
                }
                if ( dataObject.timestamp_ != timestamp_ )
                {
                    return false;
                }
                if ( dataObject.noDataTimeOut_ != noDataTimeOut_ )
                {
                    return false;
                }
                if ( dataObject.sendInterval_ != sendInterval_ )
                {
                    return false;
                }
                if ( dataObject.latitude_ != latitude_ )
                {
                    return false;
                }
                if ( dataObject.longitude_ != longitude_ )
                {
                    return false;
                }
                if ( dataObject.gyroOffset_ != gyroOffset_ )
                {
                    return false;
                }
                if ( dataObject.enableAveraging_ != enableAveraging_ )
                {
                    return false;
                }
                if ( dataObject.averagingInterval_ != averagingInterval_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        Int64 RowVersion( ) const
        {
            return rowVersion_;
        }
        void SetRowVersion( const Int64& rowVersion )
        {
            rowVersion_ = rowVersion;
        }
        const Guid& WeatherStation( ) const
        {
            return weatherStation_;
        }
        void SetWeatherStation( const Guid& weatherStation )
        {
            weatherStation_ = weatherStation;
        }
        const DateTime& Timestamp( ) const
        {
            return timestamp_;
        }
        void SetTimestamp( const DateTime& timestamp )
        {
            timestamp_ = timestamp;
        }
        const TimeSpan& NoDataTimeOut( ) const
        {
            return noDataTimeOut_;
        }
        void SetNoDataTimeOut( const TimeSpan& noDataTimeOut )
        {
            noDataTimeOut_ = noDataTimeOut;
        }
        const TimeSpan& SendInterval( ) const
        {
            return sendInterval_;
        }
        void SetSendInterval( const TimeSpan& sendInterval )
        {
            sendInterval_ = sendInterval;
        }
        double Latitude( ) const
        {
            return latitude_;
        }
        void SetLatitude( double latitude )
        {
            latitude_ = latitude;
        }
        double Longitude( ) const
        {
            return longitude_;
        }
        void SetLongitude( double longitude )
        {
            longitude_ = longitude;
        }
        double GyroOffset( ) const
        {
            return gyroOffset_;
        }
        void SetGyroOffset( double gyroOffset )
        {
            gyroOffset_ = gyroOffset;
        }
        bool EnableAveraging( ) const
        {
            return enableAveraging_;
        }
        void SetEnableAveraging( bool enableAveraging )
        {
            enableAveraging_ = enableAveraging;
        }
        const TimeSpan& AveragingInterval( ) const
        {
            return averagingInterval_;
        }
        void SetAveragingInterval( const TimeSpan& averagingInterval )
        {
            averagingInterval_ = averagingInterval;
        }
    };
    class ZoneObject : public BaseData<Kind, Guid>
    {
    public:
        using Base = BaseData<Kind, Guid>;
        static constexpr Kind KIND = Kind::Zone;
    private:
        Int64 rowVersion_ = 0;
        FixedDBWideString<127> name_;
        double longitude_ = 0.0;
        double latitude_ = 0.0;
        Types::ZoneAlarmType alarmType_ = Types::ZoneAlarmType::None;
        TimeSpan alarmTime_;
        TimeSpan radarTrackMinimumLifetime_;
        double speed_ = 0.0;
        UInt32 strokeColor_ = 0;
        UInt32 fillColor_ = 0;
    public:
        ZoneObject( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(rowVersion_);
            name_.WriteTo( destination );
            destination.Write(longitude_);
            destination.Write(latitude_);
            destination.Write(alarmType_);
            destination.Write(alarmTime_);
            destination.Write(radarTrackMinimumLifetime_);
            destination.Write(speed_);
            destination.Write(strokeColor_);
            destination.Write(fillColor_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(rowVersion_);
            name_.ReadFrom( source );
            source.Read(longitude_);
            source.Read(latitude_);
            source.Read(alarmType_);
            source.Read(alarmTime_);
            source.Read(radarTrackMinimumLifetime_);
            source.Read(speed_);
            source.Read(strokeColor_);
            source.Read(fillColor_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<ZoneObject>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<ZoneObject&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const ZoneObject& >( other );
                if ( dataObject.rowVersion_ != rowVersion_ )
                {
                    return false;
                }
                if ( dataObject.name_ != name_ )
                {
                    return false;
                }
                if ( dataObject.longitude_ != longitude_ )
                {
                    return false;
                }
                if ( dataObject.latitude_ != latitude_ )
                {
                    return false;
                }
                if ( dataObject.alarmType_ != alarmType_ )
                {
                    return false;
                }
                if ( dataObject.alarmTime_ != alarmTime_ )
                {
                    return false;
                }
                if ( dataObject.radarTrackMinimumLifetime_ != radarTrackMinimumLifetime_ )
                {
                    return false;
                }
                if ( dataObject.speed_ != speed_ )
                {
                    return false;
                }
                if ( dataObject.strokeColor_ != strokeColor_ )
                {
                    return false;
                }
                if ( dataObject.fillColor_ != fillColor_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        Int64 RowVersion( ) const
        {
            return rowVersion_;
        }
        void SetRowVersion( const Int64& rowVersion )
        {
            rowVersion_ = rowVersion;
        }
        const FixedDBWideString<127>& Name( ) const
        {
            return name_;
        }
        void SetName( const FixedDBWideString<127>& name )
        {
            name_ = name;
        }
        double Longitude( ) const
        {
            return longitude_;
        }
        void SetLongitude( double longitude )
        {
            longitude_ = longitude;
        }
        double Latitude( ) const
        {
            return latitude_;
        }
        void SetLatitude( double latitude )
        {
            latitude_ = latitude;
        }
        Types::ZoneAlarmType AlarmType( ) const
        {
            return alarmType_;
        }
        void SetAlarmType( Types::ZoneAlarmType alarmType )
        {
            alarmType_ = alarmType;
        }
        const TimeSpan& AlarmTime( ) const
        {
            return alarmTime_;
        }
        void SetAlarmTime( const TimeSpan& alarmTime )
        {
            alarmTime_ = alarmTime;
        }
        const TimeSpan& RadarTrackMinimumLifetime( ) const
        {
            return radarTrackMinimumLifetime_;
        }
        void SetRadarTrackMinimumLifetime( const TimeSpan& radarTrackMinimumLifetime )
        {
            radarTrackMinimumLifetime_ = radarTrackMinimumLifetime;
        }
        double Speed( ) const
        {
            return speed_;
        }
        void SetSpeed( double speed )
        {
            speed_ = speed;
        }
        UInt32 StrokeColor( ) const
        {
            return strokeColor_;
        }
        void SetStrokeColor( UInt32 strokeColor )
        {
            strokeColor_ = strokeColor;
        }
        UInt32 FillColor( ) const
        {
            return fillColor_;
        }
        void SetFillColor( UInt32 fillColor )
        {
            fillColor_ = fillColor;
        }
    };
    class CircularZoneObject : public ZoneObject
    {
    public:
        using Base = ZoneObject;
        static constexpr Kind KIND = Kind::CircularZone;
    private:
        double radius_ = 0.0;
    public:
        CircularZoneObject( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(radius_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(radius_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<CircularZoneObject>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<CircularZoneObject&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const CircularZoneObject& >( other );
                if ( dataObject.radius_ != radius_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        double Radius( ) const
        {
            return radius_;
        }
        void SetRadius( double radius )
        {
            radius_ = radius;
        }
    };
    class PolygonZoneObject : public ZoneObject
    {
    public:
        using Base = ZoneObject;
        static constexpr Kind KIND = Kind::PolygonZone;
    private:
        Binary polygon_;
        SQLLEN polygonLength_ = SQL_NULL_DATA;
    public:
        PolygonZoneObject( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(polygon_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(polygon_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<PolygonZoneObject>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<PolygonZoneObject&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const PolygonZoneObject& >( other );
                if ( dataObject.polygon_ != polygon_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        const Binary& Polygon( ) const
        {
            return polygon_;
        }
        void SetPolygon( const Binary& polygon )
        {
            polygon_ = polygon;
        }
    };
    class ZoneExceptionsObject : public BaseData<Kind, Guid>
    {
    public:
        using Base = BaseData<Kind, Guid>;
        static constexpr Kind KIND = Kind::ZoneExceptions;
    private:
        Int64 rowVersion_ = 0;
        Guid zone_;
        DateTime timestamp_;
    public:
        ZoneExceptionsObject( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(rowVersion_);
            destination.Write(zone_);
            destination.Write(timestamp_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(rowVersion_);
            source.Read(zone_);
            source.Read(timestamp_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<ZoneExceptionsObject>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<ZoneExceptionsObject&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const ZoneExceptionsObject& >( other );
                if ( dataObject.rowVersion_ != rowVersion_ )
                {
                    return false;
                }
                if ( dataObject.zone_ != zone_ )
                {
                    return false;
                }
                if ( dataObject.timestamp_ != timestamp_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        Int64 RowVersion( ) const
        {
            return rowVersion_;
        }
        void SetRowVersion( const Int64& rowVersion )
        {
            rowVersion_ = rowVersion;
        }
        const Guid& Zone( ) const
        {
            return zone_;
        }
        void SetZone( const Guid& zone )
        {
            zone_ = zone;
        }
        const DateTime& Timestamp( ) const
        {
            return timestamp_;
        }
        void SetTimestamp( const DateTime& timestamp )
        {
            timestamp_ = timestamp;
        }
    };
    class ZoneExceptionsVesselLinkObject : public BaseData<Kind, Guid>
    {
    public:
        using Base = BaseData<Kind, Guid>;
        static constexpr Kind KIND = Kind::ZoneExceptionsVesselLink;
    private:
        Int64 rowVersion_ = 0;
        Guid zoneExceptions_;
        Guid vessel_;
    public:
        ZoneExceptionsVesselLinkObject( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(rowVersion_);
            destination.Write(zoneExceptions_);
            destination.Write(vessel_);
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(rowVersion_);
            source.Read(zoneExceptions_);
            source.Read(vessel_);
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<ZoneExceptionsVesselLinkObject>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<ZoneExceptionsVesselLinkObject&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const ZoneExceptionsVesselLinkObject& >( other );
                if ( dataObject.rowVersion_ != rowVersion_ )
                {
                    return false;
                }
                if ( dataObject.zoneExceptions_ != zoneExceptions_ )
                {
                    return false;
                }
                if ( dataObject.vessel_ != vessel_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        Int64 RowVersion( ) const
        {
            return rowVersion_;
        }
        void SetRowVersion( const Int64& rowVersion )
        {
            rowVersion_ = rowVersion;
        }
        const Guid& ZoneExceptions( ) const
        {
            return zoneExceptions_;
        }
        void SetZoneExceptions( const Guid& zoneExceptions )
        {
            zoneExceptions_ = zoneExceptions;
        }
        const Guid& Vessel( ) const
        {
            return vessel_;
        }
        void SetVessel( const Guid& vessel )
        {
            vessel_ = vessel;
        }
    };
    class ZoneTrackAlarmObject : public BaseData<Kind, Guid>
    {
    public:
        using Base = BaseData<Kind, Guid>;
        static constexpr Kind KIND = Kind::ZoneTrackAlarm;
    private:
        Int64 rowVersion_ = 0;
        Guid track_;
        Guid zone_;
        Guid radarTrack_;
        DateTime timestamp_;
        double latitude_ = 0.0;
        double longitude_ = 0.0;
        double speed_ = 0.0;
        DBDouble course_;
        DBDouble heading_;
        double enterLatitude_ = 0.0;
        double enterLongitude_ = 0.0;
        DBDouble leaveLatitude_;
        DBDouble leaveLongitude_;
    public:
        ZoneTrackAlarmObject( ) = default;
        template<IO::StreamWriter StreamT>
        void WriteTo( IO::BinaryWriter<StreamT>& destination ) const
        {
            Base::WriteTo( destination );
            destination.Write(rowVersion_);
            destination.Write(track_);
            destination.Write(zone_);
            destination.Write(radarTrack_);
            destination.Write(timestamp_);
            destination.Write(latitude_);
            destination.Write(longitude_);
            destination.Write(speed_);
            course_.WriteTo( destination );
            heading_.WriteTo( destination );
            destination.Write(enterLatitude_);
            destination.Write(enterLongitude_);
            leaveLatitude_.WriteTo( destination );
            leaveLongitude_.WriteTo( destination );
        }
        template<IO::StreamReader StreamT>
        void ReadFrom( IO::BinaryReader<StreamT>& source )
        {
            Base::ReadFrom( source );
            source.Read(rowVersion_);
            source.Read(track_);
            source.Read(zone_);
            source.Read(radarTrack_);
            source.Read(timestamp_);
            source.Read(latitude_);
            source.Read(longitude_);
            source.Read(speed_);
            course_.ReadFrom( source );
            heading_.ReadFrom( source );
            source.Read(enterLatitude_);
            source.Read(enterLongitude_);
            leaveLatitude_.ReadFrom( source );
            leaveLongitude_.ReadFrom( source );
        }
        virtual [[nodiscard]] ObjectType GetObjectType( ) const noexcept override
        {
            return KIND;
        }
        virtual [[nodiscard]] bool IsOfType( ObjectType objectType ) const noexcept
        {
            if ( objectType == KIND )
            {
                return true;
            }
            return Base::IsOfType( objectType );
        }
        virtual [[nodiscard]] std::shared_ptr<BaseData> Create( ) const override
        {
            return std::make_shared<ZoneTrackAlarmObject>( );
        }
        virtual void AssignTo( BaseData& target ) const override
        {
            Base::AssignTo( target );
            auto& dest = static_cast<ZoneTrackAlarmObject&>( target );
        }
        virtual [[nodiscard]] bool IsEqualTo( const BaseData& other ) const
        {
            if ( Base::IsEqualTo( other ) )
            {
                const auto& dataObject = static_cast< const ZoneTrackAlarmObject& >( other );
                if ( dataObject.rowVersion_ != rowVersion_ )
                {
                    return false;
                }
                if ( dataObject.track_ != track_ )
                {
                    return false;
                }
                if ( dataObject.zone_ != zone_ )
                {
                    return false;
                }
                if ( dataObject.radarTrack_ != radarTrack_ )
                {
                    return false;
                }
                if ( dataObject.timestamp_ != timestamp_ )
                {
                    return false;
                }
                if ( dataObject.latitude_ != latitude_ )
                {
                    return false;
                }
                if ( dataObject.longitude_ != longitude_ )
                {
                    return false;
                }
                if ( dataObject.speed_ != speed_ )
                {
                    return false;
                }
                if ( dataObject.course_ != course_ )
                {
                    return false;
                }
                if ( dataObject.heading_ != heading_ )
                {
                    return false;
                }
                if ( dataObject.enterLatitude_ != enterLatitude_ )
                {
                    return false;
                }
                if ( dataObject.enterLongitude_ != enterLongitude_ )
                {
                    return false;
                }
                if ( dataObject.leaveLatitude_ != leaveLatitude_ )
                {
                    return false;
                }
                if ( dataObject.leaveLongitude_ != leaveLongitude_ )
                {
                    return false;
                }
                return true;
            }
            return false;
        }
        Int64 RowVersion( ) const
        {
            return rowVersion_;
        }
        void SetRowVersion( const Int64& rowVersion )
        {
            rowVersion_ = rowVersion;
        }
        const Guid& Track( ) const
        {
            return track_;
        }
        void SetTrack( const Guid& track )
        {
            track_ = track;
        }
        const Guid& Zone( ) const
        {
            return zone_;
        }
        void SetZone( const Guid& zone )
        {
            zone_ = zone;
        }
        const Guid& RadarTrack( ) const
        {
            return radarTrack_;
        }
        void SetRadarTrack( const Guid& radarTrack )
        {
            radarTrack_ = radarTrack;
        }
        const DateTime& Timestamp( ) const
        {
            return timestamp_;
        }
        void SetTimestamp( const DateTime& timestamp )
        {
            timestamp_ = timestamp;
        }
        double Latitude( ) const
        {
            return latitude_;
        }
        void SetLatitude( double latitude )
        {
            latitude_ = latitude;
        }
        double Longitude( ) const
        {
            return longitude_;
        }
        void SetLongitude( double longitude )
        {
            longitude_ = longitude;
        }
        double Speed( ) const
        {
            return speed_;
        }
        void SetSpeed( double speed )
        {
            speed_ = speed;
        }
        const DBDouble& Course( ) const
        {
            return course_;
        }
        void SetCourse( const DBDouble& course )
        {
            course_ = course;
        }
        const DBDouble& Heading( ) const
        {
            return heading_;
        }
        void SetHeading( const DBDouble& heading )
        {
            heading_ = heading;
        }
        double EnterLatitude( ) const
        {
            return enterLatitude_;
        }
        void SetEnterLatitude( double enterLatitude )
        {
            enterLatitude_ = enterLatitude;
        }
        double EnterLongitude( ) const
        {
            return enterLongitude_;
        }
        void SetEnterLongitude( double enterLongitude )
        {
            enterLongitude_ = enterLongitude;
        }
        const DBDouble& LeaveLatitude( ) const
        {
            return leaveLatitude_;
        }
        void SetLeaveLatitude( const DBDouble& leaveLatitude )
        {
            leaveLatitude_ = leaveLatitude;
        }
        const DBDouble& LeaveLongitude( ) const
        {
            return leaveLongitude_;
        }
        void SetLeaveLongitude( const DBDouble& leaveLongitude )
        {
            leaveLongitude_ = leaveLongitude;
        }
    };
    template<IO::StreamReader StreamT>
    std::shared_ptr<BaseData<Kind, Guid>> ReadDataFrom( IO::BinaryReader<StreamT>& source )
    {
        auto kind = source.Read<Kind>( );
        auto newObject = DataFactory( kind );
        switch ( kind )
        {
            case Kind::AircraftType:
                static_cast<AircraftTypeObject&>(*newObject).ReadFrom( source );
                break;
            case Kind::AisDeviceCommand:
                static_cast<AisDeviceCommandObject&>(*newObject).ReadFrom( source );
                break;
            case Kind::AisDeviceCommandReply:
                static_cast<AisDeviceCommandReplyObject&>(*newObject).ReadFrom( source );
                break;
            case Kind::AisDeviceConfiguration:
                static_cast<AisDeviceConfigurationObject&>(*newObject).ReadFrom( source );
                break;
            case Kind::AisDeviceRawMessage:
                static_cast<AisDeviceRawMessageObject&>(*newObject).ReadFrom( source );
                break;
            case Kind::AisDeviceRawSentence:
                static_cast<AisDeviceRawSentenceObject&>(*newObject).ReadFrom( source );
                break;
            case Kind::AidToNavigationReportMessage:
                static_cast<AidToNavigationReportMessageObject&>(*newObject).ReadFrom( source );
                break;
            case Kind::AisAddressedSafetyRelatedMessage:
                static_cast<AisAddressedSafetyRelatedMessageObject&>(*newObject).ReadFrom( source );
                break;
            case Kind::AisBaseStationReportMessage:
                static_cast<AisBaseStationReportMessageObject&>(*newObject).ReadFrom( source );
                break;
            case Kind::AisBinaryAcknowledgeMessage:
                static_cast<AisBinaryAcknowledgeMessageObject&>(*newObject).ReadFrom( source );
                break;
            case Kind::AisBinaryAddressedMessage:
                static_cast<AisBinaryAddressedMessageObject&>(*newObject).ReadFrom( source );
                break;
            case Kind::AisBinaryBroadcastMessage:
                static_cast<AisBinaryBroadcastMessageObject&>(*newObject).ReadFrom( source );
                break;
            case Kind::AisDataLinkManagementMessage:
                static_cast<AisDataLinkManagementMessageObject&>(*newObject).ReadFrom( source );
                break;
            case Kind::AisExtendedClassBCsPositionReportMessage:
                static_cast<AisExtendedClassBCsPositionReportMessageObject&>(*newObject).ReadFrom( source );
                break;
            case Kind::AisInterrogationMessage:
                static_cast<AisInterrogationMessageObject&>(*newObject).ReadFrom( source );
                break;
            case Kind::AisPositionReportClassAAssignedScheduleMessage:
                static_cast<AisPositionReportClassAAssignedScheduleMessageObject&>(*newObject).ReadFrom( source );
                break;
            case Kind::AisPositionReportClassAMessage:
                static_cast<AisPositionReportClassAMessageObject&>(*newObject).ReadFrom( source );
                break;
            case Kind::AisPositionReportClassAResponseToInterrogationMessage:
                static_cast<AisPositionReportClassAResponseToInterrogationMessageObject&>(*newObject).ReadFrom( source );
                break;
            case Kind::AisPositionReportForLongRangeApplicationsMessage:
                static_cast<AisPositionReportForLongRangeApplicationsMessageObject&>(*newObject).ReadFrom( source );
                break;
            case Kind::AisSafetyRelatedAcknowledgmentMessage:
                static_cast<AisSafetyRelatedAcknowledgmentMessageObject&>(*newObject).ReadFrom( source );
                break;
            case Kind::AisStandardClassBCsPositionReportMessage:
                static_cast<AisStandardClassBCsPositionReportMessageObject&>(*newObject).ReadFrom( source );
                break;
            case Kind::AisStandardSarAircraftPositionReportMessage:
                static_cast<AisStandardSarAircraftPositionReportMessageObject&>(*newObject).ReadFrom( source );
                break;
            case Kind::AisStaticAndVoyageRelatedDataMessage:
                static_cast<AisStaticAndVoyageRelatedDataMessageObject&>(*newObject).ReadFrom( source );
                break;
            case Kind::AisStaticDataReportMessage:
                static_cast<AisStaticDataReportMessageObject&>(*newObject).ReadFrom( source );
                break;
            case Kind::AisStaticDataReportPartAMessage:
                static_cast<AisStaticDataReportPartAMessageObject&>(*newObject).ReadFrom( source );
                break;
            case Kind::AisStaticDataReportPartBMessage:
                static_cast<AisStaticDataReportPartBMessageObject&>(*newObject).ReadFrom( source );
                break;
            case Kind::AisUtcAndDateInquiryMessage:
                static_cast<AisUtcAndDateInquiryMessageObject&>(*newObject).ReadFrom( source );
                break;
            case Kind::AisUtcAndDateResponseMessage:
                static_cast<AisUtcAndDateResponseMessageObject&>(*newObject).ReadFrom( source );
                break;
            case Kind::AlarmStateChange:
                static_cast<AlarmStateChangeObject&>(*newObject).ReadFrom( source );
                break;
            case Kind::BaseStationType:
                static_cast<BaseStationTypeObject&>(*newObject).ReadFrom( source );
                break;
            case Kind::BinaryTimeseriesValue:
                static_cast<BinaryTimeseriesValueObject&>(*newObject).ReadFrom( source );
                break;
            case Kind::Bookmark:
                static_cast<BookmarkObject&>(*newObject).ReadFrom( source );
                break;
            case Kind::BooleanTimeseriesValue:
                static_cast<BooleanTimeseriesValueObject&>(*newObject).ReadFrom( source );
                break;
            case Kind::ByteTimeseriesValue:
                static_cast<ByteTimeseriesValueObject&>(*newObject).ReadFrom( source );
                break;
            case Kind::CameraCommand:
                static_cast<CameraCommandObject&>(*newObject).ReadFrom( source );
                break;
            case Kind::CameraCommandAbsoluteMove:
                static_cast<CameraCommandAbsoluteMoveObject&>(*newObject).ReadFrom( source );
                break;
            case Kind::CameraCommandAdjustPanTiltZoom:
                static_cast<CameraCommandAdjustPanTiltZoomObject&>(*newObject).ReadFrom( source );
                break;
            case Kind::CameraCommandContinuousMove:
                static_cast<CameraCommandContinuousMoveObject&>(*newObject).ReadFrom( source );
                break;
            case Kind::CameraCommandGeoMove:
                static_cast<CameraCommandGeoMoveObject&>(*newObject).ReadFrom( source );
                break;
            case Kind::CameraCommandRelativeMove:
                static_cast<CameraCommandRelativeMoveObject&>(*newObject).ReadFrom( source );
                break;
            case Kind::CameraCommandReleasePTZOwnership:
                static_cast<CameraCommandReleasePTZOwnershipObject&>(*newObject).ReadFrom( source );
                break;
            case Kind::CameraCommandRequestPTZOwnership:
                static_cast<CameraCommandRequestPTZOwnershipObject&>(*newObject).ReadFrom( source );
                break;
            case Kind::CameraCommandSetAutoFocus:
                static_cast<CameraCommandSetAutoFocusObject&>(*newObject).ReadFrom( source );
                break;
            case Kind::CameraCommandSetBlackAndWhite:
                static_cast<CameraCommandSetBlackAndWhiteObject&>(*newObject).ReadFrom( source );
                break;
            case Kind::CameraCommandSetFollowed:
                static_cast<CameraCommandSetFollowedObject&>(*newObject).ReadFrom( source );
                break;
            case Kind::CameraCommandSetInfraRedLamp:
                static_cast<CameraCommandSetInfraRedLampObject&>(*newObject).ReadFrom( source );
                break;
            case Kind::CameraCommandSetWasher:
                static_cast<CameraCommandSetWasherObject&>(*newObject).ReadFrom( source );
                break;
            case Kind::CameraCommandSetWiper:
                static_cast<CameraCommandSetWiperObject&>(*newObject).ReadFrom( source );
                break;
            case Kind::CameraCommandStop:
                static_cast<CameraCommandStopObject&>(*newObject).ReadFrom( source );
                break;
            case Kind::CameraCommandReply:
                static_cast<CameraCommandReplyObject&>(*newObject).ReadFrom( source );
                break;
            case Kind::CameraConfiguration:
                static_cast<CameraConfigurationObject&>(*newObject).ReadFrom( source );
                break;
            case Kind::CameraPanCalibration:
                static_cast<CameraPanCalibrationObject&>(*newObject).ReadFrom( source );
                break;
            case Kind::CameraPanCalibrationValue:
                static_cast<CameraPanCalibrationValueObject&>(*newObject).ReadFrom( source );
                break;
            case Kind::CameraStatus:
                static_cast<CameraStatusObject&>(*newObject).ReadFrom( source );
                break;
            case Kind::CameraTiltCalibration:
                static_cast<CameraTiltCalibrationObject&>(*newObject).ReadFrom( source );
                break;
            case Kind::CameraTiltCalibrationValue:
                static_cast<CameraTiltCalibrationValueObject&>(*newObject).ReadFrom( source );
                break;
            case Kind::CameraZoomCalibration:
                static_cast<CameraZoomCalibrationObject&>(*newObject).ReadFrom( source );
                break;
            case Kind::CameraZoomCalibrationValue:
                static_cast<CameraZoomCalibrationValueObject&>(*newObject).ReadFrom( source );
                break;
            case Kind::Catalog:
                static_cast<CatalogObject&>(*newObject).ReadFrom( source );
                break;
            case Kind::Element:
                static_cast<ElementObject&>(*newObject).ReadFrom( source );
                break;
            case Kind::CollectionInfo:
                static_cast<CollectionInfoObject&>(*newObject).ReadFrom( source );
                break;
            case Kind::Country:
                static_cast<CountryObject&>(*newObject).ReadFrom( source );
                break;
            case Kind::CursorInfo:
                static_cast<CursorInfoObject&>(*newObject).ReadFrom( source );
                break;
            case Kind::DateTimeTimeseriesValue:
                static_cast<DateTimeTimeseriesValueObject&>(*newObject).ReadFrom( source );
                break;
            case Kind::DeviceHost:
                static_cast<DeviceHostObject&>(*newObject).ReadFrom( source );
                break;
            case Kind::DeviceHostConfiguration:
                static_cast<DeviceHostConfigurationObject&>(*newObject).ReadFrom( source );
                break;
            case Kind::DoubleTimeseriesValue:
                static_cast<DoubleTimeseriesValueObject&>(*newObject).ReadFrom( source );
                break;
            case Kind::FacilityType:
                static_cast<FacilityTypeObject&>(*newObject).ReadFrom( source );
                break;
            case Kind::GeoPosition2DTimeseriesValue:
                static_cast<GeoPosition2DTimeseriesValueObject&>(*newObject).ReadFrom( source );
                break;
            case Kind::GeoPosition3DTimeseriesValue:
                static_cast<GeoPosition3DTimeseriesValueObject&>(*newObject).ReadFrom( source );
                break;
            case Kind::GNSSDeviceCommand:
                static_cast<GNSSDeviceCommandObject&>(*newObject).ReadFrom( source );
                break;
            case Kind::GNSSDeviceCommandReply:
                static_cast<GNSSDeviceCommandReplyObject&>(*newObject).ReadFrom( source );
                break;
            case Kind::GNSSDeviceConfiguration:
                static_cast<GNSSDeviceConfigurationObject&>(*newObject).ReadFrom( source );
                break;
            case Kind::GuidTimeseriesValue:
                static_cast<GuidTimeseriesValueObject&>(*newObject).ReadFrom( source );
                break;
            case Kind::GyroDeviceCommand:
                static_cast<GyroDeviceCommandObject&>(*newObject).ReadFrom( source );
                break;
            case Kind::GyroDeviceCommandReply:
                static_cast<GyroDeviceCommandReplyObject&>(*newObject).ReadFrom( source );
                break;
            case Kind::GyroDeviceConfiguration:
                static_cast<GyroDeviceConfigurationObject&>(*newObject).ReadFrom( source );
                break;
            case Kind::Callsign:
                static_cast<CallsignObject&>(*newObject).ReadFrom( source );
                break;
            case Kind::InternationalMaritimeOrganizationNumber:
                static_cast<InternationalMaritimeOrganizationNumberObject&>(*newObject).ReadFrom( source );
                break;
            case Kind::MaritimeMobileServiceIdentity:
                static_cast<MaritimeMobileServiceIdentityObject&>(*newObject).ReadFrom( source );
                break;
            case Kind::Name:
                static_cast<NameObject&>(*newObject).ReadFrom( source );
                break;
            case Kind::Int16TimeseriesValue:
                static_cast<Int16TimeseriesValueObject&>(*newObject).ReadFrom( source );
                break;
            case Kind::Int32TimeseriesValue:
                static_cast<Int32TimeseriesValueObject&>(*newObject).ReadFrom( source );
                break;
            case Kind::Int64TimeseriesValue:
                static_cast<Int64TimeseriesValueObject&>(*newObject).ReadFrom( source );
                break;
            case Kind::BaseStation:
                static_cast<BaseStationObject&>(*newObject).ReadFrom( source );
                break;
            case Kind::CameraDevice:
                static_cast<CameraDeviceObject&>(*newObject).ReadFrom( source );
                break;
            case Kind::GNSSDevice:
                static_cast<GNSSDeviceObject&>(*newObject).ReadFrom( source );
                break;
            case Kind::GyroDevice:
                static_cast<GyroDeviceObject&>(*newObject).ReadFrom( source );
                break;
            case Kind::LineInputDevice:
                static_cast<LineInputDeviceObject&>(*newObject).ReadFrom( source );
                break;
            case Kind::OilSpillDetectorDevice:
                static_cast<OilSpillDetectorDeviceObject&>(*newObject).ReadFrom( source );
                break;
            case Kind::RadioDevice:
                static_cast<RadioDeviceObject&>(*newObject).ReadFrom( source );
                break;
            case Kind::RadomeDevice:
                static_cast<RadomeDeviceObject&>(*newObject).ReadFrom( source );
                break;
            case Kind::AisDevice:
                static_cast<AisDeviceObject&>(*newObject).ReadFrom( source );
                break;
            case Kind::RadarDevice:
                static_cast<RadarDeviceObject&>(*newObject).ReadFrom( source );
                break;
            case Kind::WeatherStationDevice:
                static_cast<WeatherStationDeviceObject&>(*newObject).ReadFrom( source );
                break;
            case Kind::Facility:
                static_cast<FacilityObject&>(*newObject).ReadFrom( source );
                break;
            case Kind::Aircraft:
                static_cast<AircraftObject&>(*newObject).ReadFrom( source );
                break;
            case Kind::AisAidToNavigation:
                static_cast<AisAidToNavigationObject&>(*newObject).ReadFrom( source );
                break;
            case Kind::Vehicle:
                static_cast<VehicleObject&>(*newObject).ReadFrom( source );
                break;
            case Kind::Vessel:
                static_cast<VesselObject&>(*newObject).ReadFrom( source );
                break;
            case Kind::ItemIdentityLink:
                static_cast<ItemIdentityLinkObject&>(*newObject).ReadFrom( source );
                break;
            case Kind::ItemParentChildLink:
                static_cast<ItemParentChildLinkObject&>(*newObject).ReadFrom( source );
                break;
            case Kind::LineInputDeviceCommand:
                static_cast<LineInputDeviceCommandObject&>(*newObject).ReadFrom( source );
                break;
            case Kind::LineInputDeviceCommandReply:
                static_cast<LineInputDeviceCommandReplyObject&>(*newObject).ReadFrom( source );
                break;
            case Kind::LineInputDeviceConfiguration:
                static_cast<LineInputDeviceConfigurationObject&>(*newObject).ReadFrom( source );
                break;
            case Kind::LineInputMessageRouting:
                static_cast<LineInputMessageRoutingObject&>(*newObject).ReadFrom( source );
                break;
            case Kind::LineInputMessageRoutingDestination:
                static_cast<LineInputMessageRoutingDestinationObject&>(*newObject).ReadFrom( source );
                break;
            case Kind::LineInputWhiteListEntry:
                static_cast<LineInputWhiteListEntryObject&>(*newObject).ReadFrom( source );
                break;
            case Kind::LogApplication:
                static_cast<LogApplicationObject&>(*newObject).ReadFrom( source );
                break;
            case Kind::LogApplicationConfiguration:
                static_cast<LogApplicationConfigurationObject&>(*newObject).ReadFrom( source );
                break;
            case Kind::LogHost:
                static_cast<LogHostObject&>(*newObject).ReadFrom( source );
                break;
            case Kind::LogHostConfiguration:
                static_cast<LogHostConfigurationObject&>(*newObject).ReadFrom( source );
                break;
            case Kind::LogLocation:
                static_cast<LogLocationObject&>(*newObject).ReadFrom( source );
                break;
            case Kind::LogProcess:
                static_cast<LogProcessObject&>(*newObject).ReadFrom( source );
                break;
            case Kind::LogRecord:
                static_cast<LogRecordObject&>(*newObject).ReadFrom( source );
                break;
            case Kind::LogThread:
                static_cast<LogThreadObject&>(*newObject).ReadFrom( source );
                break;
            case Kind::LogTraceEntry:
                static_cast<LogTraceEntryObject&>(*newObject).ReadFrom( source );
                break;
            case Kind::MapElement:
                static_cast<MapElementObject&>(*newObject).ReadFrom( source );
                break;
            case Kind::MapInfo:
                static_cast<MapInfoObject&>(*newObject).ReadFrom( source );
                break;
            case Kind::MapServiceOptions:
                static_cast<MapServiceOptionsObject&>(*newObject).ReadFrom( source );
                break;
            case Kind::MaritimeIdentificationDigits:
                static_cast<MaritimeIdentificationDigitsObject&>(*newObject).ReadFrom( source );
                break;
            case Kind::MediaProxySession:
                static_cast<MediaProxySessionObject&>(*newObject).ReadFrom( source );
                break;
            case Kind::MediaProxySessionFile:
                static_cast<MediaProxySessionFileObject&>(*newObject).ReadFrom( source );
                break;
            case Kind::MediaProxySessionOptions:
                static_cast<MediaProxySessionOptionsObject&>(*newObject).ReadFrom( source );
                break;
            case Kind::MediaService:
                static_cast<MediaServiceObject&>(*newObject).ReadFrom( source );
                break;
            case Kind::MediaServiceOptions:
                static_cast<MediaServiceOptionsObject&>(*newObject).ReadFrom( source );
                break;
            case Kind::ElementType:
                static_cast<ElementTypeObject&>(*newObject).ReadFrom( source );
                break;
            case Kind::Namespace:
                static_cast<NamespaceObject&>(*newObject).ReadFrom( source );
                break;
            case Kind::OilSpill:
                static_cast<OilSpillObject&>(*newObject).ReadFrom( source );
                break;
            case Kind::OilSpillDetectorCommand:
                static_cast<OilSpillDetectorCommandObject&>(*newObject).ReadFrom( source );
                break;
            case Kind::OilSpillDetectorCommandReply:
                static_cast<OilSpillDetectorCommandReplyObject&>(*newObject).ReadFrom( source );
                break;
            case Kind::OilSpillDetectorConfiguration:
                static_cast<OilSpillDetectorConfigurationObject&>(*newObject).ReadFrom( source );
                break;
            case Kind::Position2DTimeseriesValue:
                static_cast<Position2DTimeseriesValueObject&>(*newObject).ReadFrom( source );
                break;
            case Kind::Position3DTimeseriesValue:
                static_cast<Position3DTimeseriesValueObject&>(*newObject).ReadFrom( source );
                break;
            case Kind::ProcessTrackValueResult:
                static_cast<ProcessTrackValueResultObject&>(*newObject).ReadFrom( source );
                break;
            case Kind::BinaryProperty:
                static_cast<BinaryPropertyObject&>(*newObject).ReadFrom( source );
                break;
            case Kind::BooleanProperty:
                static_cast<BooleanPropertyObject&>(*newObject).ReadFrom( source );
                break;
            case Kind::ByteProperty:
                static_cast<BytePropertyObject&>(*newObject).ReadFrom( source );
                break;
            case Kind::DateTimeProperty:
                static_cast<DateTimePropertyObject&>(*newObject).ReadFrom( source );
                break;
            case Kind::DoubleProperty:
                static_cast<DoublePropertyObject&>(*newObject).ReadFrom( source );
                break;
            case Kind::GuidProperty:
                static_cast<GuidPropertyObject&>(*newObject).ReadFrom( source );
                break;
            case Kind::Int16Property:
                static_cast<Int16PropertyObject&>(*newObject).ReadFrom( source );
                break;
            case Kind::Int32Property:
                static_cast<Int32PropertyObject&>(*newObject).ReadFrom( source );
                break;
            case Kind::Int64Property:
                static_cast<Int64PropertyObject&>(*newObject).ReadFrom( source );
                break;
            case Kind::ReferenceProperty:
                static_cast<ReferencePropertyObject&>(*newObject).ReadFrom( source );
                break;
            case Kind::SByteProperty:
                static_cast<SBytePropertyObject&>(*newObject).ReadFrom( source );
                break;
            case Kind::SingleProperty:
                static_cast<SinglePropertyObject&>(*newObject).ReadFrom( source );
                break;
            case Kind::StringProperty:
                static_cast<StringPropertyObject&>(*newObject).ReadFrom( source );
                break;
            case Kind::BinaryTimeseriesProperty:
                static_cast<BinaryTimeseriesPropertyObject&>(*newObject).ReadFrom( source );
                break;
            case Kind::BooleanTimeseriesProperty:
                static_cast<BooleanTimeseriesPropertyObject&>(*newObject).ReadFrom( source );
                break;
            case Kind::ByteTimeseriesProperty:
                static_cast<ByteTimeseriesPropertyObject&>(*newObject).ReadFrom( source );
                break;
            case Kind::DateTimeTimeseriesProperty:
                static_cast<DateTimeTimeseriesPropertyObject&>(*newObject).ReadFrom( source );
                break;
            case Kind::DoubleTimeseriesProperty:
                static_cast<DoubleTimeseriesPropertyObject&>(*newObject).ReadFrom( source );
                break;
            case Kind::GuidTimeseriesProperty:
                static_cast<GuidTimeseriesPropertyObject&>(*newObject).ReadFrom( source );
                break;
            case Kind::Int16TimeseriesProperty:
                static_cast<Int16TimeseriesPropertyObject&>(*newObject).ReadFrom( source );
                break;
            case Kind::Int32TimeseriesProperty:
                static_cast<Int32TimeseriesPropertyObject&>(*newObject).ReadFrom( source );
                break;
            case Kind::Int64TimeseriesProperty:
                static_cast<Int64TimeseriesPropertyObject&>(*newObject).ReadFrom( source );
                break;
            case Kind::ReferenceTimeseriesProperty:
                static_cast<ReferenceTimeseriesPropertyObject&>(*newObject).ReadFrom( source );
                break;
            case Kind::SByteTimeseriesProperty:
                static_cast<SByteTimeseriesPropertyObject&>(*newObject).ReadFrom( source );
                break;
            case Kind::SingleTimeseriesProperty:
                static_cast<SingleTimeseriesPropertyObject&>(*newObject).ReadFrom( source );
                break;
            case Kind::StringTimeseriesProperty:
                static_cast<StringTimeseriesPropertyObject&>(*newObject).ReadFrom( source );
                break;
            case Kind::TimeSpanTimeseriesProperty:
                static_cast<TimeSpanTimeseriesPropertyObject&>(*newObject).ReadFrom( source );
                break;
            case Kind::UInt16TimeseriesProperty:
                static_cast<UInt16TimeseriesPropertyObject&>(*newObject).ReadFrom( source );
                break;
            case Kind::UInt32TimeseriesProperty:
                static_cast<UInt32TimeseriesPropertyObject&>(*newObject).ReadFrom( source );
                break;
            case Kind::UInt64TimeseriesProperty:
                static_cast<UInt64TimeseriesPropertyObject&>(*newObject).ReadFrom( source );
                break;
            case Kind::TimeSpanProperty:
                static_cast<TimeSpanPropertyObject&>(*newObject).ReadFrom( source );
                break;
            case Kind::UInt16Property:
                static_cast<UInt16PropertyObject&>(*newObject).ReadFrom( source );
                break;
            case Kind::UInt32Property:
                static_cast<UInt32PropertyObject&>(*newObject).ReadFrom( source );
                break;
            case Kind::UInt64Property:
                static_cast<UInt64PropertyObject&>(*newObject).ReadFrom( source );
                break;
            case Kind::BinaryPropertyDefinition:
                static_cast<BinaryPropertyDefinitionObject&>(*newObject).ReadFrom( source );
                break;
            case Kind::BooleanPropertyDefinition:
                static_cast<BooleanPropertyDefinitionObject&>(*newObject).ReadFrom( source );
                break;
            case Kind::BytePropertyDefinition:
                static_cast<BytePropertyDefinitionObject&>(*newObject).ReadFrom( source );
                break;
            case Kind::DateTimePropertyDefinition:
                static_cast<DateTimePropertyDefinitionObject&>(*newObject).ReadFrom( source );
                break;
            case Kind::DoublePropertyDefinition:
                static_cast<DoublePropertyDefinitionObject&>(*newObject).ReadFrom( source );
                break;
            case Kind::GuidPropertyDefinition:
                static_cast<GuidPropertyDefinitionObject&>(*newObject).ReadFrom( source );
                break;
            case Kind::Int16PropertyDefinition:
                static_cast<Int16PropertyDefinitionObject&>(*newObject).ReadFrom( source );
                break;
            case Kind::Int32PropertyDefinition:
                static_cast<Int32PropertyDefinitionObject&>(*newObject).ReadFrom( source );
                break;
            case Kind::Int64PropertyDefinition:
                static_cast<Int64PropertyDefinitionObject&>(*newObject).ReadFrom( source );
                break;
            case Kind::ReferencePropertyDefinition:
                static_cast<ReferencePropertyDefinitionObject&>(*newObject).ReadFrom( source );
                break;
            case Kind::SBytePropertyDefinition:
                static_cast<SBytePropertyDefinitionObject&>(*newObject).ReadFrom( source );
                break;
            case Kind::SinglePropertyDefinition:
                static_cast<SinglePropertyDefinitionObject&>(*newObject).ReadFrom( source );
                break;
            case Kind::StringPropertyDefinition:
                static_cast<StringPropertyDefinitionObject&>(*newObject).ReadFrom( source );
                break;
            case Kind::BinaryTimeseriesPropertyDefinition:
                static_cast<BinaryTimeseriesPropertyDefinitionObject&>(*newObject).ReadFrom( source );
                break;
            case Kind::BooleanTimeseriesPropertyDefinition:
                static_cast<BooleanTimeseriesPropertyDefinitionObject&>(*newObject).ReadFrom( source );
                break;
            case Kind::ByteTimeseriesPropertyDefinition:
                static_cast<ByteTimeseriesPropertyDefinitionObject&>(*newObject).ReadFrom( source );
                break;
            case Kind::DateTimeTimeseriesPropertyDefinition:
                static_cast<DateTimeTimeseriesPropertyDefinitionObject&>(*newObject).ReadFrom( source );
                break;
            case Kind::DoubleTimeseriesPropertyDefinition:
                static_cast<DoubleTimeseriesPropertyDefinitionObject&>(*newObject).ReadFrom( source );
                break;
            case Kind::GuidTimeseriesPropertyDefinition:
                static_cast<GuidTimeseriesPropertyDefinitionObject&>(*newObject).ReadFrom( source );
                break;
            case Kind::Int16TimeseriesPropertyDefinition:
                static_cast<Int16TimeseriesPropertyDefinitionObject&>(*newObject).ReadFrom( source );
                break;
            case Kind::Int32TimeseriesPropertyDefinition:
                static_cast<Int32TimeseriesPropertyDefinitionObject&>(*newObject).ReadFrom( source );
                break;
            case Kind::Int64TimeseriesPropertyDefinition:
                static_cast<Int64TimeseriesPropertyDefinitionObject&>(*newObject).ReadFrom( source );
                break;
            case Kind::ReferenceTimeseriesPropertyDefinition:
                static_cast<ReferenceTimeseriesPropertyDefinitionObject&>(*newObject).ReadFrom( source );
                break;
            case Kind::SByteTimeseriesPropertyDefinition:
                static_cast<SByteTimeseriesPropertyDefinitionObject&>(*newObject).ReadFrom( source );
                break;
            case Kind::SingleTimeseriesPropertyDefinition:
                static_cast<SingleTimeseriesPropertyDefinitionObject&>(*newObject).ReadFrom( source );
                break;
            case Kind::StringTimeseriesPropertyDefinition:
                static_cast<StringTimeseriesPropertyDefinitionObject&>(*newObject).ReadFrom( source );
                break;
            case Kind::TimeSpanTimeseriesPropertyDefinition:
                static_cast<TimeSpanTimeseriesPropertyDefinitionObject&>(*newObject).ReadFrom( source );
                break;
            case Kind::UInt16TimeseriesPropertyDefinition:
                static_cast<UInt16TimeseriesPropertyDefinitionObject&>(*newObject).ReadFrom( source );
                break;
            case Kind::UInt32TimeseriesPropertyDefinition:
                static_cast<UInt32TimeseriesPropertyDefinitionObject&>(*newObject).ReadFrom( source );
                break;
            case Kind::UInt64TimeseriesPropertyDefinition:
                static_cast<UInt64TimeseriesPropertyDefinitionObject&>(*newObject).ReadFrom( source );
                break;
            case Kind::TimeSpanPropertyDefinition:
                static_cast<TimeSpanPropertyDefinitionObject&>(*newObject).ReadFrom( source );
                break;
            case Kind::UInt16PropertyDefinition:
                static_cast<UInt16PropertyDefinitionObject&>(*newObject).ReadFrom( source );
                break;
            case Kind::UInt32PropertyDefinition:
                static_cast<UInt32PropertyDefinitionObject&>(*newObject).ReadFrom( source );
                break;
            case Kind::UInt64PropertyDefinition:
                static_cast<UInt64PropertyDefinitionObject&>(*newObject).ReadFrom( source );
                break;
            case Kind::RadarAlarmStatus:
                static_cast<RadarAlarmStatusObject&>(*newObject).ReadFrom( source );
                break;
            case Kind::RadarCommand:
                static_cast<RadarCommandObject&>(*newObject).ReadFrom( source );
                break;
            case Kind::RadarCommandGetStatus:
                static_cast<RadarCommandGetStatusObject&>(*newObject).ReadFrom( source );
                break;
            case Kind::RadarCommandReply:
                static_cast<RadarCommandReplyObject&>(*newObject).ReadFrom( source );
                break;
            case Kind::RadarCommandReplyGetStatus:
                static_cast<RadarCommandReplyGetStatusObject&>(*newObject).ReadFrom( source );
                break;
            case Kind::RadarConfiguration:
                static_cast<RadarConfigurationObject&>(*newObject).ReadFrom( source );
                break;
            case Kind::RadarImage:
                static_cast<RadarImageObject&>(*newObject).ReadFrom( source );
                break;
            case Kind::RadarRawTrackTable:
                static_cast<RadarRawTrackTableObject&>(*newObject).ReadFrom( source );
                break;
            case Kind::RadarStatus:
                static_cast<RadarStatusObject&>(*newObject).ReadFrom( source );
                break;
            case Kind::RadioCommand:
                static_cast<RadioCommandObject&>(*newObject).ReadFrom( source );
                break;
            case Kind::RadioCommandReply:
                static_cast<RadioCommandReplyObject&>(*newObject).ReadFrom( source );
                break;
            case Kind::RadioConfiguration:
                static_cast<RadioConfigurationObject&>(*newObject).ReadFrom( source );
                break;
            case Kind::RadomeCommand:
                static_cast<RadomeCommandObject&>(*newObject).ReadFrom( source );
                break;
            case Kind::RadomeCommandReply:
                static_cast<RadomeCommandReplyObject&>(*newObject).ReadFrom( source );
                break;
            case Kind::RadomeConfiguration:
                static_cast<RadomeConfigurationObject&>(*newObject).ReadFrom( source );
                break;
            case Kind::ReferenceTimeseriesValue:
                static_cast<ReferenceTimeseriesValueObject&>(*newObject).ReadFrom( source );
                break;
            case Kind::SByteTimeseriesValue:
                static_cast<SByteTimeseriesValueObject&>(*newObject).ReadFrom( source );
                break;
            case Kind::SecurityDomain:
                static_cast<SecurityDomainObject&>(*newObject).ReadFrom( source );
                break;
            case Kind::SecurityLogin:
                static_cast<SecurityLoginObject&>(*newObject).ReadFrom( source );
                break;
            case Kind::SecurityRole:
                static_cast<SecurityRoleObject&>(*newObject).ReadFrom( source );
                break;
            case Kind::SecurityIdentifierRoleLink:
                static_cast<SecurityIdentifierRoleLinkObject&>(*newObject).ReadFrom( source );
                break;
            case Kind::SecurityLoginSession:
                static_cast<SecurityLoginSessionObject&>(*newObject).ReadFrom( source );
                break;
            case Kind::SecurityPermission:
                static_cast<SecurityPermissionObject&>(*newObject).ReadFrom( source );
                break;
            case Kind::SingleTimeseriesValue:
                static_cast<SingleTimeseriesValueObject&>(*newObject).ReadFrom( source );
                break;
            case Kind::StringTimeseriesValue:
                static_cast<StringTimeseriesValueObject&>(*newObject).ReadFrom( source );
                break;
            case Kind::BinaryTimeseries:
                static_cast<BinaryTimeseriesObject&>(*newObject).ReadFrom( source );
                break;
            case Kind::BooleanTimeseries:
                static_cast<BooleanTimeseriesObject&>(*newObject).ReadFrom( source );
                break;
            case Kind::AisAidToNavigationOffPositionTimeseries:
                static_cast<AisAidToNavigationOffPositionTimeseriesObject&>(*newObject).ReadFrom( source );
                break;
            case Kind::DeviceEnabledTimeseries:
                static_cast<DeviceEnabledTimeseriesObject&>(*newObject).ReadFrom( source );
                break;
            case Kind::RadarAutomaticSensitivityTimeControlTimeseries:
                static_cast<RadarAutomaticSensitivityTimeControlTimeseriesObject&>(*newObject).ReadFrom( source );
                break;
            case Kind::RadarBlankSector1Timeseries:
                static_cast<RadarBlankSector1TimeseriesObject&>(*newObject).ReadFrom( source );
                break;
            case Kind::RadarBlankSector2Timeseries:
                static_cast<RadarBlankSector2TimeseriesObject&>(*newObject).ReadFrom( source );
                break;
            case Kind::RadarEnableAutomaticFrequencyControlTimeseries:
                static_cast<RadarEnableAutomaticFrequencyControlTimeseriesObject&>(*newObject).ReadFrom( source );
                break;
            case Kind::RadarEnableFastTimeConstantTimeseries:
                static_cast<RadarEnableFastTimeConstantTimeseriesObject&>(*newObject).ReadFrom( source );
                break;
            case Kind::RadarEnableSensitivityTimeControlTimeseries:
                static_cast<RadarEnableSensitivityTimeControlTimeseriesObject&>(*newObject).ReadFrom( source );
                break;
            case Kind::RadarPowerOnTimeseries:
                static_cast<RadarPowerOnTimeseriesObject&>(*newObject).ReadFrom( source );
                break;
            case Kind::RadarSaveSettingsTimeseries:
                static_cast<RadarSaveSettingsTimeseriesObject&>(*newObject).ReadFrom( source );
                break;
            case Kind::RadarTrackingTimeseries:
                static_cast<RadarTrackingTimeseriesObject&>(*newObject).ReadFrom( source );
                break;
            case Kind::MediaProxySessionEnabledTimeseries:
                static_cast<MediaProxySessionEnabledTimeseriesObject&>(*newObject).ReadFrom( source );
                break;
            case Kind::MediaServiceEnabledTimeseries:
                static_cast<MediaServiceEnabledTimeseriesObject&>(*newObject).ReadFrom( source );
                break;
            case Kind::ByteTimeseries:
                static_cast<ByteTimeseriesObject&>(*newObject).ReadFrom( source );
                break;
            case Kind::DateTimeTimeseries:
                static_cast<DateTimeTimeseriesObject&>(*newObject).ReadFrom( source );
                break;
            case Kind::DoubleTimeseries:
                static_cast<DoubleTimeseriesObject&>(*newObject).ReadFrom( source );
                break;
            case Kind::GNSSAltitudeTimeseries:
                static_cast<GNSSAltitudeTimeseriesObject&>(*newObject).ReadFrom( source );
                break;
            case Kind::GNSSLatitudeTimeseries:
                static_cast<GNSSLatitudeTimeseriesObject&>(*newObject).ReadFrom( source );
                break;
            case Kind::GNSSLongitudeTimeseries:
                static_cast<GNSSLongitudeTimeseriesObject&>(*newObject).ReadFrom( source );
                break;
            case Kind::GyroCourseTimeseries:
                static_cast<GyroCourseTimeseriesObject&>(*newObject).ReadFrom( source );
                break;
            case Kind::GyroHeadingMagneticNorthTimeseries:
                static_cast<GyroHeadingMagneticNorthTimeseriesObject&>(*newObject).ReadFrom( source );
                break;
            case Kind::GyroHeadingTrueNorthTimeseries:
                static_cast<GyroHeadingTrueNorthTimeseriesObject&>(*newObject).ReadFrom( source );
                break;
            case Kind::GyroPitchTimeseries:
                static_cast<GyroPitchTimeseriesObject&>(*newObject).ReadFrom( source );
                break;
            case Kind::GyroRateOfTurnTimeseries:
                static_cast<GyroRateOfTurnTimeseriesObject&>(*newObject).ReadFrom( source );
                break;
            case Kind::GyroRollTimeseries:
                static_cast<GyroRollTimeseriesObject&>(*newObject).ReadFrom( source );
                break;
            case Kind::GyroSpeedTimeseries:
                static_cast<GyroSpeedTimeseriesObject&>(*newObject).ReadFrom( source );
                break;
            case Kind::RadarLatitudeTimeseries:
                static_cast<RadarLatitudeTimeseriesObject&>(*newObject).ReadFrom( source );
                break;
            case Kind::RadarLongitudeTimeseries:
                static_cast<RadarLongitudeTimeseriesObject&>(*newObject).ReadFrom( source );
                break;
            case Kind::RadomeDewPointTimeseries:
                static_cast<RadomeDewPointTimeseriesObject&>(*newObject).ReadFrom( source );
                break;
            case Kind::RadomePressureTimeseries:
                static_cast<RadomePressureTimeseriesObject&>(*newObject).ReadFrom( source );
                break;
            case Kind::RadomeTemperatureTimeseries:
                static_cast<RadomeTemperatureTimeseriesObject&>(*newObject).ReadFrom( source );
                break;
            case Kind::VesselDraughtTimeseries:
                static_cast<VesselDraughtTimeseriesObject&>(*newObject).ReadFrom( source );
                break;
            case Kind::ViewLatitudeTimeseries:
                static_cast<ViewLatitudeTimeseriesObject&>(*newObject).ReadFrom( source );
                break;
            case Kind::ViewLongitudeTimeseries:
                static_cast<ViewLongitudeTimeseriesObject&>(*newObject).ReadFrom( source );
                break;
            case Kind::ViewZoomLevelTimeseries:
                static_cast<ViewZoomLevelTimeseriesObject&>(*newObject).ReadFrom( source );
                break;
            case Kind::WeatherStationAbsoluteHumidityTimeseries:
                static_cast<WeatherStationAbsoluteHumidityTimeseriesObject&>(*newObject).ReadFrom( source );
                break;
            case Kind::WeatherStationAirTemperatureTimeseries:
                static_cast<WeatherStationAirTemperatureTimeseriesObject&>(*newObject).ReadFrom( source );
                break;
            case Kind::WeatherStationBarometricPressureTimeseries:
                static_cast<WeatherStationBarometricPressureTimeseriesObject&>(*newObject).ReadFrom( source );
                break;
            case Kind::WeatherStationDewPointTimeseries:
                static_cast<WeatherStationDewPointTimeseriesObject&>(*newObject).ReadFrom( source );
                break;
            case Kind::WeatherStationRelativeHumidityTimeseries:
                static_cast<WeatherStationRelativeHumidityTimeseriesObject&>(*newObject).ReadFrom( source );
                break;
            case Kind::WeatherStationWaterTemperatureTimeseries:
                static_cast<WeatherStationWaterTemperatureTimeseriesObject&>(*newObject).ReadFrom( source );
                break;
            case Kind::WeatherStationWindDirectionTimeseries:
                static_cast<WeatherStationWindDirectionTimeseriesObject&>(*newObject).ReadFrom( source );
                break;
            case Kind::WeatherStationWindSpeedTimeseries:
                static_cast<WeatherStationWindSpeedTimeseriesObject&>(*newObject).ReadFrom( source );
                break;
            case Kind::GeoPosition2DTimeseries:
                static_cast<GeoPosition2DTimeseriesObject&>(*newObject).ReadFrom( source );
                break;
            case Kind::AisAidToNavigationPositionTimeseries:
                static_cast<AisAidToNavigationPositionTimeseriesObject&>(*newObject).ReadFrom( source );
                break;
            case Kind::GeoPosition3DTimeseries:
                static_cast<GeoPosition3DTimeseriesObject&>(*newObject).ReadFrom( source );
                break;
            case Kind::GuidTimeseries:
                static_cast<GuidTimeseriesObject&>(*newObject).ReadFrom( source );
                break;
            case Kind::Int16Timeseries:
                static_cast<Int16TimeseriesObject&>(*newObject).ReadFrom( source );
                break;
            case Kind::Int32Timeseries:
                static_cast<Int32TimeseriesObject&>(*newObject).ReadFrom( source );
                break;
            case Kind::RadarAzimuthOffsetTimeseries:
                static_cast<RadarAzimuthOffsetTimeseriesObject&>(*newObject).ReadFrom( source );
                break;
            case Kind::RadarFastTimeConstantLevelTimeseries:
                static_cast<RadarFastTimeConstantLevelTimeseriesObject&>(*newObject).ReadFrom( source );
                break;
            case Kind::RadarFastTimeConstantModeTimeseries:
                static_cast<RadarFastTimeConstantModeTimeseriesObject&>(*newObject).ReadFrom( source );
                break;
            case Kind::RadarPulseTimeseries:
                static_cast<RadarPulseTimeseriesObject&>(*newObject).ReadFrom( source );
                break;
            case Kind::RadarSector1EndTimeseries:
                static_cast<RadarSector1EndTimeseriesObject&>(*newObject).ReadFrom( source );
                break;
            case Kind::RadarSector1StartTimeseries:
                static_cast<RadarSector1StartTimeseriesObject&>(*newObject).ReadFrom( source );
                break;
            case Kind::RadarSector2EndTimeseries:
                static_cast<RadarSector2EndTimeseriesObject&>(*newObject).ReadFrom( source );
                break;
            case Kind::RadarSector2StartTimeseries:
                static_cast<RadarSector2StartTimeseriesObject&>(*newObject).ReadFrom( source );
                break;
            case Kind::RadarSensitivityTimeControlLevelTimeseries:
                static_cast<RadarSensitivityTimeControlLevelTimeseriesObject&>(*newObject).ReadFrom( source );
                break;
            case Kind::RadarTuningTimeseries:
                static_cast<RadarTuningTimeseriesObject&>(*newObject).ReadFrom( source );
                break;
            case Kind::VesselPersonsOnBoardTimeseries:
                static_cast<VesselPersonsOnBoardTimeseriesObject&>(*newObject).ReadFrom( source );
                break;
            case Kind::Int64Timeseries:
                static_cast<Int64TimeseriesObject&>(*newObject).ReadFrom( source );
                break;
            case Kind::Position2DTimeseries:
                static_cast<Position2DTimeseriesObject&>(*newObject).ReadFrom( source );
                break;
            case Kind::Position3DTimeseries:
                static_cast<Position3DTimeseriesObject&>(*newObject).ReadFrom( source );
                break;
            case Kind::ReferenceTimeseries:
                static_cast<ReferenceTimeseriesObject&>(*newObject).ReadFrom( source );
                break;
            case Kind::SByteTimeseries:
                static_cast<SByteTimeseriesObject&>(*newObject).ReadFrom( source );
                break;
            case Kind::SingleTimeseries:
                static_cast<SingleTimeseriesObject&>(*newObject).ReadFrom( source );
                break;
            case Kind::StringTimeseries:
                static_cast<StringTimeseriesObject&>(*newObject).ReadFrom( source );
                break;
            case Kind::TimeSpanTimeseries:
                static_cast<TimeSpanTimeseriesObject&>(*newObject).ReadFrom( source );
                break;
            case Kind::UInt16Timeseries:
                static_cast<UInt16TimeseriesObject&>(*newObject).ReadFrom( source );
                break;
            case Kind::UInt32Timeseries:
                static_cast<UInt32TimeseriesObject&>(*newObject).ReadFrom( source );
                break;
            case Kind::RadomeStatusTimeseries:
                static_cast<RadomeStatusTimeseriesObject&>(*newObject).ReadFrom( source );
                break;
            case Kind::UInt64Timeseries:
                static_cast<UInt64TimeseriesObject&>(*newObject).ReadFrom( source );
                break;
            case Kind::TimeseriesCatalog:
                static_cast<TimeseriesCatalogObject&>(*newObject).ReadFrom( source );
                break;
            case Kind::TimeseriesInfo:
                static_cast<TimeseriesInfoObject&>(*newObject).ReadFrom( source );
                break;
            case Kind::TimeSpanTimeseriesValue:
                static_cast<TimeSpanTimeseriesValueObject&>(*newObject).ReadFrom( source );
                break;
            case Kind::TrackableItemTrackLink:
                static_cast<TrackableItemTrackLinkObject&>(*newObject).ReadFrom( source );
                break;
            case Kind::Track:
                static_cast<TrackObject&>(*newObject).ReadFrom( source );
                break;
            case Kind::Track3D:
                static_cast<Track3DObject&>(*newObject).ReadFrom( source );
                break;
            case Kind::TrackerFilterParameters:
                static_cast<TrackerFilterParametersObject&>(*newObject).ReadFrom( source );
                break;
            case Kind::TrackerFilterParametersConfiguration:
                static_cast<TrackerFilterParametersConfigurationObject&>(*newObject).ReadFrom( source );
                break;
            case Kind::TrackInfo:
                static_cast<TrackInfoObject&>(*newObject).ReadFrom( source );
                break;
            case Kind::TrackingServiceOptions:
                static_cast<TrackingServiceOptionsObject&>(*newObject).ReadFrom( source );
                break;
            case Kind::TrackLink:
                static_cast<TrackLinkObject&>(*newObject).ReadFrom( source );
                break;
            case Kind::TrackValue:
                static_cast<TrackValueObject&>(*newObject).ReadFrom( source );
                break;
            case Kind::TrackValue3D:
                static_cast<TrackValue3DObject&>(*newObject).ReadFrom( source );
                break;
            case Kind::UInt16TimeseriesValue:
                static_cast<UInt16TimeseriesValueObject&>(*newObject).ReadFrom( source );
                break;
            case Kind::UInt32TimeseriesValue:
                static_cast<UInt32TimeseriesValueObject&>(*newObject).ReadFrom( source );
                break;
            case Kind::UInt64TimeseriesValue:
                static_cast<UInt64TimeseriesValueObject&>(*newObject).ReadFrom( source );
                break;
            case Kind::VehicleType:
                static_cast<VehicleTypeObject&>(*newObject).ReadFrom( source );
                break;
            case Kind::VesselType:
                static_cast<VesselTypeObject&>(*newObject).ReadFrom( source );
                break;
            case Kind::View:
                static_cast<ViewObject&>(*newObject).ReadFrom( source );
                break;
            case Kind::ViewCameraLink:
                static_cast<ViewCameraLinkObject&>(*newObject).ReadFrom( source );
                break;
            case Kind::ViewTrackerLink:
                static_cast<ViewTrackerLinkObject&>(*newObject).ReadFrom( source );
                break;
            case Kind::WeatherStationCommand:
                static_cast<WeatherStationCommandObject&>(*newObject).ReadFrom( source );
                break;
            case Kind::WeatherStationCommandReply:
                static_cast<WeatherStationCommandReplyObject&>(*newObject).ReadFrom( source );
                break;
            case Kind::WeatherStationConfiguration:
                static_cast<WeatherStationConfigurationObject&>(*newObject).ReadFrom( source );
                break;
            case Kind::CircularZone:
                static_cast<CircularZoneObject&>(*newObject).ReadFrom( source );
                break;
            case Kind::PolygonZone:
                static_cast<PolygonZoneObject&>(*newObject).ReadFrom( source );
                break;
            case Kind::ZoneExceptions:
                static_cast<ZoneExceptionsObject&>(*newObject).ReadFrom( source );
                break;
            case Kind::ZoneExceptionsVesselLink:
                static_cast<ZoneExceptionsVesselLinkObject&>(*newObject).ReadFrom( source );
                break;
            case Kind::ZoneTrackAlarm:
                static_cast<ZoneTrackAlarmObject&>(*newObject).ReadFrom( source );
                break;
        }
        return newObject;
    }

    template<IO::StreamWriter StreamT>
    void WriteDataTo( const BaseData<Kind, Guid>& data, IO::BinaryWriter<StreamT>& destination )
    {
        auto kind = data.GetObjectType( );
        switch ( kind )
        {
            case Kind::AircraftType:
                static_cast<const AircraftTypeObject&>(data).WriteTo( destination );
                break;
            case Kind::AisDeviceCommand:
                static_cast<const AisDeviceCommandObject&>(data).WriteTo( destination );
                break;
            case Kind::AisDeviceCommandReply:
                static_cast<const AisDeviceCommandReplyObject&>(data).WriteTo( destination );
                break;
            case Kind::AisDeviceConfiguration:
                static_cast<const AisDeviceConfigurationObject&>(data).WriteTo( destination );
                break;
            case Kind::AisDeviceRawMessage:
                static_cast<const AisDeviceRawMessageObject&>(data).WriteTo( destination );
                break;
            case Kind::AisDeviceRawSentence:
                static_cast<const AisDeviceRawSentenceObject&>(data).WriteTo( destination );
                break;
            case Kind::AidToNavigationReportMessage:
                static_cast<const AidToNavigationReportMessageObject&>(data).WriteTo( destination );
                break;
            case Kind::AisAddressedSafetyRelatedMessage:
                static_cast<const AisAddressedSafetyRelatedMessageObject&>(data).WriteTo( destination );
                break;
            case Kind::AisBaseStationReportMessage:
                static_cast<const AisBaseStationReportMessageObject&>(data).WriteTo( destination );
                break;
            case Kind::AisBinaryAcknowledgeMessage:
                static_cast<const AisBinaryAcknowledgeMessageObject&>(data).WriteTo( destination );
                break;
            case Kind::AisBinaryAddressedMessage:
                static_cast<const AisBinaryAddressedMessageObject&>(data).WriteTo( destination );
                break;
            case Kind::AisBinaryBroadcastMessage:
                static_cast<const AisBinaryBroadcastMessageObject&>(data).WriteTo( destination );
                break;
            case Kind::AisDataLinkManagementMessage:
                static_cast<const AisDataLinkManagementMessageObject&>(data).WriteTo( destination );
                break;
            case Kind::AisExtendedClassBCsPositionReportMessage:
                static_cast<const AisExtendedClassBCsPositionReportMessageObject&>(data).WriteTo( destination );
                break;
            case Kind::AisInterrogationMessage:
                static_cast<const AisInterrogationMessageObject&>(data).WriteTo( destination );
                break;
            case Kind::AisPositionReportClassAAssignedScheduleMessage:
                static_cast<const AisPositionReportClassAAssignedScheduleMessageObject&>(data).WriteTo( destination );
                break;
            case Kind::AisPositionReportClassAMessage:
                static_cast<const AisPositionReportClassAMessageObject&>(data).WriteTo( destination );
                break;
            case Kind::AisPositionReportClassAResponseToInterrogationMessage:
                static_cast<const AisPositionReportClassAResponseToInterrogationMessageObject&>(data).WriteTo( destination );
                break;
            case Kind::AisPositionReportForLongRangeApplicationsMessage:
                static_cast<const AisPositionReportForLongRangeApplicationsMessageObject&>(data).WriteTo( destination );
                break;
            case Kind::AisSafetyRelatedAcknowledgmentMessage:
                static_cast<const AisSafetyRelatedAcknowledgmentMessageObject&>(data).WriteTo( destination );
                break;
            case Kind::AisStandardClassBCsPositionReportMessage:
                static_cast<const AisStandardClassBCsPositionReportMessageObject&>(data).WriteTo( destination );
                break;
            case Kind::AisStandardSarAircraftPositionReportMessage:
                static_cast<const AisStandardSarAircraftPositionReportMessageObject&>(data).WriteTo( destination );
                break;
            case Kind::AisStaticAndVoyageRelatedDataMessage:
                static_cast<const AisStaticAndVoyageRelatedDataMessageObject&>(data).WriteTo( destination );
                break;
            case Kind::AisStaticDataReportMessage:
                static_cast<const AisStaticDataReportMessageObject&>(data).WriteTo( destination );
                break;
            case Kind::AisStaticDataReportPartAMessage:
                static_cast<const AisStaticDataReportPartAMessageObject&>(data).WriteTo( destination );
                break;
            case Kind::AisStaticDataReportPartBMessage:
                static_cast<const AisStaticDataReportPartBMessageObject&>(data).WriteTo( destination );
                break;
            case Kind::AisUtcAndDateInquiryMessage:
                static_cast<const AisUtcAndDateInquiryMessageObject&>(data).WriteTo( destination );
                break;
            case Kind::AisUtcAndDateResponseMessage:
                static_cast<const AisUtcAndDateResponseMessageObject&>(data).WriteTo( destination );
                break;
            case Kind::AlarmStateChange:
                static_cast<const AlarmStateChangeObject&>(data).WriteTo( destination );
                break;
            case Kind::BaseStationType:
                static_cast<const BaseStationTypeObject&>(data).WriteTo( destination );
                break;
            case Kind::BinaryTimeseriesValue:
                static_cast<const BinaryTimeseriesValueObject&>(data).WriteTo( destination );
                break;
            case Kind::Bookmark:
                static_cast<const BookmarkObject&>(data).WriteTo( destination );
                break;
            case Kind::BooleanTimeseriesValue:
                static_cast<const BooleanTimeseriesValueObject&>(data).WriteTo( destination );
                break;
            case Kind::ByteTimeseriesValue:
                static_cast<const ByteTimeseriesValueObject&>(data).WriteTo( destination );
                break;
            case Kind::CameraCommand:
                static_cast<const CameraCommandObject&>(data).WriteTo( destination );
                break;
            case Kind::CameraCommandAbsoluteMove:
                static_cast<const CameraCommandAbsoluteMoveObject&>(data).WriteTo( destination );
                break;
            case Kind::CameraCommandAdjustPanTiltZoom:
                static_cast<const CameraCommandAdjustPanTiltZoomObject&>(data).WriteTo( destination );
                break;
            case Kind::CameraCommandContinuousMove:
                static_cast<const CameraCommandContinuousMoveObject&>(data).WriteTo( destination );
                break;
            case Kind::CameraCommandGeoMove:
                static_cast<const CameraCommandGeoMoveObject&>(data).WriteTo( destination );
                break;
            case Kind::CameraCommandRelativeMove:
                static_cast<const CameraCommandRelativeMoveObject&>(data).WriteTo( destination );
                break;
            case Kind::CameraCommandReleasePTZOwnership:
                static_cast<const CameraCommandReleasePTZOwnershipObject&>(data).WriteTo( destination );
                break;
            case Kind::CameraCommandRequestPTZOwnership:
                static_cast<const CameraCommandRequestPTZOwnershipObject&>(data).WriteTo( destination );
                break;
            case Kind::CameraCommandSetAutoFocus:
                static_cast<const CameraCommandSetAutoFocusObject&>(data).WriteTo( destination );
                break;
            case Kind::CameraCommandSetBlackAndWhite:
                static_cast<const CameraCommandSetBlackAndWhiteObject&>(data).WriteTo( destination );
                break;
            case Kind::CameraCommandSetFollowed:
                static_cast<const CameraCommandSetFollowedObject&>(data).WriteTo( destination );
                break;
            case Kind::CameraCommandSetInfraRedLamp:
                static_cast<const CameraCommandSetInfraRedLampObject&>(data).WriteTo( destination );
                break;
            case Kind::CameraCommandSetWasher:
                static_cast<const CameraCommandSetWasherObject&>(data).WriteTo( destination );
                break;
            case Kind::CameraCommandSetWiper:
                static_cast<const CameraCommandSetWiperObject&>(data).WriteTo( destination );
                break;
            case Kind::CameraCommandStop:
                static_cast<const CameraCommandStopObject&>(data).WriteTo( destination );
                break;
            case Kind::CameraCommandReply:
                static_cast<const CameraCommandReplyObject&>(data).WriteTo( destination );
                break;
            case Kind::CameraConfiguration:
                static_cast<const CameraConfigurationObject&>(data).WriteTo( destination );
                break;
            case Kind::CameraPanCalibration:
                static_cast<const CameraPanCalibrationObject&>(data).WriteTo( destination );
                break;
            case Kind::CameraPanCalibrationValue:
                static_cast<const CameraPanCalibrationValueObject&>(data).WriteTo( destination );
                break;
            case Kind::CameraStatus:
                static_cast<const CameraStatusObject&>(data).WriteTo( destination );
                break;
            case Kind::CameraTiltCalibration:
                static_cast<const CameraTiltCalibrationObject&>(data).WriteTo( destination );
                break;
            case Kind::CameraTiltCalibrationValue:
                static_cast<const CameraTiltCalibrationValueObject&>(data).WriteTo( destination );
                break;
            case Kind::CameraZoomCalibration:
                static_cast<const CameraZoomCalibrationObject&>(data).WriteTo( destination );
                break;
            case Kind::CameraZoomCalibrationValue:
                static_cast<const CameraZoomCalibrationValueObject&>(data).WriteTo( destination );
                break;
            case Kind::Catalog:
                static_cast<const CatalogObject&>(data).WriteTo( destination );
                break;
            case Kind::Element:
                static_cast<const ElementObject&>(data).WriteTo( destination );
                break;
            case Kind::CollectionInfo:
                static_cast<const CollectionInfoObject&>(data).WriteTo( destination );
                break;
            case Kind::Country:
                static_cast<const CountryObject&>(data).WriteTo( destination );
                break;
            case Kind::CursorInfo:
                static_cast<const CursorInfoObject&>(data).WriteTo( destination );
                break;
            case Kind::DateTimeTimeseriesValue:
                static_cast<const DateTimeTimeseriesValueObject&>(data).WriteTo( destination );
                break;
            case Kind::DeviceHost:
                static_cast<const DeviceHostObject&>(data).WriteTo( destination );
                break;
            case Kind::DeviceHostConfiguration:
                static_cast<const DeviceHostConfigurationObject&>(data).WriteTo( destination );
                break;
            case Kind::DoubleTimeseriesValue:
                static_cast<const DoubleTimeseriesValueObject&>(data).WriteTo( destination );
                break;
            case Kind::FacilityType:
                static_cast<const FacilityTypeObject&>(data).WriteTo( destination );
                break;
            case Kind::GeoPosition2DTimeseriesValue:
                static_cast<const GeoPosition2DTimeseriesValueObject&>(data).WriteTo( destination );
                break;
            case Kind::GeoPosition3DTimeseriesValue:
                static_cast<const GeoPosition3DTimeseriesValueObject&>(data).WriteTo( destination );
                break;
            case Kind::GNSSDeviceCommand:
                static_cast<const GNSSDeviceCommandObject&>(data).WriteTo( destination );
                break;
            case Kind::GNSSDeviceCommandReply:
                static_cast<const GNSSDeviceCommandReplyObject&>(data).WriteTo( destination );
                break;
            case Kind::GNSSDeviceConfiguration:
                static_cast<const GNSSDeviceConfigurationObject&>(data).WriteTo( destination );
                break;
            case Kind::GuidTimeseriesValue:
                static_cast<const GuidTimeseriesValueObject&>(data).WriteTo( destination );
                break;
            case Kind::GyroDeviceCommand:
                static_cast<const GyroDeviceCommandObject&>(data).WriteTo( destination );
                break;
            case Kind::GyroDeviceCommandReply:
                static_cast<const GyroDeviceCommandReplyObject&>(data).WriteTo( destination );
                break;
            case Kind::GyroDeviceConfiguration:
                static_cast<const GyroDeviceConfigurationObject&>(data).WriteTo( destination );
                break;
            case Kind::Callsign:
                static_cast<const CallsignObject&>(data).WriteTo( destination );
                break;
            case Kind::InternationalMaritimeOrganizationNumber:
                static_cast<const InternationalMaritimeOrganizationNumberObject&>(data).WriteTo( destination );
                break;
            case Kind::MaritimeMobileServiceIdentity:
                static_cast<const MaritimeMobileServiceIdentityObject&>(data).WriteTo( destination );
                break;
            case Kind::Name:
                static_cast<const NameObject&>(data).WriteTo( destination );
                break;
            case Kind::Int16TimeseriesValue:
                static_cast<const Int16TimeseriesValueObject&>(data).WriteTo( destination );
                break;
            case Kind::Int32TimeseriesValue:
                static_cast<const Int32TimeseriesValueObject&>(data).WriteTo( destination );
                break;
            case Kind::Int64TimeseriesValue:
                static_cast<const Int64TimeseriesValueObject&>(data).WriteTo( destination );
                break;
            case Kind::BaseStation:
                static_cast<const BaseStationObject&>(data).WriteTo( destination );
                break;
            case Kind::CameraDevice:
                static_cast<const CameraDeviceObject&>(data).WriteTo( destination );
                break;
            case Kind::GNSSDevice:
                static_cast<const GNSSDeviceObject&>(data).WriteTo( destination );
                break;
            case Kind::GyroDevice:
                static_cast<const GyroDeviceObject&>(data).WriteTo( destination );
                break;
            case Kind::LineInputDevice:
                static_cast<const LineInputDeviceObject&>(data).WriteTo( destination );
                break;
            case Kind::OilSpillDetectorDevice:
                static_cast<const OilSpillDetectorDeviceObject&>(data).WriteTo( destination );
                break;
            case Kind::RadioDevice:
                static_cast<const RadioDeviceObject&>(data).WriteTo( destination );
                break;
            case Kind::RadomeDevice:
                static_cast<const RadomeDeviceObject&>(data).WriteTo( destination );
                break;
            case Kind::AisDevice:
                static_cast<const AisDeviceObject&>(data).WriteTo( destination );
                break;
            case Kind::RadarDevice:
                static_cast<const RadarDeviceObject&>(data).WriteTo( destination );
                break;
            case Kind::WeatherStationDevice:
                static_cast<const WeatherStationDeviceObject&>(data).WriteTo( destination );
                break;
            case Kind::Facility:
                static_cast<const FacilityObject&>(data).WriteTo( destination );
                break;
            case Kind::Aircraft:
                static_cast<const AircraftObject&>(data).WriteTo( destination );
                break;
            case Kind::AisAidToNavigation:
                static_cast<const AisAidToNavigationObject&>(data).WriteTo( destination );
                break;
            case Kind::Vehicle:
                static_cast<const VehicleObject&>(data).WriteTo( destination );
                break;
            case Kind::Vessel:
                static_cast<const VesselObject&>(data).WriteTo( destination );
                break;
            case Kind::ItemIdentityLink:
                static_cast<const ItemIdentityLinkObject&>(data).WriteTo( destination );
                break;
            case Kind::ItemParentChildLink:
                static_cast<const ItemParentChildLinkObject&>(data).WriteTo( destination );
                break;
            case Kind::LineInputDeviceCommand:
                static_cast<const LineInputDeviceCommandObject&>(data).WriteTo( destination );
                break;
            case Kind::LineInputDeviceCommandReply:
                static_cast<const LineInputDeviceCommandReplyObject&>(data).WriteTo( destination );
                break;
            case Kind::LineInputDeviceConfiguration:
                static_cast<const LineInputDeviceConfigurationObject&>(data).WriteTo( destination );
                break;
            case Kind::LineInputMessageRouting:
                static_cast<const LineInputMessageRoutingObject&>(data).WriteTo( destination );
                break;
            case Kind::LineInputMessageRoutingDestination:
                static_cast<const LineInputMessageRoutingDestinationObject&>(data).WriteTo( destination );
                break;
            case Kind::LineInputWhiteListEntry:
                static_cast<const LineInputWhiteListEntryObject&>(data).WriteTo( destination );
                break;
            case Kind::LogApplication:
                static_cast<const LogApplicationObject&>(data).WriteTo( destination );
                break;
            case Kind::LogApplicationConfiguration:
                static_cast<const LogApplicationConfigurationObject&>(data).WriteTo( destination );
                break;
            case Kind::LogHost:
                static_cast<const LogHostObject&>(data).WriteTo( destination );
                break;
            case Kind::LogHostConfiguration:
                static_cast<const LogHostConfigurationObject&>(data).WriteTo( destination );
                break;
            case Kind::LogLocation:
                static_cast<const LogLocationObject&>(data).WriteTo( destination );
                break;
            case Kind::LogProcess:
                static_cast<const LogProcessObject&>(data).WriteTo( destination );
                break;
            case Kind::LogRecord:
                static_cast<const LogRecordObject&>(data).WriteTo( destination );
                break;
            case Kind::LogThread:
                static_cast<const LogThreadObject&>(data).WriteTo( destination );
                break;
            case Kind::LogTraceEntry:
                static_cast<const LogTraceEntryObject&>(data).WriteTo( destination );
                break;
            case Kind::MapElement:
                static_cast<const MapElementObject&>(data).WriteTo( destination );
                break;
            case Kind::MapInfo:
                static_cast<const MapInfoObject&>(data).WriteTo( destination );
                break;
            case Kind::MapServiceOptions:
                static_cast<const MapServiceOptionsObject&>(data).WriteTo( destination );
                break;
            case Kind::MaritimeIdentificationDigits:
                static_cast<const MaritimeIdentificationDigitsObject&>(data).WriteTo( destination );
                break;
            case Kind::MediaProxySession:
                static_cast<const MediaProxySessionObject&>(data).WriteTo( destination );
                break;
            case Kind::MediaProxySessionFile:
                static_cast<const MediaProxySessionFileObject&>(data).WriteTo( destination );
                break;
            case Kind::MediaProxySessionOptions:
                static_cast<const MediaProxySessionOptionsObject&>(data).WriteTo( destination );
                break;
            case Kind::MediaService:
                static_cast<const MediaServiceObject&>(data).WriteTo( destination );
                break;
            case Kind::MediaServiceOptions:
                static_cast<const MediaServiceOptionsObject&>(data).WriteTo( destination );
                break;
            case Kind::ElementType:
                static_cast<const ElementTypeObject&>(data).WriteTo( destination );
                break;
            case Kind::Namespace:
                static_cast<const NamespaceObject&>(data).WriteTo( destination );
                break;
            case Kind::OilSpill:
                static_cast<const OilSpillObject&>(data).WriteTo( destination );
                break;
            case Kind::OilSpillDetectorCommand:
                static_cast<const OilSpillDetectorCommandObject&>(data).WriteTo( destination );
                break;
            case Kind::OilSpillDetectorCommandReply:
                static_cast<const OilSpillDetectorCommandReplyObject&>(data).WriteTo( destination );
                break;
            case Kind::OilSpillDetectorConfiguration:
                static_cast<const OilSpillDetectorConfigurationObject&>(data).WriteTo( destination );
                break;
            case Kind::Position2DTimeseriesValue:
                static_cast<const Position2DTimeseriesValueObject&>(data).WriteTo( destination );
                break;
            case Kind::Position3DTimeseriesValue:
                static_cast<const Position3DTimeseriesValueObject&>(data).WriteTo( destination );
                break;
            case Kind::ProcessTrackValueResult:
                static_cast<const ProcessTrackValueResultObject&>(data).WriteTo( destination );
                break;
            case Kind::BinaryProperty:
                static_cast<const BinaryPropertyObject&>(data).WriteTo( destination );
                break;
            case Kind::BooleanProperty:
                static_cast<const BooleanPropertyObject&>(data).WriteTo( destination );
                break;
            case Kind::ByteProperty:
                static_cast<const BytePropertyObject&>(data).WriteTo( destination );
                break;
            case Kind::DateTimeProperty:
                static_cast<const DateTimePropertyObject&>(data).WriteTo( destination );
                break;
            case Kind::DoubleProperty:
                static_cast<const DoublePropertyObject&>(data).WriteTo( destination );
                break;
            case Kind::GuidProperty:
                static_cast<const GuidPropertyObject&>(data).WriteTo( destination );
                break;
            case Kind::Int16Property:
                static_cast<const Int16PropertyObject&>(data).WriteTo( destination );
                break;
            case Kind::Int32Property:
                static_cast<const Int32PropertyObject&>(data).WriteTo( destination );
                break;
            case Kind::Int64Property:
                static_cast<const Int64PropertyObject&>(data).WriteTo( destination );
                break;
            case Kind::ReferenceProperty:
                static_cast<const ReferencePropertyObject&>(data).WriteTo( destination );
                break;
            case Kind::SByteProperty:
                static_cast<const SBytePropertyObject&>(data).WriteTo( destination );
                break;
            case Kind::SingleProperty:
                static_cast<const SinglePropertyObject&>(data).WriteTo( destination );
                break;
            case Kind::StringProperty:
                static_cast<const StringPropertyObject&>(data).WriteTo( destination );
                break;
            case Kind::BinaryTimeseriesProperty:
                static_cast<const BinaryTimeseriesPropertyObject&>(data).WriteTo( destination );
                break;
            case Kind::BooleanTimeseriesProperty:
                static_cast<const BooleanTimeseriesPropertyObject&>(data).WriteTo( destination );
                break;
            case Kind::ByteTimeseriesProperty:
                static_cast<const ByteTimeseriesPropertyObject&>(data).WriteTo( destination );
                break;
            case Kind::DateTimeTimeseriesProperty:
                static_cast<const DateTimeTimeseriesPropertyObject&>(data).WriteTo( destination );
                break;
            case Kind::DoubleTimeseriesProperty:
                static_cast<const DoubleTimeseriesPropertyObject&>(data).WriteTo( destination );
                break;
            case Kind::GuidTimeseriesProperty:
                static_cast<const GuidTimeseriesPropertyObject&>(data).WriteTo( destination );
                break;
            case Kind::Int16TimeseriesProperty:
                static_cast<const Int16TimeseriesPropertyObject&>(data).WriteTo( destination );
                break;
            case Kind::Int32TimeseriesProperty:
                static_cast<const Int32TimeseriesPropertyObject&>(data).WriteTo( destination );
                break;
            case Kind::Int64TimeseriesProperty:
                static_cast<const Int64TimeseriesPropertyObject&>(data).WriteTo( destination );
                break;
            case Kind::ReferenceTimeseriesProperty:
                static_cast<const ReferenceTimeseriesPropertyObject&>(data).WriteTo( destination );
                break;
            case Kind::SByteTimeseriesProperty:
                static_cast<const SByteTimeseriesPropertyObject&>(data).WriteTo( destination );
                break;
            case Kind::SingleTimeseriesProperty:
                static_cast<const SingleTimeseriesPropertyObject&>(data).WriteTo( destination );
                break;
            case Kind::StringTimeseriesProperty:
                static_cast<const StringTimeseriesPropertyObject&>(data).WriteTo( destination );
                break;
            case Kind::TimeSpanTimeseriesProperty:
                static_cast<const TimeSpanTimeseriesPropertyObject&>(data).WriteTo( destination );
                break;
            case Kind::UInt16TimeseriesProperty:
                static_cast<const UInt16TimeseriesPropertyObject&>(data).WriteTo( destination );
                break;
            case Kind::UInt32TimeseriesProperty:
                static_cast<const UInt32TimeseriesPropertyObject&>(data).WriteTo( destination );
                break;
            case Kind::UInt64TimeseriesProperty:
                static_cast<const UInt64TimeseriesPropertyObject&>(data).WriteTo( destination );
                break;
            case Kind::TimeSpanProperty:
                static_cast<const TimeSpanPropertyObject&>(data).WriteTo( destination );
                break;
            case Kind::UInt16Property:
                static_cast<const UInt16PropertyObject&>(data).WriteTo( destination );
                break;
            case Kind::UInt32Property:
                static_cast<const UInt32PropertyObject&>(data).WriteTo( destination );
                break;
            case Kind::UInt64Property:
                static_cast<const UInt64PropertyObject&>(data).WriteTo( destination );
                break;
            case Kind::BinaryPropertyDefinition:
                static_cast<const BinaryPropertyDefinitionObject&>(data).WriteTo( destination );
                break;
            case Kind::BooleanPropertyDefinition:
                static_cast<const BooleanPropertyDefinitionObject&>(data).WriteTo( destination );
                break;
            case Kind::BytePropertyDefinition:
                static_cast<const BytePropertyDefinitionObject&>(data).WriteTo( destination );
                break;
            case Kind::DateTimePropertyDefinition:
                static_cast<const DateTimePropertyDefinitionObject&>(data).WriteTo( destination );
                break;
            case Kind::DoublePropertyDefinition:
                static_cast<const DoublePropertyDefinitionObject&>(data).WriteTo( destination );
                break;
            case Kind::GuidPropertyDefinition:
                static_cast<const GuidPropertyDefinitionObject&>(data).WriteTo( destination );
                break;
            case Kind::Int16PropertyDefinition:
                static_cast<const Int16PropertyDefinitionObject&>(data).WriteTo( destination );
                break;
            case Kind::Int32PropertyDefinition:
                static_cast<const Int32PropertyDefinitionObject&>(data).WriteTo( destination );
                break;
            case Kind::Int64PropertyDefinition:
                static_cast<const Int64PropertyDefinitionObject&>(data).WriteTo( destination );
                break;
            case Kind::ReferencePropertyDefinition:
                static_cast<const ReferencePropertyDefinitionObject&>(data).WriteTo( destination );
                break;
            case Kind::SBytePropertyDefinition:
                static_cast<const SBytePropertyDefinitionObject&>(data).WriteTo( destination );
                break;
            case Kind::SinglePropertyDefinition:
                static_cast<const SinglePropertyDefinitionObject&>(data).WriteTo( destination );
                break;
            case Kind::StringPropertyDefinition:
                static_cast<const StringPropertyDefinitionObject&>(data).WriteTo( destination );
                break;
            case Kind::BinaryTimeseriesPropertyDefinition:
                static_cast<const BinaryTimeseriesPropertyDefinitionObject&>(data).WriteTo( destination );
                break;
            case Kind::BooleanTimeseriesPropertyDefinition:
                static_cast<const BooleanTimeseriesPropertyDefinitionObject&>(data).WriteTo( destination );
                break;
            case Kind::ByteTimeseriesPropertyDefinition:
                static_cast<const ByteTimeseriesPropertyDefinitionObject&>(data).WriteTo( destination );
                break;
            case Kind::DateTimeTimeseriesPropertyDefinition:
                static_cast<const DateTimeTimeseriesPropertyDefinitionObject&>(data).WriteTo( destination );
                break;
            case Kind::DoubleTimeseriesPropertyDefinition:
                static_cast<const DoubleTimeseriesPropertyDefinitionObject&>(data).WriteTo( destination );
                break;
            case Kind::GuidTimeseriesPropertyDefinition:
                static_cast<const GuidTimeseriesPropertyDefinitionObject&>(data).WriteTo( destination );
                break;
            case Kind::Int16TimeseriesPropertyDefinition:
                static_cast<const Int16TimeseriesPropertyDefinitionObject&>(data).WriteTo( destination );
                break;
            case Kind::Int32TimeseriesPropertyDefinition:
                static_cast<const Int32TimeseriesPropertyDefinitionObject&>(data).WriteTo( destination );
                break;
            case Kind::Int64TimeseriesPropertyDefinition:
                static_cast<const Int64TimeseriesPropertyDefinitionObject&>(data).WriteTo( destination );
                break;
            case Kind::ReferenceTimeseriesPropertyDefinition:
                static_cast<const ReferenceTimeseriesPropertyDefinitionObject&>(data).WriteTo( destination );
                break;
            case Kind::SByteTimeseriesPropertyDefinition:
                static_cast<const SByteTimeseriesPropertyDefinitionObject&>(data).WriteTo( destination );
                break;
            case Kind::SingleTimeseriesPropertyDefinition:
                static_cast<const SingleTimeseriesPropertyDefinitionObject&>(data).WriteTo( destination );
                break;
            case Kind::StringTimeseriesPropertyDefinition:
                static_cast<const StringTimeseriesPropertyDefinitionObject&>(data).WriteTo( destination );
                break;
            case Kind::TimeSpanTimeseriesPropertyDefinition:
                static_cast<const TimeSpanTimeseriesPropertyDefinitionObject&>(data).WriteTo( destination );
                break;
            case Kind::UInt16TimeseriesPropertyDefinition:
                static_cast<const UInt16TimeseriesPropertyDefinitionObject&>(data).WriteTo( destination );
                break;
            case Kind::UInt32TimeseriesPropertyDefinition:
                static_cast<const UInt32TimeseriesPropertyDefinitionObject&>(data).WriteTo( destination );
                break;
            case Kind::UInt64TimeseriesPropertyDefinition:
                static_cast<const UInt64TimeseriesPropertyDefinitionObject&>(data).WriteTo( destination );
                break;
            case Kind::TimeSpanPropertyDefinition:
                static_cast<const TimeSpanPropertyDefinitionObject&>(data).WriteTo( destination );
                break;
            case Kind::UInt16PropertyDefinition:
                static_cast<const UInt16PropertyDefinitionObject&>(data).WriteTo( destination );
                break;
            case Kind::UInt32PropertyDefinition:
                static_cast<const UInt32PropertyDefinitionObject&>(data).WriteTo( destination );
                break;
            case Kind::UInt64PropertyDefinition:
                static_cast<const UInt64PropertyDefinitionObject&>(data).WriteTo( destination );
                break;
            case Kind::RadarAlarmStatus:
                static_cast<const RadarAlarmStatusObject&>(data).WriteTo( destination );
                break;
            case Kind::RadarCommand:
                static_cast<const RadarCommandObject&>(data).WriteTo( destination );
                break;
            case Kind::RadarCommandGetStatus:
                static_cast<const RadarCommandGetStatusObject&>(data).WriteTo( destination );
                break;
            case Kind::RadarCommandReply:
                static_cast<const RadarCommandReplyObject&>(data).WriteTo( destination );
                break;
            case Kind::RadarCommandReplyGetStatus:
                static_cast<const RadarCommandReplyGetStatusObject&>(data).WriteTo( destination );
                break;
            case Kind::RadarConfiguration:
                static_cast<const RadarConfigurationObject&>(data).WriteTo( destination );
                break;
            case Kind::RadarImage:
                static_cast<const RadarImageObject&>(data).WriteTo( destination );
                break;
            case Kind::RadarRawTrackTable:
                static_cast<const RadarRawTrackTableObject&>(data).WriteTo( destination );
                break;
            case Kind::RadarStatus:
                static_cast<const RadarStatusObject&>(data).WriteTo( destination );
                break;
            case Kind::RadioCommand:
                static_cast<const RadioCommandObject&>(data).WriteTo( destination );
                break;
            case Kind::RadioCommandReply:
                static_cast<const RadioCommandReplyObject&>(data).WriteTo( destination );
                break;
            case Kind::RadioConfiguration:
                static_cast<const RadioConfigurationObject&>(data).WriteTo( destination );
                break;
            case Kind::RadomeCommand:
                static_cast<const RadomeCommandObject&>(data).WriteTo( destination );
                break;
            case Kind::RadomeCommandReply:
                static_cast<const RadomeCommandReplyObject&>(data).WriteTo( destination );
                break;
            case Kind::RadomeConfiguration:
                static_cast<const RadomeConfigurationObject&>(data).WriteTo( destination );
                break;
            case Kind::ReferenceTimeseriesValue:
                static_cast<const ReferenceTimeseriesValueObject&>(data).WriteTo( destination );
                break;
            case Kind::SByteTimeseriesValue:
                static_cast<const SByteTimeseriesValueObject&>(data).WriteTo( destination );
                break;
            case Kind::SecurityDomain:
                static_cast<const SecurityDomainObject&>(data).WriteTo( destination );
                break;
            case Kind::SecurityLogin:
                static_cast<const SecurityLoginObject&>(data).WriteTo( destination );
                break;
            case Kind::SecurityRole:
                static_cast<const SecurityRoleObject&>(data).WriteTo( destination );
                break;
            case Kind::SecurityIdentifierRoleLink:
                static_cast<const SecurityIdentifierRoleLinkObject&>(data).WriteTo( destination );
                break;
            case Kind::SecurityLoginSession:
                static_cast<const SecurityLoginSessionObject&>(data).WriteTo( destination );
                break;
            case Kind::SecurityPermission:
                static_cast<const SecurityPermissionObject&>(data).WriteTo( destination );
                break;
            case Kind::SingleTimeseriesValue:
                static_cast<const SingleTimeseriesValueObject&>(data).WriteTo( destination );
                break;
            case Kind::StringTimeseriesValue:
                static_cast<const StringTimeseriesValueObject&>(data).WriteTo( destination );
                break;
            case Kind::BinaryTimeseries:
                static_cast<const BinaryTimeseriesObject&>(data).WriteTo( destination );
                break;
            case Kind::BooleanTimeseries:
                static_cast<const BooleanTimeseriesObject&>(data).WriteTo( destination );
                break;
            case Kind::AisAidToNavigationOffPositionTimeseries:
                static_cast<const AisAidToNavigationOffPositionTimeseriesObject&>(data).WriteTo( destination );
                break;
            case Kind::DeviceEnabledTimeseries:
                static_cast<const DeviceEnabledTimeseriesObject&>(data).WriteTo( destination );
                break;
            case Kind::RadarAutomaticSensitivityTimeControlTimeseries:
                static_cast<const RadarAutomaticSensitivityTimeControlTimeseriesObject&>(data).WriteTo( destination );
                break;
            case Kind::RadarBlankSector1Timeseries:
                static_cast<const RadarBlankSector1TimeseriesObject&>(data).WriteTo( destination );
                break;
            case Kind::RadarBlankSector2Timeseries:
                static_cast<const RadarBlankSector2TimeseriesObject&>(data).WriteTo( destination );
                break;
            case Kind::RadarEnableAutomaticFrequencyControlTimeseries:
                static_cast<const RadarEnableAutomaticFrequencyControlTimeseriesObject&>(data).WriteTo( destination );
                break;
            case Kind::RadarEnableFastTimeConstantTimeseries:
                static_cast<const RadarEnableFastTimeConstantTimeseriesObject&>(data).WriteTo( destination );
                break;
            case Kind::RadarEnableSensitivityTimeControlTimeseries:
                static_cast<const RadarEnableSensitivityTimeControlTimeseriesObject&>(data).WriteTo( destination );
                break;
            case Kind::RadarPowerOnTimeseries:
                static_cast<const RadarPowerOnTimeseriesObject&>(data).WriteTo( destination );
                break;
            case Kind::RadarSaveSettingsTimeseries:
                static_cast<const RadarSaveSettingsTimeseriesObject&>(data).WriteTo( destination );
                break;
            case Kind::RadarTrackingTimeseries:
                static_cast<const RadarTrackingTimeseriesObject&>(data).WriteTo( destination );
                break;
            case Kind::MediaProxySessionEnabledTimeseries:
                static_cast<const MediaProxySessionEnabledTimeseriesObject&>(data).WriteTo( destination );
                break;
            case Kind::MediaServiceEnabledTimeseries:
                static_cast<const MediaServiceEnabledTimeseriesObject&>(data).WriteTo( destination );
                break;
            case Kind::ByteTimeseries:
                static_cast<const ByteTimeseriesObject&>(data).WriteTo( destination );
                break;
            case Kind::DateTimeTimeseries:
                static_cast<const DateTimeTimeseriesObject&>(data).WriteTo( destination );
                break;
            case Kind::DoubleTimeseries:
                static_cast<const DoubleTimeseriesObject&>(data).WriteTo( destination );
                break;
            case Kind::GNSSAltitudeTimeseries:
                static_cast<const GNSSAltitudeTimeseriesObject&>(data).WriteTo( destination );
                break;
            case Kind::GNSSLatitudeTimeseries:
                static_cast<const GNSSLatitudeTimeseriesObject&>(data).WriteTo( destination );
                break;
            case Kind::GNSSLongitudeTimeseries:
                static_cast<const GNSSLongitudeTimeseriesObject&>(data).WriteTo( destination );
                break;
            case Kind::GyroCourseTimeseries:
                static_cast<const GyroCourseTimeseriesObject&>(data).WriteTo( destination );
                break;
            case Kind::GyroHeadingMagneticNorthTimeseries:
                static_cast<const GyroHeadingMagneticNorthTimeseriesObject&>(data).WriteTo( destination );
                break;
            case Kind::GyroHeadingTrueNorthTimeseries:
                static_cast<const GyroHeadingTrueNorthTimeseriesObject&>(data).WriteTo( destination );
                break;
            case Kind::GyroPitchTimeseries:
                static_cast<const GyroPitchTimeseriesObject&>(data).WriteTo( destination );
                break;
            case Kind::GyroRateOfTurnTimeseries:
                static_cast<const GyroRateOfTurnTimeseriesObject&>(data).WriteTo( destination );
                break;
            case Kind::GyroRollTimeseries:
                static_cast<const GyroRollTimeseriesObject&>(data).WriteTo( destination );
                break;
            case Kind::GyroSpeedTimeseries:
                static_cast<const GyroSpeedTimeseriesObject&>(data).WriteTo( destination );
                break;
            case Kind::RadarLatitudeTimeseries:
                static_cast<const RadarLatitudeTimeseriesObject&>(data).WriteTo( destination );
                break;
            case Kind::RadarLongitudeTimeseries:
                static_cast<const RadarLongitudeTimeseriesObject&>(data).WriteTo( destination );
                break;
            case Kind::RadomeDewPointTimeseries:
                static_cast<const RadomeDewPointTimeseriesObject&>(data).WriteTo( destination );
                break;
            case Kind::RadomePressureTimeseries:
                static_cast<const RadomePressureTimeseriesObject&>(data).WriteTo( destination );
                break;
            case Kind::RadomeTemperatureTimeseries:
                static_cast<const RadomeTemperatureTimeseriesObject&>(data).WriteTo( destination );
                break;
            case Kind::VesselDraughtTimeseries:
                static_cast<const VesselDraughtTimeseriesObject&>(data).WriteTo( destination );
                break;
            case Kind::ViewLatitudeTimeseries:
                static_cast<const ViewLatitudeTimeseriesObject&>(data).WriteTo( destination );
                break;
            case Kind::ViewLongitudeTimeseries:
                static_cast<const ViewLongitudeTimeseriesObject&>(data).WriteTo( destination );
                break;
            case Kind::ViewZoomLevelTimeseries:
                static_cast<const ViewZoomLevelTimeseriesObject&>(data).WriteTo( destination );
                break;
            case Kind::WeatherStationAbsoluteHumidityTimeseries:
                static_cast<const WeatherStationAbsoluteHumidityTimeseriesObject&>(data).WriteTo( destination );
                break;
            case Kind::WeatherStationAirTemperatureTimeseries:
                static_cast<const WeatherStationAirTemperatureTimeseriesObject&>(data).WriteTo( destination );
                break;
            case Kind::WeatherStationBarometricPressureTimeseries:
                static_cast<const WeatherStationBarometricPressureTimeseriesObject&>(data).WriteTo( destination );
                break;
            case Kind::WeatherStationDewPointTimeseries:
                static_cast<const WeatherStationDewPointTimeseriesObject&>(data).WriteTo( destination );
                break;
            case Kind::WeatherStationRelativeHumidityTimeseries:
                static_cast<const WeatherStationRelativeHumidityTimeseriesObject&>(data).WriteTo( destination );
                break;
            case Kind::WeatherStationWaterTemperatureTimeseries:
                static_cast<const WeatherStationWaterTemperatureTimeseriesObject&>(data).WriteTo( destination );
                break;
            case Kind::WeatherStationWindDirectionTimeseries:
                static_cast<const WeatherStationWindDirectionTimeseriesObject&>(data).WriteTo( destination );
                break;
            case Kind::WeatherStationWindSpeedTimeseries:
                static_cast<const WeatherStationWindSpeedTimeseriesObject&>(data).WriteTo( destination );
                break;
            case Kind::GeoPosition2DTimeseries:
                static_cast<const GeoPosition2DTimeseriesObject&>(data).WriteTo( destination );
                break;
            case Kind::AisAidToNavigationPositionTimeseries:
                static_cast<const AisAidToNavigationPositionTimeseriesObject&>(data).WriteTo( destination );
                break;
            case Kind::GeoPosition3DTimeseries:
                static_cast<const GeoPosition3DTimeseriesObject&>(data).WriteTo( destination );
                break;
            case Kind::GuidTimeseries:
                static_cast<const GuidTimeseriesObject&>(data).WriteTo( destination );
                break;
            case Kind::Int16Timeseries:
                static_cast<const Int16TimeseriesObject&>(data).WriteTo( destination );
                break;
            case Kind::Int32Timeseries:
                static_cast<const Int32TimeseriesObject&>(data).WriteTo( destination );
                break;
            case Kind::RadarAzimuthOffsetTimeseries:
                static_cast<const RadarAzimuthOffsetTimeseriesObject&>(data).WriteTo( destination );
                break;
            case Kind::RadarFastTimeConstantLevelTimeseries:
                static_cast<const RadarFastTimeConstantLevelTimeseriesObject&>(data).WriteTo( destination );
                break;
            case Kind::RadarFastTimeConstantModeTimeseries:
                static_cast<const RadarFastTimeConstantModeTimeseriesObject&>(data).WriteTo( destination );
                break;
            case Kind::RadarPulseTimeseries:
                static_cast<const RadarPulseTimeseriesObject&>(data).WriteTo( destination );
                break;
            case Kind::RadarSector1EndTimeseries:
                static_cast<const RadarSector1EndTimeseriesObject&>(data).WriteTo( destination );
                break;
            case Kind::RadarSector1StartTimeseries:
                static_cast<const RadarSector1StartTimeseriesObject&>(data).WriteTo( destination );
                break;
            case Kind::RadarSector2EndTimeseries:
                static_cast<const RadarSector2EndTimeseriesObject&>(data).WriteTo( destination );
                break;
            case Kind::RadarSector2StartTimeseries:
                static_cast<const RadarSector2StartTimeseriesObject&>(data).WriteTo( destination );
                break;
            case Kind::RadarSensitivityTimeControlLevelTimeseries:
                static_cast<const RadarSensitivityTimeControlLevelTimeseriesObject&>(data).WriteTo( destination );
                break;
            case Kind::RadarTuningTimeseries:
                static_cast<const RadarTuningTimeseriesObject&>(data).WriteTo( destination );
                break;
            case Kind::VesselPersonsOnBoardTimeseries:
                static_cast<const VesselPersonsOnBoardTimeseriesObject&>(data).WriteTo( destination );
                break;
            case Kind::Int64Timeseries:
                static_cast<const Int64TimeseriesObject&>(data).WriteTo( destination );
                break;
            case Kind::Position2DTimeseries:
                static_cast<const Position2DTimeseriesObject&>(data).WriteTo( destination );
                break;
            case Kind::Position3DTimeseries:
                static_cast<const Position3DTimeseriesObject&>(data).WriteTo( destination );
                break;
            case Kind::ReferenceTimeseries:
                static_cast<const ReferenceTimeseriesObject&>(data).WriteTo( destination );
                break;
            case Kind::SByteTimeseries:
                static_cast<const SByteTimeseriesObject&>(data).WriteTo( destination );
                break;
            case Kind::SingleTimeseries:
                static_cast<const SingleTimeseriesObject&>(data).WriteTo( destination );
                break;
            case Kind::StringTimeseries:
                static_cast<const StringTimeseriesObject&>(data).WriteTo( destination );
                break;
            case Kind::TimeSpanTimeseries:
                static_cast<const TimeSpanTimeseriesObject&>(data).WriteTo( destination );
                break;
            case Kind::UInt16Timeseries:
                static_cast<const UInt16TimeseriesObject&>(data).WriteTo( destination );
                break;
            case Kind::UInt32Timeseries:
                static_cast<const UInt32TimeseriesObject&>(data).WriteTo( destination );
                break;
            case Kind::RadomeStatusTimeseries:
                static_cast<const RadomeStatusTimeseriesObject&>(data).WriteTo( destination );
                break;
            case Kind::UInt64Timeseries:
                static_cast<const UInt64TimeseriesObject&>(data).WriteTo( destination );
                break;
            case Kind::TimeseriesCatalog:
                static_cast<const TimeseriesCatalogObject&>(data).WriteTo( destination );
                break;
            case Kind::TimeseriesInfo:
                static_cast<const TimeseriesInfoObject&>(data).WriteTo( destination );
                break;
            case Kind::TimeSpanTimeseriesValue:
                static_cast<const TimeSpanTimeseriesValueObject&>(data).WriteTo( destination );
                break;
            case Kind::TrackableItemTrackLink:
                static_cast<const TrackableItemTrackLinkObject&>(data).WriteTo( destination );
                break;
            case Kind::Track:
                static_cast<const TrackObject&>(data).WriteTo( destination );
                break;
            case Kind::Track3D:
                static_cast<const Track3DObject&>(data).WriteTo( destination );
                break;
            case Kind::TrackerFilterParameters:
                static_cast<const TrackerFilterParametersObject&>(data).WriteTo( destination );
                break;
            case Kind::TrackerFilterParametersConfiguration:
                static_cast<const TrackerFilterParametersConfigurationObject&>(data).WriteTo( destination );
                break;
            case Kind::TrackInfo:
                static_cast<const TrackInfoObject&>(data).WriteTo( destination );
                break;
            case Kind::TrackingServiceOptions:
                static_cast<const TrackingServiceOptionsObject&>(data).WriteTo( destination );
                break;
            case Kind::TrackLink:
                static_cast<const TrackLinkObject&>(data).WriteTo( destination );
                break;
            case Kind::TrackValue:
                static_cast<const TrackValueObject&>(data).WriteTo( destination );
                break;
            case Kind::TrackValue3D:
                static_cast<const TrackValue3DObject&>(data).WriteTo( destination );
                break;
            case Kind::UInt16TimeseriesValue:
                static_cast<const UInt16TimeseriesValueObject&>(data).WriteTo( destination );
                break;
            case Kind::UInt32TimeseriesValue:
                static_cast<const UInt32TimeseriesValueObject&>(data).WriteTo( destination );
                break;
            case Kind::UInt64TimeseriesValue:
                static_cast<const UInt64TimeseriesValueObject&>(data).WriteTo( destination );
                break;
            case Kind::VehicleType:
                static_cast<const VehicleTypeObject&>(data).WriteTo( destination );
                break;
            case Kind::VesselType:
                static_cast<const VesselTypeObject&>(data).WriteTo( destination );
                break;
            case Kind::View:
                static_cast<const ViewObject&>(data).WriteTo( destination );
                break;
            case Kind::ViewCameraLink:
                static_cast<const ViewCameraLinkObject&>(data).WriteTo( destination );
                break;
            case Kind::ViewTrackerLink:
                static_cast<const ViewTrackerLinkObject&>(data).WriteTo( destination );
                break;
            case Kind::WeatherStationCommand:
                static_cast<const WeatherStationCommandObject&>(data).WriteTo( destination );
                break;
            case Kind::WeatherStationCommandReply:
                static_cast<const WeatherStationCommandReplyObject&>(data).WriteTo( destination );
                break;
            case Kind::WeatherStationConfiguration:
                static_cast<const WeatherStationConfigurationObject&>(data).WriteTo( destination );
                break;
            case Kind::CircularZone:
                static_cast<const CircularZoneObject&>(data).WriteTo( destination );
                break;
            case Kind::PolygonZone:
                static_cast<const PolygonZoneObject&>(data).WriteTo( destination );
                break;
            case Kind::ZoneExceptions:
                static_cast<const ZoneExceptionsObject&>(data).WriteTo( destination );
                break;
            case Kind::ZoneExceptionsVesselLink:
                static_cast<const ZoneExceptionsVesselLinkObject&>(data).WriteTo( destination );
                break;
            case Kind::ZoneTrackAlarm:
                static_cast<const ZoneTrackAlarmObject&>(data).WriteTo( destination );
                break;
        }
    }


}
#endif
