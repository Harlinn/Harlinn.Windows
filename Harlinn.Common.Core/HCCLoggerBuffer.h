#pragma once
#ifndef HCCLOGGERBUFFER_H_
#define HCCLOGGERBUFFER_H_
/*
   Copyright 2024-2025 Espen Harlinn

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.
*/

#include <HCCDef.h>
#include <HCCMemory.h>
#include <HCCDateTime.h>
#include <HCCGuid.h>
#include <HCCLogging.h>

namespace Harlinn::Common::Core::Logging
{
    class LogSite;
    class LogManager;
}

namespace Harlinn::Common::Core::Logging::Internal
{
    class RecordStream;
    class BufferManager;
#pragma pack(push,1)
    struct RecordHeader
    {
        /// <summary>
        /// size of record, excluding the size of Size itself.
        /// </summary>
        UInt32 Size;
        union
        {
            const LogSite* Site;
            UInt64 SiteId;
        };
        /// <summary>
        /// value returned by __rdtsc( )
        /// </summary>
        UInt64 Time;
    };
    constexpr size_t RecordHeaderSize = sizeof( RecordHeader );

    class BufferKey
    {
        Guid processId_;
        DateTime timestamp_;
        UInt32 threadId_ = 0;
        UInt64 sequenceNumber_ = 0;
    public:
        BufferKey()
        { }

        BufferKey( const Guid& processId, const DateTime& timestamp, UInt32 threadId, UInt64 sequenceNumber )
            : processId_( processId ), timestamp_( timestamp ), threadId_( threadId ), sequenceNumber_( sequenceNumber )
        {
        }

        void Assign( const Guid& processId, const DateTime& timeStamp, UInt32 threadId, UInt64 sequenceNumber )
        {
            processId_ = processId;
            timestamp_ = timeStamp;
            threadId_ = threadId;
            sequenceNumber_ = sequenceNumber;
        }

        auto operator<=>( const BufferKey& ) const = default;

        template<typename ReaderT>
        void Read( ReaderT& reader )
        {
            reader.Read( processId_ );
            reader.Read( timestamp_ );
            reader.Read( threadId_ );
            reader.Read( sequenceNumber_ );
        }

        template<typename WriterT>
        void Write( WriterT& writer )
        {
            writer.Write( processId_ );
            writer.Write( timestamp_ );
            writer.Write( threadId_ );
            writer.Write( sequenceNumber_ );
        }

        constexpr const Guid& ProcessId( ) const noexcept
        {
            return processId_;
        }
        constexpr void SetProcessId( const Guid& processId ) noexcept
        {
            processId_ = processId;
        }
        constexpr const DateTime& Timestamp( ) const noexcept
        {
            return timestamp_;
        }
        constexpr void SetTimestamp( const DateTime& timestamp ) noexcept
        {
            timestamp_ = timestamp;
        }
        constexpr UInt32 ThreadId( ) const noexcept
        {
            return threadId_;
        }
        constexpr void SetThreadId(UInt32 threadId ) noexcept
        {
            threadId_ = threadId;
        }
        constexpr UInt64 SequenceNumber( ) const noexcept
        {
            return sequenceNumber_;
        }
        constexpr void SetSequenceNumber( UInt64 sequenceNumber ) noexcept
        {
            sequenceNumber_ = sequenceNumber;
        }


    };
#pragma pack(pop)

    enum class BufferFlags : UInt64
    {
        None = 0,
        /// <summary>
        /// If this flag is true, then the Site member of the RecordHeader
        /// points to a Logging::LogSite object. Otherwise the SiteId member
        /// of the RecordHeader holds the id of a Logging::Types::LogSiteData
        /// object that can be retrieved from the storage.
        /// 
        /// When Buffer objects are initially serialized the storage mechanism
        /// must also make sure that each referenced Logging::LogSite is available
        /// from the underlying storage, as a Logging::Types::LogSiteData, using a 
        /// unique UInt64 key. This key must be assigned to the SiteId member of the 
        /// RecordHeader for each RecordHeader in the Buffer object
        /// before the data is written to the storage.
        /// </summary>
        RecordHeadersHasPointers = 0x00000001,
        /// <summary>
        /// When this flag is set it means that the there was not enough free space
        /// in the buffer to write a complete log entry, and that the data for the
        /// entry continues in the next Buffer object generated by the ThreadLogger. 
        /// </summary>
        LastRecordIsIncomplete = 0x00000002,
        /// <summary>
        /// When this flag is set it means that the there was not enough free space
        /// in the previous buffer generated by the ThreadLogger to write a complete log 
        /// entry, and that the data for the entry continues in this Buffer object. 
        /// </summary>
        FirstRecordIsIncomplete = 0x00000004,
        /// <summary>
        /// When this flag is set it means that this is the final Buffer written by
        /// the ThreadLogger. This usually means that the thread has exited, or, if
        /// the buffer was generated by the ThreadLogger for the main thread of the
        /// application - that the LoggerManager has stopped.
        /// </summary>
        Final = 0x00000008,
    };

    HCC_DEFINE_ENUM_FLAG_OPERATORS( BufferFlags, UInt64 );

    /// <summary>
    /// The ThreadLogger writes log information to Buffer objects.
    /// 
    /// The data is stored sequentially in the buffer object.
    /// 
    /// Log information may span multiple Buffer objects
    /// </summary>
    class Buffer 
    {
        friend class RecordStream;
    public:
        static constexpr size_t MaximumSize = 64 * 1024;
        using PrimaryKeyType = BufferKey;
    private:
        UInt32 referenceCount_ = 1;
        BufferManager* manager_ = nullptr;
        
        PrimaryKeyType primaryKey_;

        size_t size_ = 0;
        UInt64 recordCount_ = 0;
        UInt64 referenceRdtscCycle_ = 0;
        UInt64 rdtscCyclesPerTick_ = 0;
        BufferFlags flags_ = BufferFlags::RecordHeadersHasPointers;
        std::array<Byte, MaximumSize> data_{};
    public:
        Buffer( BufferManager* manager, UInt32 threadId, UInt64 sequenceNumber )
            : manager_( manager ), primaryKey_(Guid( ), DateTime::UtcNow( ), threadId, sequenceNumber ), recordCount_(0), referenceRdtscCycle_( __rdtsc( ) )
        { }

        Buffer( BufferManager* manager, const Guid& processId, UInt32 threadId, UInt64 sequenceNumber )
            : manager_( manager ), primaryKey_( processId, DateTime::UtcNow( ), threadId, sequenceNumber ), recordCount_( 0 ), referenceRdtscCycle_( __rdtsc( ) )
        { }


        UInt32 AddRef( ) noexcept
        {
            return InterlockedIncrement( &referenceCount_ );
        }
        
        UInt32 Release( ) noexcept;

        size_t StorageSize( ) const noexcept
        {
            return ( ( (const Byte*)&data_ ) - ( (const Byte*)&size_ ) ) + size_;
        }

        const Byte* Storage( ) const noexcept
        {
            return (const Byte*)&size_;
        }
        Byte* Storage( ) noexcept
        {
            return (Byte*)&size_;
        }


        constexpr size_t size( ) const noexcept
        {
            return size_;
        }

        constexpr size_t FreeCapacity( ) const noexcept
        {
            return MaximumSize - size_;
        }

        constexpr bool HasCapacity( size_t requestedCapacity ) const noexcept
        {
            return requestedCapacity <= FreeCapacity( );
        }


        constexpr Byte* data( ) noexcept
        {
            return data_.data( );
        }
        constexpr const Byte* data( ) const noexcept
        {
            return data_.data( );
        }

        RecordHeader* First( ) noexcept
        {
            return (RecordHeader*)data_.data( );
        }
        const RecordHeader* First( ) const noexcept
        {
            return (RecordHeader*)data_.data( );
        }

        RecordHeader* Next( RecordHeader* current ) noexcept
        {
            size_t recordSize = current->Size;
            return ( RecordHeader* )(((Byte*)current ) + recordSize + sizeof( RecordHeader::Size ) );
        }
        const RecordHeader* Next( const RecordHeader* current ) const noexcept
        {
            size_t recordSize = current->Size;
            return (const RecordHeader*)( ( (Byte*)current ) + recordSize + sizeof( RecordHeader::Size ) );
        }

        std::span<const Byte> DataOf( const RecordHeader* current ) const
        {
            size_t recordSize = current->Size;
            const Byte* start = reinterpret_cast< const Byte* >( current ) + Internal::RecordHeaderSize;
            size_t dataSize = recordSize - ( Internal::RecordHeaderSize - sizeof( RecordHeader::Size ) );
            return std::span<const Byte>( start, dataSize );
        }


        /// <summary>
        /// Returns true if the Site field of record headers contains pointers to
        /// LogSite objects. If false, the SiteId field of record headers identifies
        /// the LogSite in the storage.
        /// </summary>
        constexpr bool RecordHeadersHasPointers( ) const noexcept
        {
            return (flags_ & BufferFlags::RecordHeadersHasPointers) == BufferFlags::RecordHeadersHasPointers;
        }
        constexpr void SetRecordHeadersHasPointers( bool recordHeadersHasPointers ) noexcept
        {
            if ( recordHeadersHasPointers )
            {
                flags_ |= BufferFlags::RecordHeadersHasPointers;
            }
            else
            {
                flags_ &= ~BufferFlags::RecordHeadersHasPointers;
            }
        }

        /// <summary>
        /// Returns true if the data for the last record in the buffer continues
        /// in the next buffer generated by a ThreadLogger. 
        /// </summary>
        constexpr bool LastRecordIsIncomplete( ) const noexcept
        {
            return ( flags_ & BufferFlags::LastRecordIsIncomplete ) == BufferFlags::LastRecordIsIncomplete;
        }
        constexpr void SetLastRecordIsIncomplete( bool lastRecordIsIncomplete ) noexcept
        {
            if ( lastRecordIsIncomplete )
            {
                flags_ |= BufferFlags::LastRecordIsIncomplete;
            }
            else
            {
                flags_ &= ~BufferFlags::LastRecordIsIncomplete;
            }
        }

        constexpr bool FirstRecordIsIncomplete( ) const noexcept
        {
            return ( flags_ & BufferFlags::FirstRecordIsIncomplete ) == BufferFlags::FirstRecordIsIncomplete;
        }
        constexpr void SetFirstRecordIsIncomplete( bool firstRecordIsIncomplete ) noexcept
        {
            if ( firstRecordIsIncomplete )
            {
                flags_ |= BufferFlags::FirstRecordIsIncomplete;
            }
            else
            {
                flags_ &= ~BufferFlags::FirstRecordIsIncomplete;
            }
        }

        /// <summary>
        /// Returns true if this is the final Buffer generated by a ThreadLogger. 
        /// </summary>
        constexpr bool Final( ) const noexcept
        {
            return ( flags_ & BufferFlags::Final ) == BufferFlags::Final;
        }
        constexpr void SetFinal( bool final ) noexcept
        {
            if ( final )
            {
                flags_ |= BufferFlags::Final;
            }
            else
            {
                flags_ &= ~BufferFlags::Final;
            }
        }


        constexpr const PrimaryKeyType& PrimaryKey( ) const noexcept
        {
            return primaryKey_;
        }
        constexpr void SetPrimaryKey( const PrimaryKeyType& primaryKey ) noexcept
        {
            primaryKey_ = primaryKey;
        }

        constexpr const Guid& ProcessId( ) const noexcept
        {
            return primaryKey_.ProcessId();
        }
        constexpr void SetProcessId( const Guid& processId ) noexcept
        {
            primaryKey_.SetProcessId( processId );
        }
        constexpr const DateTime& Timestamp( ) const noexcept
        {
            return primaryKey_.Timestamp( );
        }
        constexpr void SetTimestamp( const DateTime& timestamp ) noexcept
        {
            primaryKey_.SetTimestamp( timestamp );
        }
        constexpr UInt32 ThreadId( ) const noexcept
        {
            return primaryKey_.ThreadId();
        }
        constexpr void SetThreadId( UInt32 threadId ) noexcept
        {
            primaryKey_.SetThreadId( threadId );
        }
        constexpr UInt64 SequenceNumber( ) const noexcept
        {
            return primaryKey_.SequenceNumber();
        }
        constexpr void SetSequenceNumber( UInt64 sequenceNumber ) noexcept
        {
            primaryKey_.SetSequenceNumber( sequenceNumber );
        }
        
        constexpr UInt64 RecordCount( ) const noexcept
        {
            return recordCount_;
        }

        constexpr void SetRecordCount( UInt64 recordCount ) noexcept
        {
            recordCount_ = recordCount;
        }

        constexpr UInt64 ReferenceRdtscCycle( ) const noexcept
        {
            return referenceRdtscCycle_;
        }
        void SetReferenceRdtscCycle( UInt64 referenceRdtscCycle )
        {
            referenceRdtscCycle_ = referenceRdtscCycle;
        }


        constexpr UInt64 RdtscCyclesPerTick( ) const noexcept
        {
            return rdtscCyclesPerTick_;
        }
        void SetRdtscCyclesPerTick( UInt64 rdtscCyclesPerTick )
        {
            rdtscCyclesPerTick_ = rdtscCyclesPerTick;
        }


    private:
        Int64 Write( const void* buffer, size_t bufferSize )
        {
            memcpy( data_.data( ) + size_, buffer, bufferSize );
            size_ += bufferSize;
            return bufferSize;
        }

        void WriteRecordSize( size_t recordStartOffset, UInt32 recordSize )
        {
            *( (UInt32*)( data_.data( ) + recordStartOffset ) ) = recordSize;
        }

        RecordHeader* GetRecordHeader( size_t recordStartOffset )
        {
            RecordHeader* result = reinterpret_cast< RecordHeader* >( data_.data( ) + recordStartOffset );
            return result;
        }

        const LogSite* GetLogSite( size_t recordStartOffset )
        {
            auto recordHeader = GetRecordHeader( recordStartOffset );
            return recordHeader->Site;
        }
    };
    
    using BufferPointer = ReferenceCountedPtr<Buffer>;


    class BufferManager
    {
    public:
        static constexpr size_t MaximumFreeBuffers = 32 * 1024;
        using StatisticsType = FixedSizeMemoryManagerStatistics;
    private:
        static constexpr size_t BlockSize = sizeof( Buffer );
        using MemoryManager = FixedSizeMemoryManager<BlockSize, MaximumFreeBuffers>;
        MemoryManager memoryManager_;
        LogManager* logManager_;
    public:
        BufferManager( LogManager* logManager )
            : logManager_( logManager )
        { }

        BufferPointer Allocate( UInt32 threadId, UInt64 sequenceNumber )
        {
            auto* mem = memoryManager_.Malloc( );
            return BufferPointer( new ( mem ) Buffer( this, threadId, sequenceNumber ) );
        }
        void Free( Buffer* buffer )
        {
            buffer->~Buffer( );
            memoryManager_.Free( buffer );
        }

        LogManager* LogManager( ) const noexcept
        {
            return logManager_;
        }

        [[nodiscard]] StatisticsType Statistics( ) const noexcept
        {
            return memoryManager_.Statistics( );
        }

    };


    inline UInt32 Buffer::Release( ) noexcept
    {
        auto result = InterlockedDecrement( &referenceCount_ );
        if ( result == 0 )
        {
            manager_->Free( this );
        }
        return result;
    }

    

    
}

namespace Harlinn::Common::Core::Logging
{
    class BufferHandler : public std::enable_shared_from_this<BufferHandler>
    {
    public:
        using Buffer = Internal::Buffer;
        using BufferPointer = Internal::BufferPointer;

        BufferHandler( ) = default;
        virtual ~BufferHandler( ) = default;

        virtual void Process( const BufferPointer& buffer ) noexcept = 0;

    };

    class LogRecord
    {
        UInt64 id_ = 0;
        Logging::Level level_ = Logging::Level::None;
        std::string_view formatString_;
        std::span<const Byte> argumentsDescriptor_;
        bool isFixedSize_ = false;
        size_t fixedSize_ = 0;
        UInt32 line_ = 0;
        UInt32 column_ = 0;
        std::string_view file_;
        std::string_view function_;
        Guid processId_;
        UInt32 threadId_ = 0;
        UInt64 bufferSequenceNumber_ = 0;
        DateTime referenceTimestamp_;
        UInt64 referenceRdtscCycle_ = 0;
        UInt64 rdtscCycle_ = 0;
        UInt64 rdtscCyclesPerTick_ = 0;
        std::span<const Byte> argumentsData_;
    public:
        using Buffer = Internal::Buffer;

        LogRecord( ) = default;

        template<typename LogSiteT>
        LogRecord( const LogSiteT& logSite, const Guid& processId, UInt32 threadId, UInt64 bufferSequenceNumber, DateTime referenceTimestamp, UInt64 referenceRdtscCycle, UInt64 rdtscCycle, UInt64 rdtscCyclesPerTick, std::span<const Byte> argumentsData )
            : id_( logSite.Id( ) ), level_( logSite.Level( ) ), formatString_( logSite.FormatString( ) ), argumentsDescriptor_( logSite.ArgumentsDescriptor( ) ), isFixedSize_( logSite.IsFixedSize( ) ), line_( logSite.Line( ) ), column_( logSite.Column( ) ), file_( logSite.File( ) ), function_( logSite.Function( ) ),
            processId_( processId ), threadId_( threadId ), bufferSequenceNumber_( bufferSequenceNumber ), referenceTimestamp_( referenceTimestamp ), referenceRdtscCycle_( referenceRdtscCycle ), rdtscCycle_( rdtscCycle ), rdtscCyclesPerTick_( rdtscCyclesPerTick ), argumentsData_( argumentsData )
        {
        }

        template<typename LogSiteT>
        LogRecord( const LogSiteT& logSite, const Buffer& buffer, UInt64 rdtscCycle, std::span<const Byte> argumentsData )
            : id_( logSite.Id( ) ), level_( logSite.Level( ) ), formatString_( logSite.FormatString( ) ), argumentsDescriptor_( logSite.ArgumentsDescriptor( ) ), isFixedSize_( logSite.IsFixedSize( ) ), line_( logSite.Line( ) ), column_( logSite.Column( ) ), file_( logSite.File( ) ), function_( logSite.Function( ) ),
            processId_( buffer.ProcessId( ) ), threadId_( buffer.ThreadId( ) ), bufferSequenceNumber_( buffer.SequenceNumber( ) ), referenceTimestamp_( buffer.Timestamp( ) ),
            referenceRdtscCycle_( buffer.ReferenceRdtscCycle( ) ), rdtscCycle_( rdtscCycle ), rdtscCyclesPerTick_( buffer.RdtscCyclesPerTick( ) ), argumentsData_( argumentsData )
        {
        }

        constexpr UInt64 Id( ) const noexcept
        {
            return id_;
        }
        /// <summary>
        /// The logging lvel of the LogRecord
        /// </summary>
        constexpr Logging::Level Level( ) const noexcept
        {
            return level_;
        }

        /// <summary>
        /// The format string of the LogRecord.
        /// 
        /// The format string can be passed to Persistent::Printer
        /// with the data returned from ArgumentsDescriptor( ) and
        /// ArgumentsData( ) to render a human readable representation
        /// into a stream.
        /// 
        /// This operation can performed using Logging::Formatters::TextFormatter.
        /// </summary>
        constexpr std::string_view FormatString( ) const noexcept
        {
            return formatString_;
        }

        /// <summary>
        /// This is the argument descriptor generated by Persistent::Describe
        /// that describes the data returned from ArgumentsData( ).
        /// </summary>
        constexpr std::span<const Byte> ArgumentsDescriptor( ) const noexcept
        {
            return argumentsDescriptor_;
        }

        /// <summary>
        /// Returns true if the arguments will always have the
        /// same size.
        /// </summary>
        constexpr bool IsFixedSize( ) const noexcept
        {
            return isFixedSize_;
        }

        /// <summary>
        /// If IsFixedSize() returns true, then this is the 
        /// fixed size of the arguments 
        /// </summary>
        constexpr size_t FixedSize( ) const noexcept
        {
            return fixedSize_;
        }
        /// <summary>
        /// The line number where the logging operation was performed.
        /// </summary>
        constexpr UInt32 Line( ) const noexcept
        {
            return line_;
        }
        /// <summary>
        /// The column where the logging operation was performed.
        /// </summary>
        constexpr UInt32 Column( ) const noexcept
        {
            return column_;
        }
        /// <summary>
        /// The name of the file where the logging operation was performed.
        /// </summary>
        constexpr std::string_view File( ) const noexcept
        {
            return file_;
        }
        /// <summary>
        /// The name of the function that performed the logging operation.
        /// </summary>
        constexpr std::string_view Function( ) const noexcept
        {
            return function_;
        }

        constexpr Guid ProcessId( ) const noexcept
        {
            return processId_;
        }

        /// <summary>
        /// The system thread id of the thread that performed the logging operation.
        /// </summary>
        constexpr UInt32 ThreadId( ) const noexcept
        {
            return threadId_;
        }

        /// <summary>
        /// The sequence number of the Buffer object that the log information was written to.
        /// </summary>
        constexpr UInt64 BufferSequenceNumber( ) const noexcept
        {
            return bufferSequenceNumber_;
        }

        ///<summary>
        /// This is the reference timestamp of the record
        ///</summary>
        constexpr DateTime ReferenceTimestamp( ) const noexcept
        {
            return referenceTimestamp_;
        }

        ///<summary>
        /// This is the value returned from __rdtsc() at
        /// the time when the value of referenceTimestamp_
        /// was generated.
        ///</summary>
        constexpr UInt64 ReferenceRdtscCycle( ) const noexcept
        {
            return referenceRdtscCycle_;
        }

        ///<summary>
        /// This is the value returned from from __rdtsc()
        /// at the time the entry was created by the ThreadLogger
        ///</summary>
        constexpr UInt64 RdtscCycle( ) const noexcept
        {
            return rdtscCycle_;
        }

        ///<summary>
        /// This is an approximation that calculates the
        /// timestamp for the log record based on the offset
        /// of the value returned from __rdtsc() at the
        /// time the entry was created by the ThreadLogger
        /// from the value stored in referenceRdtscCycle_.  
        ///</summary>
        constexpr DateTime Timestamp( ) const noexcept
        {
            if ( rdtscCycle_ > referenceRdtscCycle_ )
            {
                auto ticksSinceReference = static_cast<Int64>((rdtscCycle_ - referenceRdtscCycle_) / rdtscCyclesPerTick_);
                return DateTime( referenceTimestamp_.Ticks( ) + ticksSinceReference );
            }
            else
            {
                return referenceTimestamp_;
            }
        }

        ///<summary>
        /// This is the number of __rdtsc() cycles per
        /// DateTime 'tick'.
        ///</summary>
        constexpr UInt64 RdtscCyclesPerTick( ) const noexcept
        {
            return rdtscCyclesPerTick_;
        }

        ///<summary>
        /// This is the binary representation of the arguments passed to the
        /// various logging functions.
        ///</summary>
        constexpr std::span<const Byte> ArgumentsData( ) const noexcept
        {
            return argumentsData_;
        }
        
    };


    /// <summary>
    /// Base class for record handlers.
    /// 
    /// Record handlers can be added to a BufferConverter 
    /// </summary>
    class RecordHandler : public std::shared_ptr<RecordHandler>
    {
    public:
        RecordHandler( ) = default;
        virtual ~RecordHandler( ) = default;

        /// <summary>
        /// Called for each log record that can be completely
        /// decoded by the BufferConverter.
        /// </summary>
        virtual void Process( const LogRecord& logRecord ) noexcept = 0;

        /// <summary>
        /// Called when the BufferConverter detects that it has processed
        /// the final buffer from a ThreadLogger.
        /// </summary>
        virtual void Final( const Guid& processId, UInt32 threadId ) noexcept
        {

        }

    };



    namespace Internal
    {
        class ThreadKeyData
        {
            Guid processId_;
            UInt32 threadId_ = 0;
        public:
            ThreadKeyData( ) = default;
            ThreadKeyData( Guid processId, UInt32 threadId )
                : processId_( processId ), threadId_( threadId )
            { }

            ThreadKeyData( const BufferPointer& buffer )
                : processId_( buffer->ProcessId( ) ), threadId_( buffer->ThreadId( ) )
            { }

            auto operator<=>( const ThreadKeyData& ) const = default;

            void AddTo( XXH64Hasher& hasher ) const noexcept
            {
                hasher.Add( processId_ );
                hasher.Add( threadId_ );
            }

            size_t Hash( ) const noexcept
            {
                XXH64Hasher hasher;
                AddTo( hasher );
                auto result = hasher.Digest( );
                return result;
            }

            constexpr const Guid& ProcessId( ) const noexcept
            {
                return processId_;
            }
            void SetProcessId( const Guid& processId ) noexcept
            {
                processId_ = processId;
            }
            constexpr UInt32 ThreadId( ) const noexcept
            {
                return threadId_;
            }
            void SetThreadId( UInt32 threadId ) noexcept
            {
                threadId_ = threadId;
            }
        };
    }
}

namespace std
{
    template<> 
    struct hash<Harlinn::Common::Core::Logging::Internal::ThreadKeyData>
    {
        std::size_t operator()( const Harlinn::Common::Core::Logging::Internal::ThreadKeyData& s ) const noexcept
        {
            return s.Hash( );
        }
    };
}


namespace Harlinn::Common::Core::Logging
{
    using RecordHeader = Internal::RecordHeader;
    struct LogSiteExtractor
    {
        using LogSiteType = LogSite;
        using LogSitePointer = const LogSiteType*;
        LogSitePointer Extract( const RecordHeader& recordHeader )
        {
            return recordHeader.Site;
        }
    };

    using Buffer = Internal::Buffer;
    /// <summary>
    /// BufferConverter processes Buffer objects and converts the
    /// log entries in the buffer into LogRecord objects.
    /// 
    /// Add RecordHander implementations to the BufferConverter
    /// to process the individual records extracted from the buffer.
    /// </summary>
    template<typename LogSiteExtractorT, typename LoggerT = ConsoleLogger>
    class BufferConverter : public BufferHandler
    {
    public:
        using LoggerType = LoggerT;
        using LogSiteExtractorType = LogSiteExtractorT;
        using LogSiteType = typename LogSiteExtractorType::LogSiteType;
        using LogSitePointer = typename LogSiteExtractorType::LogSitePointer;
    private:
        using ThreadKeyData = Internal::ThreadKeyData;
        /// <summary>
        /// The data for a LogRecord may span multiple 
        /// Buffer objects. 
        /// </summary>
        struct ThreadData
        {
            Types::LogSiteData logSite_;
            Guid processId_;
            UInt32 threadId_ = 0;
            UInt64 bufferSequenceNumber_ = 0;
            DateTime referenceTimestamp_;
            UInt64 referenceRdtscCycle_ = 0;
            UInt64 rdtscCycle_ = 0;
            UInt64 rdtscCyclesPerTick_ = 0;
            std::vector<Byte> argumentsData_;

            ThreadData( const LogSiteType& logSite, const BufferPointer& buffer, UInt64 rdtscCycle, std::span<const Byte> argumentsData )
                : logSite_( logSite ), processId_( buffer->ProcessId() ), threadId_( buffer->ThreadId() ), 
                  bufferSequenceNumber_( buffer->SequenceNumber() ), referenceTimestamp_( buffer->Timestamp( ) ), 
                  referenceRdtscCycle_( buffer->ReferenceRdtscCycle( ) ), rdtscCycle_( rdtscCycle ), argumentsData_( argumentsData.data(), argumentsData.data() + argumentsData.size() )
            { }

            
        };
        using ThreadDataMap = std::unordered_map<ThreadKeyData, std::unique_ptr<ThreadData>>;
        std::unordered_map<ThreadKeyData, std::unique_ptr<ThreadData>> threadDataMap_;
        std::vector<std::shared_ptr<RecordHandler>> handlers_;
        LogSiteExtractorType& logSiteExtractor_;
        LoggerType& logger_;
    public:
        using RecordHeader = Internal::RecordHeader;
        BufferConverter( LogSiteExtractorType& logSiteExtractor, LoggerType& logger )
            : logSiteExtractor_( logSiteExtractor ), logger_( logger )
        { }


        virtual void Process( const BufferPointer& buffer ) noexcept override
        {
            Process( buffer, true );
        }
        /// <summary>
        /// Processes a Buffer, and routes the fully decoded LogRecords to the
        /// RecordHandler instances added to this BufferConverter.
        /// 
        /// Buffer objects must be passed in the order they were generated
        /// by a particular ThreadLogger. A single BufferConverter can process
        /// Buffer objects from multiple ThreadLogger instances.  
        /// </summary>
        void Process( const BufferPointer& buffer, bool ignoreMissingIncompleteRecord ) noexcept
        {
            auto recordCount = buffer->RecordCount( );
            if ( recordCount )
            {
                auto first = buffer->First( );
                if ( buffer->FirstRecordIsIncomplete( ) == false )
                {
                    ProcessRecords( buffer, first, recordCount );
                }
                else
                {
                    ThreadKeyData keyData( buffer );
                    auto it = threadDataMap_.find( keyData );
                    if ( it != threadDataMap_.end( ) )
                    {
                        MergeRecord( buffer, it, first, recordCount );
                    }
                    else if( ignoreMissingIncompleteRecord == false )
                    {
                        HCC_INFO_EX( logger_, "Buffer has incomplete first record, and the missing data is not buffered by this BufferConverter." );
                    }
                    if ( recordCount > 1 )
                    {
                        auto next = buffer->Next( first );
                        ProcessRecords( buffer, next, recordCount - 1);
                    }
                }
            }
        }
    private:
        void ProcessRecords( const BufferPointer& buffer, const RecordHeader* startHeader, size_t count )
        {
            const auto* currentHeader = startHeader;
            while ( count )
            {
                --count;
                ProcessRecord( buffer, currentHeader, count );
                if ( count )
                {
                    currentHeader = buffer->Next( currentHeader );
                }
            }
            if ( buffer->Final( ) )
            {
                DispatchFinal( buffer->ProcessId(), buffer->ThreadId() );
            }
        }

        void ProcessRecord( const BufferPointer& buffer, const RecordHeader* header, size_t remainingRecordsCount )
        {
            LogSitePointer logSite = logSiteExtractor_.Extract( *header );
            auto argumentsData = buffer->DataOf( header );
            
            if ( remainingRecordsCount == 0 && buffer->LastRecordIsIncomplete( ) )
            {
                ThreadKeyData keyData( buffer );
                auto threadData = std::make_unique<ThreadData>(*logSite, buffer, header->Time, argumentsData );
                threadDataMap_[ keyData ] = std::move( threadData );
            }
            else
            {
                LogRecord logRecord( *logSite, *buffer, header->Time, argumentsData );
                Dispatch( logRecord );
            }
        }

        void MergeRecord( const BufferPointer& buffer, ThreadDataMap::iterator threadDataIt, const RecordHeader* firstHeader, size_t count )
        {
            auto argumentsData = buffer->DataOf( firstHeader );
            ThreadData& threadData = *threadDataIt->second;
            threadData.argumentsData_.append_range( argumentsData );
            if ( count > 1 || buffer->LastRecordIsIncomplete( ) == false )
            {
                std::span<const Byte> argumentsData( threadData.argumentsData_.data( ), threadData.argumentsData_.size( ) );
                LogRecord logRecord( threadData.logSite_, threadData.processId_, threadData.threadId_, threadData.bufferSequenceNumber_, 
                    threadData.referenceTimestamp_, threadData.referenceRdtscCycle_, threadData.rdtscCycle_, threadData.rdtscCyclesPerTick_, argumentsData );
                Dispatch( logRecord );
                threadDataMap_.erase( threadDataIt );
            }
            if ( count == 1 && buffer->Final( ) )
            {
                DispatchFinal( buffer->ProcessId( ), buffer->ThreadId( ) );
            }

        }
    public:
        /// <summary>
        /// Adds a RecordHandler to this BufferConverter
        /// </summary>
        void Add( const std::shared_ptr<RecordHandler>& recordHandler )
        {
            auto it = std::find( handlers_.begin( ), handlers_.end( ), recordHandler );
            if ( it == handlers_.end( ) )
            {
                handlers_.emplace_back( recordHandler );
            }
        }

        /// <summary>
        /// Removes a RecordHandler from this BufferConverter
        /// </summary>
        void Remove( const std::shared_ptr<RecordHandler>& recordHandler )
        {
            auto it = std::find( handlers_.begin( ), handlers_.end( ), recordHandler );
            if ( it != handlers_.end( ) )
            {
                handlers_.erase( it );
            }
        }
    private:
        void Dispatch( const LogRecord& logRecord ) const noexcept
        {
            for ( const auto& handler : handlers_ )
            {
                handler->Process( logRecord );
            }
        }

        void DispatchFinal( const Guid& processId, UInt32 threadId ) const noexcept
        {
            for ( const auto& handler : handlers_ )
            {
                handler->Final( processId, threadId );
            }
        }


    };

}

#endif
