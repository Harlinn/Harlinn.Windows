#pragma once
#ifndef __HCCTYPEDESCRIPTORCURSOR_H__
#define __HCCTYPEDESCRIPTORCURSOR_H__
/*
   Copyright 2024-2025 Espen Harlinn

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.
*/

#include <HCCArray.h>
#include <HCCTuple.h>
#include <HCCVector.h>
#include <HCCPersistent.h>


namespace Harlinn::Common::Core::Persistent
{
    // This file contains the implementation of TypeDescriptorCursor.
    // TypeDescriptorCursor implements the functionality required to
    // decode a typedescriptor generated by Persistent::Descriptor.



    class TypeDescriptorCursor;

    // A type description starts with two 7-bit encoded numbers,
    // then follows a sequence of type description elements:
    // 
    //      1: [ cobined size of type description elements in bytes ]
    //      2: [ number of type description elements ]
    //      3  [ type description elements ]
    //
    // The maximum size size of an encoded number is 9 bytes:
    //      Values less or equal to 127 requires 1 byte
    //      Values greater than 127 and less or equal to 16383 requires 2 bytes
    //      Values greater than 16383 and less or equal to 2097151 requires 3 bytes
    //      Values greater than 2097151 and less or equal to 268435455 requires 4 bytes
    //      Values greater than 268435455 and less or equal to 34359738367 requires 5 bytes
    //      Values greater than 34359738367 and less or equal to 4398046511103 requires 6 bytes
    //      Values greater than 4398046511103 and less or equal to 562949953421311 requires 7 bytes
    //      Values greater than 562949953421311 and less or equal to 72057594037927935 requires 8 bytes
    //      Values greater than 72057594037927935 and less or equal to 0xFFFFFFFFFFFFFFFF requires 9 bytes
    //      Values greater than 0xFFFFFFFFFFFFFFFF are not supported
    //
    // 

    class Type
    {
        Byte typeId_ = 0;
        ModifierFlags modifiers_ = ModifierFlags::None;
    public:

        constexpr Type( Types::BasicTypeId basicType, ModifierFlags modifiers = ModifierFlags::None ) noexcept
            : typeId_( static_cast<Byte>( basicType ) ), modifiers_( modifiers )
        {
        }

        constexpr Type( Types::ContainerTypeId containerType, ModifierFlags modifiers = ModifierFlags::None ) noexcept
            : typeId_( static_cast<Byte>( containerType ) ), modifiers_( modifiers )
        {
        }

        constexpr Type( Types::TupleTypeId tupleType, ModifierFlags modifiers = ModifierFlags::None ) noexcept
            : typeId_( static_cast<Byte>( tupleType ) ), modifiers_( modifiers )
        {
        }

        constexpr Type( Types::UtilityTypeId utilityType, ModifierFlags modifiers = ModifierFlags::None ) noexcept
            : typeId_( static_cast<Byte>( utilityType ) ), modifiers_( modifiers )
        {
        }

        constexpr Type( Byte type, Byte modifiers ) noexcept
            : typeId_( type ), modifiers_( static_cast<ModifierFlags>( modifiers ) )
        {
        }

        constexpr void Assign( Types::BasicTypeId basicType, ModifierFlags modifiers ) noexcept
        {
            typeId_ = static_cast<Byte>( basicType );
            modifiers_ = modifiers;
        }

        constexpr void Assign( Types::ContainerTypeId containerType, ModifierFlags modifiers ) noexcept
        {
            typeId_ = static_cast<Byte>( containerType );
            modifiers_ = modifiers;
        }

        constexpr void Assign( Types::TupleTypeId tupleType, ModifierFlags modifiers ) noexcept
        {
            typeId_ = static_cast<Byte>( tupleType );
            modifiers_ = modifiers;
        }

        constexpr void Assign( Types::UtilityTypeId utilityType, ModifierFlags modifiers ) noexcept
        {
            typeId_ = static_cast<Byte>( utilityType );
            modifiers_ = modifiers;
        }


        constexpr void Assign( Byte type, Byte modifiers ) noexcept
        {
            typeId_ = type; 
            modifiers_ = static_cast<ModifierFlags>( modifiers );
        }


        constexpr Byte TypeId( ) const noexcept
        {
            return typeId_;
        }

        constexpr ModifierFlags Modifiers( ) const noexcept
        {
            return modifiers_;
        }

        constexpr bool IsUnknown( ) const noexcept
        {
            return typeId_ == 0;
        }

        constexpr bool IsKnownBasicType( ) const noexcept
        {
            return typeId_ >= static_cast<Byte>( Types::BasicTypeIdMin ) && typeId_ <= static_cast<Byte>( Types::BasicTypeIdMax );
        }

        constexpr bool IsKnownContainerType( ) const noexcept
        {
            return typeId_ >= static_cast<Byte>( Types::ContainerTypeIdMin ) && typeId_ <= static_cast<Byte>( Types::ContainerTypeIdMax );
        }
        constexpr bool IsKnownTupleType( ) const noexcept
        {
            return typeId_ >= static_cast<Byte>( Types::TupleTypeIdMin ) && typeId_ <= static_cast<Byte>( Types::TupleTypeIdMax );
        }
        constexpr bool IsKnownUtilityType( ) const noexcept
        {
            return typeId_ >= static_cast<Byte>( Types::UtilityTypeIdMin ) && typeId_ <= static_cast<Byte>( Types::UtilityTypeIdMax );
        }


        constexpr bool IsBasicType( ) const noexcept
        {
            return IsKnownBasicType( ) && Modifiers( ) == ModifierFlags::None;
        }
        constexpr bool IsBasicArrayType( ) const noexcept
        {
            return IsKnownBasicType( ) && Modifiers( ) == ModifierFlags::Array;
        }

        constexpr bool IsFixedSizeBasicArrayType( ) const noexcept
        {
            return IsKnownBasicType( ) && Modifiers( ) == (ModifierFlags::Array | ModifierFlags::Fixed);
        }

        constexpr bool IsArrayType( ) const noexcept
        {
            return (typeId_ == static_cast<Byte>( Types::ContainerTypeId::StdVector ) || 
                typeId_ == static_cast<Byte>( Types::ContainerTypeId::Vector ) ) && Modifiers( ) == ModifierFlags::Array;
        }
        constexpr bool IsFixedSizeArrayType( ) const noexcept
        {
            return ( typeId_ == static_cast<Byte>( Types::ContainerTypeId::StdArray ) ||
                typeId_ == static_cast<Byte>( Types::UtilityTypeId::Array ) ) && Modifiers( ) == ( ModifierFlags::Array | ModifierFlags::Fixed );
        }

        constexpr bool IsTupleType( ) const noexcept
        {
            return IsKnownTupleType( ) && Modifiers( ) == ModifierFlags::None;
        }

        constexpr bool IsTypeListType( ) const noexcept
        {
            return typeId_ == static_cast<Byte>( Types::UtilityTypeId::TypeList ) && Modifiers( ) == ModifierFlags::None;
        }

        constexpr bool IsAdaptedType( ) const noexcept
        {
            return typeId_ == static_cast<Byte>( Types::UtilityTypeId::Adapted ) && Modifiers( ) == ModifierFlags::None;
        }

        constexpr Types::BasicTypeId BasicTypeId( ) const noexcept
        {
            return static_cast<Types::BasicTypeId>( typeId_ );
        }
        constexpr Types::ContainerTypeId ContainerTypeId( ) const noexcept
        {
            return static_cast<Types::ContainerTypeId>( typeId_ );
        }
        constexpr Types::TupleTypeId TupleTypeId( ) const noexcept
        {
            return static_cast<Types::TupleTypeId>( typeId_ );
        }
        constexpr Types::UtilityTypeId UtilityTypeId( ) const noexcept
        {
            return static_cast<Types::UtilityTypeId>( typeId_ );
        }

    };
    constexpr size_t TypeSize = sizeof( Type );
    static_assert( TypeSize == 2 );


    class BasicType : public Type
    {
    public:
        using Base = Type;
    public:
        constexpr BasicType( Types::BasicTypeId basicType, ModifierFlags modifiers = ModifierFlags::None ) noexcept
            : Base( basicType, modifiers )
        {
        }
    };

    class BasicArrayType : public Type
    {
    public:
        using Base = Type;
    public:
        constexpr BasicArrayType( Types::BasicTypeId basicType, ModifierFlags modifiers = ModifierFlags::None ) noexcept
            : Base( basicType, modifiers )
        {
        }
    };



    class FixedSizeBasicArrayType : public BasicArrayType
    {
    public:
        using Base = BasicArrayType;
    private:
        size_t arraySize_ = 0;
    public:
        constexpr FixedSizeBasicArrayType( Types::BasicTypeId basicType, ModifierFlags modifiers, size_t arraySize ) noexcept
            : Base( basicType, modifiers ), arraySize_( arraySize )
        {
        }

        constexpr size_t ArraySize( ) const noexcept
        {
            return arraySize_;
        }

        constexpr void Assign( Types::BasicTypeId basicType, ModifierFlags modifiers, size_t arraySize ) noexcept
        {
            Base::Assign( basicType, modifiers );
            arraySize_ = arraySize;
        }

    };

    class ArrayType : public Type
    {
    public:
        using Base = Type;
    private:
        size_t descriptorByteSize_ = 0;
        size_t memberCount_ = 0;
        const Byte* descriptor_ = nullptr;
        size_t startOffset_ = 0;
    public:

        constexpr ArrayType( Types::UtilityTypeId typeId, ModifierFlags modifiers, size_t descriptorByteSize, size_t memberCount, const Byte* descriptor, size_t startOffset ) noexcept
            : Base( typeId, modifiers ), descriptorByteSize_( descriptorByteSize ), memberCount_( memberCount ), descriptor_( descriptor ), startOffset_( startOffset )
        {
        }

        constexpr void Assign( Types::UtilityTypeId typeId, ModifierFlags modifiers, size_t descriptorByteSize, size_t memberCount, const Byte* descriptor, size_t startOffset ) noexcept
        {
            Base::Assign( typeId, modifiers );
            descriptorByteSize_ = descriptorByteSize;
            memberCount_ = memberCount;
            descriptor_ = descriptor;
            startOffset_ = startOffset;
        }

        TypeDescriptorCursor Cursor( ) noexcept;

        constexpr size_t DescriptorByteSize( ) const noexcept
        {
            return descriptorByteSize_;
        }
        constexpr size_t MemberCount( ) const noexcept
        {
            return memberCount_;
        }
        constexpr const Byte* Descriptor( ) const noexcept
        {
            return descriptor_;
        }
        constexpr size_t StartOffset( ) const noexcept
        {
            return startOffset_;
        }
    };

    class FixedSizeArrayType : public ArrayType
    {
    public:
        using Base = ArrayType;
    private:
        size_t arraySize_ = 0;
    public:
        constexpr FixedSizeArrayType( Types::UtilityTypeId typeId, ModifierFlags modifiers, size_t descriptorByteSize, size_t elementCount, const Byte* descriptor, size_t startOffset, size_t arraySize ) noexcept
            : Base( typeId, modifiers, descriptorByteSize, elementCount, descriptor, startOffset ), arraySize_( arraySize )
        {
        }

        constexpr void Assign( Types::UtilityTypeId typeId, ModifierFlags modifiers, size_t descriptorByteSize, size_t memberCount, const Byte* descriptor, size_t startOffset, size_t arraySize ) noexcept
        {
            Base::Assign( typeId, modifiers, descriptorByteSize, memberCount, descriptor, startOffset );
            arraySize_ = arraySize;
        }

        constexpr size_t ArraySize( ) const noexcept
        {
            return arraySize_;
        }
    };




    class TupleType : public Type
    {
    public:
        using Base = Type;
    private:
        size_t descriptorByteSize_ = 0;
        size_t memberCount_ = 0;
        const Byte* descriptor_ = nullptr;
        size_t startOffset_ = 0;
    public:

        constexpr TupleType( Types::TupleTypeId typeId, ModifierFlags modifiers, size_t descriptorByteSize, size_t memberCount, const Byte* descriptor, size_t startOffset ) noexcept
            : Base( typeId, modifiers ), descriptorByteSize_( descriptorByteSize ), memberCount_( memberCount ), descriptor_( descriptor ), startOffset_( startOffset )
        {
        }

        constexpr void Assign( Types::UtilityTypeId typeId, ModifierFlags modifiers, size_t descriptorByteSize, size_t memberCount, const Byte* descriptor, size_t startOffset ) noexcept
        {
            Base::Assign( typeId, modifiers );
            descriptorByteSize_ = descriptorByteSize;
            memberCount_ = memberCount;
            descriptor_ = descriptor;
            startOffset_ = startOffset;
        }


        TypeDescriptorCursor Cursor( ) noexcept;

        constexpr size_t DescriptorByteSize( ) const noexcept
        {
            return descriptorByteSize_;
        }
        constexpr size_t MemberCount( ) const noexcept
        {
            return memberCount_;
        }
        constexpr const Byte* Descriptor( ) const noexcept
        {
            return descriptor_;
        }
        constexpr size_t StartOffset( ) const noexcept
        {
            return startOffset_;
        }
    };

    class TypeListType : public Type
    {
    public:
        using Base = Type;
    private:
        size_t descriptorByteSize_ = 0;
        size_t elementCount_ = 0;
        const Byte* descriptor_ = nullptr;
        size_t startOffset_ = 0;
    public:

        constexpr TypeListType( Types::UtilityTypeId typeId, ModifierFlags modifiers, size_t descriptorByteSize, size_t elementCount, const Byte* descriptor, size_t startOffset ) noexcept
            : Base( typeId, modifiers ), descriptorByteSize_( descriptorByteSize ), elementCount_( elementCount ), descriptor_( descriptor ), startOffset_( startOffset )
        {
        }

        constexpr void Assign( Types::UtilityTypeId typeId, ModifierFlags modifiers, size_t descriptorByteSize, size_t elementCount, const Byte* descriptor, size_t startOffset ) noexcept
        {
            Base::Assign( typeId, modifiers );
            descriptorByteSize_ = descriptorByteSize;
            elementCount_ = elementCount;
            descriptor_ = descriptor;
            startOffset_ = startOffset;
        }

        TypeDescriptorCursor Cursor( ) noexcept;

        constexpr size_t DescriptorByteSize( ) const noexcept
        {
            return descriptorByteSize_;
        }
        constexpr size_t ElementCount( ) const noexcept
        {
            return elementCount_;
        }
        constexpr const Byte* Descriptor( ) const noexcept
        {
            return descriptor_;
        }
        constexpr size_t StartOffset( ) const noexcept
        {
            return startOffset_;
        }
    };

    class AdaptedType : public Type
    {
    public:
        using Base = Type;
    private:
        size_t descriptorByteSize_ = 0;
        size_t memberCount_ = 0;
        const Byte* descriptor_ = nullptr;
        size_t startOffset_ = 0;
    public:

        constexpr AdaptedType( Types::UtilityTypeId typeId, ModifierFlags modifiers, size_t descriptorByteSize, size_t elementCount, const Byte* descriptor, size_t startOffset ) noexcept
            : Base( typeId, modifiers ), descriptorByteSize_( descriptorByteSize ), memberCount_( elementCount ), descriptor_( descriptor ), startOffset_( startOffset )
        {
        }

        constexpr void Assign( Types::UtilityTypeId typeId, ModifierFlags modifiers, size_t descriptorByteSize, size_t memberCount, const Byte* descriptor, size_t startOffset ) noexcept
        {
            Base::Assign( typeId, modifiers );
            descriptorByteSize_ = descriptorByteSize;
            memberCount_ = memberCount;
            descriptor_ = descriptor;
            startOffset_ = startOffset;
        }

        TypeDescriptorCursor Cursor( ) noexcept;

        constexpr size_t DescriptorByteSize( ) const noexcept
        {
            return descriptorByteSize_;
        }
        constexpr size_t MemberCount( ) const noexcept
        {
            return memberCount_;
        }
        constexpr const Byte* Descriptor( ) const noexcept
        {
            return descriptor_;
        }
        constexpr size_t StartOffset( ) const noexcept
        {
            return startOffset_;
        }
    };



    // 
    // A type description element start with a single byte that identifies
    // the type using values from Types::BasicTypeId or a value from the 
    // Persistent::ExtendedType enumeration.
    //
    // The next byte identifies the modifier value, from the BasicTypeModifier 
    // enumeration, for the type description element.
    // 
    // Type description elements with a type from the Types::BasicTypeId enumeration
    // and a modifier value of ::None, ::LengthPrefixedArray or ::Sequence is fully
    // described and requires only a single byte:
    //
    //      ::None indicates a single value of the given type 
    //      ::LengthPrefixedArray indicates an array of values prefixed by a 7-bit encoded number giving the number of elements in the array 
    //      ::Sequence that the data is formatted in a way that is encoded in a way that is suitable for comparing elements using memcmp 
    //
    // A type description element with the FixedSizeArray modifier is followed by a 7-bit encoded number giving the number of elements in the array.
    //


    class TypeDescriptorCursor
    {
        const Byte* descriptor_;
        size_t byteSize_ = 0;
        size_t size_ = 0;
        size_t offset_ = 0;
        size_t startOffset_ = 0;
        size_t position_ = 0;
    public:
        constexpr TypeDescriptorCursor( const Byte* descriptor ) noexcept
            : descriptor_( descriptor )
        {
            Initialize( );
        }

        constexpr TypeDescriptorCursor( const Byte* descriptor, size_t byteSize, size_t size, size_t startOffset ) noexcept
            : descriptor_( descriptor ), byteSize_( byteSize ), size_( size ), offset_( startOffset ), startOffset_( startOffset )
        {

        }

        template<typename ...Types>
        TypeDescriptorCursor( const Tuple<Types...>& descriptor ) noexcept
            : descriptor_( reinterpret_cast<const Byte*>( &descriptor) )
        {
            Initialize( );
        }


        constexpr void Reset( ) noexcept
        {
            size_ = 0;
            offset_ = 0;
            startOffset_ = 0;
            position_ = 0;
            Initialize( );
        }

        constexpr bool IsValid( ) const noexcept
        {
            return position_ < size_;
        }

        constexpr explicit operator bool( ) const noexcept
        {
            return IsValid( );
        }


        constexpr size_t ByteSize( ) const noexcept
        {
            return byteSize_;
        }
        constexpr size_t Size( ) const noexcept
        {
            return size_;
        }
        constexpr size_t Offset( ) const noexcept
        {
            return offset_;
        }
        constexpr size_t Position( ) const noexcept
        {
            return position_;
        }

        constexpr Type CurrentType( ) const noexcept
        {
            return Type( descriptor_[offset_], descriptor_[offset_ + 1] );
        }
        constexpr Byte TypeId( ) const noexcept
        {
            return descriptor_[offset_];
        }
        constexpr ModifierFlags Modifiers( ) const noexcept
        {
            return static_cast<ModifierFlags>( descriptor_[offset_ + 1] );
        }



        constexpr bool IsUnknown( ) const noexcept
        {
            return descriptor_[offset_] == 0;
        }
        constexpr bool IsKnownBasicType( ) const noexcept
        {
            return descriptor_[offset_] >= static_cast<Byte>( Types::BasicTypeIdMin ) && descriptor_[offset_] <= static_cast<Byte>( Types::BasicTypeIdMax );
        }

        constexpr bool IsKnownContainerType( ) const noexcept
        {
            return descriptor_[offset_] >= static_cast<Byte>( Types::ContainerTypeIdMin ) && descriptor_[offset_] <= static_cast<Byte>( Types::ContainerTypeIdMax );
        }
        constexpr bool IsKnownTupleType( ) const noexcept
        {
            return descriptor_[offset_] >= static_cast<Byte>( Types::TupleTypeIdMin ) && descriptor_[offset_] <= static_cast<Byte>( Types::TupleTypeIdMax );
        }

        constexpr bool IsKnownUtilityType( ) const noexcept
        {
            return descriptor_[offset_] >= static_cast<Byte>( Types::UtilityTypeIdMin ) && descriptor_[offset_] <= static_cast<Byte>( Types::UtilityTypeIdMax );
        }

        constexpr bool IsBasicType( ) const noexcept
        {
            return IsKnownBasicType( ) && Modifiers( ) == ModifierFlags::None;
        }
        constexpr bool IsBasicArrayType( ) const noexcept
        {
            return IsKnownBasicType( ) && Modifiers( ) == ModifierFlags::Array;
        }

        constexpr bool IsFixedSizeBasicArrayType( ) const noexcept
        {
            return IsKnownBasicType( ) && Modifiers( ) == ( ModifierFlags::Array | ModifierFlags::Fixed );
        }

        constexpr bool IsArrayType( ) const noexcept
        {
            return ( descriptor_[offset_] == static_cast<Byte>( Types::ContainerTypeId::StdVector ) ||
                descriptor_[offset_] == static_cast<Byte>( Types::ContainerTypeId::Vector ) ) && Modifiers( ) == ModifierFlags::Array;
        }
        constexpr bool IsFixedSizeArrayType( ) const noexcept
        {
            return ( descriptor_[offset_] == static_cast<Byte>( Types::ContainerTypeId::StdArray ) ||
                descriptor_[offset_] == static_cast<Byte>( Types::UtilityTypeId::Array ) ) && Modifiers( ) == ( ModifierFlags::Array | ModifierFlags::Fixed );
        }

        constexpr bool IsTupleType( ) const noexcept
        {
            return IsKnownTupleType( ) && Modifiers( ) == ModifierFlags::None;
        }

        constexpr bool IsTypeListType( ) const noexcept
        {
            return descriptor_[offset_] == static_cast<Byte>( Types::UtilityTypeId::TypeList ) && Modifiers( ) == ModifierFlags::None;
        }

        constexpr bool IsAdaptedType( ) const noexcept
        {
            return descriptor_[offset_] == static_cast<Byte>( Types::UtilityTypeId::Adapted ) && Modifiers( ) == ModifierFlags::None;
        }


        constexpr Types::BasicTypeId BasicTypeId( ) const noexcept
        {
            return static_cast<Types::BasicTypeId>( descriptor_[offset_] );
        }
        constexpr Types::ContainerTypeId ContainerTypeId( ) const noexcept
        {
            return static_cast<Types::ContainerTypeId>( descriptor_[offset_] );
        }
        constexpr Types::TupleTypeId TupleTypeId( ) const noexcept
        {
            return static_cast<Types::TupleTypeId>( descriptor_[offset_] );
        }
        constexpr Types::UtilityTypeId UtilityTypeId( ) const noexcept
        {
            return static_cast<Types::UtilityTypeId>( descriptor_[offset_] );
        }

        const Byte* StartElement( ) const noexcept
        {
            return &descriptor_[startOffset_];
        }
        const Byte* EndElement( ) const noexcept
        {
            return &descriptor_[startOffset_ + byteSize_];
        }

        const Byte* CurrentElement( ) const noexcept
        {
            return &descriptor_[offset_];
        }

        Persistent::BasicType ReadBasicType( ) noexcept
        {
            Persistent::BasicType result( static_cast<Types::BasicTypeId>( descriptor_[offset_] ), static_cast<ModifierFlags>( descriptor_[offset_ + 1] ) );
            offset_ += TypeSize;
            position_++;
            return result;
        }

        Persistent::BasicArrayType ReadBasicArrayType( ) noexcept
        {
            Persistent::BasicArrayType result( static_cast<Types::BasicTypeId>( descriptor_[offset_] ), static_cast<ModifierFlags>( descriptor_[offset_ + 1] ) );
            offset_ += TypeSize;
            position_++;
            return result;
        }

        FixedSizeBasicArrayType ReadFixedSizeBasicArrayType( ) noexcept
        {
            UInt64 arraySize = 0;
            size_t encodingSize = Core::Read7BitEncodedValue( &descriptor_[offset_ + TypeSize], 0, arraySize );
            FixedSizeBasicArrayType result( static_cast<Types::BasicTypeId>( descriptor_[offset_] ), static_cast<ModifierFlags>( descriptor_[offset_ + 1] ), arraySize );
            offset_ += TypeSize + encodingSize;
            position_++;
            return result;
        }


        ArrayType ReadArrayType( ) noexcept
        {
            UInt64 byteSize = 0;
            const Byte* elementDescriptor = &descriptor_[offset_ + TypeSize];
            size_t byteSizeEncodingSize = Core::Read7BitEncodedValue( elementDescriptor, 0, byteSize );
            UInt64 elementMemberCount = 0;
            size_t elementMemberCountEncodingSize = Core::Read7BitEncodedValue( &elementDescriptor[byteSizeEncodingSize], 0, elementMemberCount );
            size_t startOffset = byteSizeEncodingSize + elementMemberCountEncodingSize;
            ArrayType result( static_cast<Types::UtilityTypeId>( descriptor_[offset_] ), static_cast<ModifierFlags>( descriptor_[offset_ + 1] ), byteSize, elementMemberCount, elementDescriptor, startOffset );

            offset_ += TypeSize + startOffset + byteSize;
            position_++;

            return result;
        }

        FixedSizeArrayType ReadFixedSizeArrayType( ) noexcept
        {
            UInt64 elementDescriptorByteSize = 0;
            const Byte* elementDescriptor = &descriptor_[offset_ + TypeSize];
            size_t elementDescriptorByteSizeEncodingSize = Core::Read7BitEncodedValue( elementDescriptor, 0, elementDescriptorByteSize );
            UInt64 elementMemberCount = 0;
            size_t elementMemberCountEncodingSize = Core::Read7BitEncodedValue( &elementDescriptor[elementDescriptorByteSizeEncodingSize], 0, elementMemberCount );

            size_t startOffset = elementDescriptorByteSizeEncodingSize + elementMemberCountEncodingSize;

            UInt64 arraySize = 0;
            size_t arraySizeEncodingSize = Core::Read7BitEncodedValue( &elementDescriptor[startOffset + elementDescriptorByteSize], 0, arraySize );

            FixedSizeArrayType result( static_cast<Types::UtilityTypeId>( descriptor_[offset_] ), static_cast<ModifierFlags>( descriptor_[offset_ + 1] ), elementDescriptorByteSize, elementMemberCount, elementDescriptor, startOffset, arraySize );

            offset_ += TypeSize + startOffset + elementDescriptorByteSize + arraySizeEncodingSize;
            position_++;

            return result;
        }



        constexpr Persistent::TupleType ReadTupleType( ) noexcept
        {
            UInt64 byteSize = 0;
            const Byte* tupleDescriptor = &descriptor_[offset_ + TypeSize];
            size_t byteSizeEncodingSize = Core::Read7BitEncodedValue( tupleDescriptor, 0, byteSize );
            UInt64 tupleMemberCount = 0;
            size_t tupleMemberCountEncodingSize = Core::Read7BitEncodedValue( &tupleDescriptor[byteSizeEncodingSize], 0, tupleMemberCount );
            size_t startOffset = byteSizeEncodingSize + tupleMemberCountEncodingSize;
            Persistent::TupleType result( static_cast<Types::TupleTypeId>( descriptor_[offset_] ), static_cast<ModifierFlags>( descriptor_[offset_ + 1] ), byteSize, tupleMemberCount, tupleDescriptor, startOffset );

            offset_ += TypeSize + startOffset + byteSize;
            position_++;

            return result;
        }

        constexpr TypeListType ReadTypeListType( ) noexcept
        {
            UInt64 byteSize = 0;
            const Byte* tupleDescriptor = &descriptor_[offset_ + TypeSize];
            size_t byteSizeEncodingSize = Core::Read7BitEncodedValue( tupleDescriptor, 0, byteSize );
            UInt64 typeListElementCount = 0;
            size_t typeListElementCountEncodingSize = Core::Read7BitEncodedValue( &tupleDescriptor[byteSizeEncodingSize], 0, typeListElementCount );
            size_t startOffset = byteSizeEncodingSize + typeListElementCountEncodingSize;
            TypeListType result( static_cast<Types::UtilityTypeId>( descriptor_[offset_] ), static_cast<ModifierFlags>( descriptor_[offset_ + 1] ), byteSize, typeListElementCount, tupleDescriptor, startOffset );

            offset_ += TypeSize + startOffset + byteSize;
            position_++;

            return result;
        }

        constexpr AdaptedType ReadAdaptedType( ) noexcept
        {
            UInt64 byteSize = 0;
            const Byte* adaptedDescriptor = &descriptor_[offset_ + TypeSize];
            size_t byteSizeEncodingSize = Core::Read7BitEncodedValue( adaptedDescriptor, 0, byteSize );
            UInt64 adaptedMemberCount = 0;
            size_t adaptedMemberCountEncodingSize = Core::Read7BitEncodedValue( &adaptedDescriptor[byteSizeEncodingSize], 0, adaptedMemberCount );
            size_t startOffset = byteSizeEncodingSize + adaptedMemberCountEncodingSize;
            AdaptedType result( static_cast<Types::UtilityTypeId>( descriptor_[offset_] ), static_cast<ModifierFlags>( descriptor_[offset_ + 1] ), byteSize, adaptedMemberCount, adaptedDescriptor, startOffset );

            offset_ += TypeSize + startOffset + byteSize;
            position_++;

            return result;
        }



    private:
        constexpr void Initialize( ) noexcept
        {
            if ( descriptor_ )
            {
                UInt64 byteSize = 0;
                auto offset = Read7BitEncodedValue( descriptor_, 0, byteSize );
                UInt64 count = 0;
                offset += Read7BitEncodedValue( descriptor_, offset, count );
                byteSize_ = byteSize;
                size_ = count;
                offset_ = offset;
                startOffset_ = offset;
            }
        }
    public:

    };


    inline TypeDescriptorCursor ArrayType::Cursor( ) noexcept
    {
        return TypeDescriptorCursor( descriptor_, descriptorByteSize_, memberCount_, startOffset_ );
    }

    inline TypeDescriptorCursor TupleType::Cursor( ) noexcept
    {
        return TypeDescriptorCursor( descriptor_, descriptorByteSize_, memberCount_, startOffset_ );
    }
    inline TypeDescriptorCursor TypeListType::Cursor( ) noexcept
    {
        return TypeDescriptorCursor( descriptor_, descriptorByteSize_, elementCount_, startOffset_ );
    }
    inline TypeDescriptorCursor AdaptedType::Cursor( ) noexcept
    {
        return TypeDescriptorCursor( descriptor_, descriptorByteSize_, memberCount_, startOffset_ );
    }


}

#endif
