#pragma once
#ifndef HARLINN_COMMON_CORE_HCCPERSISTENTPRINTER_H_
#define HARLINN_COMMON_CORE_HCCPERSISTENTPRINTER_H_
/*
   Copyright 2024 Espen Harlinn

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.
*/

#include "HCCIO.h"
#include "HCCBinaryReader.h"
#include "HCCFormatStringParser.h"
#include "HCCTypeDescriptorCursor.h"

namespace Harlinn::Common::Core::Persistent
{
    template<typename CharT, IO::StreamReader ArgumentsStreamT = IO::MemoryStream, IO::StreamWriter DestinationStreamT = IO::MemoryStream>
    class Printer;

    template<SimpleStringLike StringT, IO::StreamReader ArgumentsStreamT, IO::StreamWriter DestinationStreamT>
    Printer(const StringT&, const Byte* argumentDescriptor, ArgumentsStreamT& argumentsStream, DestinationStreamT& destination ) -> Printer<typename StringT::value_type, ArgumentsStreamT, DestinationStreamT>;

    template<SimpleStringLike StringT, IO::StreamReader ArgumentsStreamT, IO::StreamWriter DestinationStreamT, typename ...Types>
    Printer( const StringT&, const Tuple<Types...>& argumentDescriptor, ArgumentsStreamT& argumentsStream, DestinationStreamT& destination ) -> Printer<typename StringT::value_type, ArgumentsStreamT, DestinationStreamT>;



    /// <summary>
    /// Uses a format string, a type descriptor generated by Persistent::Describe
    /// and serialized data written by Persistent::Write to generate a formatted
    /// text representation of the serialized data.
    /// </summary>
    /// <typeparam name="">The destination character type</typeparam>
    /// <typeparam name="">The arguments stream type</typeparam>
    /// <typeparam name="ArgumentsStreamT">The destination stream type</typeparam>
    template<typename CharT, IO::StreamReader ArgumentsStreamT, IO::StreamWriter DestinationStreamT>
    class Printer
    {
    public:
        using CharType = CharT;
        using DestinationStreamType = DestinationStreamT;
        using ArgumentsStreamType = ArgumentsStreamT;
    private:
        using FormatStringSectionType = Formatting::FormatStringSectionType;
        using Section = Formatting::FormatStringSection<CharType>;
        using FormatStringParser = Formatting::FormatStringParser<CharType>;
    public:
        using FormatStringView = typename FormatStringParser::StringViewType;
    private:
        using StringType = std::basic_string<CharType>;
        DestinationStreamType& stream_;
        TypeDescriptorCursor typeDescriptor_;
        FormatStringParser formatStringParser_;
        size_t argumentCount_ = 0;
        ArgumentsStreamType& argumentsStream_;
        IO::BinaryReader<ArgumentsStreamType> argumentReader_;
        size_t argumentIndex_ = 0;
        size_t sectionIndex_ = 0;
    public:
        Printer( const CharType* formatString, size_t formatStringLength, const Byte* argumentDescriptor, ArgumentsStreamType& argumentsStream, DestinationStreamType& destination )
            : formatStringParser_( formatString, formatStringLength ), typeDescriptor_( argumentDescriptor ), argumentsStream_( argumentsStream ), argumentReader_( argumentsStream_ ), stream_( destination )
        { }

        Printer( FormatStringView formatString, const Byte* argumentDescriptor, ArgumentsStreamType& argumentsStream, DestinationStreamType& destination )
            : formatStringParser_( formatString ), typeDescriptor_( argumentDescriptor ), argumentsStream_( argumentsStream ), argumentReader_( argumentsStream_ ), stream_( destination )
        { }

        template<SimpleStringLike StringT>
        Printer( const StringT& formatString, const Byte* argumentDescriptor, ArgumentsStreamType& argumentsStream, DestinationStreamType& destination )
            : formatStringParser_( FormatStringView( formatString.data( ), formatString.size( ) ) ), typeDescriptor_( argumentDescriptor ), argumentsStream_( argumentsStream ), argumentReader_( argumentsStream_ ), stream_( destination )
        { }

        template<typename ...Types>
        Printer( const CharType* formatString, size_t formatStringLength, const Tuple<Types...>& argumentDescriptor, ArgumentsStreamType& argumentsStream, DestinationStreamType& destination )
            : formatStringParser_( formatString, formatStringLength ), typeDescriptor_( argumentDescriptor ), argumentsStream_( argumentsStream ), argumentReader_( argumentsStream_ ), stream_( destination )
        { }

        template<typename ...Types>
        Printer( FormatStringView formatString, const Tuple<Types...>& argumentDescriptor, ArgumentsStreamType& argumentsStream, DestinationStreamType& destination )
            : formatStringParser_( formatString ), typeDescriptor_( argumentDescriptor ), argumentsStream_( argumentsStream ), argumentReader_( argumentsStream_ ), stream_( destination )
        { }

        template<SimpleStringLike StringT, typename ...Types>
        Printer( const StringT& formatString, const Tuple<Types...>& argumentDescriptor, ArgumentsStreamType& argumentsStream, DestinationStreamType& destination )
            : formatStringParser_( FormatStringView( formatString.data( ), formatString.size( ) ) ), typeDescriptor_( argumentDescriptor ), argumentsStream_( argumentsStream ), argumentReader_( argumentsStream_ ), stream_( destination )
        { }


        void Print( )
        {
            Print( std::locale::classic( ) );
        }

        void Print( const std::locale& locale )
        {
            auto typelist = typeDescriptor_.ReadTypeListType( );
            argumentCount_ = typelist.ElementCount( );
            auto typelistCursor = typelist.Cursor( );
            
            auto sectionCount = formatStringParser_.size( );
            for ( sectionIndex_ = 0; sectionIndex_ < sectionCount; ++sectionIndex_ )
            {
                
                PrintSection( typelistCursor, locale );
            }
        }
    private:
        void PrintSection( TypeDescriptorCursor& cursor, const std::locale& locale )
        {
            const auto& section = formatStringParser_[ sectionIndex_ ];
            if ( section.SectionType( ) == FormatStringSectionType::Text )
            {
                PrintTextSection( section );
            }
            else if ( section.SectionType( ) == FormatStringSectionType::Specification )
            {
                if ( argumentIndex_ < argumentCount_ )
                {
                    PrintSpecificationSection( cursor, locale, section );
                    argumentIndex_++;
                }
                else
                {
                    WriteMissingArgument( );
                }
            }
        }

        void WriteMissingArgument( )
        {
            if constexpr ( sizeof( CharType ) == 2 )
            {
                static const std::wstring_view missingArgument( L"<missing argument>" );
                Write( missingArgument.data( ), missingArgument.size( ) );
            }
            else
            {
                static const std::string_view missingArgument( "<missing argument>" );
                Write( missingArgument.data( ), missingArgument.size( ) );
            }
        }


        void Write( const CharType* data, size_t dataSize )
        {
            if ( dataSize )
            {
                stream_.Write( data, dataSize * sizeof(CharType) );
            }
        }
        void Write( const StringType& buffer )
        {
            Write( buffer.data(), buffer.size() );
        }

        void PrintTextSection( const Section& section )
        {
            const auto dataPtr = section.data( );
            const auto dataSize = section.size( );
            Write( dataPtr, dataSize );
        }

        void PrintSpecificationSection( TypeDescriptorCursor& cursor, const std::locale& locale, const Section& section )
        {
            if ( cursor.IsBasicType() )
            {
                PrintBasicType( cursor, locale, section );
            }
            else if ( cursor.IsFixedSizeBasicArrayType( ) )
            {
                PrintFixedSizeBasicArrayType( cursor, locale, section );
            }
            else if ( cursor.IsBasicArrayType( ) )
            {
                PrintBasicArrayType( cursor, locale, section );
            }
            else if ( cursor.IsFixedSizeArrayType( ) )
            {
                PrintFixedSizeArrayType( cursor, locale, section );
            }
            else if ( cursor.IsArrayType( ) )
            {
                PrintArrayType( cursor, locale, section );
            }
            else if ( cursor.IsTupleType( ) )
            {
                PrintTupleType( cursor, locale, section );
            }
            else if ( cursor.IsKnownUtilityType( ) )
            {
                PrintKnownUtilityType( cursor, locale, section );
            }
            else
            {
                printf( "Unknown type" );
            }
        }

        
        template<typename ...Args>
        void PrintBasicType( TypeDescriptorCursor& cursor, Args&& ... args )
        {
            auto basicType = cursor.ReadBasicType( );
            auto basicTypeId = basicType.BasicTypeId( );
            switch ( basicTypeId )
            {
                case Types::BasicTypeId::Boolean:
                {
                    PrintBoolean( cursor, std::forward<Args>( args )... );
                }
                break;
                case Types::BasicTypeId::Char:
                {
                    PrintChar( cursor, std::forward<Args>( args )... );
                }
                break;
                case Types::BasicTypeId::SByte:
                {
                    PrintSByte( cursor, std::forward<Args>( args )... );
                }
                break;
                case Types::BasicTypeId::Byte:
                {
                    PrintByte( cursor, std::forward<Args>( args )... );
                }
                break;
                case Types::BasicTypeId::WChar:
                {
                    PrintWChar( cursor, std::forward<Args>( args )... );
                }
                break;
                case Types::BasicTypeId::Int16:
                {
                    PrintInt16( cursor, std::forward<Args>( args )... );
                }
                break;
                case Types::BasicTypeId::UInt16:
                {
                    PrintUInt16( cursor, std::forward<Args>( args )... );
                }
                break;
                case Types::BasicTypeId::Int32:
                {
                    PrintInt32( cursor, std::forward<Args>( args )... );
                }
                break;
                case Types::BasicTypeId::UInt32:
                {
                    PrintUInt32( cursor, std::forward<Args>( args )... );
                }
                break;
                case Types::BasicTypeId::Int64:
                {
                    PrintInt64( cursor, std::forward<Args>( args )... );
                }
                break;
                case Types::BasicTypeId::UInt64:
                {
                    PrintUInt64( cursor, std::forward<Args>( args )... );
                }
                break;
                case Types::BasicTypeId::Single:
                {
                    PrintSingle( cursor, std::forward<Args>( args )... );
                }
                break;
                case Types::BasicTypeId::Double:
                {
                    PrintDouble( cursor, std::forward<Args>( args )... );
                }
                break;
                case Types::BasicTypeId::TimeSpan:
                {
                    PrintTimeSpan( cursor, std::forward<Args>( args )... );
                }
                break;
                case Types::BasicTypeId::DateTime:
                {
                    PrintDateTime( cursor, std::forward<Args>( args )... );
                }
                break;
                case Types::BasicTypeId::Currency:
                {
                    PrintCurrency( cursor, std::forward<Args>( args )... );
                }
                break;
                case Types::BasicTypeId::Guid:
                {
                    PrintGuid( cursor, std::forward<Args>( args )... );
                }
                break;
            }
        }

        template<typename ArgT>
        void PrintValue( TypeDescriptorCursor& cursor, const std::locale& locale, const std::basic_string_view<CharType> fmt )
        {
            auto value = argumentReader_.Read<ArgT>( );
            StringType buffer;
            if constexpr ( sizeof( CharType ) == 2 )
            {
                std::vformat_to( std::back_inserter( buffer ), locale, fmt, std::make_wformat_args( value ) );
            }
            else
            {
                std::vformat_to( std::back_inserter( buffer ), locale, fmt, std::make_format_args( value ) );
            }
            Write( buffer );
        }

        template<typename ArgT>
        void PrintValue( TypeDescriptorCursor& cursor, const std::locale& locale, const Section& section )
        {
            std::basic_string_view fmt( section );
            PrintValue<ArgT>( cursor, locale, fmt );
        }

        template<typename ArgT>
        void PrintValue( TypeDescriptorCursor& cursor, const std::locale& locale )
        {
            if constexpr ( sizeof( CharType ) == 2 )
            {
                constexpr std::wstring_view fmt( L"{}" );
                PrintValue<ArgT>( cursor, locale, fmt );
            }
            else
            {
                constexpr std::string_view fmt( "{}" );
                PrintValue<ArgT>( cursor, locale, fmt );
            }
        }


        void PrintBoolean( TypeDescriptorCursor& cursor, const std::locale& locale, const Section& section )
        {
            PrintValue<bool>( cursor, locale, section );
        }
        void PrintBoolean( TypeDescriptorCursor& cursor, const std::locale& locale )
        {
            PrintValue<bool>( cursor, locale );
        }


        void PrintChar( TypeDescriptorCursor& cursor, const std::locale& locale, const Section& section )
        {
            PrintValue<char>( cursor, locale, section );
        }

        void PrintChar( TypeDescriptorCursor& cursor, const std::locale& locale )
        {
            PrintValue<char>( cursor, locale );
        }

        void PrintSByte( TypeDescriptorCursor& cursor, const std::locale& locale, const Section& section )
        {
            PrintValue<SByte>( cursor, locale, section );
        }

        void PrintSByte( TypeDescriptorCursor& cursor, const std::locale& locale )
        {
            PrintValue<SByte>( cursor, locale );
        }

        void PrintByte( TypeDescriptorCursor& cursor, const std::locale& locale, const Section& section )
        {
            PrintValue<Byte>( cursor, locale, section );
        }

        void PrintByte( TypeDescriptorCursor& cursor, const std::locale& locale )
        {
            PrintValue<Byte>( cursor, locale );
        }

        void PrintWChar( TypeDescriptorCursor& cursor, const std::locale& locale, const Section& section )
        {
            //PrintValue<wchar_t>( cursor, locale, section );
        }

        void PrintWChar( TypeDescriptorCursor& cursor, const std::locale& locale )
        {
            //PrintValue<wchar_t>( cursor, locale  );
        }

        void PrintInt16( TypeDescriptorCursor& cursor, const std::locale& locale, const Section& section )
        {
            PrintValue<Int16>( cursor, locale, section );
        }
        void PrintInt16( TypeDescriptorCursor& cursor, const std::locale& locale )
        {
            PrintValue<Int16>( cursor, locale );
        }


        void PrintUInt16( TypeDescriptorCursor& cursor, const std::locale& locale, const Section& section )
        {
            PrintValue<UInt16>( cursor, locale, section );
        }
        void PrintUInt16( TypeDescriptorCursor& cursor, const std::locale& locale )
        {
            PrintValue<UInt16>( cursor, locale );
        }


        void PrintInt32( TypeDescriptorCursor& cursor, const std::locale& locale, const Section& section )
        {
            PrintValue<Int32>( cursor, locale, section );
        }
        void PrintInt32( TypeDescriptorCursor& cursor, const std::locale& locale )
        {
            PrintValue<Int32>( cursor, locale );
        }


        void PrintUInt32( TypeDescriptorCursor& cursor, const std::locale& locale, const Section& section )
        {
            PrintValue<UInt32>( cursor, locale, section );
        }

        void PrintUInt32( TypeDescriptorCursor& cursor, const std::locale& locale )
        {
            PrintValue<UInt32>( cursor, locale );
        }

        void PrintInt64( TypeDescriptorCursor& cursor, const std::locale& locale, const Section& section )
        {
            PrintValue<Int64>( cursor, locale, section );
        }

        void PrintInt64( TypeDescriptorCursor& cursor, const std::locale& locale )
        {
            PrintValue<Int64>( cursor, locale );
        }

        void PrintUInt64( TypeDescriptorCursor& cursor, const std::locale& locale, const Section& section )
        {
            PrintValue<UInt64>( cursor, locale, section );
        }
        void PrintUInt64( TypeDescriptorCursor& cursor, const std::locale& locale )
        {
            PrintValue<UInt64>( cursor, locale );
        }


        void PrintSingle( TypeDescriptorCursor& cursor, const std::locale& locale, const Section& section )
        {
            PrintValue<float>( cursor, locale, section );
        }
        void PrintSingle( TypeDescriptorCursor& cursor, const std::locale& locale )
        {
            PrintValue<float>( cursor, locale );
        }


        void PrintDouble( TypeDescriptorCursor& cursor, const std::locale& locale, const Section& section )
        {
            PrintValue<double>( cursor, locale, section );
        }
        void PrintDouble( TypeDescriptorCursor& cursor, const std::locale& locale )
        {
            PrintValue<double>( cursor, locale );
        }


        void PrintTimeSpan( TypeDescriptorCursor& cursor, const std::locale& locale, const Section& section )
        {
            PrintValue<TimeSpan>( cursor, locale, section );
        }
        void PrintTimeSpan( TypeDescriptorCursor& cursor, const std::locale& locale )
        {
            PrintValue<TimeSpan>( cursor, locale );
        }


        void PrintDateTime( TypeDescriptorCursor& cursor, const std::locale& locale, const Section& section )
        {
            PrintValue<DateTime>( cursor, locale, section );
        }
        void PrintDateTime( TypeDescriptorCursor& cursor, const std::locale& locale )
        {
            PrintValue<DateTime>( cursor, locale );
        }


        void PrintCurrency( TypeDescriptorCursor& cursor, const std::locale& locale, const Section& section )
        {
            auto value = argumentReader_.Read<Currency>( );
            if constexpr ( sizeof( CharType ) == 2 )
            {
                auto str = value.ToWideString( );
                Write( str.data( ), str.size( ) );
            }
            else
            {
                auto str = value.ToAnsiString( );
                Write( str.data( ), str.size( ) );
            }
            //PrintValue<Currency>( cursor, section );
        }
        void PrintCurrency( TypeDescriptorCursor& cursor, const std::locale& locale )
        {
            auto value = argumentReader_.Read<Currency>( );
            if constexpr ( sizeof( CharType ) == 2 )
            {
                auto str = value.ToWideString( );
                Write( str.data( ), str.size( ) );
            }
            else
            {
                auto str = value.ToAnsiString( );
                Write( str.data( ), str.size( ) );
            }
            //PrintValue<Currency>( cursor, section );
        }


        void PrintGuid( TypeDescriptorCursor& cursor, const std::locale& locale, const Section& section )
        {
            auto value = argumentReader_.Read<Guid>( );
            if constexpr ( sizeof( CharType ) == 2 )
            {
                auto str = value.ToString( );
                Write( str.data(), str.size() );
            }
            else
            {
                auto str = value.ToAnsiString( );
                Write( str.data( ), str.size( ) );
            }

            //PrintValue<Guid>( cursor, section );
        }
        void PrintGuid( TypeDescriptorCursor& cursor, const std::locale& locale )
        {
            auto value = argumentReader_.Read<Guid>( );
            if constexpr ( sizeof( CharType ) == 2 )
            {
                auto str = value.ToString( );
                Write( str.data( ), str.size( ) );
            }
            else
            {
                auto str = value.ToAnsiString( );
                Write( str.data( ), str.size( ) );
            }

            //PrintValue<Guid>( cursor, section );
        }


        void PrintFixedSizeBasicArrayType( TypeDescriptorCursor& cursor, const std::locale& locale, const Section& section )
        {
            Persistent::FixedSizeBasicArrayType fixedSizeBasicArrayType = cursor.ReadFixedSizeBasicArrayType( );
            auto basicTypeId = fixedSizeBasicArrayType.BasicTypeId( );
            auto arraySize = fixedSizeBasicArrayType.ArraySize( );
            PrintBasicArrayType( cursor, basicTypeId, arraySize, locale, section );
        }

        void PrintBasicArrayType( TypeDescriptorCursor& cursor, const std::locale& locale, const Section& section )
        {
            Persistent::BasicArrayType basicArrayType = cursor.ReadBasicArrayType( );
            auto basicTypeId = basicArrayType.BasicTypeId( );
            auto arraySize = argumentReader_.Read7BitEncoded( );
            PrintBasicArrayType( cursor, basicTypeId, arraySize, locale, section );
        }

        void PrintBasicArrayType( TypeDescriptorCursor& cursor, Types::BasicTypeId basicTypeId,size_t arraySize, const std::locale& locale, const Section& section )
        {
            switch ( basicTypeId )
            {
                case Types::BasicTypeId::Boolean:
                {
                    PrintBasicValues<bool>( cursor, arraySize, locale, section );
                }
                break;
                case Types::BasicTypeId::Char:
                {
                    PrintString<char>( cursor, arraySize, locale, section );
                }
                break;
                case Types::BasicTypeId::SByte:
                {
                    PrintBasicValues<SByte>( cursor, arraySize, locale, section );
                }
                break;
                case Types::BasicTypeId::Byte:
                {
                    PrintBasicValues<Byte>( cursor, arraySize, locale, section );
                }
                break;
                case Types::BasicTypeId::WChar:
                {
                    PrintString<wchar_t>( cursor, arraySize, locale, section );
                }
                break;
                case Types::BasicTypeId::Int16:
                {
                    PrintBasicValues<Int16>( cursor, arraySize, locale, section );
                }
                break;
                case Types::BasicTypeId::UInt16:
                {
                    PrintBasicValues<UInt16>( cursor, arraySize, locale, section );
                }
                break;
                case Types::BasicTypeId::Int32:
                {
                    PrintBasicValues<Int32>( cursor, arraySize, locale, section );
                }
                break;
                case Types::BasicTypeId::UInt32:
                {
                    PrintBasicValues<UInt32>( cursor, arraySize, locale, section );
                }
                break;
                case Types::BasicTypeId::Int64:
                {
                    PrintBasicValues<Int64>( cursor, arraySize, locale, section );
                }
                break;
                case Types::BasicTypeId::UInt64:
                {
                    PrintBasicValues<UInt64>( cursor, arraySize, locale, section );
                }
                break;
                case Types::BasicTypeId::Single:
                {
                    PrintBasicValues<float>( cursor, arraySize, locale, section );
                }
                break;
                case Types::BasicTypeId::Double:
                {
                    PrintBasicValues<double>( cursor, arraySize, locale, section );
                }
                break;
                case Types::BasicTypeId::TimeSpan:
                {
                    PrintBasicValues<TimeSpan>( cursor, arraySize, locale, section );
                }
                break;
                case Types::BasicTypeId::DateTime:
                {
                    PrintBasicValues<DateTime>( cursor, arraySize, locale, section );
                }
                break;
                case Types::BasicTypeId::Currency:
                {
                    //PrintBasicValues<Currency>( cursor, arraySize, locale, section );
                }
                break;
                case Types::BasicTypeId::Guid:
                {
                    //PrintBasicValues<Guid>( cursor, arraySize, locale, section );
                }
                break;
            }
        }

        void PrintFixedSizeArrayType( TypeDescriptorCursor& cursor, const std::locale& locale, const Section& section )
        {
            auto containerTypeId = cursor.ContainerTypeId( );
            switch ( containerTypeId )
            {
                case Types::ContainerTypeId::StdBasicString:
                    break;
            }
        }

        template<typename CharT2>
        void PrintString( TypeDescriptorCursor& cursor, size_t size, const std::locale& locale, const std::basic_string_view<CharType> fmt )
        {
            StringType buffer;
            if constexpr ( sizeof( CharType ) == 2 )
            {
                if constexpr ( sizeof( CharT2 ) == 2 )
                {
                    std::wstring value( size, L'\x0' );
                    argumentReader_.Read( value.data( ), size * sizeof( wchar_t ) );
                    std::vformat_to( std::back_inserter( buffer ), locale, fmt, std::make_wformat_args( value ) );
                }
                else
                {
                    std::string value( size, L'\x0' );
                    argumentReader_.Read( value.data( ), size );
                    auto wvalue = ToWideString( value );
                    std::vformat_to( std::back_inserter( buffer ), locale, fmt, std::make_wformat_args( wvalue ) );
                }
            }
            else
            {
                if constexpr ( sizeof( CharT2 ) == 2 )
                {
                    std::wstring wvalue( size, '\x0' );
                    argumentReader_.Read( wvalue.data( ), size * sizeof(wchar_t) );
                    std::string value = ToAnsiString<std::string>( wvalue );
                    std::vformat_to( std::back_inserter( buffer ), locale, fmt, std::make_format_args( value ) );
                }
                else
                {
                    std::string value( size, '\x0' );
                    argumentReader_.Read( value.data( ), size );
                    std::vformat_to( std::back_inserter( buffer ), locale, fmt, std::make_format_args( value ) );
                }
            }
            Write( buffer );
        }
        template<typename CharT2>
        void PrintString( TypeDescriptorCursor& cursor, size_t size, const std::locale& locale, const Section& section )
        {
            std::basic_string_view fmt( section );
            PrintString<CharT2>( cursor, size, locale, fmt );
        }

        template<typename ValueT>
        void PrintBasicValues( TypeDescriptorCursor& cursor, size_t size, const std::locale& locale, const std::basic_string_view<CharType> fmt )
        {
            if ( size )
            {
                CharType start[ ] = { static_cast< CharType >( '{' ) };
                CharType separator[ ] = { static_cast< CharType >( ';' ) };
                Write( start, 1 );
                size_t i = 0;
                for ( ; i < size - 1; ++i )
                {
                    PrintValue<ValueT>( cursor, locale, fmt );
                    Write( separator, 1 );
                }
                PrintValue<ValueT>( cursor, locale, fmt );
                CharType end[ ] = { static_cast< CharType >( '}' ) };
                Write( end, 1 );
            }
            else
            {
                CharType empty[ ] = { static_cast< CharType >( '{' ), static_cast< CharType >( '}' ) };
                Write( empty, 2 );
            }
        }
        template<typename ValueT>
        void PrintBasicValues( TypeDescriptorCursor& cursor, size_t size, const std::locale& locale, const Section& section )
        {
            std::basic_string_view fmt( section );
            PrintBasicValues<ValueT>( cursor, size, locale, fmt );
        }


        void PrintArrayType( TypeDescriptorCursor& cursor, const std::locale& locale, const Section& section )
        {
            auto containerTypeId = cursor.ContainerTypeId( );
            switch ( containerTypeId )
            {
                case Types::ContainerTypeId::StdBasicString:
                    break;
            }

        }


        void PrintTupleType( TypeDescriptorCursor& cursor, const std::locale& locale, const Section& section )
        {

        }

        void PrintKnownUtilityType( TypeDescriptorCursor& cursor, const std::locale& locale, const Section& section )
        {

        }



    };
}



#endif
