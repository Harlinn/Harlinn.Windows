#pragma once
#ifndef __HCCHTTP_H__
#define __HCCHTTP_H__
/*
   Copyright 2024-2025 Espen Harlinn

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.
*/

#include <HCCDef.h>
#include <HCCDateTime.h>
#include <HCCString.h>
#include <HCCGuid.h>
#include <HCCIOContext.h>


#pragma pack(push,8)
#pragma comment(lib,"Httpapi.lib")

namespace Harlinn::Common::Core::Http
{

    enum class InitializeFlags : UInt32
    {
        None = 0,
        /// <summary>
        /// Initializes the HTTP API layer and driver for
        /// applications using server APIs.
        /// </summary>
        Server = HTTP_INITIALIZE_SERVER,
        /// <summary>
        /// Initializes the HTTP API layer and driver for
        /// applications using HTTP configuration APIs.
        /// </summary>
        Config = HTTP_INITIALIZE_CONFIG,
    };

    HCC_DEFINE_ENUM_FLAG_OPERATORS( InitializeFlags, UInt32 );

    enum class ServerProperty
    {
        /// <summary>
        /// Used for enabling server side authentication.
        /// </summary>
        Authentication = HttpServerAuthenticationProperty,

        /// <summary>
        /// Used for enabling logging.
        /// </summary>
        Logging = HttpServerLoggingProperty,

        /// <summary>
        /// Used for setting QoS properties.
        /// </summary>
        Qos = HttpServerQosProperty,

        /// <summary>
        /// Used for configuring timeouts.
        /// </summary>
        Timeouts = HttpServerTimeoutsProperty,

        /// <summary>
        /// Used for limiting request queue lengths.
        /// </summary>
        QueueLength = HttpServerQueueLengthProperty,

        /// <summary>
        /// Used for manipulating the state.
        /// </summary>
        State = HttpServerStateProperty,

        /// <summary>
        /// Used for modifying the verbosity level of 503 type responses
        /// generated by server side API.
        /// </summary>
        Verbosity503 = HttpServer503VerbosityProperty,

        /// <summary>
        /// Used for manipulating Url Group to Request Queue association.
        /// </summary>
        Binding = HttpServerBindingProperty,

        /// <summary>
        /// Extended authentication property.
        /// </summary>
        ExtendedAuthentication = HttpServerExtendedAuthenticationProperty,

        /// <summary>
        /// Listening endpoint property.
        /// </summary>
        ListenEndpoint = HttpServerListenEndpointProperty,


        /// <summary>
        /// Authentication channel binding property
        /// </summary>
        ChannelBind = HttpServerChannelBindProperty,

        /// <summary>
        /// IP Protection level policy for a Url Group.
        /// </summary>
        ProtectionLevel = HttpServerProtectionLevelProperty

    };

    
    constexpr size_t MaxServerQueueLength = HTTP_MAX_SERVER_QUEUE_LENGTH;
    constexpr size_t MinServerQueueLength = HTTP_MIN_SERVER_QUEUE_LENGTH;

    /// <summary>
    /// Generic property flags. Each structure defining a property info typically
    /// contain an element of this type.
    /// </summary>
    using PropertyFlags = HTTP_PROPERTY_FLAGS;

    enum class EnabledState
    {
        Active = HttpEnabledStateActive,
        Inactive = HttpEnabledStateInactive
    };

    struct StateInfo 
    {
        PropertyFlags Flags;
        EnabledState State;
        constexpr StateInfo( )
            : Flags{}, State{}
        {}

        constexpr explicit StateInfo( bool active )
            : Flags{ 1 }, State( active ? EnabledState::Active: EnabledState::Inactive )
        {}
        constexpr explicit StateInfo( EnabledState enabledState )
            : Flags{ 1 }, State( enabledState )
        {}

    };

    static_assert( sizeof( StateInfo ) == sizeof( HTTP_STATE_INFO ) );

    /// <summary>
    /// Defines the verbosity level for a request queue which will be used
    /// when sending "503 - Service Unavailable" type error responses. Note that
    /// this setting only affects the error responses generated internally
    /// by HTTPAPI.
    /// </summary>
    enum class ResponseVerbosity503
    {
        /// <summary>
        /// Instead of sending a 503 response, the connection will be reset.
        /// This is the default behavior.
        /// </summary>
        Basic = Http503ResponseVerbosityBasic,

        /// <summary>
        /// Will send a 503 w/ a generic reason phrase.
        /// </summary>
        Limited = Http503ResponseVerbosityLimited,

        /// <summary>
        /// Will send a 503 w/ a detailed reason phrase.
        /// </summary>
        Full = Http503ResponseVerbosityFull
    };

    enum class QosSettingType
    {
        Bandwidth = HttpQosSettingTypeBandwidth,
        ConnectionLimit = HttpQosSettingTypeConnectionLimit,
        FlowRate = HttpQosSettingTypeFlowRate
    };

    struct QosSettingInfo
    {
        QosSettingType QosType;
        void* QosSetting;
    };
    static_assert( sizeof( QosSettingInfo ) == sizeof( HTTP_QOS_SETTING_INFO ) );

    struct ConnectionLimitInfo
    {
        PropertyFlags Flags;
        UInt32 MaxConnections;
    };
    static_assert( sizeof( HTTP_CONNECTION_LIMIT_INFO ) == sizeof( ConnectionLimitInfo ) );

    struct BandwidthLimitInfo
    {
        PropertyFlags Flags;
        UInt32 MaxBandwidth;
    };
    static_assert( sizeof( HTTP_BANDWIDTH_LIMIT_INFO ) == sizeof( BandwidthLimitInfo ) );


    struct FlowrateInfo
    {
        PropertyFlags Flags;
        UInt32 MaxBandwidth;
        UInt32 MaxPeakBandwidth;
        UInt32 BurstSize;
    };
    static_assert( sizeof( HTTP_FLOWRATE_INFO ) == sizeof( FlowrateInfo ) );

    /// <summary>
    /// Bandwidth throttling limit can not be set lower than the following
    /// number. The value is in bytes/sec.
    /// </summary>
    constexpr UInt32 MinAllowedBandwidthThrottlingRate = HTTP_MIN_ALLOWED_BANDWIDTH_THROTTLING_RATE;

    /// <summary>
    /// Distinguished value for bandwidth, connection limits and logging rollover
    /// size indicating "no limit".
    /// </summary>
    constexpr UInt32 LimitInfinite = HTTP_LIMIT_INFINITE;


    /// <summary>
    /// For manipulating global timeout settings.
    /// These timers run when connection does not belong to any application.
    /// Value zero is not allowed for driver wide timeout settings.
    /// </summary>
    enum class ConfigTimeoutKey
    {
        IdleConnectionTimeout = 0,
        HeaderWaitTimeout
    };

    using ConfigTimeoutParam = UInt16;
    

    struct ConfigTimeoutSet
    {
        ConfigTimeoutKey KeyDesc;
        ConfigTimeoutParam ParamDesc;
    };
    static_assert( sizeof( HTTP_SERVICE_CONFIG_TIMEOUT_SET ) == sizeof( ConfigTimeoutSet ) );

    /// <summary>
    /// For manipulating application specific timeout settings.
    /// These timers run when there's a request being processed on a connection
    /// and HTTPAPI has already associated the request with an application.
    /// Setting a timeout value to zero will cause HTTPAPI to revert to default.
    /// </summary>
    struct TimeoutLimitInfo
    {
        PropertyFlags Flags;

        //
        // Timeouts configured in seconds.
        //

        UInt16 EntityBody;
        UInt16 DrainEntityBody;
        UInt16 RequestQueue;

        //
        // Following two timeouts are only enforced after first request on
        // connection is routed to the application. These will not manipulate
        // the driver wide timeouts.
        //

        UInt16 IdleConnection;
        UInt16 HeaderWait;

        //
        // Timeouts configured in bytes/second.
        // This timer can be turned off by setting it to MAXULONG.
        //

        UInt32 MinSendRate;
    };
    static_assert( sizeof( HTTP_TIMEOUT_LIMIT_INFO ) == sizeof( TimeoutLimitInfo ) );


    /// <summary>
    /// Controls config settings
    /// </summary>
    enum class ConfigSettingKey
    {
        None = 0,
        TlsThrottle
    };
    using ConfigSettingParam = UInt32;

    struct ConfigSettingSet
    {
        ConfigSettingKey KeyDesc;
        ConfigSettingParam ParamDesc;
    };
    static_assert( sizeof( HTTP_SERVICE_CONFIG_SETTING_SET ) == sizeof( ConfigSettingSet ) );

    /// <summary>
    /// Controls whether IP-based URLs should listen on the specific IP or wildcard.
    /// </summary>
    struct ListenEndpointInfo
    {
        PropertyFlags Flags;
        Byte EnableSharing;
    };

    static_assert( sizeof( HTTP_LISTEN_ENDPOINT_INFO ) == sizeof( ListenEndpointInfo ) );

    struct AuthenticationDigestParams
    {
        UInt16 DomainNameLength;
        wchar_t* DomainName;
        UInt16 RealmLength;
        wchar_t* Realm;
    };
    static_assert( sizeof( HTTP_SERVER_AUTHENTICATION_DIGEST_PARAMS ) == sizeof( AuthenticationDigestParams ) );

    struct AuthenticationBasicParams
    {
        UInt16 RealmLength;
        wchar_t* Realm;
    };
    static_assert( sizeof( HTTP_SERVER_AUTHENTICATION_BASIC_PARAMS ) == sizeof( AuthenticationBasicParams ) );

    /// <summary>
    /// Definitions used for setting server side authentication property.
    /// </summary>
    enum class AuthenticationSchemes : UInt32
    {
        None = 0,
        Basic = HTTP_AUTH_ENABLE_BASIC,
        Digest = HTTP_AUTH_ENABLE_DIGEST,
        NTLM = HTTP_AUTH_ENABLE_NTLM,
        Negotiate = HTTP_AUTH_ENABLE_NEGOTIATE,
        Kerberos = HTTP_AUTH_ENABLE_KERBEROS,
        All = HTTP_AUTH_ENABLE_ALL
    };
    HCC_DEFINE_ENUM_FLAG_OPERATORS( AuthenticationSchemes, UInt32 );

    enum class AuthenticationExFlags : Byte
    {
        None = 0,
        EnableKerberosCredentialCaching = HTTP_AUTH_EX_FLAG_ENABLE_KERBEROS_CREDENTIAL_CACHING,
        CaptureCredential = HTTP_AUTH_EX_FLAG_CAPTURE_CREDENTIAL
    };
    HCC_DEFINE_ENUM_FLAG_OPERATORS( AuthenticationExFlags, Byte );


    struct AuthenticationInfo
    {
        PropertyFlags Flags;

        AuthenticationSchemes AuthSchemes;

        Byte ReceiveMutualAuth;
        Byte ReceiveContextHandle;
        Byte DisableNTLMCredentialCaching;

        AuthenticationExFlags ExFlags;

        AuthenticationDigestParams DigestParams;
        AuthenticationBasicParams BasicParams;

    };
    static_assert( sizeof( HTTP_SERVER_AUTHENTICATION_INFO ) == sizeof( AuthenticationInfo ) );

    enum class ServiceBindingType : Int32
    {
        None = 0,
        Wide,
        Ansi
    };

    struct ServiceBindingBase
    {
        ServiceBindingType Type;
    };
    static_assert( sizeof( HTTP_SERVICE_BINDING_BASE ) == sizeof( ServiceBindingBase ) );

    struct AnsiServiceBinding : ServiceBindingBase
    {
        char* Buffer;
        UInt32 BufferSize;
    };
    static_assert( sizeof( HTTP_SERVICE_BINDING_A ) == sizeof( AnsiServiceBinding ) );


    struct WideServiceBinding : ServiceBindingBase
    {
        wchar_t* Buffer;
        UInt32 BufferSize;
    };
    static_assert( sizeof( HTTP_SERVICE_BINDING_W ) == sizeof( WideServiceBinding ) );

    enum class AuthenticationHardeningLevel
    {
        Legacy = 0,
        Medium,
        Strict
    };
    
    enum class ChannelBindFlags : UInt32
    {
        /// <summary>
        /// Channel binding token verification flags.
        /// </summary>
        Proxy = HTTP_CHANNEL_BIND_PROXY,
        ProxyCohosting = HTTP_CHANNEL_BIND_PROXY_COHOSTING,

        /// <summary>
        /// Service bind verification flags
        /// </summary>
        NoServiceNameCheck = HTTP_CHANNEL_BIND_NO_SERVICE_NAME_CHECK,
        DotlessService = HTTP_CHANNEL_BIND_DOTLESS_SERVICE,

        /// <summary>
        /// Flags triggering channel bind parameters retrieval
        /// </summary>
        SecureChannelToken = HTTP_CHANNEL_BIND_SECURE_CHANNEL_TOKEN,
        ClientService = HTTP_CHANNEL_BIND_CLIENT_SERVICE,
    };
    HCC_DEFINE_ENUM_FLAG_OPERATORS( ChannelBindFlags, UInt32 );

    struct ChannelBindInfo
    {
        AuthenticationHardeningLevel Hardening;
        ChannelBindFlags Flags;
        ServiceBindingBase* ServiceNames;
        UInt32 NumberOfServiceNames;

    };
    static_assert( sizeof( HTTP_CHANNEL_BIND_INFO ) == sizeof( ChannelBindInfo ) );

    struct RequestChannelBindStatus
    {
        ServiceBindingBase* ServiceName;
        Byte* ChannelToken;
        UInt32 ChannelTokenSize;
        ChannelBindFlags Flags;
    };
    static_assert( sizeof( HTTP_REQUEST_CHANNEL_BIND_STATUS ) == sizeof(RequestChannelBindStatus) );

    struct RequestTokenBindingInfo
    {
        Byte* TokenBinding;
        UInt32 TokenBindingSize;

        Byte* EKM;
        UInt32 EKMSize;

        Byte KeyType;

    };
    static_assert( sizeof( HTTP_REQUEST_TOKEN_BINDING_INFO ) == sizeof( RequestTokenBindingInfo ) );


    enum class LogField : Int32
    {
        Date = HTTP_LOG_FIELD_DATE,
        Time = HTTP_LOG_FIELD_TIME,
        ClientIP = HTTP_LOG_FIELD_CLIENT_IP,
        Username = HTTP_LOG_FIELD_USER_NAME,
        Sitename = HTTP_LOG_FIELD_SITE_NAME,
        Computername = HTTP_LOG_FIELD_COMPUTER_NAME,
        ServerIP = HTTP_LOG_FIELD_SERVER_IP,
        Method = HTTP_LOG_FIELD_METHOD,
        UriStem = HTTP_LOG_FIELD_URI_STEM,
        UriQuery = HTTP_LOG_FIELD_URI_QUERY,
        Status = HTTP_LOG_FIELD_STATUS,
        Win32Status = HTTP_LOG_FIELD_WIN32_STATUS,
        BytesSent = HTTP_LOG_FIELD_BYTES_SENT,
        BytesReceived = HTTP_LOG_FIELD_BYTES_RECV,
        TimeTaken = HTTP_LOG_FIELD_TIME_TAKEN,
        ServerPort = HTTP_LOG_FIELD_SERVER_PORT,
        UserAgent = HTTP_LOG_FIELD_USER_AGENT,
        Cookie = HTTP_LOG_FIELD_COOKIE,
        Referer = HTTP_LOG_FIELD_REFERER,
        Version = HTTP_LOG_FIELD_VERSION,
        Host = HTTP_LOG_FIELD_HOST,
        SubStatus = HTTP_LOG_FIELD_SUB_STATUS,
        StreamID = HTTP_LOG_FIELD_STREAM_ID,
        StreamIDEx = HTTP_LOG_FIELD_STREAM_ID_EX,
        TransportType = HTTP_LOG_FIELD_TRANSPORT_TYPE,

        //
        // Fields that are used only for error logging.
        //

        ClientPort = HTTP_LOG_FIELD_CLIENT_PORT,
        Uri = HTTP_LOG_FIELD_URI,
        SiteID = HTTP_LOG_FIELD_SITE_ID,
        Reason = HTTP_LOG_FIELD_REASON,
        QueueName = HTTP_LOG_FIELD_QUEUE_NAME

    };

    /// <summary>
    /// Defines the logging type.
    /// </summary>
    enum class LoggingType
    {
        W3C,
        IIS,
        NCSA,
        Raw
    };

    /// <summary>
    /// Defines the rollover type for log files.
    /// </summary>
    enum class LoggingRolloverType
    {
        Size,
        Daily,
        Weekly,
        Monthly,
        Hourly
    };

    constexpr UInt32 MinAllowedLogFileRolloverSize = HTTP_MIN_ALLOWED_LOG_FILE_ROLLOVER_SIZE;

    /// <summary>
    /// Logging option flags. When used in the logging configuration alters
    /// some default logging behaviour.
    /// </summary>
    enum class LoggingFlags : Int32
    {
        None = 0,
        /// <summary>
        /// This flag is used to change the log file rollover to happen by 
        /// local time based. By default log file rollovers happen by GMT time.
        /// </summary>
        LocalTimeRollover = HTTP_LOGGING_FLAG_LOCAL_TIME_ROLLOVER,
        /// <summary>
        /// When set the unicode fields will be converted to UTF8 multibytes 
        /// when writting to the log files. When this flag is not present, the 
        /// local code page conversion happens.
        /// </summary>
        UseUTF8Conversion = HTTP_LOGGING_FLAG_USE_UTF8_CONVERSION,

        /// <summary>
        /// These two flags are used to to do selective logging. If neither 
        /// of them are present both types of requests will be logged. Only 
        /// one these flags can be set at a time. They are mutually exclusive.
        /// </summary>
        LogErrorsOnly = HTTP_LOGGING_FLAG_LOG_ERRORS_ONLY,
        LogSuccessOnly = HTTP_LOGGING_FLAG_LOG_SUCCESS_ONLY
    };
    HCC_DEFINE_ENUM_FLAG_OPERATORS( LoggingFlags, Int32 );

    /// <summary>
    /// Configuration structure used for setting the logging property.
    /// </summary>
    struct LoggingInfo
    {
        /// <summary>
        /// Specifies whether this property exists or not.
        /// </summary>
        PropertyFlags Flags;

        /// <summary>
        /// Optional logging flags.
        /// </summary>
        Http::LoggingFlags LoggingFlags;

        /// <summary>
        /// Optional informatonal software directive string for W3C type logging. 
        /// Not used for other types of logging. If nothing is provided here 
        /// HTTPAPI will log a default string. Any arbitrary string could be used here 
        /// to identify the application. Length cannot be greater than MAX_PATH. 
        /// Lenght is in bytes.
        /// </summary>
        wchar_t* SoftwareName;
        UInt16 SoftwareNameLength;

        /// <summary>
        /// Log file directory must be a fully qualified path. Length must be in number of bytes.
        /// </summary>
        UInt16 DirectoryNameLength;
        wchar_t* DirectoryName;

        /// <summary>
        /// Specifies the format for the log files.
        /// </summary>
        LoggingType Format;

        /// <summary>
        /// Bitmask value indicates which fields to be logged if the log format 
        /// is set to W3C. This must be the 'bitwise or' of the values from the LogField enumeration.
        /// </summary>
        LogField Fields;

        //
        // Following fields are reserved they must be NULL and zero..
        //

        PVOID pExtFields;
        UInt16 NumOfExtFields;

        //
        // Reserved must be zero.
        //

        UInt16 MaxRecordSize;

        //
        // Defines the rollover type for the log files.
        //

        LoggingRolloverType RolloverType;

        //
        // Indicates the maximum size (in bytes) after which
        // the log files should be rolled over. A value of -1
        // (HTTP_LIMIT_INFINITE) indicates an unlimited size.
        // This value is discarded if rollover type is not set to
        // HttpLoggingRolloverSize.
        //

        UInt32 RolloverSize;

        //
        // Specifies the security descriptor to be applied to
        // the log files and the sub-directories. If null we will
        // inherit the system default. This security descriptor must
        // be self-relative.
        //

        PSECURITY_DESCRIPTOR pSecurityDescriptor;

    };

    static_assert( sizeof( HTTP_LOGGING_INFO ) == sizeof( LoggingInfo ) );

    struct BindingInfo
    {
        PropertyFlags Flags;
        HANDLE RequestQueueHandle;
        
        BindingInfo( )
            : Flags{ }, RequestQueueHandle(nullptr)
        {}
        explicit BindingInfo( HANDLE requestQueueHandle )
            : Flags{ 1 }, RequestQueueHandle( requestQueueHandle )
        {}
        
    };
    static_assert( sizeof( HTTP_BINDING_INFO ) == sizeof( BindingInfo ) );

    /// <summary>
    /// Defines the protection level types for UrlGroups.
    /// </summary>
    enum class ProtectionLevelType
    {
        
        /// <summary>
        /// This option will allow edge (NAT) traversed traffic, i.e. Teredo for 
        /// the UrlGroup, unless there is an admin rule that overwrites the 
        /// application's intend.
        /// </summary>
        Unrestricted = HttpProtectionLevelUnrestricted,

        /// <summary>
        /// This setting will ensure that edge (NAT) traversed traffic will not 
        /// be allowed.
        /// </summary>
        EdgeRestricted = HttpProtectionLevelEdgeRestricted,

        /// <summary>
        /// Below type is not supported by HTTP API.
        /// </summary>
        Restricted = HttpProtectionLevelRestricted
    };

    /// <summary>
    /// Controls whether the associated UrlGroup Namespace should receive 
    /// edge traversed traffic. By default this parameter is unspecified.
    /// </summary>
    struct ProtectionLevelInfo
    {
        PropertyFlags Flags;
        ProtectionLevelType Level;
    };
    static_assert( sizeof( HTTP_PROTECTION_LEVEL_INFO ) == sizeof( ProtectionLevelInfo ) );

    /// <summary>
    /// These flags are used with CreateRequestQueue() API.
    /// </summary>
    enum class CreateRequestQueueFlags : UInt32
    { 
        None = 0,
        /// <summary>
        /// To open an existing request queue. The request queue name must be supplied.
        /// </summary>
        OpenExisting = HTTP_CREATE_REQUEST_QUEUE_FLAG_OPEN_EXISTING,
        /// <summary>
        /// Creates the request queue and marks that the caller process is not willing 
        /// to do send/receive (HTTP I/O)on the handle directly.
        /// </summary>
        Controller = HTTP_CREATE_REQUEST_QUEUE_FLAG_CONTROLLER
    };
    HCC_DEFINE_ENUM_FLAG_OPERATORS( CreateRequestQueueFlags, UInt32 );

    /// <summary>
    /// Flags for HttpReceiveHttpRequest().
    /// </summary>
    enum class ReceiveRequestFlags : UInt32
    {
        /// <summary>
        /// Only the request headers are retrieved; the entity body is not copied.
        /// </summary>
        None = 0,
        /// <summary>
        /// Specifies that the caller would like any available entity body to be copied 
        /// along with the protocol headers.
        /// </summary>
        CopyBody = HTTP_RECEIVE_REQUEST_FLAG_COPY_BODY,
        /// <summary>
        /// Specifies that the caller would like all of the entity bodies to be copied 
        /// along with the protocol headers.
        /// </summary>
        FlushBody = HTTP_RECEIVE_REQUEST_FLAG_FLUSH_BODY
    };
    HCC_DEFINE_ENUM_FLAG_OPERATORS( ReceiveRequestFlags, UInt32 );


    /// <summary>
    /// Flags for HttpReceiveRequestEntityBody( ).
    /// </summary>
    enum class ReceiveRequestEntityBodyFlags : UInt32
    {
        None = 0,
        /// <summary>
        /// Specifies that the caller would like the buffer to get filled up with entity 
        /// bodies unless there are no more entity bodies to be copied.
        /// </summary>
        FillBuffer = HTTP_RECEIVE_REQUEST_ENTITY_BODY_FLAG_FILL_BUFFER
    };
    HCC_DEFINE_ENUM_FLAG_OPERATORS( ReceiveRequestEntityBodyFlags, UInt32 );

    /// <summary>
    /// Flags for HttpSendHttpResponse() and HttpSendResponseEntityBody().
    /// </summary>
    enum class SendResponseFlags : UInt32
    {
        None = 0,
        /// <summary>
        /// Specifies that the network connection should be disconnected 
        /// immediately after sending the response, overriding the HTTP 
        /// protocol's persistent connection features, such as 
        /// "Connection: keep-alive".
        /// </summary>
        Disconnect = HTTP_SEND_RESPONSE_FLAG_DISCONNECT,
        /// <summary>
        /// Specifies that additional entity body data will be sent by 
        /// the caller.
        /// </summary>
        MoreData = HTTP_SEND_RESPONSE_FLAG_MORE_DATA,
        /// <summary>
        /// Specifies that a caller wants the response to complete as soon 
        /// as possible at the cost of buffering partial or the entire response.
        /// </summary>
        BufferData = HTTP_SEND_RESPONSE_FLAG_BUFFER_DATA,
        /// <summary>
        /// Specifies that a caller wants to enable the TCP nagling algorithm 
        /// for this particular send.
        /// </summary>
        EnableNagling = HTTP_SEND_RESPONSE_FLAG_ENABLE_NAGLING,
        /// <summary>
        /// Specifies that for a range request a full response content is passed 
        /// and a caller wants HTTP API to process ranges properly.
        /// </summary>
        ProcessRanges = HTTP_SEND_RESPONSE_FLAG_PROCESS_RANGES,
        /// <summary>
        /// Specifies that the request/response is not HTTP compliant and all 
        /// subsequent bytes should be treated as entity-body.
        /// </summary>
        Opaque = HTTP_SEND_RESPONSE_FLAG_OPAQUE,
        /// <summary>
        /// A flag that must always be specified with SendResponseFlags::Disconnect. 
        /// For pure HTTP/1.x connections, that is connections that don't do HTTP/2 
        /// and HTTP/3, this behaves the same as SendResponseFlags::Disconnect. 
        /// For HTTP/2 and HTTP/3, this results insending a GOAWAY frame and will cause 
        /// the client to move to a different connection.
        /// </summary>
        Goaway = HTTP_SEND_RESPONSE_FLAG_GOAWAY
    };
    HCC_DEFINE_ENUM_FLAG_OPERATORS( SendResponseFlags, UInt32 );

    /// <summary>
    /// Flags for HttpFlushResponseCache().
    /// </summary>
    enum class FlushResponseFlags : UInt32
    {
        None = 0,
        /// <summary>
        /// Flushes the specified URL and all hierarchally-related 
        /// sub-URLs from the response or fragment cache.
        /// </summary>
        Recursive = HTTP_FLUSH_RESPONSE_FLAG_RECURSIVE
    };
    HCC_DEFINE_ENUM_FLAG_OPERATORS( FlushResponseFlags, UInt32 );

    // Opaque identifiers for various HTTPAPI objects.
    using OpaqueId = HTTP_OPAQUE_ID;
    using RequestId = HTTP_REQUEST_ID;
    using ConnectionId = HTTP_CONNECTION_ID;
    using RawConnectionId = HTTP_RAW_CONNECTION_ID;
    using UrlGroupId = HTTP_URL_GROUP_ID;
    using ServerSessionId = HTTP_SERVER_SESSION_ID;
    using ClientRequestId = HTTP_CLIENT_REQUEST_ID;
    constexpr OpaqueId NullId = HTTP_NULL_ID;
    constexpr bool IsNullId( const OpaqueId& id ) noexcept
    {
        return id == NullId;
    }
    constexpr bool IsNullId( const OpaqueId* id ) noexcept
    {
        return *id == NullId;
    }
    constexpr void SetNUllId( OpaqueId& id ) noexcept
    {
        id = NullId;
    }
    constexpr void SetNUllId( OpaqueId* id ) noexcept
    {
        *id = NullId;
    }

    /// <summary>
    /// This structure defines a file byte range.
    /// </summary>
    struct ByteRange
    {
        UInt64 StartingOffset;
        UInt64 Length;
    };
    static_assert( sizeof( HTTP_BYTE_RANGE ) == sizeof( ByteRange ) );

    /// <summary>
    /// If the Length field of ByteRange is ByteRangeToEOF then the 
    /// remainder of the file (everything after StartingOffset) is sent.
    /// </summary>
    constexpr UInt64 ByteRangeToEOF = HTTP_BYTE_RANGE_TO_EOF;


    /// <summary>
    /// HTTP protocol version information and manipulation.
    /// </summary>
    struct Version
    {
        UInt16 MajorVersion;
        UInt16 MinorVersion;

        constexpr Version() noexcept
            :MajorVersion(0), MinorVersion(0)
        { }

        constexpr explicit Version( UInt16 majorVersion, UInt16 minorVersion = 0 ) noexcept
            :MajorVersion( majorVersion ), MinorVersion( minorVersion )
        {
        }

        constexpr explicit Version( const HTTP_VERSION& other ) noexcept
            :MajorVersion( other.MajorVersion ), MinorVersion( other.MinorVersion )
        {
        }

        constexpr bool IsUnknown( ) const noexcept
        {
            return MajorVersion == 0 && MinorVersion == 0;
        }

        template<typename T>
        requires requires( T t )
        {
            { t.MajorVersion } -> std::same_as<UInt16>;
            { t.MinorVersion } -> std::same_as<UInt16>;
        }
        constexpr bool operator == ( const T& other ) const noexcept
        {
            return MajorVersion == other.MajorVersion && MinorVersion == other.MinorVersion;
        }
        template<typename T>
        requires requires( T t )
        {
            { t.MajorVersion } -> std::same_as<UInt16>;
            { t.MinorVersion } -> std::same_as<UInt16>;
        }
        constexpr bool operator != ( const T& other ) const noexcept
        {
            return MajorVersion != other.MajorVersion || MinorVersion != other.MinorVersion;
        }
        template<typename T>
        requires requires( T t )
        {
            { t.MajorVersion } -> std::same_as<UInt16>;
            { t.MinorVersion } -> std::same_as<UInt16>;
        }
        constexpr bool operator < ( const T& other ) const noexcept
        {
            return MajorVersion < other.MajorVersion || 
                ( MajorVersion == other.MajorVersion &&  MinorVersion < other.MinorVersion);
        }
        template<typename T>
        requires requires( T t )
        {
            { t.MajorVersion } -> std::same_as<UInt16>;
            { t.MinorVersion } -> std::same_as<UInt16>;
        }
        constexpr bool operator <= ( const T& other ) const noexcept
        {
            return MajorVersion < other.MajorVersion ||
                ( MajorVersion == other.MajorVersion && MinorVersion <= other.MinorVersion );
        }
        template<typename T>
        requires requires( T t )
        {
            { t.MajorVersion } -> std::same_as<UInt16>;
            { t.MinorVersion } -> std::same_as<UInt16>;
        }
        constexpr bool operator > ( const T& other ) const noexcept
        {
            return MajorVersion > other.MajorVersion ||
                ( MajorVersion == other.MajorVersion && MinorVersion > other.MinorVersion );
        }
        template<typename T>
        requires requires( T t )
        {
            { t.MajorVersion } -> std::same_as<UInt16>;
            { t.MinorVersion } -> std::same_as<UInt16>;
        }
        constexpr bool operator >= ( const T& other ) const noexcept
        {
            return MajorVersion > other.MajorVersion ||
                ( MajorVersion == other.MajorVersion && MinorVersion >= other.MinorVersion );
        }

    };
    static_assert( sizeof( HTTP_VERSION ) == sizeof( Version ) );
    

    /// <summary>
    /// The enum type for HTTP Scheme.
    /// </summary>
    enum class Scheme
    {
        Http = HttpSchemeHttp,
        Https = HttpSchemeHttps,
        Maximum = HttpSchemeMaximum
    };

    /// <summary>
    /// The enum type for HTTP verbs.
    /// </summary>
    enum class Verb
    {
        Unparsed = HttpVerbUnparsed,
        Unknown = HttpVerbUnknown,
        Invalid = HttpVerbInvalid,
        Options = HttpVerbOPTIONS,
        Get = HttpVerbGET,
        Head = HttpVerbHEAD,
        Post = HttpVerbPOST,
        Put = HttpVerbPUT,
        Delete = HttpVerbDELETE,
        Trace = HttpVerbTRACE,
        Connect = HttpVerbCONNECT,
        Track = HttpVerbTRACK,  // used by Microsoft Cluster Server for a non-logged trace
        Move = HttpVerbMOVE,
        Copy = HttpVerbCOPY,
        PropFind = HttpVerbPROPFIND,
        PropPatch = HttpVerbPROPPATCH,
        MkCol = HttpVerbMKCOL,
        Lock = HttpVerbLOCK,
        Unlock = HttpVerbUNLOCK,
        Search = HttpVerbSEARCH,

        Maximum = HttpVerbMaximum

    };

    /// <summary>
    /// Symbols for all HTTP/1.1 headers and other tokens. Notice request + response 
    /// values overlap. Make sure you know which type of header array you are indexing.
    /// </summary>
    /// <remarks>
    /// These values are used as offsets into arrays and as token values in 
    /// HTTP_KNOWN_HEADER arrays in HTTP_REQUEST_HEADERS and HTTP_RESPONSE_HEADERS.
    /// 
    /// See RFC 2616, HTTP/1.1, for further explanation of most of these headers.
    /// </remarks>
    enum class HeaderId
    {
        /// <summary>
        /// general-header [section 4.5]
        /// </summary>
        CacheControl = HttpHeaderCacheControl,
        /// <summary>
        /// general-header [section 4.5]
        /// </summary>
        Connection = HttpHeaderConnection,
        /// <summary>
        /// general-header [section 4.5]
        /// </summary>
        Date = HttpHeaderDate,
        /// <summary>
        /// general-header [not in rfc]
        /// </summary>
        KeepAlive = HttpHeaderKeepAlive,
        /// <summary>
        /// general-header [section 4.5]
        /// </summary>
        Pragma = HttpHeaderPragma,
        /// <summary>
        /// general-header [section 4.5]
        /// </summary>
        Trailer = HttpHeaderTrailer,
        /// <summary>
        /// general-header [section 4.5]
        /// </summary>
        TransferEncoding = HttpHeaderTransferEncoding,
        /// <summary>
        /// general-header [section 4.5]
        /// </summary>
        Upgrade = HttpHeaderUpgrade,
        /// <summary>
        /// general-header [section 4.5]
        /// </summary>
        Via = HttpHeaderVia,
        /// <summary>
        /// general-header [section 4.5]
        /// </summary>
        Warning = HttpHeaderWarning,

        /// <summary>
        /// entity-header  [section 7.1]
        /// </summary>
        Allow = HttpHeaderAllow,
        /// <summary>
        /// entity-header  [section 7.1]
        /// </summary>
        ContentLength = HttpHeaderContentLength,   
        /// <summary>
        /// entity-header  [section 7.1]
        /// </summary>
        ContentType = HttpHeaderContentType,
        /// <summary>
        /// entity-header  [section 7.1]
        /// </summary>
        ContentEncoding = HttpHeaderContentEncoding,   
        /// <summary>
        /// entity-header  [section 7.1]
        /// </summary>
        ContentLanguage = HttpHeaderContentLanguage,
        /// <summary>
        /// entity-header  [section 7.1]
        /// </summary>
        ContentLocation = HttpHeaderContentLocation,
        /// <summary>
        /// entity-header  [section 7.1]
        /// </summary>
        ContentMd5 = HttpHeaderContentMd5,   
        /// <summary>
        /// entity-header  [section 7.1]
        /// </summary>
        ContentRange = HttpHeaderContentRange,   
        /// <summary>
        /// entity-header  [section 7.1]
        /// </summary>
        Expires = HttpHeaderExpires,
        /// <summary>
        /// entity - header[section 7.1]
        /// </summary>
        LastModified = HttpHeaderLastModified,

        // Request Headers

        /// <summary>
        /// request-header [section 5.3]
        /// </summary>
        Accept = HttpHeaderAccept,
        /// <summary>
        /// request-header [section 5.3]
        /// </summary>
        AcceptCharset = HttpHeaderAcceptCharset,
        /// <summary>
        /// request-header [section 5.3]
        /// </summary>
        AcceptEncoding = HttpHeaderAcceptEncoding,
        /// <summary>
        /// request-header [section 5.3]
        /// </summary>
        AcceptLanguage = HttpHeaderAcceptLanguage,

        /// <summary>
        /// request-header [section 5.3]
        /// </summary>
        Authorization = HttpHeaderAuthorization,
        /// <summary>
        /// request-header [not in rfc]
        /// </summary>
        Cookie = HttpHeaderCookie,
        /// <summary>
        /// request-header [section 5.3]
        /// </summary>
        Expect = HttpHeaderExpect,
        /// <summary>
        /// request-header [section 5.3]
        /// </summary>
        From = HttpHeaderFrom,
        /// <summary>
        /// request-header [section 5.3]
        /// </summary>
        Host = HttpHeaderHost,
        /// <summary>
        /// request-header [section 5.3]
        /// </summary>
        IfMatch = HttpHeaderIfMatch,
        /// <summary>
        /// request-header [section 5.3]
        /// </summary>
        IfModifiedSince = HttpHeaderIfModifiedSince,
        /// <summary>
        /// request-header [section 5.3]
        /// </summary>
        IfNoneMatch = HttpHeaderIfNoneMatch,
        /// <summary>
        /// request-header [section 5.3]
        /// </summary>
        IfRange = HttpHeaderIfRange, 
        /// <summary>
        /// request-header [section 5.3]
        /// </summary>
        IfUnmodifiedSince = HttpHeaderIfUnmodifiedSince, 
        /// <summary>
        /// request-header [section 5.3]
        /// </summary>
        MaxForwards = HttpHeaderMaxForwards, 
        /// <summary>
        /// request-header [section 5.3]
        /// </summary>
        ProxyAuthorization = HttpHeaderProxyAuthorization,  
        /// <summary>
        /// request-header [section 5.3]
        /// </summary>
        Referer = HttpHeaderReferer, 
        /// <summary>
        /// request-header [section 5.3]
        /// </summary>
        Range = HttpHeaderRange,
        /// <summary>
        /// request-header [section 5.3]
        /// </summary>
        Te = HttpHeaderTe,
        /// <summary>
        /// request-header [webDAV, not in rfc 2518]
        /// </summary>
        Translate = HttpHeaderTranslate,
        /// <summary>
        /// request-header [section 5.3]
        /// </summary>
        UserAgent = HttpHeaderUserAgent,  

        RequestMaximum = HttpHeaderRequestMaximum,

        // Response Headers

        /// <summary>
        /// response-header [section 6.2]
        /// </summary>
        AcceptRanges = HttpHeaderAcceptRanges, 
        /// <summary>
        /// response-header [section 6.2]
        /// </summary>
        Age = HttpHeaderAge,
        /// <summary>
        /// response-header [section 6.2]
        /// </summary>
        Etag = HttpHeaderEtag,
        /// <summary>
        /// response-header [section 6.2]
        /// </summary>
        Location = HttpHeaderLocation,
        /// <summary>
        /// response-header [section 6.2]
        /// </summary>
        ProxyAuthenticate = HttpHeaderProxyAuthenticate,
        /// <summary>
        /// response-header [section 6.2]
        /// </summary>
        RetryAfter = HttpHeaderRetryAfter, 
        /// <summary>
        /// response-header [section 6.2]
        /// </summary>
        Server = HttpHeaderServer,
        /// <summary>
        /// response-header [not in rfc]
        /// </summary>
        SetCookie = HttpHeaderSetCookie,   
        /// <summary>
        /// response-header [section 6.2]
        /// </summary>
        Vary = HttpHeaderVary, 
        /// <summary>
        /// response-header [section 6.2]
        /// </summary>
        WwwAuthenticate = HttpHeaderWwwAuthenticate,

        ResponseMaximum = HttpHeaderResponseMaximum ,

        Maximum = HttpHeaderMaximum
    };

    /// <summary>
    /// Structure defining format of a known HTTP header.
    /// </summary>
    struct KnownHeader
    {
        /// <summary>
        /// in bytes not including the NUL
        /// </summary>
        UInt16 RawValueLength;
        const char* pRawValue;

        constexpr std::span< const char > Value( ) const noexcept
        {
            return std::span< const char >( pRawValue, static_cast<size_t>( RawValueLength ) );
        }
    };
    static_assert( sizeof( HTTP_KNOWN_HEADER ) == sizeof( KnownHeader ) );

    /// <summary>
    /// Structure defining format of an unknown header.
    /// </summary>
    struct UnknownHeader
    {
        /// <summary>
        /// in bytes not including the NUL
        /// </summary>
        UInt16 NameLength;
        /// <summary>
        /// in bytes not including the NUL
        /// </summary>
        UInt16 RawValueLength;
        /// <summary>
        /// The header name (minus the ':' character)
        /// </summary>
        const char* pName;
        /// <summary>
        /// The header value
        /// </summary>
        const char* pRawValue;

        constexpr std::string_view Name( ) const noexcept
        {
            return std::string_view( pName, static_cast<size_t>( NameLength ) );
        }

        constexpr std::span< const char > Value( ) const noexcept
        {
            return std::span< const char >( pRawValue, static_cast<size_t>( RawValueLength ) );
        }

    };
    static_assert( sizeof( HTTP_UNKNOWN_HEADER ) == sizeof( UnknownHeader ) );


    /// <summary>
    /// Base structure is for future versioning.
    /// </summary>
    enum class LogDataType
    {
        Fields = HttpLogDataTypeFields
    };


    struct LogData
    {
        LogDataType Type;

    }; 
    static_assert( sizeof( HTTP_LOG_DATA ) == sizeof( LogDataType ) );

    /// <summary>
    /// The LogFieldsData structure is used to pass the fields that are logged for an HTTP response when WC3 logging is enabled.
    /// </summary>
    struct LogFieldsData : LogData
    {
        /// <summary>
        /// The size, in bytes, of the user name member
        /// </summary>
        UInt16 UserNameLength;
        /// <summary>
        /// The size, in bytes, of the URI stem member.
        /// </summary>
        UInt16 UriStemLength;
        /// <summary>
        /// The size, in bytes, of the client IP address member.
        /// </summary>
        UInt16 ClientIpLength;
        /// <summary>
        /// The size, in bytes, of the server name member.
        /// </summary>
        UInt16 ServerNameLength;
        
        UInt16 ServiceNameLength;
        /// <summary>
        /// The size, in bytes, of the server IP address member.
        /// </summary>
        UInt16 ServerIpLength;
        /// <summary>
        /// The size, in bytes, of the HTTP method member
        /// </summary>
        UInt16 MethodLength;
        /// <summary>
        /// The size, in bytes, of the URI query member
        /// </summary>
        UInt16 UriQueryLength;
        /// <summary>
        /// The size, in bytes, of the host name member
        /// </summary>
        UInt16 HostLength;
        /// <summary>
        /// The size, in bytes, of the user agent member
        /// </summary>
        UInt16 UserAgentLength;
        /// <summary>
        /// The size, in bytes, of the cookie member
        /// </summary>
        UInt16 CookieLength;
        /// <summary>
        /// The size, in bytes, of the referrer member.
        /// </summary>
        UInt16 ReferrerLength;
        /// <summary>
        /// The name of the user
        /// </summary>
        PWCHAR UserName_;
        /// <summary>
        /// The URI stem
        /// </summary>
        PWCHAR UriStem_;
        /// <summary>
        /// The IP address of the client
        /// </summary>
        PCHAR  ClientIp_;
        /// <summary>
        /// The name of the server
        /// </summary>
        PCHAR  ServerName_;
        /// <summary>
        /// The name of the service
        /// </summary>
        PCHAR  ServiceName_;
        /// <summary>
        /// The IP address of the server
        /// </summary>
        PCHAR  ServerIp_;
        /// <summary>
        /// The HTTP method
        /// </summary>
        PCHAR  Method_;
        /// <summary>
        /// The URI query
        /// </summary>
        PCHAR  UriQuery_;
        /// <summary>
        /// The host information from the request
        /// </summary>
        PCHAR  Host_;
        /// <summary>
        /// The user agent name
        /// </summary>
        PCHAR  UserAgent_;
        /// <summary>
        /// The cookie provided by the application
        /// </summary>
        PCHAR  Cookie_;
        /// <summary>
        /// The referrer
        /// </summary>
        PCHAR  Referrer_;

        /// <summary>
        /// The port for the server
        /// </summary>
        UInt16 ServerPort;
        /// <summary>
        /// The protocol status
        /// </summary>
        UInt16 ProtocolStatus;

        /// <summary>
        /// The win32 status
        /// </summary>
        UInt32 Win32Status;

        /// <summary>
        /// The method number
        /// </summary>
        Verb MethodNum;

        /// <summary>
        /// The sub status
        /// </summary>
        UInt16 SubStatus;

        constexpr std::wstring_view UserName( ) const noexcept
        {
            return std::wstring_view( UserName_, static_cast<size_t>( UserNameLength/sizeof(wchar_t) ) );
        }

    };
    static_assert( sizeof( HTTP_LOG_FIELDS_DATA ) == sizeof( LogFieldsData ) );

    enum class DataChunkType
    {
        Memory = HttpDataChunkFromMemory,
        FileHandle = HttpDataChunkFromFileHandle,
        FragmentCache = HttpDataChunkFromFragmentCache,
        FragmentCacheEx = HttpDataChunkFromFragmentCacheEx,

        Maximum = HttpDataChunkMaximum
    };

    /// <summary>
    /// This structure describes an individual data chunk.
    /// </summary>
    struct DataChunk
    {
        /// <summary>
        /// The type of this data chunk.
        /// </summary>
        Http::DataChunkType DataChunkType;

        /// <summary>
        /// The data chunk structures, one per supported data chunk type.
        /// </summary>
        union
        {
            /// <summary>
            /// From-memory data chunk.
            /// </summary>
            struct
            {
                void* pBuffer;
                UInt32 BufferLength;

            } FromMemory;

            /// <summary>
            /// From-file handle data chunk.
            /// </summary>
            struct
            {
                ByteRange ByteRange;
                HANDLE FileHandle;

            } FromFileHandle;

            /// <summary>
            /// From-fragment cache data chunk.
            /// </summary>
            struct
            {
                // in bytes not including the NUL
                UInt16 FragmentNameLength;
                // NULL-terminated string
                const wchar_t* pFragmentName;

            } FromFragmentCache;

            /// <summary>
            /// From-fragment cache data chunk that specifies a byte range.
            /// </summary>
            struct
            {
                Http::ByteRange ByteRange;
                // NULL-terminated string
                const wchar_t* pFragmentName;

            } FromFragmentCacheEx;
        };

        DataChunk()
            : DataChunkType( Http::DataChunkType::Memory ), FromMemory{}
        { }
        DataChunk(void* buffer, UInt32 bufferSize )
            : DataChunkType( Http::DataChunkType::Memory ), FromMemory{ buffer,bufferSize }
        { }


    };
    static_assert( sizeof( HTTP_DATA_CHUNK ) == sizeof( DataChunk ) );
    static_assert( TYPE_ALIGNMENT( DataChunk ) == sizeof( ULONGLONG ) );

    /// <summary>
    /// Structure defining format of request headers.
    /// </summary>
    struct RequestHeaders
    {
        /// <summary>
        /// The array of unknown HTTP headers and the number of entries in the array.
        /// </summary>
        UInt16 UnknownHeaderCount;
        UnknownHeader* pUnknownHeaders;

        
        // Trailers - don't use these currently, reserved for a future release
        // Reserved, must be 0
        UInt16 TrailerCount;
        // Reserved, must be NULL
        UnknownHeader* pTrailers;

        /// <summary>
        /// Known headers.
        /// </summary>
        KnownHeader KnownHeaders[static_cast<size_t>( HeaderId::Maximum )];

    };
    static_assert( sizeof( HTTP_REQUEST_HEADERS ) == sizeof( RequestHeaders ) );

    /// <summary>
    /// Structure defining format of response headers.
    /// </summary>
    struct ResponseHeaders
    {
        /// <summary>
        /// The array of unknown HTTP headers and the number of entries in the array.
        /// </summary>
        UInt16 UnknownHeaderCount;
        UnknownHeader* pUnknownHeaders;

        // Trailers - we don't use these currently, reserved for a future release
        // Reserved, must be 0
        UInt16 TrailerCount;
        // Reserved, must be NULL
        UnknownHeader* pTrailers;

        /// <summary>
        /// Known headers.
        /// </summary>
        KnownHeader KnownHeaders[static_cast<size_t>( HeaderId::ResponseMaximum )];

        constexpr ResponseHeaders( ) noexcept
            : UnknownHeaderCount( 0 ),
              pUnknownHeaders( nullptr ),
              TrailerCount( 0 ),
              pTrailers( nullptr ),
              KnownHeaders{}
        {}

        void SetKnownHeader( HeaderId headerId, const char* value )
        {
            KnownHeader& knownHeader = KnownHeaders[static_cast<size_t>( headerId )];
            knownHeader.pRawValue = value;
            knownHeader.RawValueLength = static_cast<UInt16>(strlen( value ));
        }
        void SetKnownHeader( HeaderId headerId, const char* value, UInt16 valueLength )
        {
            KnownHeader& knownHeader = KnownHeaders[static_cast<size_t>( headerId )];
            knownHeader.pRawValue = value;
            knownHeader.RawValueLength = valueLength;
        }

        void SetContentType( const char* value )
        {
            SetKnownHeader( HeaderId::ContentType,value );
        }


        

    };
    static_assert( sizeof( HTTP_RESPONSE_HEADERS ) == sizeof( ResponseHeaders ) );

    /// <summary>
    /// Properties that can be passed down with IOCTL_HTTP_DELEGATE_REQUEST_EX
    /// </summary>
    enum class DelegateRequestPropertyId
    {
        Reserved
    };

    struct DelegateRequestPropertyInfo
    {
        DelegateRequestPropertyId ProperyId;
        UInt32 PropertyInfoLength;
        void* PropertyInfo;
    };
    static_assert( sizeof( HTTP_DELEGATE_REQUEST_PROPERTY_INFO ) == sizeof( DelegateRequestPropertyInfo ) );

    /// <summary>
    /// Structure defining format of transport address. Use pLocalAddress->sa_family
    /// to determine whether this is an IPv4 address (AF_INET) or IPv6 (AF_INET6).
    ///
    /// pRemoteAddress->sa_family will be the same as pLocalAddress->sa_family.
    ///
    /// SOCKADDRs are always in network order, not host order.
    /// </summary>
    struct TransportAddress
    {
        PSOCKADDR pRemoteAddress;
        PSOCKADDR pLocalAddress;
    }; 
    static_assert( sizeof( HTTP_TRANSPORT_ADDRESS ) == sizeof( TransportAddress ) );

    /// <summary>
    /// Structure defining format of cooked URL.
    /// </summary>
    /// <remarks>
    /// Pointers overlap and point into pFullUrl. NULL if not present.
    /// </remarks>
    struct CookedUrl
    {
        /// <summary>
        /// in bytes not including the NUL
        /// </summary>
        UInt16 FullUrlLength;
        /// <summary>
        /// in bytes (no NUL)
        /// </summary>
        UInt16 HostLength;
        /// <summary>
        /// in bytes (no NUL)
        /// </summary>
        UInt16 AbsPathLength;
        /// <summary>
        /// in bytes (no NUL)
        /// </summary>
        UInt16 QueryStringLength;

        /// <summary>
        /// points to "http://hostname:port/abs/.../path?query"
        /// </summary>
        const wchar_t* pFullUrl;     
        /// <summary>
        /// points to the first char in the hostname
        /// </summary>
        const wchar_t* pHost;
        /// <summary>
        /// Points to the 3rd '/' char
        /// </summary>
        const wchar_t* pAbsPath;
        /// <summary>
        /// Points to the 1st '?' char or NULL
        /// </summary>
        const wchar_t* pQueryString;

    };
    static_assert( sizeof( HTTP_COOKED_URL ) == sizeof( CookedUrl ) );

    using UrlContext = UInt64;

    enum class UrlFlags : UInt32
    {
        None = 0,
        RemoveAll = HTTP_URL_FLAG_REMOVE_ALL
    };
    HCC_DEFINE_ENUM_FLAG_OPERATORS( UrlFlags, UInt32 );


    enum class AuthStatus
    {
        Success = HttpAuthStatusSuccess,
        NotAuthenticated = HttpAuthStatusNotAuthenticated,
        Failure = HttpAuthStatusFailure
    };

    enum class RequestAuthType
    {
        None = 0,
        Basic,
        Digest,
        NTLM,
        Negotiate,
        Kerberos
    };

    /// <summary>
    /// SSL Client certificate information.
    /// </summary>
    struct SSLClientCertInfo
    {
        ULONG   CertFlags;
        ULONG   CertEncodedSize;
        PUCHAR  pCertEncoded;
        HANDLE  Token;
        BOOLEAN CertDeniedByMapper;

    };
    static_assert( sizeof( HTTP_SSL_CLIENT_CERT_INFO ) == sizeof( SSLClientCertInfo ) );

    /// <summary>
    /// Flag to retrieve secure channel binding with HttpReceiveClientCertificate
    /// </summary>
    enum class ReceiveClientCertificateFlags
    {
        None = 0,
        /// <summary>
        /// The sslClientCertInfo parameter will be populated with CBT data.
        /// </summary>
        ReceiveSecureChannelToken = HTTP_RECEIVE_SECURE_CHANNEL_TOKEN
    };

    struct SSLInfo
    {
        USHORT ServerCertKeySize;
        USHORT ConnectionKeySize;
        ULONG  ServerCertIssuerSize;
        ULONG  ServerCertSubjectSize;

        PCSTR  pServerCertIssuer;
        PCSTR  pServerCertSubject;

        SSLClientCertInfo* pClientCertInfo;
        ULONG SslClientCertNegotiated;

    };
    static_assert( sizeof( HTTP_SSL_INFO ) == sizeof( SSLInfo ) );

    struct SSLProtocolInfo
    {
        ULONG Protocol;
        ULONG CipherType;
        ULONG CipherStrength;
        ULONG HashType;
        ULONG HashStrength;
        ULONG KeyExchangeType;
        ULONG KeyExchangeStrength;

    }; 
    static_assert( sizeof( HTTP_SSL_PROTOCOL_INFO ) == sizeof( SSLProtocolInfo ) );

    enum class RequestSizingType
    {
        TlsHandshakeLeg1ClientData, // Inbound/outbound data?
        TlsHandshakeLeg1ServerData,
        TlsHandshakeLeg2ClientData,
        TlsHandshakeLeg2ServerData,
        Headers,
        Max
    };

    enum class RequestSizingInfoFlags : UInt32
    { 
        None = 0,
        TcpFastOpen = HTTP_REQUEST_SIZING_INFO_FLAG_TCP_FAST_OPEN,
        TlsSessionResumption = HTTP_REQUEST_SIZING_INFO_FLAG_TLS_SESSION_RESUMPTION,
        TlsFalseStart = HTTP_REQUEST_SIZING_INFO_FLAG_TLS_FALSE_START,
        FirstRequest = HTTP_REQUEST_SIZING_INFO_FLAG_FIRST_REQUEST
    };
    HCC_DEFINE_ENUM_FLAG_OPERATORS( RequestSizingInfoFlags, UInt32 );

    /// <summary>
    /// HttpRequestInfoTypeSizeInfo payload. Contains size information 
    /// filled by each processsing stage.
    /// </summary>
    struct RequestSizingInfo
    {
        ULONGLONG Flags;
        ULONG RequestIndex;
        ULONG RequestSizingCount;
        ULONGLONG RequestSizing[static_cast<size_t>( RequestSizingType::Max )];

    };
    static_assert( sizeof( HTTP_REQUEST_SIZING_INFO ) == sizeof( RequestSizingInfo ) );

    /// <summary>
    /// List of possible request timings for which information will be retured 
    /// in RequestTimingInfo. Not all timings apply for every request.
    /// </summary>
    enum  class RequestTimingType
    {
        ConnectionStart,
        DataStart,
        TlsCertificateLoadStart,
        TlsCertificateLoadEnd,
        TlsHandshakeLeg1Start,
        TlsHandshakeLeg1End,
        TlsHandshakeLeg2Start,
        TlsHandshakeLeg2End,
        TlsAttributesQueryStart,
        TlsAttributesQueryEnd,
        TlsClientCertQueryStart,
        TlsClientCertQueryEnd,
        Http2StreamStart,
        Http2HeaderDecodeStart,
        Http2HeaderDecodeEnd,
        RequestHeaderParseStart,
        RequestHeaderParseEnd,
        RequestRoutingStart,
        RequestRoutingEnd,
        RequestQueuedForInspection,
        RequestDeliveredForInspection,
        RequestReturnedAfterInspection,
        RequestQueuedForDelegation,
        RequestDeliveredForDelegation,
        RequestReturnedAfterDelegation,
        RequestQueuedForIO,
        RequestDeliveredForIO,
        Http3StreamStart,
        Http3HeaderDecodeStart,
        Http3HeaderDecodeEnd,
        Max
    };

    /// <summary>
    /// HttpRequestInfoTypeTiming payload.  Contains information about how 
    /// much time was spent at each request processing stage.
    /// </summary>
    typedef struct RequestTimingInfo
    {
        UInt32 RequestTimingCount;
        UInt64 RequestTiming[static_cast<size_t>( RequestTimingType::Max )];

        constexpr const UInt64& operator[]( RequestTimingType type ) const noexcept
        {
            return RequestTiming[static_cast<size_t>( type )];
        }
        constexpr UInt64& operator[]( RequestTimingType type ) noexcept
        {
            return RequestTiming[static_cast<size_t>( type )];
        }
    }; 
    static_assert( sizeof( HTTP_REQUEST_TIMING_INFO ) == sizeof( RequestTimingInfo ) );


    /// <summary>
    /// Generic request information type.
    /// </summary>
    enum class RequestInfoType
    {
        Auth,
        ChannelBind,
        SslProtocol,
        SslTokenBindingDraft,
        SslTokenBinding,
        RequestTiming,
        TcpInfoV0,
        RequestSizing,
        QuicStats,
        TcpInfoV1
    };

    struct RequestInfo
    {
        RequestInfoType InfoType;
        UInt32 InfoLength;
        void* pInfo;

    };

    static_assert( sizeof( HTTP_REQUEST_INFO ) == sizeof( RequestInfo ) );

    using SecurityStatus = Int32;

    enum class RequestAuthFlags : UInt32
    {
        None = 0,
        /// <summary>
        /// The provided token is for NTLM and is based on a cached 
        /// credential of a Keep Alive (KA) connection.
        /// </summary>
        TokenForCachedCred = HTTP_REQUEST_AUTH_FLAG_TOKEN_FOR_CACHED_CRED
    };

    /// <summary>
    /// Authentication request info structure
    /// </summary>
    struct RequestAuthInfo
    {
        /// <summary>
        /// A member of the AuthStatus enumeration that indicates 
        /// the final authentication status of the request.
        /// 
        /// If the authentication status is not AuthStatus::Success, 
        /// applications should disregard members of this structure 
        /// except AuthStatus, SecStatus, and AuthType.
        /// </summary>
        Http::AuthStatus AuthStatus;

        /// <summary>
        /// value that indicates the security failure status when the AuthStatus 
        /// member is AuthStatus::Failure
        /// </summary>
        SecurityStatus  SecStatus;

        /// <summary>
        /// The authentication flags indicating that the provided token is for 
        /// NTLM and is based on a cached credential of a Keep Alive (KA) connection.
        /// </summary>
        RequestAuthFlags Flags;

        /// <summary>
        /// A member of the RequestAuthType enumeration that indicates the 
        /// authentication scheme attempted or established for the request.
        /// </summary>
        RequestAuthType AuthType;

        /// <summary>
        /// A handle to the client token that the receiving process can use 
        /// to impersonate the authenticated client.
        /// 
        /// The handle to the token should be closed by calling CloseHandle 
        /// when it is no longer required. This token is valid only for the 
        /// lifetime of the request. Applications can regenerate the initial 
        /// 401 challenge to reauthenticate when the token expires.
        /// </summary>
        HANDLE AccessToken;

        /// <summary>
        /// The client context attributes for the access token.
        /// </summary>
        UInt32 ContextAttributes;

        //
        // Optional serialized context.
        //

        /// <summary>
        /// The length, in bytes, of the PackedContext.
        /// </summary>
        UInt32 PackedContextLength;

        /// <summary>
        /// The type of context in the PackedContext member.
        /// </summary>
        UInt32 PackedContextType;
        /// <summary>
        /// The security context for the authentication type.
        /// 
        /// Applications can query the attributes of the packed context by 
        /// calling the SSPI QueryContextAttributes API. However, applications 
        /// must acquire a credential handle for the security package for the 
        /// indicated AuthType.
        /// 
        /// Application should call the SSPI FreeContextBuffer API to free the 
        /// serialized context when it is no longer required.
        /// </summary>
        void* PackedContext;

        //
        // Optional mutual authentication data and its length in bytes.
        //

        /// <summary>
        /// The length, in bytes, of the pMutualAuthData member.
        /// </summary>
        UInt32 MutualAuthDataLength;
        /// <summary>
        /// The Base64 encoded mutual authentication data used in the WWW-Authenticate header.
        /// </summary>
        char* pMutualAuthData;

        //
        // For SSPI based schemes the package name is returned. Length does
        // not include the terminating null and it is in bytes.
        //
        UInt16 PackageNameLength;
        wchar_t* pPackageName;

    };
    static_assert( sizeof( HTTP_REQUEST_AUTH_INFO ) == sizeof( RequestAuthInfo ) );


    enum class RequestFlags : UInt32
    {
        None = 0,
        /// <summary>
        /// there is more entity body to be read for this request. 
        /// Otherwise, there is no entity body or all of the entity 
        /// body was copied into pEntityChunks.
        /// </summary>
        MoreEntityBodyExists = HTTP_REQUEST_FLAG_MORE_ENTITY_BODY_EXISTS,
        /// <summary>
        /// This flag indicates that the request has been routed based 
        /// on host plus ip or ip binding. This is a hint for the 
        /// application to include the local ip while flushing kernel 
        /// cache entries build for this request if any.
        /// </summary>
        IPRouted = HTTP_REQUEST_FLAG_IP_ROUTED,
        HTTP2 = HTTP_REQUEST_FLAG_HTTP2
    };
    HCC_DEFINE_ENUM_FLAG_OPERATORS( RequestFlags, UInt32 );

    struct RequestV1
    {
        //
        // Request flags (see RequestFlags definitions above).
        //

        RequestFlags Flags;

        //
        // An opaque request identifier. These values are used by the driver
        // to correlate outgoing responses with incoming requests.
        //

        Http::ConnectionId ConnectionId;
        Http::RequestId    RequestId;

        //
        // The context associated with the URL prefix.
        //

        Http::UrlContext UrlContext;

        //
        // The HTTP version number.
        //

        Http::Version Version;

        //
        // The request verb.
        //

        Http::Verb Verb;

        //
        // The length of the verb string if the Verb field is HttpVerbUnknown.
        //

        UInt16 UnknownVerbLength;           // in bytes not including the NUL

        //
        // The length of the raw (uncooked) URL
        //

        UInt16 RawUrlLength;                // in bytes not including the NUL

        //
        // Pointer to the verb string if the Verb field is HttpVerbUnknown.
        //

        const char* pUnknownVerb;

        //
        // Pointer to the raw (uncooked) URL
        //

        const char* pRawUrl;

        //
        // The canonicalized Unicode URL
        //

        Http::CookedUrl CookedUrl;

        //
        // Local and remote transport addresses for the connection.
        //

        Http::TransportAddress Address;

        //
        // The request headers.
        //

        Http::RequestHeaders Headers;

        //
        // The total number of bytes received from network for this request.
        //

        UInt64 BytesReceived;

        //
        // pEntityChunks is an array of EntityChunkCount DataChunks. The
        // entity body is copied only if HTTP_RECEIVE_REQUEST_FLAG_COPY_BODY
        // was passed to HttpReceiveHttpRequest().
        //

        UInt16 EntityChunkCount;
        DataChunk* pEntityChunks;

        //
        // SSL connection information.
        //

        Http::RawConnectionId RawConnectionId;
        SSLInfo* pSslInfo;

    }; 

    static_assert( sizeof( HTTP_REQUEST_V1 ) == sizeof( RequestV1 ) );

    struct RequestV2 : RequestV1
    {
        //
        // Additional Request Informations.
        //

        UInt16 RequestInfoCount;
        RequestInfo* pRequestInfo;
    };
    static_assert( sizeof( HTTP_REQUEST_V2 ) == sizeof( RequestV2 ) );

    using Request = RequestV2;

    /// <summary>
    /// Values for ResponseV1::Flags.
    /// </summary>
    enum class ResponseFlags : UInt32
    {
        None = 0,
        /// <summary>
        /// Set this flag if encodings other than identity form are available 
        /// for this resource.This flag is ignored if application has not asked 
        /// for response to be cached. It's used as a hint to the Http Server 
        /// API for content negotiation  used when serving from the the kernel 
        /// response cache.
        /// </summary>
        MultipleEncodingsAvailable = HTTP_RESPONSE_FLAG_MULTIPLE_ENCODINGS_AVAILABLE,
        /// <summary>
        /// there is more entity body to be read for this response.  Otherwise, 
        /// there is no entity body or all of the entity body was copied into 
        /// pEntityChunks.
        /// </summary>
        MoreEntityBodyExists = HTTP_RESPONSE_FLAG_MORE_ENTITY_BODY_EXISTS
    };
    HCC_DEFINE_ENUM_FLAG_OPERATORS( ResponseFlags, UInt32 );

    struct ResponseV1
    {
        //
        // Response flags (see ResponseFlags definitions above).
        //

        ResponseFlags Flags;

        //
        // The raw HTTP protocol version number.
        //

        Http::Version Version;

        //
        // The HTTP status code (e.g., 200).
        //

        UInt16 StatusCode;

        //
        // The HTTP reason (e.g., "OK"). This MUST not contain
        // non-ASCII characters (i.e., all chars must be in range 0x20-0x7E).
        //

        UInt16 ReasonLength;                 // in bytes not including the '\0'
        const char* pReason;

        //
        // The response headers.
        //

        ResponseHeaders Headers;

        //
        // pEntityChunks points to an array of EntityChunkCount HTTP_DATA_CHUNKs.
        //

        UInt16 EntityChunkCount;
        DataChunk* pEntityChunks;

        constexpr ResponseV1() noexcept
            : Flags( Http::ResponseFlags::None ), 
              Version( 1,1 ),
              StatusCode(0),
              ReasonLength(0),
              pReason( nullptr ),
              EntityChunkCount(0),
              pEntityChunks(nullptr)
        { }

    };
    static_assert( sizeof( HTTP_RESPONSE_V1 ) == sizeof( ResponseV1 ) );


    enum class ResponseInfoType
    {
        MultipleKnownHeaders,
        AuthenticationProperty,
        QoSProperty,
        ChannelBind
    };

    struct ResponseInfo
    {
        ResponseInfoType Type;
        UInt32 Length;
        void* pInfo;
    };
    static_assert( sizeof( HTTP_RESPONSE_INFO ) == sizeof( ResponseInfo ) );


    enum class ResponseInfoFlags : UInt32
    {
        None = 0,
        /// <summary>
        /// The specified order of authentication schemes is preserved on the challenge response.
        /// </summary>
        PreserveOrder = HTTP_RESPONSE_INFO_FLAGS_PRESERVE_ORDER
    };

    /// <summary>
    /// This structure allows the provision of providing multiple known headers.
    /// </summary>
    struct MultipleKnownHeaders
    {
        /// <summary>
        /// A member of the Http::HeaderId enumeration specifying the response header ID.
        /// </summary>
        Http::HeaderId HeaderId;

        /// <summary>
        /// The flags corresponding to the response header in the HeaderId member. 
        /// This member is used only when the WWW-Authenticate header is present.
        /// </summary>
        ResponseInfoFlags Flags;

        /// <summary>
        /// Number of headers of the same category.
        /// </summary>
        UInt16 KnownHeaderCount;

        /// <summary>
        /// A pointer to the first element in the array of KnownHeader structures.
        /// </summary>
        KnownHeader* KnownHeaders;

    };
    static_assert( sizeof( HTTP_MULTIPLE_KNOWN_HEADERS ) == sizeof( MultipleKnownHeaders ) );


    struct ResponseV2 : ResponseV1
    {
        using Base = ResponseV1;
        // Version 2.0 members are declared below
        UInt16 ResponseInfoCount;
        ResponseInfo* pResponseInfo;

        constexpr ResponseV2() noexcept
            : Base{}, ResponseInfoCount( 0 ), pResponseInfo(nullptr)
        { }


    };

    static_assert( sizeof( HTTP_RESPONSE_V2 ) == sizeof( ResponseV2 ) );
    using Response = ResponseV2;

    /// <summary>
    /// Api Version. This is used to ensure compatibility between applications and httpapi.dll and http.sys. 
    /// 
    /// This must not be confused with the HTTP Protocol version.
    /// 
    /// </summary>
    struct ApiVersion
    {
        UInt16 MajorVersion;
        UInt16 MinorVersion;

        constexpr ApiVersion( ) noexcept
            :MajorVersion( 0 ), MinorVersion( 0 )
        {
        }

        constexpr explicit ApiVersion( UInt16 majorVersion, UInt16 minorVersion = 0 ) noexcept
            :MajorVersion( majorVersion ), MinorVersion( minorVersion )
        {
        }

        constexpr explicit ApiVersion( const HTTPAPI_VERSION& other ) noexcept
            :MajorVersion( other.HttpApiMajorVersion ), MinorVersion( other.HttpApiMinorVersion )
        {
        }

        constexpr bool IsUnknown( ) const noexcept
        {
            return MajorVersion == 0 && MinorVersion == 0;
        }

        template<typename T>
        requires requires( T t )
        {
            { t.MajorVersion } -> std::same_as<UInt16>;
            { t.MinorVersion } -> std::same_as<UInt16>;
        }
        constexpr bool operator == ( const T& other ) const noexcept
        {
            return MajorVersion == other.MajorVersion && MinorVersion == other.MinorVersion;
        }
        template<typename T>
        requires requires( T t )
        {
            { t.MajorVersion } -> std::same_as<UInt16>;
            { t.MinorVersion } -> std::same_as<UInt16>;
        }
        constexpr bool operator != ( const T& other ) const noexcept
        {
            return MajorVersion != other.MajorVersion || MinorVersion != other.MinorVersion;
        }
        template<typename T>
        requires requires( T t )
        {
            { t.MajorVersion } -> std::same_as<UInt16>;
            { t.MinorVersion } -> std::same_as<UInt16>;
        }
        constexpr bool operator < ( const T& other ) const noexcept
        {
            return MajorVersion < other.MajorVersion ||
                ( MajorVersion == other.MajorVersion && MinorVersion < other.MinorVersion );
        }
        template<typename T>
        requires requires( T t )
        {
            { t.MajorVersion } -> std::same_as<UInt16>;
            { t.MinorVersion } -> std::same_as<UInt16>;
        }
        constexpr bool operator <= ( const T& other ) const noexcept
        {
            return MajorVersion < other.MajorVersion ||
                ( MajorVersion == other.MajorVersion && MinorVersion <= other.MinorVersion );
        }
        template<typename T>
        requires requires( T t )
        {
            { t.MajorVersion } -> std::same_as<UInt16>;
            { t.MinorVersion } -> std::same_as<UInt16>;
        }
        constexpr bool operator > ( const T& other ) const noexcept
        {
            return MajorVersion > other.MajorVersion ||
                ( MajorVersion == other.MajorVersion && MinorVersion > other.MinorVersion );
        }
        template<typename T>
        requires requires( T t )
        {
            { t.MajorVersion } -> std::same_as<UInt16>;
            { t.MinorVersion } -> std::same_as<UInt16>;
        }
        constexpr bool operator >= ( const T& other ) const noexcept
        {
            return MajorVersion > other.MajorVersion ||
                ( MajorVersion == other.MajorVersion && MinorVersion >= other.MinorVersion );
        }

    };
    static_assert( sizeof( HTTPAPI_VERSION ) == sizeof( ApiVersion ) );

    /// <summary>
    /// This enum defines the available cache policies.
    /// </summary>
    enum class CachePolicyType
    {
        Nocache,
        UserInvalidates,
        TimeToLive,

        Maximum

    };

    /// <summary>
    /// Only cache unauthorized GETs + HEADs.
    /// </summary>
    struct CachePolicy
    {
        CachePolicyType Policy;
        UInt32 SecondsToLive;

        CachePolicy()
            : Policy( CachePolicyType::Nocache ), SecondsToLive( 0 )
        { }

    }; 
    static_assert( sizeof( HTTP_CACHE_POLICY ) == sizeof( CachePolicy ) );


    /// <summary>
    /// Enum that is used with HttpSetServiceConfiguration(), HttpQueryServiceConfiguration(), and HttpDeleteServiceConfiguration() APIs.
    /// </summary>
    enum class ServiceConfigId
    {
        IPListenList,    // Set, Query & Delete.
        SSLCertInfo,     // Set, Update, Query & Delete.
        UrlAclInfo,      // Set, Query & Delete.
        Timeout,         // Set, Query & Delete.
        Cache,           // Set, Query & Delete.
#if _WIN32_WINNT >= _WIN32_WINNT_WIN8
        SslSniCertInfo,  // Set, Update, Query & Delete.
        SslCcsCertInfo,  // Set, Update, Query & Delete.
#endif

#if _WIN32_WINNT >= _WIN32_WINNT_WIN10
        Setting,        // Set, Query & Delete.
#endif
        SslCertInfoEx,
        SslSniCertInfoEx,
        SslCcsCertInfoEx,
        SslScopedCcsCertInfo,
        SslScopedCcsCertInfoEx,
        Max
    };

    /// <summary>
    /// Generic Query enum that can be used with HttpQueryServiceConfiguration()
    /// </summary>
    enum ServiceConfigQueryType
    {
        Exact,
        Next,
        Max
    };



    struct ServiceConfigSslKey
    {
        PSOCKADDR pIpPort;
    }; 
    static_assert( sizeof( HTTP_SERVICE_CONFIG_SSL_KEY ) == sizeof( ServiceConfigSslKey ) );

    struct ServiceConfigSslKeyEx
    {
        SOCKADDR_STORAGE IpPort;
    };
    static_assert( sizeof( HTTP_SERVICE_CONFIG_SSL_KEY_EX ) == sizeof( ServiceConfigSslKeyEx ) );

    struct ServiceConfigSslSniKey
    {
        SOCKADDR_STORAGE IpPort;
        wchar_t* Host;
    }; 
    static_assert( sizeof( HTTP_SERVICE_CONFIG_SSL_SNI_KEY ) == sizeof( ServiceConfigSslSniKey ) );

    struct ServiceConfigSslCcsKey
    {
        SOCKADDR_STORAGE LocalAddress;
    }; 
    static_assert( sizeof( HTTP_SERVICE_CONFIG_SSL_CCS_KEY ) == sizeof( ServiceConfigSslCcsKey ) );


    //
    // The SSL config flags.
    //
    enum class ServiceConfigSslFlags : UInt32
    {
        None = 0,

        UseDsMapper = HTTP_SERVICE_CONFIG_SSL_FLAG_USE_DS_MAPPER,
        NegotiateClientCert = HTTP_SERVICE_CONFIG_SSL_FLAG_NEGOTIATE_CLIENT_CERT,
#if _WIN32_WINNT < 0x0600
        NoRawFilter = HTTP_SERVICE_CONFIG_SSL_FLAG_NO_RAW_FILTER,
#endif // _WIN32_WINNT < 0x0600
        Reject = HTTP_SERVICE_CONFIG_SSL_FLAG_REJECT,

        DisableHttp2 = HTTP_SERVICE_CONFIG_SSL_FLAG_DISABLE_HTTP2,
        DisableQuic = HTTP_SERVICE_CONFIG_SSL_FLAG_DISABLE_QUIC,
        DisableTls13 = HTTP_SERVICE_CONFIG_SSL_FLAG_DISABLE_TLS13,

        DisableOcspStapling = HTTP_SERVICE_CONFIG_SSL_FLAG_DISABLE_OCSP_STAPLING,
        EnableTokenBinding = HTTP_SERVICE_CONFIG_SSL_FLAG_ENABLE_TOKEN_BINDING,
        LogExtendedEvents = HTTP_SERVICE_CONFIG_SSL_FLAG_LOG_EXTENDED_EVENTS,
        DisableKegacyTls = HTTP_SERVICE_CONFIG_SSL_FLAG_DISABLE_LEGACY_TLS,
        EnableSessionTicket = HTTP_SERVICE_CONFIG_SSL_FLAG_ENABLE_SESSION_TICKET,
        DisableTls12 = HTTP_SERVICE_CONFIG_SSL_FLAG_DISABLE_TLS12
    };
    HCC_DEFINE_ENUM_FLAG_OPERATORS( ServiceConfigSslFlags, UInt32 );


    struct ServiceConfigSslParam
    {
        /// <summary>
        /// Length of the SSL hash (in bytes)
        /// </summary>
        ULONG SslHashLength;
        /// <summary>
        /// Pointer to the SSL hash
        /// </summary>
        PVOID pSslHash; 

        constexpr std::span<const Byte> SslHash( ) const noexcept
        {
            return std::span<const Byte>( reinterpret_cast<Byte*>( pSslHash ), static_cast<size_t>( SslHashLength ) );
        }
        constexpr std::span<Byte> SslHash( ) noexcept
        {
            return std::span<Byte>( reinterpret_cast<Byte*>( pSslHash ), static_cast<size_t>( SslHashLength ) );
        }

        /// <summary>
        /// A unique identifier that can be used to identify the app that has set this parameter
        /// </summary>
        Guid  AppId;

        /// <summary>
        /// Store name to read the server certificate from; defaults to "MY". Certificate must be stored in the LOCAL_MACHINE context.
        /// </summary>
        PWSTR pSslCertStoreName;

        //
        // The following settings are used only for client certificates
        //

        //
        // DefaultCertCheckMode is a bit flag with the following semantics
        //  0x1     - Client certificate will not be verified for revocation
        //  0x2     - Only cached certificate revocation will be used.
        //  0x4     - Enable use of the DefaultRevocationFreshnessTime setting
        //  0x10000 - No usage check.

        DWORD DefaultCertCheckMode;

        //
        // DefaultRevocationFreshnessTime (seconds) - How often to check for
        // an updated Certificate revocation list (CRL). If this value is 0
        // then the new CRL is updated only if the previous one expires
        //

        DWORD DefaultRevocationFreshnessTime;

        //
        // DefaultRevocationUrlRetrievalTimeout (milliseconds) - Timeout on
        // attempt to retrieve certificate revocation list from the remote URL.
        //

        DWORD DefaultRevocationUrlRetrievalTimeout;

        //
        // pDefaultSslCtlIdentifier - Restrict the certificate issuers that you
        // want to trust. Can be a subset of the certificate issuers that are
        // trusted by the machine.
        //

        PWSTR pDefaultSslCtlIdentifier;

        //
        // Store name under LOCAL_MACHINE where Ctl identified by
        // pDefaultSslCtlIdentifier is stored.
        //

        PWSTR pDefaultSslCtlStoreName;

        //
        // Default Flags - see ServiceConfigSslFlags above.
        //

        ServiceConfigSslFlags DefaultFlags;

    }; 
    static_assert( sizeof( HTTP_SERVICE_CONFIG_SSL_PARAM ) == sizeof( ServiceConfigSslParam ) );


    enum class SslServiceConfigExParamType
    {
        Http2Window,
        Http2SettingsLimits,
        HttpPerformance,
        Max
    };

    struct Http2WindowSizeParam
    {
        //
        // The http/2 connection receive window size.
        //

        DWORD Http2ReceiveWindowSize;
    };
    static_assert( sizeof( HTTP2_WINDOW_SIZE_PARAM ) == sizeof( Http2WindowSizeParam ) );

    struct Http2SettingsLimitsParam
    {
        //
        // The maximum allowed settings per SETTINGS frame.
        //

        DWORD Http2MaxSettingsPerFrame;

        //
        // The maximum settings we will process in a minute.
        //

        DWORD Http2MaxSettingsPerMinute;
    };
    static_assert( sizeof( HTTP2_SETTINGS_LIMITS_PARAM ) == sizeof( Http2SettingsLimitsParam ) );

    enum class PerformanceParamType
    {
        SendBufferingFlags,
        AggressiveICW,
        MaxSendBufferSize,
        MaxConcurrentClientStreams,
        MaxReceiveBufferSize,
        DecryptOnSspiThread,
        Max
    };

    struct PerformanceParam
    {
        PerformanceParamType Type;
        ULONG BufferSize;
        PVOID Buffer;
    };
    static_assert( sizeof( HTTP_PERFORMANCE_PARAM ) == sizeof( PerformanceParam ) );

    struct ServiceConfigSslParamEx
    {
        //
        // The id that decides which param property is passed below.
        //

        SslServiceConfigExParamType ParamType;

        //
        // Flags for future use, if any.
        //

        ULONGLONG Flags;

        //
        // The property.
        //

        union
        {
            Http2WindowSizeParam Http2WindowSizeParam;
            Http2SettingsLimitsParam Http2SettingsLimitsParam;
            PerformanceParam HttpPerformanceParam;
        };
    };
    static_assert( sizeof( HTTP_SERVICE_CONFIG_SSL_PARAM_EX ) == sizeof( ServiceConfigSslParamEx ) );

    struct ServiceConfigSslSet
    {
        ServiceConfigSslKey KeyDesc;
        ServiceConfigSslParam ParamDesc;
    }; 
    static_assert( sizeof( HTTP_SERVICE_CONFIG_SSL_SET ) == sizeof( ServiceConfigSslSet ) );

    struct ServiceConfigSslSniSet
    {
        ServiceConfigSslSniKey KeyDesc;
        ServiceConfigSslParam ParamDesc;
    };
    static_assert( sizeof( HTTP_SERVICE_CONFIG_SSL_SNI_SET ) == sizeof( ServiceConfigSslSniSet ) );

    struct ServiceConfigSslCcsSet
    {
        ServiceConfigSslCcsKey KeyDesc;
        ServiceConfigSslParam ParamDesc;
    };
    static_assert( sizeof( HTTP_SERVICE_CONFIG_SSL_CCS_SET ) == sizeof( ServiceConfigSslCcsSet ) );

    struct ServiceConfigSslSetEx
    {
        ServiceConfigSslKeyEx KeyDesc;
        ServiceConfigSslParamEx ParamDesc;
    };
    static_assert( sizeof( HTTP_SERVICE_CONFIG_SSL_SET_EX ) == sizeof( ServiceConfigSslSetEx ) );

    struct ServiceConfigSslSniSetEx
    {
        ServiceConfigSslSniKey KeyDesc;
        ServiceConfigSslParamEx ParamDesc;
    };
    static_assert( sizeof( HTTP_SERVICE_CONFIG_SSL_SNI_SET_EX ) == sizeof( ServiceConfigSslSniSetEx ) );

    struct ServiceConfigSslCcsSetEx
    {
        ServiceConfigSslCcsKey KeyDesc;
        ServiceConfigSslParamEx ParamDesc;
    };
    static_assert( sizeof( HTTP_SERVICE_CONFIG_SSL_CCS_SET_EX ) == sizeof( ServiceConfigSslCcsSetEx ) );


    struct ServiceConfigSslQuery
    {
        ServiceConfigQueryType QueryDesc;
        ServiceConfigSslKey KeyDesc;
        DWORD dwToken;
    };
    static_assert( sizeof( HTTP_SERVICE_CONFIG_SSL_QUERY ) == sizeof( ServiceConfigSslQuery ) );

#if _WIN32_WINNT >= _WIN32_WINNT_WIN8

    struct ServiceConfigSslSniQuery
    {
        ServiceConfigQueryType QueryDesc;
        ServiceConfigSslSniKey KeyDesc;
        DWORD dwToken;
    };
    static_assert( sizeof( HTTP_SERVICE_CONFIG_SSL_SNI_QUERY ) == sizeof( ServiceConfigSslSniQuery ) );

    struct ServiceConfigSslCcsQuery
    {
        ServiceConfigQueryType QueryDesc;
        ServiceConfigSslCcsKey KeyDesc;
        DWORD dwToken;
    };
    static_assert( sizeof( HTTP_SERVICE_CONFIG_SSL_CCS_QUERY ) == sizeof( ServiceConfigSslCcsQuery ) );

    struct ServiceConfigSslQueryEx
    {
        ServiceConfigQueryType QueryDesc;
        ServiceConfigSslKeyEx KeyDesc;
        DWORD dwToken;
        SslServiceConfigExParamType ParamType;
    };
    static_assert( sizeof( HTTP_SERVICE_CONFIG_SSL_QUERY_EX ) == sizeof( ServiceConfigSslQueryEx ) );

    struct ServiceConfigSslSniQueryEx
    {
        ServiceConfigQueryType QueryDesc;
        ServiceConfigSslSniKey KeyDesc;
        DWORD dwToken;
        SslServiceConfigExParamType ParamType;
    };
    static_assert( sizeof( HTTP_SERVICE_CONFIG_SSL_SNI_QUERY_EX ) == sizeof( ServiceConfigSslSniQueryEx ) );

    struct ServiceConfigSslCcsQueryEx
    {
        ServiceConfigQueryType QueryDesc;
        ServiceConfigSslCcsKey KeyDesc;
        DWORD dwToken;
        SslServiceConfigExParamType ParamType;
    };
    static_assert( sizeof( HTTP_SERVICE_CONFIG_SSL_CCS_QUERY_EX ) == sizeof( ServiceConfigSslCcsQueryEx ) );
#endif

    /// <summary>
    /// Set/Delete IP Listen-Only List record 
    /// 
    /// Used as a parameter to both HttpSetServiceConfiguration() and HttpDeleteServiceConfiguration() functions.
    /// </summary>
    struct ServiceConfigIpListenParam
    {
        UInt16 AddrLength;
        PSOCKADDR pAddress;
    };
    static_assert( sizeof( HTTP_SERVICE_CONFIG_IP_LISTEN_PARAM ) == sizeof( ServiceConfigIpListenParam ) );

    /// <summary>
    /// Query IP Listen-Only List record.
    /// </summary>
    /// <remarks>
    /// Parameter to HttpQueryServiceConfiguration() for the config ID
    /// HttpServiceConfigIPListenList.  On successful return, AddrList
    /// contains an array of AddrCount elements.  Caller must provide a
    /// large enough buffer to hold all elements in one call.
    ///
    /// Caller may determine the type of each returned element by examining
    /// AddrList[i].ss_family. If it's AF_INET, use ((PSOCKADDR_IN) &AddrList[i]);
    /// otherwise, for AF_INET6, use ((PSOCKADDR_IN6) &AddrList[i])
    /// to select the appropriate address type.
    /// </remarks>
    struct ServiceConfigIpListenQuery
    {
        ULONG              AddrCount;
        SOCKADDR_STORAGE   AddrList[ANYSIZE_ARRAY];
    };
    static_assert( sizeof( HTTP_SERVICE_CONFIG_IP_LISTEN_QUERY ) == sizeof( ServiceConfigIpListenQuery ) );

    /// <summary>
    /// Url ACL
    /// </summary>
    typedef struct ServiceConfigUrlaclKey
    {
        PWSTR pUrlPrefix;

    };
    static_assert( sizeof( HTTP_SERVICE_CONFIG_URLACL_KEY ) == sizeof( ServiceConfigUrlaclKey ) );

    /// <summary>
    /// This defines a record for the SSL config store.
    /// </summary>
    typedef struct ServiceConfigUrlaclParam
    {
        PWSTR pStringSecurityDescriptor;
    };
    static_assert( sizeof( HTTP_SERVICE_CONFIG_URLACL_PARAM ) == sizeof( ServiceConfigUrlaclParam ) );

    typedef struct ServiceConfigUrlaclSet
    {
        ServiceConfigUrlaclKey KeyDesc;
        ServiceConfigUrlaclParam ParamDesc;
    };
    static_assert( sizeof( HTTP_SERVICE_CONFIG_URLACL_SET ) == sizeof( ServiceConfigUrlaclSet ) );

    /// <summary>
    /// This data structure is used by HttpQueryServiceConfiguration() for the
    /// config ID HttpServiceConfigUrlAclInfo. It's used to query a particular
    /// record from the URL ACL store.
    /// </summary>
    /// <remarks>
    /// If QueryType is HttpServiceConfigQueryExact, then one particular record of
    /// the type HTTP_SERVICE_CONFIG_URLACL_SET is returned. If the QueryType is
    /// HttpServiceConfigQueryNext, then the next instance of
    /// HTTP_SERVICE_CONFIG_URLACL_SET is returned. In such cases, the dwToken field
    /// represents the cursor. For the first item,  dwToken has to be 0.
    /// For subsequent items, dwToken has to be incremented by 1,
    /// until ERROR_NO_MORE_ITEMS is returned.
    /// </remarks>
    struct ServiceConfigUrlaclQuery
    {
        HTTP_SERVICE_CONFIG_QUERY_TYPE  QueryDesc;
        HTTP_SERVICE_CONFIG_URLACL_KEY  KeyDesc;
        DWORD                           dwToken;
    };
    static_assert( sizeof( HTTP_SERVICE_CONFIG_URLACL_QUERY ) == sizeof( ServiceConfigUrlaclQuery ) );

    //
    // Cache Paramemers
    //

    //
    // For manipulating global cache parameters.
    // The parameters that can be changed or queued are per-uri cache size
    // and cached range chunk size.
    //

    enum class ServiceConfigCacheKey
    {
        MaxCacheResponseSize = 0,
        CacheRangeChunkSize
    };

    using ServiceConfigCacheParam = UInt32;

    //
    // To set a cache parameter value use the set structure. To query use the key
    // directly. When you query a parameter value the output buffer must be exactly
    // the sizeof param.
    //

    struct ServiceConfigCacheSet
    {
        ServiceConfigCacheKey KeyDesc;
        ServiceConfigCacheParam ParamDesc;
    };
    static_assert( sizeof( HTTP_SERVICE_CONFIG_CACHE_SET ) == sizeof( ServiceConfigCacheSet ) );


    //
    // Input types for HttpQueryRequestProperty. Only types are public and not the API
    // so that IIS need not have their own types for public usage.
    //

    enum class RequestProperty
    {
        Isb,
        TcpInfoV0,
        QuicStats,
        TcpInfoV1,
        Sni,
    };

    struct QueryRequestQualifierTcp
    {
        ULONGLONG Freshness;
    };
    static_assert( sizeof( HTTP_QUERY_REQUEST_QUALIFIER_TCP ) == sizeof( QueryRequestQualifierTcp ) );


    struct QueryRequestQualifierQuic
    {
        ULONGLONG Freshness;
    };
    static_assert( sizeof( HTTP_QUERY_REQUEST_QUALIFIER_QUIC ) == sizeof( QueryRequestQualifierQuic ) );

    constexpr UInt32 RequestPropertySniHostMaxLength = HTTP_REQUEST_PROPERTY_SNI_HOST_MAX_LENGTH;

    enum class RequestPropertySniFlags : UInt32
    {
        None = 0,
        SniUsed = HTTP_REQUEST_PROPERTY_SNI_FLAG_SNI_USED,
        NoSni = HTTP_REQUEST_PROPERTY_SNI_FLAG_NO_SNI
    };
    HCC_DEFINE_ENUM_FLAG_OPERATORS( RequestPropertySniFlags, UInt32 );

    struct RequestPropertySni
    {
        wchar_t Hostname[RequestPropertySniHostMaxLength + 1];
        ULONG Flags;
    };
    static_assert( sizeof( HTTP_REQUEST_PROPERTY_SNI ) == sizeof( RequestPropertySni ) );


    /// <summary>
    /// Initializes the HTTP Server API driver, starts it, if it has not already 
    /// been started, and allocates data structures for the calling application 
    /// to support response-queue creation and other operations. Call this function 
    /// before calling any other functions in the HTTP Server API
    /// </summary>
    /// <param name="version">The API version information</param>
    /// <param name="flags">Initialization options</param>
    void Initialize( const ApiVersion& version, InitializeFlags flags )
    {
        auto rc = HttpInitialize( reinterpret_cast<const HTTPAPI_VERSION&>( version ), static_cast<ULONG>(flags), 0 );
        if ( rc != NO_ERROR )
        {
            ThrowOSError( rc );
        }
    }

    /// <summary>
    /// Cleans up resources used by the HTTP Server API to process calls by an application. 
    /// An application should call Terminate once for every time it called Initialize, with 
    /// matching flag settings.
    /// </summary>
    /// <param name="flags"></param>
    /// <remarks>
    /// Every call to Initialize should be matched by a corresponding call to Terminate. 
    /// For example, if you call Initialize with InitializeFlags::Server, you must call 
    /// Terminate with InitializeFlags::Server. If you call Initialize twice, once with 
    /// InitializeFlags::Server and the second time with InitializeFlags::Config, you 
    /// can call Terminate one time with both flags.
    /// </remarks>
    void Terminate( InitializeFlags flags )
    {
        auto rc = HttpTerminate( static_cast<ULONG>( flags ), nullptr );
        if ( rc != NO_ERROR )
        {
            ThrowOSError( rc );
        }
    }


    /// <summary>
    /// Creates an HTTP request queue for the calling application and returns a handle to it.
    /// </summary>
    /// <returns>handle to the request queue</returns>
    /// <remarks>
    /// Starting with HTTP Server API Version 2.0, applications should call CreateRequestQueue 
    /// to create the request queue; CreateHttpHandle should not be used.
    /// </remarks>
    HANDLE CreateHttpHandle( )
    {
        HANDLE result = 0;
        auto rc = HttpCreateHttpHandle( &result, 0 );
        if ( rc != NO_ERROR )
        {
            ThrowOSError( rc );
        }
        return result;
    }

    /// <summary>
    /// Creates a new request queue or opens an existing request queue
    /// </summary>
    /// <param name="version">The request queue API version information, must be 2.0 or greater</param>
    /// <param name="requestQueueName">The name of the request queue. The length, in bytes, cannot exceed MAX_PATH</param>
    /// <param name="securityAttributes">
    /// A pointer to the SECURITY_ATTRIBUTES structure that contains the access permissions for the request queue.
    /// <p>
    /// This parameter must be NULL when opening an existing request queue
    /// </p>
    /// </param>
    /// <param name="flags">The flags parameter defines the scope of the request queue.</param>
    /// <returns>The handle to the request queue</returns>
    HANDLE CreateRequestQueue( const ApiVersion& version, 
        const wchar_t* requestQueueName = nullptr, 
        PSECURITY_ATTRIBUTES securityAttributes = nullptr, 
        CreateRequestQueueFlags flags = CreateRequestQueueFlags::None )
    {
        HANDLE result = 0;
        auto rc = HttpCreateRequestQueue( reinterpret_cast<const HTTPAPI_VERSION&>( version ), requestQueueName, securityAttributes, static_cast<ULONG>( flags ), &result );
        if ( rc != NO_ERROR )
        {
            ThrowOSError( rc );
        }
        return result;
    }

    /// <summary>
    /// Closes the handle to the specified request queue created by CreateRequestQueue
    /// </summary>
    /// <param name="requestQueueHandle">The handle to the request queue that is closed.</param>
    void CloseRequestQueue( HANDLE requestQueueHandle )
    {
        auto rc = HttpCloseRequestQueue( requestQueueHandle );
        if ( rc != NO_ERROR )
        {
            ThrowOSError( rc );
        }
    }


    /// <summary>
    /// Sets a new property or modifies an existing property on the request queue identified by the specified handle
    /// </summary>
    /// <param name="requestQueueHandle">The handle to the request queue on which the property is set</param>
    /// <param name="property">A member of the Http::ServerProperty enumeration describing the property type that is set.</param>
    /// <param name="propertyInformation">A pointer to the buffer that contains the property information</param>
    /// <param name="propertyInformationLength">The length, in bytes, of the buffer pointed to by the propertyInformation parameter.</param>
    void SetRequestQueueProperty( HANDLE requestQueueHandle, 
        Http::ServerProperty property, void* propertyInformation, UInt32 propertyInformationLength )
    {
        auto rc = HttpSetRequestQueueProperty( requestQueueHandle, static_cast<HTTP_SERVER_PROPERTY>( property ), propertyInformation, propertyInformationLength, 0, nullptr );
        if ( rc != NO_ERROR )
        {
            ThrowOSError( rc );
        }
    }

    /// <summary>
    /// Queries a property of the request queue identified by the specified handle
    /// </summary>
    /// <param name="requestQueueHandle">The handle to the request queue for which the property setting is returned.</param>
    /// <param name="property">A member of the Http::ServerProperty enumeration that describes the property type that is set</param>
    /// <param name="propertyInformation">A pointer to the buffer that receives the property information.</param>
    /// <param name="propertyInformationLength">The length, in bytes, of the buffer pointed to by the pPropertyInformation parameter.</param>
    /// <param name="returnLength">The number, in bytes, returned in the pPropertyInformation buffer if not nullptr.
    /// <p>
    /// If the output buffer is too small, the call fails with a return value of ERROR_MORE_DATA. 
    /// The value pointed to by pReturnLength can be used to determine the minimum length of 
    /// the buffer required for the call to succeed.
    /// </p>
    /// </param>
    /// <returns></returns>
    UInt32 QueryRequestQueueProperty( HANDLE requestQueueHandle,
        Http::ServerProperty property, PVOID propertyInformation, UInt32 propertyInformationLength, UInt32* returnLength )
    {
        auto rc = HttpQueryRequestQueueProperty( requestQueueHandle, static_cast<HTTP_SERVER_PROPERTY>( property ), propertyInformation, propertyInformationLength,0, (PULONG)&returnLength, nullptr );
        if ( rc != NO_ERROR && ( rc != ERROR_MORE_DATA && returnLength != nullptr ) )
        {
            ThrowOSError( rc );
        }
        return rc;
    }

    /// <summary>
    /// Stops queuing requests for the specified request queue process. Outstanding calls to Http::ReceiveHttpRequest are canceled
    /// </summary>
    /// <param name="requestQueueHandle">The handle to the request queue that is shut down</param>
    /// <remarks>
    /// Http::ShutdownRequestQueue cancels outstanding requests and stops all processing on the 
    /// request queue process. The following steps are performed when this function is called:
    /// <ol>
    /// <li>The request queue process is marked for cleanup and no new requests are routed to the request queue process</li>
    /// <li>If the calling process is a controller, outstanding Http::WaitForDemandStart calls are canceled</li>
    /// <li>Pending Http::ReceiveHttpRequest calls from the calling process are canceled</li>
    /// <li>Requests that are already bound to the calling process are canceled.</li>
    /// <li>The unreceived pending requests that are queued to the request queue process rerouted to 
    /// another request queue process. If no other request queue process is available, the pending 
    /// requests are saved until the request queue is closed, or another non-controller request 
    /// queue process launches.</li>
    /// <li>Pending Http::WaitForDisconnect calls initiated by the calling process are canceled</li>
    /// <li>Outstanding responses indicated by the calling process are not affected, they are properly completed.</li>
    /// </ol>
    /// <p>
    /// Be aware that if the request queue handle is shared by multiple processes, 
    /// Http::ShutdownRequestQueue limits cleanup to the calling process. Other processes 
    /// currently working on the request queue are not affected.
    /// </p>
    /// <p>
    /// Http::ShutdownRequestQueue can be used by applications to recycle request queue processes. 
    /// For this purpose, Http::ShutdownRequestQueue is called prior to terminating a process that 
    /// shares the request queue with other processes. After Http::ShutdownRequestQueue returns, 
    /// the process can be safely terminated or recycled.
    /// </p>
    /// </remarks>
    void ShutdownRequestQueue( HANDLE requestQueueHandle )
    {
        auto rc = HttpShutdownRequestQueue( requestQueueHandle );
        if ( rc != NO_ERROR )
        {
            ThrowOSError( rc );
        }
    }

    /// <summary>
    /// Used by server applications to retrieve a client SSL certificate or channel binding token (CBT).
    /// </summary>
    /// <param name="requestQueueHandle">A handle to the request queue with which the specified SSL client or CBT is associated.</param>
    /// <param name="connectionId">
    /// A value that identifies the connection to the client. This value is obtained from the 
    /// ConnectionId element of an Http::Request structure filled in by the Http::ReceiveHttpRequest function.
    /// </param>
    /// <param name="flags">A value that modifies the behavior of the Http::ReceiveClientCertificate function</param>
    /// <param name="sslClientCertInfo">
    /// <p>
    /// If the flags parameter is ReceiveClientCertificateFlags::None, then this parameter points to 
    /// an Http::SSLClientCertInfo structure into which the function writes the requested client 
    /// certificate information. The buffer pointed to by the pSslClientCertInfo should be sufficiently 
    /// large enough to hold the Http::SSLClientCertInfo structure plus the value of the CertEncodedSize 
    /// member of this structure.
    /// </p>
    /// <p>
    /// If the Flags parameter is ReceiveClientCertificateFlags::ReceiveSecureChannelToken, then this 
    /// parameter points to an Http::RequestChannelBindStatus structure into which the function writes 
    /// the requested CBT information. The buffer pointed to by the sslClientCertInfo should be 
    /// sufficiently large enough to hold the Http::RequestChannelBindStatus structure plus the value 
    /// of the ChannelTokenSize member of this structure.
    /// </p>
    /// </param>
    /// <param name="sslClientCertInfoSize">The size, in bytes, of the buffer pointed to by the pSslClientCertInfo parameter.</param>
    /// <param name="bytesReceived">
    /// <p>
    /// An optional pointer to a variable that receives the number of bytes to be written to 
    /// the structure pointed to by sslClientCertInfo. If not used, set it to NULL.
    /// </p>
    /// <p>
    /// When making an asynchronous call using overlapped, set bytesReceived to NULL. Otherwise, when 
    /// overlapped is set to NULL, bytesReceived must contain a valid memory address, and not be set to NULL.
    /// </p>
    /// </param>
    /// <param name="overlapped">
    /// <p>
    /// For asynchronous calls, set overlapped to point to an OVERLAPPED structure, or for 
    /// synchronous calls, set it to NULL.
    /// </p>
    /// <p>
    /// A synchronous call blocks until the client certificate is retrieved, whereas 
    /// an asynchronous call immediately returns ERROR_IO_PENDING and the calling application 
    /// then uses GetOverlappedResult or I/O completion ports to determine when the operation 
    /// is completed. For more information about using OVERLAPPED structures for 
    /// synchronization, see the section Synchronization and Overlapped Input and Output.
    /// </p>
    /// </param>
    void ReceiveClientCertificate(
        HANDLE requestQueueHandle,
        Http::ConnectionId connectionId,
        ReceiveClientCertificateFlags flags,
        SSLClientCertInfo* sslClientCertInfo,
        UInt32 sslClientCertInfoSize,
        UInt32* bytesReceived,
        LPOVERLAPPED overlapped )
    {
        auto rc = HttpReceiveClientCertificate( requestQueueHandle, connectionId, static_cast<ULONG>( flags ), (PHTTP_SSL_CLIENT_CERT_INFO)sslClientCertInfo, sslClientCertInfoSize, (PULONG)bytesReceived, overlapped );
        if ( rc != NO_ERROR && (rc != ERROR_IO_PENDING && overlapped ) )
        {
            ThrowOSError( rc );
        }

    }

    /// <summary>
    /// Creates a server session for the specified version
    /// </summary>
    /// <param name="version">The structure that indicates the version of the server session, must be 2.0 or greater</param>
    /// <returns>the id of the server session</returns>
    Http::ServerSessionId CreateServerSession( const ApiVersion& version )
    {
        HTTP_SERVER_SESSION_ID result = 0;
        auto rc = HttpCreateServerSession( reinterpret_cast<const HTTPAPI_VERSION&>( version ), &result, 0 );
        if ( rc != NO_ERROR )
        {
            ThrowOSError( rc );
        }
        return result;
    }
    Http::ServerSessionId CreateServerSession( const HTTPAPI_VERSION& version )
    {
        HTTP_SERVER_SESSION_ID result = 0;
        auto rc = HttpCreateServerSession( version, &result, 0 );
        if ( rc != NO_ERROR )
        {
            ThrowOSError( rc );
        }
        return result;
    }

    /// <summary>
    /// Deletes the server session identified by the server session ID. 
    /// All remaining URL Groups associated with the server session will 
    /// also be closed.
    /// </summary>
    /// <param name="sessionId">The id of the server session that is closed</param>
    void CloseServerSession( Http::ServerSessionId sessionId )
    {
        auto rc = HttpCloseServerSession( sessionId );
        if ( rc != NO_ERROR )
        {
            ThrowOSError( rc );
        }
    }

    
    /// <summary>
    /// Queries a server property on the specified server session
    /// </summary>
    /// <param name="serverSessionId">The server session for which the property setting is returned</param>
    /// <param name="property">A member of the Http::ServerProperty enumeration that describes the property type that is queried.</param>
    /// <param name="propertyInformation">A pointer to the buffer that receives the property data</param>
    /// <param name="propertyInformationLength">The length, in bytes, of the buffer pointed to by the pPropertyInformation parameter</param>
    /// <param name="returnLength">
    /// <p>
    /// The number, in bytes, returned in the pPropertyInformation buffer.
    /// </p>
    /// <p>
    /// If the output buffer is too small, the call fails with a return 
    /// value of ERROR_MORE_DATA. The value pointed to by returnLength 
    /// can be used to determine the minimum length of the buffer required 
    /// for the call to succeed.
    /// </p>
    /// </param>
    /// <returns>
    /// <p>
    /// If the function succeeds, it returns NO_ERROR
    /// </p>
    /// <p>
    /// ERROR_MORE_DATA: The size, in bytes, of the buffer pointed to by 
    /// the propertyInformation parameter is too small to receive the property 
    /// data. On exit call the function again with a buffer at least as large 
    /// as the size pointed to by returnLength on exit.
    /// </p>
    /// </returns>
    UInt32 QueryServerSessionProperty( Http::ServerSessionId serverSessionId,
        Http::ServerProperty property,
        void* propertyInformation,
        UInt32 propertyInformationLength,
        UInt32* returnLength )
    {
        auto rc = HttpQueryServerSessionProperty( serverSessionId,
                        static_cast<HTTP_SERVER_PROPERTY>( property ),
                        propertyInformation,
                        propertyInformationLength,
                        reinterpret_cast<PULONG>( returnLength ) );
        if ( rc != NO_ERROR && ( rc != ERROR_MORE_DATA && returnLength ) )
        {
            ThrowOSError( rc );
        }
        return rc;
    }

    /// <summary>
    /// Sets a new server session property or modifies an existing property on the specified server session.
    /// </summary>
    /// <param name="serverSessionId">The server session for which the property is set.</param>
    /// <param name="property">A member of the Http::ServerProperty enumeration that describes the property type that is set.</param>
    /// <param name="propertyInformation">A pointer to the buffer that contains the property data.</param>
    /// <param name="propertyInformationLength">The length, in bytes, of the buffer pointed to by the propertyInformation parameter.</param>
    void SetServerSessionProperty( Http::ServerSessionId serverSessionId,
        Http::ServerProperty property,
        void* propertyInformation,
        UInt32 propertyInformationLength )
    {
        auto rc = HttpSetServerSessionProperty( serverSessionId, static_cast<HTTP_SERVER_PROPERTY>( property ), propertyInformation, propertyInformationLength );
        if ( rc != NO_ERROR )
        {
            ThrowOSError( rc );
        }
    }


    void AddUrl( HANDLE requestQueueHandle, const wchar_t* fullyQualifiedUrl )
    {
        auto rc = HttpAddUrl( requestQueueHandle, fullyQualifiedUrl, nullptr );
        if ( rc != NO_ERROR )
        {
            ThrowOSError( rc );
        }
    }

    void RemoveUrl( HANDLE requestQueueHandle, const wchar_t* fullyQualifiedUrl )
    {
        auto rc = HttpRemoveUrl( requestQueueHandle, fullyQualifiedUrl );
        if ( rc != NO_ERROR )
        {
            ThrowOSError( rc );
        }
    }

    /// <summary>
    /// creates a URL Group under the specified server session.
    /// </summary>
    /// <param name="serverSessionId">The identifier of the server session under which the URL Group is created.</param>
    /// <returns>The ID of the URL Group</returns>
    UrlGroupId CreateUrlGroup( ServerSessionId serverSessionId )
    {
        UrlGroupId result;
        auto rc = HttpCreateUrlGroup( serverSessionId,&result, 0 );
        if ( rc != NO_ERROR )
        {
            ThrowOSError( rc );
        }
        return result;
    }

    /// <summary>
    /// closes the URL Group identified by the URL Group ID. This call 
    /// also removes all of the URLs that are associated with the URL Group.
    /// </summary>
    /// <param name="urlGroupId">The ID of the URL Group that is deleted</param>
    void CloseUrlGroup( UrlGroupId urlGroupId )
    {
        auto rc = HttpCloseUrlGroup( urlGroupId );
        if ( rc != NO_ERROR )
        {
            ThrowOSError( rc );
        }
    }

    /// <summary>
    /// adds the specified URL to the URL Group identified by the URL Group ID
    /// </summary>
    /// <param name="urlGroupId">The group ID for the URL group to which requests for the specified URL are routed.</param>
    /// <param name="fullyQualifiedUrl">A pointer to a Unicode string that contains a properly formed UrlPrefix String that identifies the URL to be registered</param>
    /// <param name="urlContext">
    /// The context that is associated with the URL registered in this call. 
    /// The URL context is returned in the Http::Request structure with every 
    /// request received on the URL specified in the fullyQualifiedUrl parameter.
    /// </param>
    bool AddUrlToUrlGroup( UrlGroupId urlGroupId, const wchar_t* fullyQualifiedUrl, Http::UrlContext urlContext = 0 )
    {
        auto rc = HttpAddUrlToUrlGroup( urlGroupId, fullyQualifiedUrl, urlContext, 0 );
        if ( rc != NO_ERROR && rc != ERROR_ALREADY_EXISTS )
        {
            ThrowOSError( rc );
        }
        return rc != ERROR_ALREADY_EXISTS;
    }

    /// <summary>
    /// removes the specified URL from the group identified by the URL Group ID. 
    /// This function removes one, or all, of the URLs from the group.
    /// </summary>
    /// <param name="urlGroupId">The ID of the URL group from which the URL specified in pFullyQualifiedUrl is removed.</param>
    /// <param name="fullyQualifiedUrl">
    /// <p>
    /// A pointer to a Unicode string that contains a properly formed UrlPrefix String that identifies the URL to be removed.
    /// </p>
    /// <p>
    /// When UrlFlags::RemoveAll is passed in the flags parameter, all of the existing URL registrations for the URL Group 
    /// identified in UrlGroupId are removed from the group. In this case, fullyQualifiedUrl must be nullptr.
    /// </p>
    /// </param>
    /// <param name="flags"></param>
    /// <returns></returns>
    bool RemoveUrlFromUrlGroup( UrlGroupId urlGroupId, const wchar_t* fullyQualifiedUrl, UrlFlags flags = UrlFlags::None )
    {
        auto rc = HttpRemoveUrlFromUrlGroup( urlGroupId, fullyQualifiedUrl, static_cast<ULONG>(flags) );
        if ( rc != NO_ERROR && rc != ERROR_FILE_NOT_FOUND )
        {
            ThrowOSError( rc );
        }
        return rc != ERROR_FILE_NOT_FOUND;
    }

    /// <summary>
    /// Sets a new property or modifies an existing property on the specified URL Group
    /// </summary>
    /// <param name="urlGroupId">The ID of the URL Group for which the property is set</param>
    /// <param name="property">A member of the Http::ServerProperty enumeration that describes the property type that is modified or set</param>
    /// <param name="propertyInformation">A pointer to the buffer that contains the property information</param>
    /// <param name="propertyInformationLength">The length, in bytes, of the buffer pointed to by the propertyInformation parameter</param>
    void SetUrlGroupProperty( UrlGroupId urlGroupId, Http::ServerProperty property, void* propertyInformation, UInt32 propertyInformationLength )
    {
        auto rc = HttpSetUrlGroupProperty( urlGroupId, static_cast<HTTP_SERVER_PROPERTY>( property ), propertyInformation, propertyInformationLength );
        if ( rc != NO_ERROR )
        {
            ThrowOSError( rc );
        }
    }

    /// <summary>
    /// Queries a property on the specified URL Group
    /// </summary>
    /// <param name="urlGroupId">The ID of the URL Group for which the property setting is returned</param>
    /// <param name="property">A member of the Http::ServerProperty enumeration that describes the property type that is queried.</param>
    /// <param name="propertyInformation">A pointer to the buffer that receives the property information</param>
    /// <param name="propertyInformationLength">
    /// <p>
    /// The size, in bytes, returned in the propertyInformation buffer
    /// </p>
    /// <p>
    /// If the output buffer is too small, the call fails with a return value of ERROR_MORE_DATA. 
    /// The value pointed to by returnLength can be used to determine the minimum length of the 
    /// buffer required for the call to succeed
    /// </p>
    /// </param>
    /// <param name="returnLength"></param>
    /// <returns></returns>
    UInt32 QueryUrlGroupProperty( UrlGroupId urlGroupId, Http::ServerProperty property, void* propertyInformation, UInt32 propertyInformationLength, UInt32* returnLength )
    {
        auto rc = HttpQueryUrlGroupProperty( urlGroupId,
            static_cast<HTTP_SERVER_PROPERTY>( property ),
            propertyInformation,
            propertyInformationLength,
            reinterpret_cast<PULONG>( returnLength ) );
        if ( rc != NO_ERROR && ( rc != ERROR_MORE_DATA && returnLength ) )
        {
            ThrowOSError( rc );
        }
        return rc;
    }


    /// <summary>
    /// Parses, analyzes, and normalizes a non-normalized Unicode or punycode URL so it is safe and valid to use in other HTTP functions
    /// </summary>
    /// <param name="url">A pointer to a string that represents the non-normalized Unicode or punycode URL to prepare</param>
    /// <param name="preparedUrl">On successful output, a pointer to a string that represents the normalized URL</param>
    void PrepareUrl( const wchar_t* url, wchar_t** preparedUrl )
    {
        auto rc = HttpPrepareUrl( nullptr, 0, url, preparedUrl );
        if ( rc != NO_ERROR )
        {
            ThrowOSError( rc );
        }
    }

    WideString PrepareUrl( const wchar_t* url )
    {
        wchar_t* preparedUrl = nullptr;
        PrepareUrl( url, &preparedUrl );
        WideString result( preparedUrl );
        HeapFree( GetProcessHeap( ), 0, preparedUrl );
        return result;
    }


    /// <summary>
    /// retrieves the next available HTTP request from the specified request queue either synchronously or asynchronously
    /// </summary>
    /// <param name="requestQueueHandle">A handle to the request queue from which to retrieve the next available request.</param>
    /// <param name="requestId">
    /// On the first call to retrieve a request, this parameter should be Http::NullId. 
    /// Then, if more than one call is required to retrieve the entire request, 
    /// Http::ReceiveHttpRequest or Http::ReceiveRequestEntityBody can be called 
    /// with RequestID set to the value returned in the RequestId member of the 
    /// Http::Request structure pointed to by requestBuffer.
    /// </param>
    /// <param name="flags">A value from the Http::ReceiveRequestFlags enumeration</param>
    /// <param name="requestBuffer">
    /// A pointer to a buffer into which the function copies an Http::Request 
    /// structure and entity body for the HTTP request. Http::Request.RequestId 
    /// contains the identifier for this HTTP request, which the application 
    /// can use in subsequent calls Http::ReceiveRequestEntityBody, 
    /// Http::SendHttpResponse, or Http::SendResponseEntityBody.
    /// </param>
    /// <param name="requestBufferLength">Size, in bytes, of the pRequestBuffer buffer.</param>
    /// <param name="bytesReturned">
    /// <p>
    /// Optional. A pointer to a variable that receives the size, in bytes, 
    /// of the entity body, or of the remaining part of the entity body.
    /// </p>
    /// <p>
    /// When making an asynchronous call using overlapped, set bytesReceived to nullptr. 
    /// Otherwise, when overlapped is set to nullptr, bytesReceived must contain a 
    /// valid memory address, and not be set to nullptr.
    /// </p>
    /// </param>
    /// <param name="overlapped">
    /// <p>
    /// For asynchronous calls, set overlapped to point to an OVERLAPPED structure; 
    /// for synchronous calls, set it to NULL.
    /// </p>
    /// <p>
    /// A synchronous call blocks until a request has arrived in the specified queue 
    /// and some or all of it has been retrieved, whereas an asynchronous call immediately 
    /// returns ERROR_IO_PENDING and the calling application then uses GetOverlappedResult 
    /// or I/O completion ports to determine when the operation is completed.
    /// </p>
    /// </param>
    /// <returns></returns>
    ULONG ReceiveHttpRequest( HANDLE requestQueueHandle,
        Http::RequestId requestId,
        Http::ReceiveRequestFlags flags,
        Http::Request* requestBuffer,
        UInt32 requestBufferLength,
        UInt32* bytesReturned,
        LPOVERLAPPED overlapped )
    {
        
        auto rc = HttpReceiveHttpRequest( requestQueueHandle,
                            requestId,
                            static_cast<ULONG>(flags),
                            reinterpret_cast<HTTP_REQUEST*>( requestBuffer ),
                            requestBufferLength,
                            reinterpret_cast<PULONG>(bytesReturned),
                            overlapped );
        if ( rc != NO_ERROR && ( rc != ERROR_MORE_DATA && bytesReturned ) && (rc != ERROR_IO_PENDING && overlapped ) )
        {
            ThrowOSError( rc );
        }
        return rc;
    }

    /// <summary>
    /// receives additional entity body data for a specified HTTP request
    /// </summary>
    /// <param name="requestQueueHandle">The handle to the request queue from which to retrieve the specified entity body data.</param>
    /// <param name="requestId">The identifier of the HTTP request that contains the retrieved entity body. </param>
    /// <param name="flags">A value from the Http::ReceiveRequestEntityBodyFlags enumeration</param>
    /// <param name="entityBuffer">A pointer to a buffer that receives entity-body data</param>
    /// <param name="entityBufferLength">The size, in bytes, of the buffer pointed to by the pBuffer parameter</param>
    /// <param name="bytesReturned">
    /// <p>
    /// Optional. A pointer to a variables that receives the size, in bytes, 
    /// of the entity body data returned in the entityBuffer buffer.
    /// </p>
    /// <p>
    /// When making an asynchronous call using overlapped, set bytesReturned to nullptr. 
    /// Otherwise, when overlapped is set to nullptr, bytesReturned must contain a valid 
    /// memory address, and not be set to nullptr.
    /// </p>
    /// </param>
    /// <param name="overlapped">
    /// For asynchronous calls, set overlapped to point to an 
    /// OVERLAPPED structure; for synchronous calls, set it to nullptr.
    /// </param>
    /// <returns></returns>
    ULONG ReceiveRequestEntityBody( HANDLE requestQueueHandle, Http::RequestId requestId,
        Http::ReceiveRequestEntityBodyFlags flags,
        void* entityBuffer,
        UInt32 entityBufferLength,
        UInt32* bytesReturned,
        LPOVERLAPPED overlapped )
    {
        auto rc = HttpReceiveRequestEntityBody( requestQueueHandle, requestId, static_cast<ULONG>( flags ), entityBuffer, entityBufferLength, reinterpret_cast<PULONG>(bytesReturned), overlapped );
        if ( rc != NO_ERROR && ( rc != ERROR_IO_PENDING && overlapped ) )
        {
            ThrowOSError( rc );
        }
        return rc;
    }



    /// <summary>
    /// Sends an HTTP response to the specified HTTP request
    /// </summary>
    /// <param name="requestQueueHandle">A handle to the request queue from which the specified request was retrieved.</param>
    /// <param name="requestId">An identifier of the HTTP request to which this response corresponds.</param>
    /// <param name="flags">This parameter can be a combination of some of the flag values from the Http::SendResponseFlags enumeration</param>
    /// <param name="response">A pointer to an Http::Response structure that defines the HTTP response.</param>
    /// <param name="cachePolicy">A pointer to the Http::CachePolicy structure used to cache the response.</param>
    /// <param name="bytesSent">A pointer to a variable that receives the number, in bytes, sent if the function operates synchronously</param>
    /// <param name="overlapped">For asynchronous calls, set pOverlapped to point to an OVERLAPPED structure; for synchronous calls, set to NULL</param>
    /// <param name="logData">A pointer to the Http::LogData structure used to log the response.</param>
    /// <returns></returns>
    ULONG SendHttpResponse( HANDLE requestQueueHandle, Http::RequestId requestId,
        Http::SendResponseFlags flags,
        Http::Response* response,
        Http::CachePolicy* cachePolicy,
        UInt32* bytesSent,
        LPOVERLAPPED overlapped,
        LogData* logData = nullptr )
    {
        auto rc = HttpSendHttpResponse( requestQueueHandle, requestId,
            static_cast<ULONG>( flags ),
            reinterpret_cast<PHTTP_RESPONSE>( response ),
            reinterpret_cast<PHTTP_CACHE_POLICY>( cachePolicy ),
            reinterpret_cast<PULONG>( bytesSent ),
            nullptr, 0, overlapped, reinterpret_cast<PHTTP_LOG_DATA>(logData) );
        if ( rc != NO_ERROR && ( rc != ERROR_IO_PENDING && overlapped ) )
        {
            ThrowOSError( rc );
        }
        return rc;
    }


    /// <summary>
    /// Sends entity-body data associated with an HTTP response.
    /// </summary>
    /// <param name="requestQueueHandle">A handle to the request queue from which the specified request was retrieved.</param>
    /// <param name="requestId">An identifier of the HTTP request to which this response corresponds.</param>
    /// <param name="flags">This parameter can be a combination of some of the flag values from the Http::SendResponseFlags enumeration</param>
    /// <param name="entityChunkCount">A number of structures in the array pointed to by pEntityChunks. This count cannot exceed 9999</param>
    /// <param name="entityChunks">A pointer to an array of Http::DataChunk structures to be sent as entity-body data</param>
    /// <param name="bytesSent">A pointer to a variable that receives the number, in bytes, sent if the function operates synchronously.</param>
    /// <param name="overlapped">For asynchronous calls, set pOverlapped to point to an OVERLAPPED structure; for synchronous calls, set it to nullptr.</param>
    /// <param name="logData">A pointer to the Http::LogData structure used to log the response.</param>
    /// <returns></returns>
    ULONG SendResponseEntityBody( HANDLE requestQueueHandle, Http::RequestId requestId,
        Http::SendResponseFlags flags,
        UInt16 entityChunkCount,
        DataChunk* entityChunks,
        UInt32* bytesSent,
        LPOVERLAPPED overlapped,
        LogData* logData = nullptr )
    {
        auto rc = HttpSendResponseEntityBody( requestQueueHandle, requestId,
            static_cast<ULONG>( flags ),
            entityChunkCount,
            reinterpret_cast<PHTTP_DATA_CHUNK>(entityChunks),
            reinterpret_cast<PULONG>(bytesSent),
            nullptr,0,
            overlapped,
            reinterpret_cast<PHTTP_LOG_DATA>( logData ) );
        if ( rc != NO_ERROR && ( rc != ERROR_IO_PENDING && overlapped ) )
        {
            ThrowOSError( rc );
        }
        return rc;
    }

    
    /// <summary>
    /// Declares a resource-to-subresource relationship to use for 
    /// an HTTP server push. HTTP.sys then performs an HTTP 2.0 server 
    /// push for the given resource, if the underlying protocol, 
    /// connection, client, and policies allow the push operation.
    /// </summary>
    /// <param name="requestQueueHandle">The handle to an HTTP.sys request queue</param>
    /// <param name="requestId">The opaque identifier of the request that is declaring the push operation. The request must be from the specified queue handle</param>
    /// <param name="verb">The HTTP verb to use for the push operation. The HTTP.sys push operation only supports Http::Verb::Get and Http::Verb::Head</param>
    /// <param name="path">The path portion of the URL for the resource being pushed.</param>
    /// <param name="query">The query portion of the URL for the resource being pushed. This string should not include the leading question mark (?).</param>
    /// <param name="headers">
    /// <p>
    /// The request headers for the push operation
    /// </p>
    /// <p>
    /// You should not provide a Host header, because HTTP.sys automatically 
    /// generates the correct Host information. HTTP.sys does not support 
    /// cross-origin push operations, so HTTP.sys enforces and generates Host 
    /// information that matches the original client-initiated request.
    /// </p>
    /// <p>
    /// The push request is not allowed to have an entity body, so you 
    /// cannot include a non-zero Content-Length header or any 
    /// Transfer-Encoding header.
    /// </p>
    /// </param>
    /// <remarks>
    /// You should call Http::DeclarePush before you send any response 
    /// bytes that would cause the client to discover the subresource 
    /// itself. Failure to observe this order results in a race between 
    /// the server that is pushing the resource and the client that is 
    /// retrieving the resources, which can waste bandwidth. The server 
    /// application should only use Http::DeclarePush to push resources 
    /// that the server application is highly confident are needed and 
    /// not already cached by the client. If the server application pushes 
    /// other resources, unnecessary use of bandwidth and CPU may occur.
    /// </remarks>
    /// <returns></returns>
    void DeclarePush( HANDLE requestQueueHandle, Http::RequestId requestId, Http::Verb verb,
        const wchar_t* path,
        _In_opt_ PCSTR query,
        _In_opt_ PHTTP_REQUEST_HEADERS headers )
    {
        auto rc = HttpDeclarePush( requestQueueHandle, requestId, static_cast<HTTP_VERB>( verb ), path, query, reinterpret_cast<PHTTP_REQUEST_HEADERS>( headers ) );
        if ( rc != NO_ERROR )
        {
            ThrowOSError( rc );
        }
    }


    /// <summary>
    /// Notifies the application when the connection to an HTTP client is broken for any reason.
    /// </summary>
    /// <param name="requestQueueHandle">A handle to the request queue that handles requests from the specified connection.</param>
    /// <param name="connectionId">
    /// Identifier for the connection to the client computer. This value is returned 
    /// in the ConnectionID member of the Http::Request structure by a call to the 
    /// Http::ReceiveHttpRequest function.
    /// </param>
    /// <param name="overlapped">For asynchronous calls, set overlapped to point to an OVERLAPPED structure; for synchronous calls, set it to nullptr.</param>
    void WaitForDisconnect( HANDLE requestQueueHandle, Http::ConnectionId connectionId, LPOVERLAPPED overlapped )
    {
        auto rc = HttpWaitForDisconnect( requestQueueHandle, connectionId, overlapped );
        if ( rc != NO_ERROR && ( rc != ERROR_IO_PENDING && overlapped ) )
        {
            ThrowOSError( rc );
        }
    }

    /// <summary>
    /// Notifies the application when the connection to an HTTP client is broken for any reason.
    /// </summary>
    /// <param name="requestQueueHandle">A handle to the request queue that handles requests from the specified connection.</param>
    /// <param name="connectionId">
    /// Identifier for the connection to the client computer. This value is returned 
    /// in the ConnectionID member of the Http::Request structure by a call to the 
    /// Http::ReceiveHttpRequest function.
    /// </param>
    /// <param name="overlapped">For asynchronous calls, set overlapped to point to an OVERLAPPED structure; for synchronous calls, set it to nullptr.</param>
    void WaitForDisconnectEx( HANDLE requestQueueHandle, Http::ConnectionId connectionId, LPOVERLAPPED overlapped )
    {
        auto rc = HttpWaitForDisconnectEx( requestQueueHandle, connectionId, 0, overlapped );
        if ( rc != NO_ERROR && ( rc != ERROR_IO_PENDING && overlapped ) )
        {
            ThrowOSError( rc );
        }
    }

    /// <summary>
    /// Cancels a specified reqest
    /// </summary>
    /// <param name="requestQueueHandle">A handle to the request queue from which the request came</param>
    /// <param name="requestId">The ID of the request to be canceled</param>
    /// <param name="overlapped">For asynchronous calls, set overlapped to point to an OVERLAPPED structure; for synchronous calls, set it to nullptr.</param>
    void CancelHttpRequest( HANDLE requestQueueHandle, Http::RequestId requestId, LPOVERLAPPED overlapped )
    {
        auto rc = HttpCancelHttpRequest( requestQueueHandle, requestId, overlapped );
        if ( rc != NO_ERROR && ( rc != ERROR_IO_PENDING && overlapped ) )
        {
            ThrowOSError( rc );
        }
    }

    /// <summary>
    /// waits for the arrival of a new request that can be served by a new request queue process.
    /// </summary>
    /// <param name="requestQueueHandle">A handle to the request queue on which demand start is registered.</param>
    /// <param name="overlapped">For asynchronous calls, set overlapped to point to an OVERLAPPED structure; for synchronous calls, set it to nullptr. </param>
    /// <returns></returns>
    void WaitForDemandStart( HANDLE requestQueueHandle, LPOVERLAPPED overlapped )
    {
        auto rc = HttpWaitForDemandStart( requestQueueHandle, overlapped );
        if ( rc != NO_ERROR && ( rc != ERROR_IO_PENDING && overlapped ) )
        {
            ThrowOSError( rc );
        }
    }

    class RequestQueue;
    class ServerSession;
    /// <summary>
    /// 
    /// </summary>
    class UrlGroup
    {
        UrlGroupId urlGroupId_;
    public:
        constexpr UrlGroup() noexcept
            : urlGroupId_(0)
        { }

        constexpr explicit UrlGroup( UrlGroupId urlGroupId ) noexcept
            : urlGroupId_( urlGroupId )
        {
        }

        UrlGroup( const Http::ServerSession& serverSessionId );

        UrlGroup( const UrlGroup& other ) = delete;
        constexpr UrlGroup( UrlGroup&& other ) noexcept
            : urlGroupId_( other.urlGroupId_ )
        {
            other.urlGroupId_ = 0;
        }


        ~UrlGroup( )
        {
            if ( urlGroupId_ )
            {
                HttpCloseUrlGroup( urlGroupId_ );
            }
        }

        UrlGroup& operator = ( const UrlGroup& other ) = delete;
        UrlGroup& operator = ( UrlGroup&& other ) noexcept
        {
            if ( this != &other )
            {
                Close( );
                urlGroupId_ = other.urlGroupId_;
                other.urlGroupId_ = 0;
            }
            return *this;
        }

        constexpr UrlGroupId Id( ) const noexcept
        {
            return urlGroupId_;
        }

        void Close( ) noexcept
        {
            if ( urlGroupId_ )
            {
                HttpCloseUrlGroup( urlGroupId_ );
                urlGroupId_ = 0;
            }
        }

        Http::EnabledState EnabledState( ) const
        {
            UInt32 returnLength = 0;
            Http::StateInfo stateInfo;
            QueryUrlGroupProperty( urlGroupId_, ServerProperty::State, &stateInfo, sizeof( Http::StateInfo ), &returnLength );
            return stateInfo.State;
        }
        void SetEnabledState( Http::EnabledState enabledState )
        {
            Http::StateInfo stateInfo( enabledState );
            SetUrlGroupProperty( urlGroupId_, ServerProperty::State, &stateInfo, sizeof( Http::StateInfo ) );
        }

        void Bind( HANDLE requestQueueHandle ) const
        {
            Http::BindingInfo bindingInfo( requestQueueHandle );
            SetUrlGroupProperty( urlGroupId_, ServerProperty::Binding, &bindingInfo, sizeof( Http::BindingInfo ) );
        }

        void Bind( const RequestQueue& requestQueue ) const;

        void Unbind( ) const
        {
            Http::BindingInfo bindingInfo( nullptr );
            SetUrlGroupProperty( urlGroupId_, ServerProperty::Binding, &bindingInfo, sizeof( Http::BindingInfo ) );
        }

        bool AddUrl( const wchar_t* fullyQualifiedUrl, Http::UrlContext urlContext = 0 ) const
        {
            return AddUrlToUrlGroup( urlGroupId_, fullyQualifiedUrl, urlContext );
        }
        bool RemoveUrl( const wchar_t* fullyQualifiedUrl ) const
        {
            return RemoveUrlFromUrlGroup( urlGroupId_, fullyQualifiedUrl );
        }
        bool RemoveAllUrls( ) const
        {
            return RemoveUrlFromUrlGroup( urlGroupId_, nullptr, UrlFlags::RemoveAll );
        }




    };


    /// <summary>
    /// 
    /// </summary>
    class RequestQueue
    {
        HANDLE requestQueueHandle_;
    public:
        static constexpr UInt32 DefaultRequestBufferSize = 64 * 1024;

        constexpr RequestQueue( ) noexcept
            : requestQueueHandle_( 0 )
        { }

        constexpr explicit RequestQueue( HANDLE requestQueueHandle ) noexcept
            : requestQueueHandle_( requestQueueHandle )
        { }


        explicit RequestQueue( const ApiVersion& version, const wchar_t* requestQueueName = nullptr, CreateRequestQueueFlags flags = CreateRequestQueueFlags::None, PSECURITY_ATTRIBUTES securityAttributes = nullptr )
            : requestQueueHandle_( CreateRequestQueue( version, requestQueueName, securityAttributes, flags ) )
        {
            
        }

        constexpr RequestQueue( const RequestQueue& other ) = delete;
        constexpr RequestQueue( RequestQueue&& other ) noexcept
            : requestQueueHandle_( other.requestQueueHandle_ )
        {
            other.requestQueueHandle_ = 0;
        }


        ~RequestQueue( )
        {
            if ( requestQueueHandle_ )
            {
                HttpCloseRequestQueue( requestQueueHandle_ );
            }
        }

        RequestQueue& operator = ( const RequestQueue& other ) = delete;
        RequestQueue& operator = ( RequestQueue&& other ) noexcept
        {
            if ( this != &other )
            {
                Close( );
                requestQueueHandle_ = other.requestQueueHandle_;
                other.requestQueueHandle_ = 0;
            }
            return *this;
        }


        void Close( ) noexcept
        {
            if ( requestQueueHandle_ )
            {
                HttpCloseRequestQueue( requestQueueHandle_ );
                requestQueueHandle_ = 0;
            }
        }

        constexpr HANDLE Handle( ) const noexcept
        {
            return requestQueueHandle_;
        }

        ULONG Receive( Http::ReceiveRequestFlags flags,
            Http::Request* requestBuffer,
            UInt32 requestBufferLength,
            UInt32* bytesReturned ) const
        {
            return ReceiveHttpRequest( requestQueueHandle_, Http::NullId, flags, requestBuffer, requestBufferLength, bytesReturned, nullptr );
        }
        ULONG Receive( Http::RequestId requestId, Http::ReceiveRequestFlags flags,
            Http::Request* requestBuffer,
            UInt32 requestBufferLength,
            UInt32* bytesReturned ) const
        {
            return ReceiveHttpRequest( requestQueueHandle_, requestId, flags, requestBuffer, requestBufferLength, bytesReturned, nullptr );
        }


        ULONG Receive( Http::ReceiveRequestFlags flags,
            Http::Request* requestBuffer,
            UInt32 requestBufferLength,
            LPOVERLAPPED overlapped ) const
        {
            return ReceiveHttpRequest( requestQueueHandle_, Http::NullId, flags, requestBuffer, requestBufferLength, nullptr, overlapped );
        }

        ULONG SendResponse( Http::RequestId requestId,
            Http::SendResponseFlags flags,
            Http::Response* response,
            Http::CachePolicy* cachePolicy,
            UInt32* bytesSent,
            LogData* logData = nullptr ) const
        {
            return SendHttpResponse( requestQueueHandle_, requestId,
                flags,
                response,
                cachePolicy,
                bytesSent,
                nullptr,
                logData );
        }

        ULONG SendResponse( Http::RequestId requestId,
            Http::SendResponseFlags flags,
            Http::Response* response,
            Http::CachePolicy* cachePolicy,
            LPOVERLAPPED overlapped,
            LogData* logData = nullptr ) const
        {
            return SendHttpResponse( requestQueueHandle_, requestId,
                flags,
                response,
                cachePolicy,
                nullptr,
                overlapped,
                logData );
        }

        ULONG SendResponse( Http::RequestId requestId, UInt16 statusCode, const char* reason, const char* html ) const
        {
            Http::Response httpResponse;
            httpResponse.Headers.SetContentType("text/html");
            httpResponse.StatusCode = statusCode;
            httpResponse.pReason = reason;
            httpResponse.ReasonLength = static_cast<UInt16>( strlen( reason ) );
            Http::DataChunk httpDataChunk;
            Http::CachePolicy httpCachePolicy;
            UInt32 bytesSent = 0;
            if ( html )
            {
                httpResponse.EntityChunkCount = 1;
                httpResponse.pEntityChunks = &httpDataChunk;
                httpDataChunk.FromMemory.pBuffer = const_cast<char*>(html);
                httpDataChunk.FromMemory.BufferLength = static_cast<UInt32>( strlen( html ) );
            }

            return SendResponse( requestId, Http::SendResponseFlags::None,&httpResponse,&httpCachePolicy, &bytesSent );

        }


    };

    inline void UrlGroup::Bind( const RequestQueue& requestQueue ) const
    {
        Bind( requestQueue.Handle() );
    }


    /// <summary>
    /// 
    /// </summary>
    class ServerSession
    {
        Http::ServerSessionId serverSessionId_;
    public:
        constexpr ServerSession() noexcept
            : serverSessionId_(0)
        { }

        constexpr explicit ServerSession( Http::ServerSessionId serverSessionId ) noexcept
            : serverSessionId_( serverSessionId )
        { }

        ServerSession(const ApiVersion& version )
            : serverSessionId_( CreateServerSession( version ) )
        { }

        ServerSession( const ServerSession& other ) = delete;
        ServerSession( ServerSession&& other ) noexcept
            : serverSessionId_( other.serverSessionId_ )
        {
            other.serverSessionId_ = 0;
        }


        ~ServerSession( )
        {
            if ( serverSessionId_ )
            {
                HttpCloseServerSession( serverSessionId_ );
            }
        }

        constexpr Http::ServerSessionId Id( ) const noexcept
        {
            return serverSessionId_;
        }

        ServerSession& operator = ( const ServerSession& other ) = delete;
        ServerSession& operator = ( ServerSession&& other ) noexcept
        {
            if ( this != &other )
            {
                Close( );
                serverSessionId_ = other.serverSessionId_;
                other.serverSessionId_ = 0;
            }
            return *this;
        }

        void Close( ) noexcept
        {
            if ( serverSessionId_ )
            {
                HttpCloseServerSession( serverSessionId_ );
                serverSessionId_ = 0;
            }
        }

        UrlGroup CreateUrlGroup( ) const
        {
            return UrlGroup( *this );
        }

        Http::EnabledState EnabledState( ) const
        {
            UInt32 returnLength = 0;
            Http::StateInfo stateInfo;
            QueryServerSessionProperty( serverSessionId_, ServerProperty::State, &stateInfo, sizeof( Http::StateInfo ), &returnLength );
            return stateInfo.State;
        }
        void SetEnabledState( Http::EnabledState enabledState )
        {
            Http::StateInfo stateInfo( enabledState );
            SetServerSessionProperty( serverSessionId_, ServerProperty::State, &stateInfo, sizeof( Http::StateInfo ) );
        }




    };

    inline UrlGroup::UrlGroup( const Http::ServerSession& serverSession )
        : urlGroupId_( Http::CreateUrlGroup( serverSession.Id() ) )
    {
    }




    /// <summary>
    /// HTTP.sys initialization/termination
    /// </summary>
    class Application
    {
        InitializeFlags flags_;
    public:
        Application(const ApiVersion& version = ApiVersion(2,0), InitializeFlags flags = InitializeFlags::Server | InitializeFlags::Config )
            : flags_( flags )
        {
            Http::Initialize( version, flags );
        }
        ~Application( )
        {
            Http::Terminate( flags_ );
        }
    };

    
    namespace Server
    {

        enum class RequestType
        {
            Unknown,
            Receive,
            ReceiveBody,
            Send,
            SendBody,
            ReceiveClientCertificate,
            WaitForDisconnect,
            WaitForDisconnectEx,
            Cancel,
            WaitForDemandStart,
        };


        class Request : public IO::Request
        {
        public:
            using Base = IO::Request;
        private:
            RequestType type_;
        protected:
            explicit Request( HANDLE handle, Server::RequestType type )
                : Base( handle ), type_( type )
            {
            }

            constexpr explicit Request( HANDLE handle, HANDLE manualResetEvent, bool ownsEvent, Server::RequestType type ) noexcept
                : Base( handle, manualResetEvent, ownsEvent ), type_( type )
            {
            }
            explicit Request( const RequestQueue& requestQueue, Server::RequestType type )
                : Base( requestQueue.Handle( ) ), type_( type )
            {
            }

            constexpr explicit Request( const RequestQueue& requestQueue, HANDLE manualResetEvent, bool ownsEvent, Server::RequestType type ) noexcept
                : Base( requestQueue.Handle( ), manualResetEvent, ownsEvent ), type_( type )
            {
            }
        public:
            constexpr RequestType Type( ) const noexcept
            {
                return type_;
            }

        };

        class ReceiveRequest : public Request
        {
        public:
            using Base = Request;
            static constexpr Server::RequestType RequestType = Server::RequestType::Receive;
        private:
            Http::RequestId requestId_;
            Http::ReceiveRequestFlags flags_;
            Http::Request* requestBuffer_;
            UInt32 requestBufferLength_;
        public:
            explicit ReceiveRequest( HANDLE handle, Http::RequestId requestId, Http::ReceiveRequestFlags flags, Http::Request* requestBuffer, UInt32 requestBufferLength )
                : Base( handle, RequestType ), requestId_( requestId ), flags_( flags ), requestBuffer_( requestBuffer ), requestBufferLength_( requestBufferLength )
            {
            }

            constexpr explicit ReceiveRequest( HANDLE handle, HANDLE manualResetEvent, bool ownsEvent, Http::RequestId requestId, Http::ReceiveRequestFlags flags, Http::Request* requestBuffer, UInt32 requestBufferLength )
                : Base( handle, manualResetEvent, ownsEvent, RequestType ), requestId_( requestId ), flags_( flags ), requestBuffer_( requestBuffer ), requestBufferLength_( requestBufferLength )
            {
            }
            explicit ReceiveRequest( const RequestQueue& requestQueue, Http::RequestId requestId, Http::ReceiveRequestFlags flags, Http::Request* requestBuffer, UInt32 requestBufferLength )
                : Base( requestQueue.Handle( ), RequestType ), requestId_( requestId ), flags_( flags ), requestBuffer_( requestBuffer ), requestBufferLength_( requestBufferLength )
            {
            }

            constexpr explicit ReceiveRequest( const RequestQueue& requestQueue, HANDLE manualResetEvent, bool ownsEvent, Http::RequestId requestId, Http::ReceiveRequestFlags flags, Http::Request* requestBuffer, UInt32 requestBufferLength )
                : Base( requestQueue.Handle( ), manualResetEvent, ownsEvent, RequestType ), requestId_( requestId ), flags_( flags ), requestBuffer_( requestBuffer ), requestBufferLength_( requestBufferLength )
            {
            }

            constexpr void Assign( Http::RequestId requestId, Http::ReceiveRequestFlags flags, Http::Request* requestBuffer, UInt32 requestBufferLength )
            {
                requestId_ = requestId;
                flags_ = flags;
                requestBuffer_ = requestBuffer;
                requestBufferLength_ = requestBufferLength;
            }

            constexpr Http::RequestId RequestId( ) const noexcept
            {
                return requestId_;
            }

            constexpr Http::ReceiveRequestFlags Flags( ) const noexcept
            {
                return flags_;
            }

            constexpr Http::Request* Request( ) const noexcept
            {
                return requestBuffer_;
            }

            constexpr UInt32 RequestLength( ) const noexcept
            {
                return requestBufferLength_;
            }

        };

        class ReceiveBodyRequest : public Request
        {
        public:
            using Base = Request;
            static constexpr Server::RequestType RequestType = Server::RequestType::ReceiveBody;
        private:
            Http::RequestId requestId_;
            Http::ReceiveRequestEntityBodyFlags flags_;
            Byte* buffer_;
            UInt32 bufferLength_;
        public:
            explicit ReceiveBodyRequest( HANDLE handle, Http::RequestId requestId, Http::ReceiveRequestEntityBodyFlags flags, void* buffer, UInt32 bufferLength )
                : Base( handle, RequestType ), requestId_( requestId ), flags_( flags ), buffer_( reinterpret_cast<Byte*>( buffer ) ), bufferLength_( bufferLength )
            {
            }

            constexpr explicit ReceiveBodyRequest( HANDLE handle, HANDLE manualResetEvent, bool ownsEvent, Http::RequestId requestId, Http::ReceiveRequestEntityBodyFlags flags, void* buffer, UInt32 bufferLength )
                : Base( handle, manualResetEvent, ownsEvent, RequestType ), requestId_( requestId ), flags_( flags ), buffer_( (Byte*)buffer ), bufferLength_( bufferLength )
            {
            }
            explicit ReceiveBodyRequest( const RequestQueue& requestQueue, Http::RequestId requestId, Http::ReceiveRequestEntityBodyFlags flags, void* buffer, UInt32 bufferLength )
                : Base( requestQueue.Handle( ), RequestType ), requestId_( requestId ), flags_( flags ), buffer_( reinterpret_cast<Byte*>( buffer ) ), bufferLength_( bufferLength )
            {
            }

            constexpr explicit ReceiveBodyRequest( const RequestQueue& requestQueue, HANDLE manualResetEvent, bool ownsEvent, Http::RequestId requestId, Http::ReceiveRequestEntityBodyFlags flags, void* buffer, UInt32 bufferLength )
                : Base( requestQueue.Handle( ), manualResetEvent, ownsEvent, RequestType ), requestId_( requestId ), flags_( flags ), buffer_( (Byte*)buffer ), bufferLength_( bufferLength )
            {
            }

            constexpr void Assign( Http::RequestId requestId, Http::ReceiveRequestEntityBodyFlags flags, void* requestBuffer, UInt32 requestBufferLength )
            {
                requestId_ = requestId;
                flags_ = flags;
                buffer_ = (Byte*)requestBuffer;
                bufferLength_ = requestBufferLength;
            }

            constexpr Http::RequestId RequestId( ) const noexcept
            {
                return requestId_;
            }

            constexpr Http::ReceiveRequestEntityBodyFlags Flags( ) const noexcept
            {
                return flags_;
            }

            constexpr Byte* Buffer( ) const noexcept
            {
                return buffer_;
            }

            constexpr UInt32 BufferLength( ) const noexcept
            {
                return bufferLength_;
            }
        };

        class SendRequest : public Request
        {
        public:
            using Base = Request;
            static constexpr Server::RequestType RequestType = Server::RequestType::Send;
        private:
            Http::RequestId requestId_;
            Http::SendResponseFlags flags_;
            Http::Response* response_;
            Http::CachePolicy* cachePolicy_;
            Http::LogData* logData_;
        public:
            explicit SendRequest( HANDLE handle, Http::RequestId requestId, Http::SendResponseFlags flags, Http::Response* response, Http::CachePolicy* cachePolicy, Http::LogData* logData = nullptr )
                : Base( handle, RequestType ), requestId_( requestId ), flags_( flags ), response_( response ), cachePolicy_( cachePolicy ), logData_( logData )
            {
            }

            constexpr explicit SendRequest( HANDLE handle, HANDLE manualResetEvent, bool ownsEvent, Http::RequestId requestId, Http::SendResponseFlags flags, Http::Response* response, Http::CachePolicy* cachePolicy, Http::LogData* logData = nullptr ) noexcept
                : Base( handle, manualResetEvent, ownsEvent, RequestType ), requestId_( requestId ), flags_( flags ), response_( response ), cachePolicy_( cachePolicy ), logData_( logData )
            {
            }
            explicit SendRequest( const RequestQueue& requestQueue, Http::RequestId requestId, Http::SendResponseFlags flags, Http::Response* response, Http::CachePolicy* cachePolicy, Http::LogData* logData = nullptr )
                : Base( requestQueue.Handle( ), RequestType ), requestId_( requestId ), flags_( flags ), response_( response ), cachePolicy_( cachePolicy ), logData_( logData )
            {
            }

            constexpr explicit SendRequest( const RequestQueue& requestQueue, HANDLE manualResetEvent, bool ownsEvent, Http::RequestId requestId, Http::SendResponseFlags flags, Http::Response* response, Http::CachePolicy* cachePolicy, Http::LogData* logData = nullptr ) noexcept
                : Base( requestQueue.Handle( ), manualResetEvent, ownsEvent, RequestType ), requestId_( requestId ), flags_( flags ), response_( response ), cachePolicy_( cachePolicy ), logData_( logData )
            {
            }

            constexpr void Assign( Http::RequestId requestId, Http::SendResponseFlags flags, Http::Response* response, Http::CachePolicy* cachePolicy, Http::LogData* logData = nullptr ) noexcept
            {
                requestId_ = requestId; 
                flags_ = flags; 
                response_ = response; 
                cachePolicy_ = cachePolicy; 
                logData_ = logData;
            }

            constexpr Http::RequestId RequestId( ) const noexcept
            {
                return requestId_;
            }
            constexpr Http::SendResponseFlags Flags( ) const noexcept
            {
                return flags_;
            }
            constexpr Http::Response* Response( ) const noexcept
            {
                return response_;
            }
            constexpr Http::CachePolicy* CachePolicy( ) const noexcept
            {
                return cachePolicy_;
            }
            constexpr Http::LogData* LogData( ) const noexcept
            {
                return logData_;
            }

        };

        class SendBodyRequest : public Request
        {
        public:
            using Base = Request;
            static constexpr Server::RequestType RequestType = Server::RequestType::SendBody;
        private:
            Http::RequestId requestId_;
            Http::SendResponseFlags flags_;
            UInt16 entityChunkCount_;
            DataChunk* entityChunks_;
            LogData* logData_;
        public:
            explicit SendBodyRequest( HANDLE handle, Http::RequestId requestId, Http::SendResponseFlags flags, UInt16 entityChunkCount, DataChunk* entityChunks, LogData* logData = nullptr )
                : Base( handle, RequestType ), requestId_( requestId ), flags_( flags ), entityChunkCount_( entityChunkCount ), entityChunks_( entityChunks ), logData_( logData )
            {
            }

            constexpr explicit SendBodyRequest( HANDLE handle, HANDLE manualResetEvent, bool ownsEvent, Http::RequestId requestId, Http::SendResponseFlags flags, UInt16 entityChunkCount, DataChunk* entityChunks, LogData* logData = nullptr ) noexcept
                : Base( handle, manualResetEvent, ownsEvent, RequestType ), requestId_( requestId ), flags_( flags ), entityChunkCount_( entityChunkCount ), entityChunks_( entityChunks ), logData_( logData )
            {
            }
            explicit SendBodyRequest( const RequestQueue& requestQueue, Http::RequestId requestId, Http::SendResponseFlags flags, UInt16 entityChunkCount, DataChunk* entityChunks, LogData* logData = nullptr )
                : Base( requestQueue.Handle( ), RequestType ), requestId_( requestId ), flags_( flags ), entityChunkCount_( entityChunkCount ), entityChunks_( entityChunks ), logData_( logData )
            {
            }

            constexpr explicit SendBodyRequest( const RequestQueue& requestQueue, HANDLE manualResetEvent, bool ownsEvent, Http::RequestId requestId, Http::SendResponseFlags flags, UInt16 entityChunkCount, DataChunk* entityChunks, LogData* logData = nullptr ) noexcept
                : Base( requestQueue.Handle( ), manualResetEvent, ownsEvent, RequestType ), requestId_( requestId ), flags_( flags ), entityChunkCount_( entityChunkCount ), entityChunks_( entityChunks ), logData_( logData )
            {
            }

            constexpr void Assign( Http::RequestId requestId, Http::SendResponseFlags flags, UInt16 entityChunkCount, DataChunk* entityChunks, LogData* logData = nullptr )
            {
                requestId_ = requestId; 
                flags_ = flags; 
                entityChunkCount_ = entityChunkCount; 
                entityChunks_ = entityChunks; 
                logData_ = logData;
            }

            constexpr Http::RequestId RequestId( ) const noexcept
            {
                return requestId_;
            }
            constexpr Http::SendResponseFlags Flags( ) const noexcept
            {
                return flags_;
            }
            constexpr UInt16 EntityChunkCount( ) const noexcept
            {
                return entityChunkCount_;
            }
            constexpr DataChunk* EntityChunks( ) const noexcept
            {
                return entityChunks_;
            }
            constexpr LogData* LogData( ) const noexcept
            {
                return logData_;
            }

        };

        class ReceiveClientCertificateRequest : public Request
        {
        public:
            using Base = Request;
            static constexpr Server::RequestType RequestType = Server::RequestType::ReceiveClientCertificate;
        private:
            Http::ConnectionId connectionId_;
            Http::ReceiveClientCertificateFlags flags_;
            // May point to a RequestChannelBindStatus struct 
            Http::SSLClientCertInfo* sslClientCertInfo_;
            UInt32 sslClientCertInfoSize_;
        public:
            explicit ReceiveClientCertificateRequest( HANDLE handle, Http::ConnectionId connectionId, Http::ReceiveClientCertificateFlags flags, Http::SSLClientCertInfo* sslClientCertInfo, UInt32 sslClientCertInfoSize )
                : Base( handle, RequestType ), connectionId_( connectionId ), flags_( flags ), sslClientCertInfo_( sslClientCertInfo ), sslClientCertInfoSize_( sslClientCertInfoSize )
            {
            }

            constexpr explicit ReceiveClientCertificateRequest( HANDLE handle, HANDLE manualResetEvent, bool ownsEvent, Http::ConnectionId connectionId, Http::ReceiveClientCertificateFlags flags, Http::SSLClientCertInfo* sslClientCertInfo, UInt32 sslClientCertInfoSize )
                : Base( handle, manualResetEvent, ownsEvent, RequestType ), connectionId_( connectionId ), flags_( flags ), sslClientCertInfo_( sslClientCertInfo ), sslClientCertInfoSize_( sslClientCertInfoSize )
            {
            }
            explicit ReceiveClientCertificateRequest( const RequestQueue& requestQueue, Http::ConnectionId connectionId, Http::ReceiveClientCertificateFlags flags, Http::SSLClientCertInfo* sslClientCertInfo, UInt32 sslClientCertInfoSize )
                : Base( requestQueue.Handle( ), RequestType ), connectionId_( connectionId ), flags_( flags ), sslClientCertInfo_( sslClientCertInfo ), sslClientCertInfoSize_( sslClientCertInfoSize )
            {
            }

            constexpr explicit ReceiveClientCertificateRequest( const RequestQueue& requestQueue, HANDLE manualResetEvent, bool ownsEvent, Http::ConnectionId connectionId, Http::ReceiveClientCertificateFlags flags, Http::SSLClientCertInfo* sslClientCertInfo, UInt32 sslClientCertInfoSize )
                : Base( requestQueue.Handle( ), manualResetEvent, ownsEvent, RequestType ), connectionId_( connectionId ), flags_( flags ), sslClientCertInfo_( sslClientCertInfo ), sslClientCertInfoSize_( sslClientCertInfoSize )
            {
            }


            explicit ReceiveClientCertificateRequest( HANDLE handle, Http::ConnectionId connectionId, Http::ReceiveClientCertificateFlags flags, Http::RequestChannelBindStatus* requestChannelBindStatus, UInt32 requestChannelBindStatusSize )
                : Base( handle, RequestType ), connectionId_( connectionId ), flags_( flags ), sslClientCertInfo_( (Http::SSLClientCertInfo*)requestChannelBindStatus ), sslClientCertInfoSize_( requestChannelBindStatusSize )
            {
            }

            constexpr explicit ReceiveClientCertificateRequest( HANDLE handle, HANDLE manualResetEvent, bool ownsEvent, Http::ConnectionId connectionId, Http::ReceiveClientCertificateFlags flags, Http::RequestChannelBindStatus* requestChannelBindStatus, UInt32 requestChannelBindStatusSize )
                : Base( handle, manualResetEvent, ownsEvent, RequestType ), connectionId_( connectionId ), flags_( flags ), sslClientCertInfo_( (Http::SSLClientCertInfo*) requestChannelBindStatus ), sslClientCertInfoSize_( requestChannelBindStatusSize )
            {
            }
            explicit ReceiveClientCertificateRequest( const RequestQueue& requestQueue, Http::ConnectionId connectionId, Http::ReceiveClientCertificateFlags flags, Http::RequestChannelBindStatus* requestChannelBindStatus, UInt32 requestChannelBindStatusSize )
                : Base( requestQueue.Handle( ), RequestType ), connectionId_( connectionId ), flags_( flags ), sslClientCertInfo_( (Http::SSLClientCertInfo*)requestChannelBindStatus ), sslClientCertInfoSize_( requestChannelBindStatusSize )
            {
            }

            constexpr explicit ReceiveClientCertificateRequest( const RequestQueue& requestQueue, HANDLE manualResetEvent, bool ownsEvent, Http::ConnectionId connectionId, Http::ReceiveClientCertificateFlags flags, Http::RequestChannelBindStatus* requestChannelBindStatus, UInt32 requestChannelBindStatusSize )
                : Base( requestQueue.Handle( ), manualResetEvent, ownsEvent, RequestType ), connectionId_( connectionId ), flags_( flags ), sslClientCertInfo_( (Http::SSLClientCertInfo*)requestChannelBindStatus ), sslClientCertInfoSize_( requestChannelBindStatusSize )
            {
            }


            constexpr Http::ConnectionId ConnectionId( ) const noexcept
            {
                return connectionId_;
            }
            constexpr Http::ReceiveClientCertificateFlags Flags( ) const noexcept
            {
                return flags_;
            }
            // May point to a RequestChannelBindStatus struct 
            constexpr Http::SSLClientCertInfo* SslClientCertInfo( ) const noexcept
            {
                return sslClientCertInfo_;
            }
            constexpr Http::RequestChannelBindStatus* RequestChannelBindStatus( ) const
            {
                return (Http::RequestChannelBindStatus*)sslClientCertInfo_;
            }
            constexpr UInt32 SslClientCertInfoSize( ) const noexcept
            {
                return sslClientCertInfoSize_;
            }

        };

        class WaitForDisconnectRequest : public Request
        {
        public:
            using Base = Request;
            static constexpr Server::RequestType RequestType = Server::RequestType::WaitForDisconnect;
        private:
            Http::ConnectionId connectionId_;
        public:
            explicit WaitForDisconnectRequest( HANDLE handle, Http::ConnectionId connectionId )
                : Base( handle, RequestType ), connectionId_( connectionId )
            {
            }

            constexpr explicit WaitForDisconnectRequest( HANDLE handle, HANDLE manualResetEvent, bool ownsEvent, Http::ConnectionId connectionId )
                : Base( handle, manualResetEvent, ownsEvent, RequestType ), connectionId_( connectionId )
            {
            }
            explicit WaitForDisconnectRequest( const RequestQueue& requestQueue, Http::ConnectionId connectionId )
                : Base( requestQueue.Handle( ), RequestType ), connectionId_( connectionId )
            {
            }

            constexpr explicit WaitForDisconnectRequest( const RequestQueue& requestQueue, HANDLE manualResetEvent, bool ownsEvent, Http::ConnectionId connectionId )
                : Base( requestQueue.Handle( ), manualResetEvent, ownsEvent, RequestType ), connectionId_( connectionId )
            {
            }

            constexpr Http::ConnectionId ConnectionId( ) const noexcept
            {
                return connectionId_;
            }

        };


        class WaitForDisconnectExRequest : public Request
        {
        public:
            using Base = Request;
            static constexpr Server::RequestType RequestType = Server::RequestType::WaitForDisconnectEx;
        private:
            Http::ConnectionId connectionId_;
        public:
            explicit WaitForDisconnectExRequest( HANDLE handle, Http::ConnectionId connectionId )
                : Base( handle, RequestType ), connectionId_( connectionId )
            {
            }

            constexpr explicit WaitForDisconnectExRequest( HANDLE handle, HANDLE manualResetEvent, bool ownsEvent, Http::ConnectionId connectionId )
                : Base( handle, manualResetEvent, ownsEvent, RequestType ), connectionId_( connectionId )
            {
            }
            explicit WaitForDisconnectExRequest( const RequestQueue& requestQueue, Http::ConnectionId connectionId )
                : Base( requestQueue.Handle( ), RequestType ), connectionId_( connectionId )
            {
            }

            constexpr explicit WaitForDisconnectExRequest( const RequestQueue& requestQueue, HANDLE manualResetEvent, bool ownsEvent, Http::ConnectionId connectionId )
                : Base( requestQueue.Handle( ), manualResetEvent, ownsEvent, RequestType ), connectionId_( connectionId )
            {
            }

            constexpr Http::ConnectionId ConnectionId( ) const noexcept
            {
                return connectionId_;
            }

        };

        class CancelRequest : public Request
        {
        public:
            using Base = Request;
            static constexpr Server::RequestType RequestType = Server::RequestType::Cancel;
        private:
            Http::RequestId requestId_;
        public:
            explicit CancelRequest( HANDLE handle, Http::RequestId requestId )
                : Base( handle, RequestType ), requestId_( requestId )
            {
            }

            constexpr explicit CancelRequest( HANDLE handle, HANDLE manualResetEvent, bool ownsEvent, Http::RequestId requestId )
                : Base( handle, manualResetEvent, ownsEvent, RequestType ), requestId_( requestId )
            {
            }
            explicit CancelRequest( const RequestQueue& requestQueue, Http::RequestId requestId )
                : Base( requestQueue.Handle( ), RequestType ), requestId_( requestId )
            {
            }

            constexpr explicit CancelRequest( const RequestQueue& requestQueue, HANDLE manualResetEvent, bool ownsEvent, Http::RequestId requestId )
                : Base( requestQueue.Handle( ), manualResetEvent, ownsEvent, RequestType ), requestId_( requestId )
            {
            }

            constexpr Http::RequestId RequestId( ) const noexcept
            {
                return requestId_;
            }
        };


        class WaitForDemandStartRequest : public Request
        {
        public:
            using Base = Request;
            static constexpr Server::RequestType RequestType = Server::RequestType::WaitForDemandStart;

            explicit WaitForDemandStartRequest( HANDLE handle )
                : Base( handle, RequestType )
            {
            }

            constexpr explicit WaitForDemandStartRequest( HANDLE handle, HANDLE manualResetEvent, bool ownsEvent )
                : Base( handle, manualResetEvent, ownsEvent, RequestType )
            {
            }
            explicit WaitForDemandStartRequest( const RequestQueue& requestQueue )
                : Base( requestQueue.Handle( ), RequestType )
            {
            }

            constexpr explicit WaitForDemandStartRequest( const RequestQueue& requestQueue, HANDLE manualResetEvent, bool ownsEvent )
                : Base( requestQueue.Handle( ), manualResetEvent, ownsEvent, RequestType )
            {
            }
        };


        template<typename DerivedT>
        class RequestQueueHandler : public IO::ContextHandler
        {
        public:
            using Base = IO::ContextHandler;
            using DerivedType = DerivedT;
        private:
            Http::RequestQueue& requestQueue_;
        protected:
            RequestQueueHandler( const std::shared_ptr<IO::Context>& context, Http::RequestQueue& requestQueue )
                : Base( context ), requestQueue_( requestQueue )
            {
                context->Bind( requestQueue.Handle( ), this );
            }
        public:
            std::shared_ptr<const DerivedType> Self( ) const
            {
                return std::dynamic_pointer_cast<const DerivedType>( shared_from_this() );
            }
            std::shared_ptr<DerivedType> Self( )
            {
                return std::dynamic_pointer_cast<DerivedType>( shared_from_this( ) );
            }

            const Http::RequestQueue& RequestQueue( ) const
            {
                return requestQueue_;
            }

            bool BeginAsyncReceive( ReceiveRequest* request ) const
            {
                BindRequestToContext( request );
                Http::RequestId requestId = request->RequestId( );
                Http::ReceiveRequestFlags flags = request->Flags( );
                Http::Request* requestBuffer = request->Request( );
                UInt32 requestBufferLength = request->RequestLength( );
                auto rc = HttpReceiveHttpRequest( requestQueue_.Handle( ), requestId, static_cast<ULONG>( flags ), (PHTTP_REQUEST)requestBuffer, requestBufferLength, nullptr, request );
                if ( rc == NO_ERROR || rc == ERROR_HANDLE_EOF )
                {
                    request->SetResult( static_cast<WinError>( rc ) );
                    DerivedType& self = static_cast<DerivedType&>( const_cast<RequestQueueHandler&>( *this ) );
                    self.HandleReceiveCompleted( request );
                    return true;
                }
                else if ( rc != ERROR_IO_PENDING )
                {
                    ThrowOSError( rc );
                }
                return false;
            }
            bool BeginAsyncReceiveBody( ReceiveBodyRequest* request ) const
            {
                BindRequestToContext( request );
                Http::RequestId requestId = request->RequestId( );
                Http::ReceiveRequestEntityBodyFlags flags = request->Flags( );
                Byte* buffer = request->Buffer( );
                UInt32 bufferLength = request->BufferLength( );
                auto rc = HttpReceiveRequestEntityBody( requestQueue_.Handle( ), requestId, static_cast<ULONG>( flags ), buffer, bufferLength, nullptr, request );
                if ( rc == NO_ERROR || rc == ERROR_HANDLE_EOF )
                {
                    request->SetResult( static_cast<WinError>( rc ) );
                    DerivedType& self = static_cast<DerivedType&>( const_cast<RequestQueueHandler&>( *this ) );
                    self.HandleReceiveBodyCompleted( request );
                    return true;
                }
                else if ( rc != ERROR_IO_PENDING )
                {
                    ThrowOSError( rc );
                }
                return false;
            }
            bool BeginAsyncSend( SendRequest* request ) const
            {
                BindRequestToContext( request );
                Http::RequestId requestId = request->RequestId( );
                Http::SendResponseFlags flags = request->Flags( );
                Http::Response* response = request->Response( );
                Http::CachePolicy* cachePolicy = request->CachePolicy( );
                Http::LogData* logData = request->LogData( );
                auto rc = HttpSendHttpResponse( requestQueue_.Handle( ), requestId, static_cast<ULONG>( flags ), (PHTTP_RESPONSE)response, (PHTTP_CACHE_POLICY)cachePolicy, nullptr, nullptr, 0, request, (PHTTP_LOG_DATA)logData );
                if ( rc == NO_ERROR )
                {
                    request->SetResult( static_cast<WinError>( rc ) );
                    DerivedType& self = static_cast<DerivedType&>( const_cast<RequestQueueHandler&>( *this ) );
                    self.HandleSendCompleted( request );
                    return true;
                }
                if ( rc != ERROR_IO_PENDING )
                {
                    ThrowOSError( rc );
                }
                return false;
            }
            bool BeginAsyncSendBody( SendBodyRequest* request ) const
            {
                BindRequestToContext( request );
                Http::RequestId requestId = request->RequestId( );
                Http::SendResponseFlags flags = request->Flags( );
                UInt16 entityChunkCount = request->EntityChunkCount( );
                DataChunk* entityChunks = request->EntityChunks( );
                LogData* logData = request->LogData( );
                auto rc = HttpSendResponseEntityBody( requestQueue_.Handle( ), requestId, static_cast<ULONG>( flags ), entityChunkCount, (PHTTP_DATA_CHUNK)entityChunks, nullptr, nullptr, 0, request, (PHTTP_LOG_DATA)logData );
                if ( rc == NO_ERROR )
                {
                    request->SetResult( static_cast<WinError>( rc ) );
                    DerivedType& self = static_cast<DerivedType&>( const_cast<RequestQueueHandler&>( *this ) );
                    self.HandleSendBodyCompleted( request );
                    return true;
                }
                if ( rc != ERROR_IO_PENDING )
                {
                    ThrowOSError( rc );
                }
                return false;
            }
            bool BeginAsyncReceiveClientCertificate( ReceiveClientCertificateRequest* request )
            {
                BindRequestToContext( request );
                Http::ConnectionId connectionId = request->ConnectionId( );
                Http::ReceiveClientCertificateFlags flags = request->Flags( );
                Http::SSLClientCertInfo* sslClientCertInfo = request->SslClientCertInfo( );
                UInt32 sslClientCertInfoSize = request->SslClientCertInfoSize( );
                auto rc = HttpReceiveClientCertificate( requestQueue_.Handle( ), connectionId, static_cast<ULONG>( flags ), (PHTTP_SSL_CLIENT_CERT_INFO)sslClientCertInfo, sslClientCertInfoSize, nullptr, request );
                if ( rc == NO_ERROR )
                {
                    request->SetResult( static_cast<WinError>( rc ) );
                    DerivedType& self = static_cast<DerivedType&>( const_cast<RequestQueueHandler&>( *this ) );
                    self.HandleReceiveClientCertificateCompleted( request );
                    return true;
                }
                if ( rc != ERROR_IO_PENDING )
                {
                    ThrowOSError( rc );
                }
                return false;
            }
            bool BeginAsyncWaitForDisconnect( WaitForDisconnectRequest* request )
            {
                BindRequestToContext( request );
                Http::ConnectionId connectionId = request->ConnectionId( );
                auto rc = HttpWaitForDisconnect( requestQueue_.Handle( ), connectionId, request );
                if ( rc == NO_ERROR )
                {
                    request->SetResult( static_cast<WinError>(rc) );
                    DerivedType& self = static_cast<DerivedType&>( const_cast<RequestQueueHandler&>( *this ) );
                    self.HandleWaitForDisconnectCompleted( request );
                    return true;
                }
                if ( rc != ERROR_IO_PENDING )
                {
                    ThrowOSError( rc );
                }
                return false;
            }
            bool BeginAsyncWaitForDisconnectEx( WaitForDisconnectExRequest* request )
            {
                BindRequestToContext( request );
                Http::ConnectionId connectionId = request->ConnectionId( );
                auto rc = HttpWaitForDisconnectEx( requestQueue_.Handle( ), connectionId, 0 ,request );
                if ( rc == NO_ERROR )
                {
                    request->SetResult( static_cast<WinError>( rc ) );
                    DerivedType& self = static_cast<DerivedType&>( const_cast<RequestQueueHandler&>( *this ) );
                    self.HandleWaitForDisconnectExCompleted( request );
                    return true;
                }
                if ( rc != ERROR_IO_PENDING )
                {
                    ThrowOSError( rc );
                }
                return false;
            }
            bool BeginAsyncCancel( CancelRequest* request )
            {
                BindRequestToContext( request );
                Http::RequestId requestId = request->RequestId( );
                auto rc = HttpCancelHttpRequest( requestQueue_.Handle( ), requestId, request );
                if ( rc == NO_ERROR )
                {
                    request->SetResult( static_cast<WinError>( rc ) );
                    DerivedType& self = static_cast<DerivedType&>( const_cast<RequestQueueHandler&>( *this ) );
                    self.HandleCancelCompleted( request );
                    return true;
                }
                if ( rc != ERROR_IO_PENDING )
                {
                    ThrowOSError( rc );
                }
                return false;
            }
            bool BeginAsyncWaitForDemandStart( WaitForDemandStartRequest* request )
            {
                BindRequestToContext( request );
                auto rc = HttpWaitForDemandStart( requestQueue_.Handle( ), request );
                if ( rc == NO_ERROR )
                {
                    request->SetResult( static_cast<WinError>( rc ) );
                    DerivedType& self = static_cast<DerivedType&>( const_cast<RequestQueueHandler&>( *this ) );
                    self.HandleWaitForDemandStartCompleted( request );
                    return true;
                }
                if ( rc != ERROR_IO_PENDING )
                {
                    ThrowOSError( rc );
                }
                return false;
            }

            virtual bool Process( Message& message ) override
            {
                bool result = false;
                auto request = static_cast<Server::Request*>( message.Request( ) );
                DerivedType& self = static_cast<DerivedType&>( *this );
                Server::RequestType requestType = request->Type( );
                switch ( requestType )
                {
                    case Server::RequestType::Receive:
                    {
                        result = self.HandleReceiveCompleted( static_cast<Server::ReceiveRequest*>( request ) );
                    }
                    break;
                    case Server::RequestType::ReceiveBody:
                    {
                        result = self.HandleReceiveBodyCompleted( static_cast<Server::ReceiveBodyRequest*>( request ) );
                    }
                    break;
                    case Server::RequestType::Send:
                    {
                        result = self.HandleSendCompleted( static_cast<Server::SendRequest*>( request ) );
                    }
                    break;
                    case Server::RequestType::SendBody:
                    {
                        result = self.HandleSendBodyCompleted( static_cast<Server::SendBodyRequest*>( request ) );
                    }
                    break;
                    case Server::RequestType::ReceiveClientCertificate:
                    {
                        result = self.HandleReceiveClientCertificateCompleted( static_cast<Server::ReceiveClientCertificateRequest*>( request ) );
                    }
                    break;
                    case Server::RequestType::WaitForDisconnect:
                    {
                        result = self.HandleWaitForDisconnectCompleted( static_cast<Server::WaitForDisconnectRequest*>( request ) );
                    }
                    break;
                    case Server::RequestType::WaitForDisconnectEx:
                    {
                        result = self.HandleWaitForDisconnectExCompleted( static_cast<Server::WaitForDisconnectExRequest*>( request ) );
                    }
                    break;
                    case Server::RequestType::Cancel:
                    {
                        result = self.HandleCancelCompleted( static_cast<Server::CancelRequest*>( request ) );
                    }
                    break;
                    case Server::RequestType::WaitForDemandStart:
                    {
                        result = self.HandleWaitForDemandStartCompleted( static_cast<Server::WaitForDemandStartRequest*>( request ) );
                    }
                    break;
                }
                return result;
            }
        protected:
            constexpr bool HandleReceiveCompleted( ReceiveRequest* request ) const noexcept
            {
                return false;
            }
            constexpr bool HandleReceiveBodyCompleted( ReceiveBodyRequest* request ) const noexcept
            {
                return false;
            }
            constexpr bool HandleSendCompleted( SendRequest* request ) const noexcept
            {
                return false;
            }
            constexpr bool HandleSendBodyCompleted( SendBodyRequest* request ) const noexcept
            {
                return false;
            }
            constexpr bool HandleReceiveClientCertificateCompleted( ReceiveClientCertificateRequest* request ) const noexcept
            {
                return false;
            }
            constexpr bool HandleWaitForDisconnectCompleted( WaitForDisconnectRequest* request ) const noexcept
            {
                return false;
            }
            constexpr bool HandleWaitForDisconnectExCompleted( WaitForDisconnectExRequest* request ) const noexcept
            {
                return false;
            }
            constexpr bool HandleCancelCompleted( CancelRequest* request ) const noexcept
            {
                return false;
            }
            constexpr bool HandleWaitForDemandStartCompleted( WaitForDemandStartRequest* request ) const noexcept
            {
                return false;
            }
        };

        class RequestQueueDispatcher : public RequestQueueHandler<RequestQueueDispatcher>
        {
            template<typename DerivedT>
            friend class RequestQueueHandler;
        public:
            using Base = RequestQueueHandler<RequestQueueDispatcher>;

            boost::signals2::signal<void( const RequestQueueDispatcher& dispatcher, ReceiveRequest* request )> OnReceiveCompleted;
            boost::signals2::signal<void( const RequestQueueDispatcher& dispatcher, ReceiveBodyRequest* request )> OnReceiveBodyCompleted;
            boost::signals2::signal<void( const RequestQueueDispatcher& dispatcher, SendRequest* request )> OnSendCompleted;
            boost::signals2::signal<void( const RequestQueueDispatcher& dispatcher, SendBodyRequest* request )> OnSendBodyCompleted;
            boost::signals2::signal<void( const RequestQueueDispatcher& dispatcher, ReceiveClientCertificateRequest* request )> OnReceiveClientCertificateCompleted;
            boost::signals2::signal<void( const RequestQueueDispatcher& dispatcher, WaitForDisconnectRequest* request )> OnWaitForDisconnectCompleted;
            boost::signals2::signal<void( const RequestQueueDispatcher& dispatcher, WaitForDisconnectExRequest* request )> OnWaitForDisconnectExCompleted;
            boost::signals2::signal<void( const RequestQueueDispatcher& dispatcher, CancelRequest* request )> OnCancelCompleted;
            boost::signals2::signal<void( const RequestQueueDispatcher& dispatcher, WaitForDemandStartRequest* request )> OnWaitForDemandStartCompleted;

            RequestQueueDispatcher( const std::shared_ptr<IO::Context>& context, Http::RequestQueue& requestQueue )
                : Base( context, requestQueue )
            {
            }

        private:
            bool HandleReceiveCompleted( ReceiveRequest* request ) const
            {
                OnReceiveCompleted( *this, request );
                return true;
            }
            bool HandleReceiveBodyCompleted( ReceiveBodyRequest* request ) const
            {
                OnReceiveBodyCompleted( *this, request );
                return true;
            }
            bool HandleSendCompleted( SendRequest* request ) const
            {
                OnSendCompleted( *this, request );
                return true;
            }
            bool HandleSendBodyCompleted( SendBodyRequest* request ) const
            {
                OnSendBodyCompleted( *this, request );
                return true;
            }
            bool HandleReceiveClientCertificateCompleted( ReceiveClientCertificateRequest* request ) const
            {
                OnReceiveClientCertificateCompleted( *this, request );
                return true;
            }
            bool HandleWaitForDisconnectCompleted( WaitForDisconnectRequest* request ) const
            {
                OnWaitForDisconnectCompleted( *this, request );
                return true;
            }
            bool HandleWaitForDisconnectExCompleted( WaitForDisconnectExRequest* request ) const
            {
                OnWaitForDisconnectExCompleted( *this, request );
                return true;
            }
            bool HandleCancelCompleted( CancelRequest* request ) const
            {
                OnCancelCompleted( *this, request );
                return true;
            }
            bool HandleWaitForDemandStartCompleted( WaitForDemandStartRequest* request ) const
            {
                OnWaitForDemandStartCompleted( *this, request );
                return true;
            }
        };


    }

}

#pragma pack(pop)

#endif

